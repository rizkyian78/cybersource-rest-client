// Code generated by go-swagger; DO NOT EDIT.

package customer_payment_instrument

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"fmt"
	"io"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// GetCustomerPaymentInstrumentsListReader is a Reader for the GetCustomerPaymentInstrumentsList structure.
type GetCustomerPaymentInstrumentsListReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *GetCustomerPaymentInstrumentsListReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 200:
		result := NewGetCustomerPaymentInstrumentsListOK()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	case 400:
		result := NewGetCustomerPaymentInstrumentsListBadRequest()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 403:
		result := NewGetCustomerPaymentInstrumentsListForbidden()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 404:
		result := NewGetCustomerPaymentInstrumentsListNotFound()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 410:
		result := NewGetCustomerPaymentInstrumentsListGone()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 424:
		result := NewGetCustomerPaymentInstrumentsListFailedDependency()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 500:
		result := NewGetCustomerPaymentInstrumentsListInternalServerError()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	default:
		return nil, runtime.NewAPIError("response status code does not match any response statuses defined for this endpoint in the swagger spec", response, response.Code())
	}
}

// NewGetCustomerPaymentInstrumentsListOK creates a GetCustomerPaymentInstrumentsListOK with default headers values
func NewGetCustomerPaymentInstrumentsListOK() *GetCustomerPaymentInstrumentsListOK {
	return &GetCustomerPaymentInstrumentsListOK{}
}

/* GetCustomerPaymentInstrumentsListOK describes a response with status code 200, with default header values.

Returns all existing Payment Instruments associated with the supplied token id.
*/
type GetCustomerPaymentInstrumentsListOK struct {

	/* The total number of Payment Instruments associated with the Customer or Instrument Identifier.
	 */
	XTotalCount string

	/* A globally-unique ID associated with your request.
	 */
	UniqueTransactionID string

	/* The mandatory correlation id passed by upstream (calling) system.
	 */
	VcCorrelationID string

	Payload *GetCustomerPaymentInstrumentsListOKBody
}

func (o *GetCustomerPaymentInstrumentsListOK) Error() string {
	return fmt.Sprintf("[GET /tms/v2/customers/{customerTokenId}/payment-instruments][%d] getCustomerPaymentInstrumentsListOK  %+v", 200, o.Payload)
}
func (o *GetCustomerPaymentInstrumentsListOK) GetPayload() *GetCustomerPaymentInstrumentsListOKBody {
	return o.Payload
}

func (o *GetCustomerPaymentInstrumentsListOK) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	// hydrates response header X-Total-Count
	hdrXTotalCount := response.GetHeader("X-Total-Count")

	if hdrXTotalCount != "" {
		o.XTotalCount = hdrXTotalCount
	}

	// hydrates response header uniqueTransactionID
	hdrUniqueTransactionID := response.GetHeader("uniqueTransactionID")

	if hdrUniqueTransactionID != "" {
		o.UniqueTransactionID = hdrUniqueTransactionID
	}

	// hydrates response header v-c-correlation-id
	hdrVcCorrelationID := response.GetHeader("v-c-correlation-id")

	if hdrVcCorrelationID != "" {
		o.VcCorrelationID = hdrVcCorrelationID
	}

	o.Payload = new(GetCustomerPaymentInstrumentsListOKBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewGetCustomerPaymentInstrumentsListBadRequest creates a GetCustomerPaymentInstrumentsListBadRequest with default headers values
func NewGetCustomerPaymentInstrumentsListBadRequest() *GetCustomerPaymentInstrumentsListBadRequest {
	return &GetCustomerPaymentInstrumentsListBadRequest{}
}

/* GetCustomerPaymentInstrumentsListBadRequest describes a response with status code 400, with default header values.

Bad Request: e.g. A required header value could be missing.
*/
type GetCustomerPaymentInstrumentsListBadRequest struct {

	/* A globally unique id associated with your request.
	 */
	UniqueTransactionID string

	/* The mandatory correlation id passed by upstream (calling) system.
	 */
	VcCorrelationID string

	Payload *GetCustomerPaymentInstrumentsListBadRequestBody
}

func (o *GetCustomerPaymentInstrumentsListBadRequest) Error() string {
	return fmt.Sprintf("[GET /tms/v2/customers/{customerTokenId}/payment-instruments][%d] getCustomerPaymentInstrumentsListBadRequest  %+v", 400, o.Payload)
}
func (o *GetCustomerPaymentInstrumentsListBadRequest) GetPayload() *GetCustomerPaymentInstrumentsListBadRequestBody {
	return o.Payload
}

func (o *GetCustomerPaymentInstrumentsListBadRequest) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	// hydrates response header uniqueTransactionID
	hdrUniqueTransactionID := response.GetHeader("uniqueTransactionID")

	if hdrUniqueTransactionID != "" {
		o.UniqueTransactionID = hdrUniqueTransactionID
	}

	// hydrates response header v-c-correlation-id
	hdrVcCorrelationID := response.GetHeader("v-c-correlation-id")

	if hdrVcCorrelationID != "" {
		o.VcCorrelationID = hdrVcCorrelationID
	}

	o.Payload = new(GetCustomerPaymentInstrumentsListBadRequestBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewGetCustomerPaymentInstrumentsListForbidden creates a GetCustomerPaymentInstrumentsListForbidden with default headers values
func NewGetCustomerPaymentInstrumentsListForbidden() *GetCustomerPaymentInstrumentsListForbidden {
	return &GetCustomerPaymentInstrumentsListForbidden{}
}

/* GetCustomerPaymentInstrumentsListForbidden describes a response with status code 403, with default header values.

403ForbiddenResponse: e.g. The profile might not have permission to perform the operation.
*/
type GetCustomerPaymentInstrumentsListForbidden struct {

	/* A globally unique id associated with your request.
	 */
	UniqueTransactionID string

	/* The mandatory correlation id passed by upstream (calling) system.
	 */
	VcCorrelationID string

	Payload *GetCustomerPaymentInstrumentsListForbiddenBody
}

func (o *GetCustomerPaymentInstrumentsListForbidden) Error() string {
	return fmt.Sprintf("[GET /tms/v2/customers/{customerTokenId}/payment-instruments][%d] getCustomerPaymentInstrumentsListForbidden  %+v", 403, o.Payload)
}
func (o *GetCustomerPaymentInstrumentsListForbidden) GetPayload() *GetCustomerPaymentInstrumentsListForbiddenBody {
	return o.Payload
}

func (o *GetCustomerPaymentInstrumentsListForbidden) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	// hydrates response header uniqueTransactionID
	hdrUniqueTransactionID := response.GetHeader("uniqueTransactionID")

	if hdrUniqueTransactionID != "" {
		o.UniqueTransactionID = hdrUniqueTransactionID
	}

	// hydrates response header v-c-correlation-id
	hdrVcCorrelationID := response.GetHeader("v-c-correlation-id")

	if hdrVcCorrelationID != "" {
		o.VcCorrelationID = hdrVcCorrelationID
	}

	o.Payload = new(GetCustomerPaymentInstrumentsListForbiddenBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewGetCustomerPaymentInstrumentsListNotFound creates a GetCustomerPaymentInstrumentsListNotFound with default headers values
func NewGetCustomerPaymentInstrumentsListNotFound() *GetCustomerPaymentInstrumentsListNotFound {
	return &GetCustomerPaymentInstrumentsListNotFound{}
}

/* GetCustomerPaymentInstrumentsListNotFound describes a response with status code 404, with default header values.

Token Not Found. The `tokenid` may not exist or was entered incorrectly.
*/
type GetCustomerPaymentInstrumentsListNotFound struct {

	/* A globally unique ID associated with your request.
	 */
	UniqueTransactionID string

	/* The mandatory correlation id passed by upstream (calling) system.
	 */
	VcCorrelationID string

	Payload *GetCustomerPaymentInstrumentsListNotFoundBody
}

func (o *GetCustomerPaymentInstrumentsListNotFound) Error() string {
	return fmt.Sprintf("[GET /tms/v2/customers/{customerTokenId}/payment-instruments][%d] getCustomerPaymentInstrumentsListNotFound  %+v", 404, o.Payload)
}
func (o *GetCustomerPaymentInstrumentsListNotFound) GetPayload() *GetCustomerPaymentInstrumentsListNotFoundBody {
	return o.Payload
}

func (o *GetCustomerPaymentInstrumentsListNotFound) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	// hydrates response header uniqueTransactionID
	hdrUniqueTransactionID := response.GetHeader("uniqueTransactionID")

	if hdrUniqueTransactionID != "" {
		o.UniqueTransactionID = hdrUniqueTransactionID
	}

	// hydrates response header v-c-correlation-id
	hdrVcCorrelationID := response.GetHeader("v-c-correlation-id")

	if hdrVcCorrelationID != "" {
		o.VcCorrelationID = hdrVcCorrelationID
	}

	o.Payload = new(GetCustomerPaymentInstrumentsListNotFoundBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewGetCustomerPaymentInstrumentsListGone creates a GetCustomerPaymentInstrumentsListGone with default headers values
func NewGetCustomerPaymentInstrumentsListGone() *GetCustomerPaymentInstrumentsListGone {
	return &GetCustomerPaymentInstrumentsListGone{}
}

/* GetCustomerPaymentInstrumentsListGone describes a response with status code 410, with default header values.

Token Not Available. The token has been deleted.
*/
type GetCustomerPaymentInstrumentsListGone struct {

	/* A globally unique ID associated with your request.
	 */
	UniqueTransactionID string

	/* The mandatory correlation id passed by upstream (calling) system.
	 */
	VcCorrelationID string

	Payload *GetCustomerPaymentInstrumentsListGoneBody
}

func (o *GetCustomerPaymentInstrumentsListGone) Error() string {
	return fmt.Sprintf("[GET /tms/v2/customers/{customerTokenId}/payment-instruments][%d] getCustomerPaymentInstrumentsListGone  %+v", 410, o.Payload)
}
func (o *GetCustomerPaymentInstrumentsListGone) GetPayload() *GetCustomerPaymentInstrumentsListGoneBody {
	return o.Payload
}

func (o *GetCustomerPaymentInstrumentsListGone) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	// hydrates response header uniqueTransactionID
	hdrUniqueTransactionID := response.GetHeader("uniqueTransactionID")

	if hdrUniqueTransactionID != "" {
		o.UniqueTransactionID = hdrUniqueTransactionID
	}

	// hydrates response header v-c-correlation-id
	hdrVcCorrelationID := response.GetHeader("v-c-correlation-id")

	if hdrVcCorrelationID != "" {
		o.VcCorrelationID = hdrVcCorrelationID
	}

	o.Payload = new(GetCustomerPaymentInstrumentsListGoneBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewGetCustomerPaymentInstrumentsListFailedDependency creates a GetCustomerPaymentInstrumentsListFailedDependency with default headers values
func NewGetCustomerPaymentInstrumentsListFailedDependency() *GetCustomerPaymentInstrumentsListFailedDependency {
	return &GetCustomerPaymentInstrumentsListFailedDependency{}
}

/* GetCustomerPaymentInstrumentsListFailedDependency describes a response with status code 424, with default header values.

Failed Dependency: e.g. The profile represented by the profile-id may not exist or the profile-id was entered incorrectly.
*/
type GetCustomerPaymentInstrumentsListFailedDependency struct {

	/* A globally unique id associated with your request.
	 */
	UniqueTransactionID string

	/* The mandatory correlation id passed by upstream (calling) system.
	 */
	VcCorrelationID string

	Payload *GetCustomerPaymentInstrumentsListFailedDependencyBody
}

func (o *GetCustomerPaymentInstrumentsListFailedDependency) Error() string {
	return fmt.Sprintf("[GET /tms/v2/customers/{customerTokenId}/payment-instruments][%d] getCustomerPaymentInstrumentsListFailedDependency  %+v", 424, o.Payload)
}
func (o *GetCustomerPaymentInstrumentsListFailedDependency) GetPayload() *GetCustomerPaymentInstrumentsListFailedDependencyBody {
	return o.Payload
}

func (o *GetCustomerPaymentInstrumentsListFailedDependency) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	// hydrates response header uniqueTransactionID
	hdrUniqueTransactionID := response.GetHeader("uniqueTransactionID")

	if hdrUniqueTransactionID != "" {
		o.UniqueTransactionID = hdrUniqueTransactionID
	}

	// hydrates response header v-c-correlation-id
	hdrVcCorrelationID := response.GetHeader("v-c-correlation-id")

	if hdrVcCorrelationID != "" {
		o.VcCorrelationID = hdrVcCorrelationID
	}

	o.Payload = new(GetCustomerPaymentInstrumentsListFailedDependencyBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewGetCustomerPaymentInstrumentsListInternalServerError creates a GetCustomerPaymentInstrumentsListInternalServerError with default headers values
func NewGetCustomerPaymentInstrumentsListInternalServerError() *GetCustomerPaymentInstrumentsListInternalServerError {
	return &GetCustomerPaymentInstrumentsListInternalServerError{}
}

/* GetCustomerPaymentInstrumentsListInternalServerError describes a response with status code 500, with default header values.

Unexpected error.
*/
type GetCustomerPaymentInstrumentsListInternalServerError struct {

	/* A globally unique id associated with your request.
	 */
	UniqueTransactionID string

	/* The mandatory correlation id passed by upstream (calling) system.
	 */
	VcCorrelationID string

	Payload *GetCustomerPaymentInstrumentsListInternalServerErrorBody
}

func (o *GetCustomerPaymentInstrumentsListInternalServerError) Error() string {
	return fmt.Sprintf("[GET /tms/v2/customers/{customerTokenId}/payment-instruments][%d] getCustomerPaymentInstrumentsListInternalServerError  %+v", 500, o.Payload)
}
func (o *GetCustomerPaymentInstrumentsListInternalServerError) GetPayload() *GetCustomerPaymentInstrumentsListInternalServerErrorBody {
	return o.Payload
}

func (o *GetCustomerPaymentInstrumentsListInternalServerError) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	// hydrates response header uniqueTransactionID
	hdrUniqueTransactionID := response.GetHeader("uniqueTransactionID")

	if hdrUniqueTransactionID != "" {
		o.UniqueTransactionID = hdrUniqueTransactionID
	}

	// hydrates response header v-c-correlation-id
	hdrVcCorrelationID := response.GetHeader("v-c-correlation-id")

	if hdrVcCorrelationID != "" {
		o.VcCorrelationID = hdrVcCorrelationID
	}

	o.Payload = new(GetCustomerPaymentInstrumentsListInternalServerErrorBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

/*GetCustomerPaymentInstrumentsListBadRequestBody get customer payment instruments list bad request body
swagger:model GetCustomerPaymentInstrumentsListBadRequestBody
*/
type GetCustomerPaymentInstrumentsListBadRequestBody struct {

	// errors
	// Read Only: true
	Errors []*GetCustomerPaymentInstrumentsListBadRequestBodyErrorsItems0 `json:"errors"`
}

// Validate validates this get customer payment instruments list bad request body
func (o *GetCustomerPaymentInstrumentsListBadRequestBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateErrors(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListBadRequestBody) validateErrors(formats strfmt.Registry) error {
	if swag.IsZero(o.Errors) { // not required
		return nil
	}

	for i := 0; i < len(o.Errors); i++ {
		if swag.IsZero(o.Errors[i]) { // not required
			continue
		}

		if o.Errors[i] != nil {
			if err := o.Errors[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("getCustomerPaymentInstrumentsListBadRequest" + "." + "errors" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("getCustomerPaymentInstrumentsListBadRequest" + "." + "errors" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this get customer payment instruments list bad request body based on the context it is used
func (o *GetCustomerPaymentInstrumentsListBadRequestBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateErrors(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListBadRequestBody) contextValidateErrors(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "getCustomerPaymentInstrumentsListBadRequest"+"."+"errors", "body", []*GetCustomerPaymentInstrumentsListBadRequestBodyErrorsItems0(o.Errors)); err != nil {
		return err
	}

	for i := 0; i < len(o.Errors); i++ {

		if o.Errors[i] != nil {
			if err := o.Errors[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("getCustomerPaymentInstrumentsListBadRequest" + "." + "errors" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("getCustomerPaymentInstrumentsListBadRequest" + "." + "errors" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListBadRequestBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListBadRequestBody) UnmarshalBinary(b []byte) error {
	var res GetCustomerPaymentInstrumentsListBadRequestBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetCustomerPaymentInstrumentsListBadRequestBodyErrorsItems0 get customer payment instruments list bad request body errors items0
swagger:model GetCustomerPaymentInstrumentsListBadRequestBodyErrorsItems0
*/
type GetCustomerPaymentInstrumentsListBadRequestBodyErrorsItems0 struct {

	// details
	// Read Only: true
	Details []*GetCustomerPaymentInstrumentsListBadRequestBodyErrorsItems0DetailsItems0 `json:"details"`

	// The detailed message related to the type stated above.
	// Read Only: true
	Message string `json:"message,omitempty"`

	// The type of error.
	// Read Only: true
	Type string `json:"type,omitempty"`
}

// Validate validates this get customer payment instruments list bad request body errors items0
func (o *GetCustomerPaymentInstrumentsListBadRequestBodyErrorsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListBadRequestBodyErrorsItems0) validateDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.Details) { // not required
		return nil
	}

	for i := 0; i < len(o.Details); i++ {
		if swag.IsZero(o.Details[i]) { // not required
			continue
		}

		if o.Details[i] != nil {
			if err := o.Details[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this get customer payment instruments list bad request body errors items0 based on the context it is used
func (o *GetCustomerPaymentInstrumentsListBadRequestBodyErrorsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateMessage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListBadRequestBodyErrorsItems0) contextValidateDetails(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "details", "body", []*GetCustomerPaymentInstrumentsListBadRequestBodyErrorsItems0DetailsItems0(o.Details)); err != nil {
		return err
	}

	for i := 0; i < len(o.Details); i++ {

		if o.Details[i] != nil {
			if err := o.Details[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListBadRequestBodyErrorsItems0) contextValidateMessage(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "message", "body", string(o.Message)); err != nil {
		return err
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListBadRequestBodyErrorsItems0) contextValidateType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "type", "body", string(o.Type)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListBadRequestBodyErrorsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListBadRequestBodyErrorsItems0) UnmarshalBinary(b []byte) error {
	var res GetCustomerPaymentInstrumentsListBadRequestBodyErrorsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetCustomerPaymentInstrumentsListBadRequestBodyErrorsItems0DetailsItems0 get customer payment instruments list bad request body errors items0 details items0
swagger:model GetCustomerPaymentInstrumentsListBadRequestBodyErrorsItems0DetailsItems0
*/
type GetCustomerPaymentInstrumentsListBadRequestBodyErrorsItems0DetailsItems0 struct {

	// The location of the field that caused the error.
	// Read Only: true
	Location string `json:"location,omitempty"`

	// The name of the field that caused the error.
	// Read Only: true
	Name string `json:"name,omitempty"`
}

// Validate validates this get customer payment instruments list bad request body errors items0 details items0
func (o *GetCustomerPaymentInstrumentsListBadRequestBodyErrorsItems0DetailsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this get customer payment instruments list bad request body errors items0 details items0 based on the context it is used
func (o *GetCustomerPaymentInstrumentsListBadRequestBodyErrorsItems0DetailsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateLocation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListBadRequestBodyErrorsItems0DetailsItems0) contextValidateLocation(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "location", "body", string(o.Location)); err != nil {
		return err
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListBadRequestBodyErrorsItems0DetailsItems0) contextValidateName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "name", "body", string(o.Name)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListBadRequestBodyErrorsItems0DetailsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListBadRequestBodyErrorsItems0DetailsItems0) UnmarshalBinary(b []byte) error {
	var res GetCustomerPaymentInstrumentsListBadRequestBodyErrorsItems0DetailsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetCustomerPaymentInstrumentsListFailedDependencyBody get customer payment instruments list failed dependency body
swagger:model GetCustomerPaymentInstrumentsListFailedDependencyBody
*/
type GetCustomerPaymentInstrumentsListFailedDependencyBody struct {

	// errors
	// Read Only: true
	Errors []*GetCustomerPaymentInstrumentsListFailedDependencyBodyErrorsItems0 `json:"errors"`
}

// Validate validates this get customer payment instruments list failed dependency body
func (o *GetCustomerPaymentInstrumentsListFailedDependencyBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateErrors(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListFailedDependencyBody) validateErrors(formats strfmt.Registry) error {
	if swag.IsZero(o.Errors) { // not required
		return nil
	}

	for i := 0; i < len(o.Errors); i++ {
		if swag.IsZero(o.Errors[i]) { // not required
			continue
		}

		if o.Errors[i] != nil {
			if err := o.Errors[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("getCustomerPaymentInstrumentsListFailedDependency" + "." + "errors" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("getCustomerPaymentInstrumentsListFailedDependency" + "." + "errors" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this get customer payment instruments list failed dependency body based on the context it is used
func (o *GetCustomerPaymentInstrumentsListFailedDependencyBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateErrors(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListFailedDependencyBody) contextValidateErrors(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "getCustomerPaymentInstrumentsListFailedDependency"+"."+"errors", "body", []*GetCustomerPaymentInstrumentsListFailedDependencyBodyErrorsItems0(o.Errors)); err != nil {
		return err
	}

	for i := 0; i < len(o.Errors); i++ {

		if o.Errors[i] != nil {
			if err := o.Errors[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("getCustomerPaymentInstrumentsListFailedDependency" + "." + "errors" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("getCustomerPaymentInstrumentsListFailedDependency" + "." + "errors" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListFailedDependencyBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListFailedDependencyBody) UnmarshalBinary(b []byte) error {
	var res GetCustomerPaymentInstrumentsListFailedDependencyBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetCustomerPaymentInstrumentsListFailedDependencyBodyErrorsItems0 get customer payment instruments list failed dependency body errors items0
swagger:model GetCustomerPaymentInstrumentsListFailedDependencyBodyErrorsItems0
*/
type GetCustomerPaymentInstrumentsListFailedDependencyBodyErrorsItems0 struct {

	// details
	// Read Only: true
	Details []*GetCustomerPaymentInstrumentsListFailedDependencyBodyErrorsItems0DetailsItems0 `json:"details"`

	// The detailed message related to the type stated above.
	// Read Only: true
	Message string `json:"message,omitempty"`

	// The type of error.
	// Read Only: true
	Type string `json:"type,omitempty"`
}

// Validate validates this get customer payment instruments list failed dependency body errors items0
func (o *GetCustomerPaymentInstrumentsListFailedDependencyBodyErrorsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListFailedDependencyBodyErrorsItems0) validateDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.Details) { // not required
		return nil
	}

	for i := 0; i < len(o.Details); i++ {
		if swag.IsZero(o.Details[i]) { // not required
			continue
		}

		if o.Details[i] != nil {
			if err := o.Details[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this get customer payment instruments list failed dependency body errors items0 based on the context it is used
func (o *GetCustomerPaymentInstrumentsListFailedDependencyBodyErrorsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateMessage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListFailedDependencyBodyErrorsItems0) contextValidateDetails(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "details", "body", []*GetCustomerPaymentInstrumentsListFailedDependencyBodyErrorsItems0DetailsItems0(o.Details)); err != nil {
		return err
	}

	for i := 0; i < len(o.Details); i++ {

		if o.Details[i] != nil {
			if err := o.Details[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListFailedDependencyBodyErrorsItems0) contextValidateMessage(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "message", "body", string(o.Message)); err != nil {
		return err
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListFailedDependencyBodyErrorsItems0) contextValidateType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "type", "body", string(o.Type)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListFailedDependencyBodyErrorsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListFailedDependencyBodyErrorsItems0) UnmarshalBinary(b []byte) error {
	var res GetCustomerPaymentInstrumentsListFailedDependencyBodyErrorsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetCustomerPaymentInstrumentsListFailedDependencyBodyErrorsItems0DetailsItems0 get customer payment instruments list failed dependency body errors items0 details items0
swagger:model GetCustomerPaymentInstrumentsListFailedDependencyBodyErrorsItems0DetailsItems0
*/
type GetCustomerPaymentInstrumentsListFailedDependencyBodyErrorsItems0DetailsItems0 struct {

	// The location of the field that caused the error.
	// Read Only: true
	Location string `json:"location,omitempty"`

	// The name of the field that caused the error.
	// Read Only: true
	Name string `json:"name,omitempty"`
}

// Validate validates this get customer payment instruments list failed dependency body errors items0 details items0
func (o *GetCustomerPaymentInstrumentsListFailedDependencyBodyErrorsItems0DetailsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this get customer payment instruments list failed dependency body errors items0 details items0 based on the context it is used
func (o *GetCustomerPaymentInstrumentsListFailedDependencyBodyErrorsItems0DetailsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateLocation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListFailedDependencyBodyErrorsItems0DetailsItems0) contextValidateLocation(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "location", "body", string(o.Location)); err != nil {
		return err
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListFailedDependencyBodyErrorsItems0DetailsItems0) contextValidateName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "name", "body", string(o.Name)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListFailedDependencyBodyErrorsItems0DetailsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListFailedDependencyBodyErrorsItems0DetailsItems0) UnmarshalBinary(b []byte) error {
	var res GetCustomerPaymentInstrumentsListFailedDependencyBodyErrorsItems0DetailsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetCustomerPaymentInstrumentsListForbiddenBody get customer payment instruments list forbidden body
swagger:model GetCustomerPaymentInstrumentsListForbiddenBody
*/
type GetCustomerPaymentInstrumentsListForbiddenBody struct {

	// errors
	// Read Only: true
	Errors []*GetCustomerPaymentInstrumentsListForbiddenBodyErrorsItems0 `json:"errors"`
}

// Validate validates this get customer payment instruments list forbidden body
func (o *GetCustomerPaymentInstrumentsListForbiddenBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateErrors(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListForbiddenBody) validateErrors(formats strfmt.Registry) error {
	if swag.IsZero(o.Errors) { // not required
		return nil
	}

	for i := 0; i < len(o.Errors); i++ {
		if swag.IsZero(o.Errors[i]) { // not required
			continue
		}

		if o.Errors[i] != nil {
			if err := o.Errors[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("getCustomerPaymentInstrumentsListForbidden" + "." + "errors" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("getCustomerPaymentInstrumentsListForbidden" + "." + "errors" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this get customer payment instruments list forbidden body based on the context it is used
func (o *GetCustomerPaymentInstrumentsListForbiddenBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateErrors(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListForbiddenBody) contextValidateErrors(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "getCustomerPaymentInstrumentsListForbidden"+"."+"errors", "body", []*GetCustomerPaymentInstrumentsListForbiddenBodyErrorsItems0(o.Errors)); err != nil {
		return err
	}

	for i := 0; i < len(o.Errors); i++ {

		if o.Errors[i] != nil {
			if err := o.Errors[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("getCustomerPaymentInstrumentsListForbidden" + "." + "errors" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("getCustomerPaymentInstrumentsListForbidden" + "." + "errors" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListForbiddenBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListForbiddenBody) UnmarshalBinary(b []byte) error {
	var res GetCustomerPaymentInstrumentsListForbiddenBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetCustomerPaymentInstrumentsListForbiddenBodyErrorsItems0 get customer payment instruments list forbidden body errors items0
swagger:model GetCustomerPaymentInstrumentsListForbiddenBodyErrorsItems0
*/
type GetCustomerPaymentInstrumentsListForbiddenBodyErrorsItems0 struct {

	// details
	// Read Only: true
	Details []*GetCustomerPaymentInstrumentsListForbiddenBodyErrorsItems0DetailsItems0 `json:"details"`

	// The detailed message related to the type stated above.
	// Read Only: true
	Message string `json:"message,omitempty"`

	// The type of error.
	// Read Only: true
	Type string `json:"type,omitempty"`
}

// Validate validates this get customer payment instruments list forbidden body errors items0
func (o *GetCustomerPaymentInstrumentsListForbiddenBodyErrorsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListForbiddenBodyErrorsItems0) validateDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.Details) { // not required
		return nil
	}

	for i := 0; i < len(o.Details); i++ {
		if swag.IsZero(o.Details[i]) { // not required
			continue
		}

		if o.Details[i] != nil {
			if err := o.Details[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this get customer payment instruments list forbidden body errors items0 based on the context it is used
func (o *GetCustomerPaymentInstrumentsListForbiddenBodyErrorsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateMessage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListForbiddenBodyErrorsItems0) contextValidateDetails(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "details", "body", []*GetCustomerPaymentInstrumentsListForbiddenBodyErrorsItems0DetailsItems0(o.Details)); err != nil {
		return err
	}

	for i := 0; i < len(o.Details); i++ {

		if o.Details[i] != nil {
			if err := o.Details[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListForbiddenBodyErrorsItems0) contextValidateMessage(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "message", "body", string(o.Message)); err != nil {
		return err
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListForbiddenBodyErrorsItems0) contextValidateType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "type", "body", string(o.Type)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListForbiddenBodyErrorsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListForbiddenBodyErrorsItems0) UnmarshalBinary(b []byte) error {
	var res GetCustomerPaymentInstrumentsListForbiddenBodyErrorsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetCustomerPaymentInstrumentsListForbiddenBodyErrorsItems0DetailsItems0 get customer payment instruments list forbidden body errors items0 details items0
swagger:model GetCustomerPaymentInstrumentsListForbiddenBodyErrorsItems0DetailsItems0
*/
type GetCustomerPaymentInstrumentsListForbiddenBodyErrorsItems0DetailsItems0 struct {

	// The location of the field that caused the error.
	// Read Only: true
	Location string `json:"location,omitempty"`

	// The name of the field that caused the error.
	// Read Only: true
	Name string `json:"name,omitempty"`
}

// Validate validates this get customer payment instruments list forbidden body errors items0 details items0
func (o *GetCustomerPaymentInstrumentsListForbiddenBodyErrorsItems0DetailsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this get customer payment instruments list forbidden body errors items0 details items0 based on the context it is used
func (o *GetCustomerPaymentInstrumentsListForbiddenBodyErrorsItems0DetailsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateLocation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListForbiddenBodyErrorsItems0DetailsItems0) contextValidateLocation(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "location", "body", string(o.Location)); err != nil {
		return err
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListForbiddenBodyErrorsItems0DetailsItems0) contextValidateName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "name", "body", string(o.Name)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListForbiddenBodyErrorsItems0DetailsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListForbiddenBodyErrorsItems0DetailsItems0) UnmarshalBinary(b []byte) error {
	var res GetCustomerPaymentInstrumentsListForbiddenBodyErrorsItems0DetailsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetCustomerPaymentInstrumentsListGoneBody get customer payment instruments list gone body
swagger:model GetCustomerPaymentInstrumentsListGoneBody
*/
type GetCustomerPaymentInstrumentsListGoneBody struct {

	// errors
	// Read Only: true
	Errors []*GetCustomerPaymentInstrumentsListGoneBodyErrorsItems0 `json:"errors"`
}

// Validate validates this get customer payment instruments list gone body
func (o *GetCustomerPaymentInstrumentsListGoneBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateErrors(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListGoneBody) validateErrors(formats strfmt.Registry) error {
	if swag.IsZero(o.Errors) { // not required
		return nil
	}

	for i := 0; i < len(o.Errors); i++ {
		if swag.IsZero(o.Errors[i]) { // not required
			continue
		}

		if o.Errors[i] != nil {
			if err := o.Errors[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("getCustomerPaymentInstrumentsListGone" + "." + "errors" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("getCustomerPaymentInstrumentsListGone" + "." + "errors" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this get customer payment instruments list gone body based on the context it is used
func (o *GetCustomerPaymentInstrumentsListGoneBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateErrors(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListGoneBody) contextValidateErrors(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "getCustomerPaymentInstrumentsListGone"+"."+"errors", "body", []*GetCustomerPaymentInstrumentsListGoneBodyErrorsItems0(o.Errors)); err != nil {
		return err
	}

	for i := 0; i < len(o.Errors); i++ {

		if o.Errors[i] != nil {
			if err := o.Errors[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("getCustomerPaymentInstrumentsListGone" + "." + "errors" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("getCustomerPaymentInstrumentsListGone" + "." + "errors" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListGoneBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListGoneBody) UnmarshalBinary(b []byte) error {
	var res GetCustomerPaymentInstrumentsListGoneBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetCustomerPaymentInstrumentsListGoneBodyErrorsItems0 get customer payment instruments list gone body errors items0
swagger:model GetCustomerPaymentInstrumentsListGoneBodyErrorsItems0
*/
type GetCustomerPaymentInstrumentsListGoneBodyErrorsItems0 struct {

	// details
	// Read Only: true
	Details []*GetCustomerPaymentInstrumentsListGoneBodyErrorsItems0DetailsItems0 `json:"details"`

	// The detailed message related to the type stated above.
	// Read Only: true
	Message string `json:"message,omitempty"`

	// The type of error.
	// Read Only: true
	Type string `json:"type,omitempty"`
}

// Validate validates this get customer payment instruments list gone body errors items0
func (o *GetCustomerPaymentInstrumentsListGoneBodyErrorsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListGoneBodyErrorsItems0) validateDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.Details) { // not required
		return nil
	}

	for i := 0; i < len(o.Details); i++ {
		if swag.IsZero(o.Details[i]) { // not required
			continue
		}

		if o.Details[i] != nil {
			if err := o.Details[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this get customer payment instruments list gone body errors items0 based on the context it is used
func (o *GetCustomerPaymentInstrumentsListGoneBodyErrorsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateMessage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListGoneBodyErrorsItems0) contextValidateDetails(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "details", "body", []*GetCustomerPaymentInstrumentsListGoneBodyErrorsItems0DetailsItems0(o.Details)); err != nil {
		return err
	}

	for i := 0; i < len(o.Details); i++ {

		if o.Details[i] != nil {
			if err := o.Details[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListGoneBodyErrorsItems0) contextValidateMessage(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "message", "body", string(o.Message)); err != nil {
		return err
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListGoneBodyErrorsItems0) contextValidateType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "type", "body", string(o.Type)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListGoneBodyErrorsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListGoneBodyErrorsItems0) UnmarshalBinary(b []byte) error {
	var res GetCustomerPaymentInstrumentsListGoneBodyErrorsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetCustomerPaymentInstrumentsListGoneBodyErrorsItems0DetailsItems0 get customer payment instruments list gone body errors items0 details items0
swagger:model GetCustomerPaymentInstrumentsListGoneBodyErrorsItems0DetailsItems0
*/
type GetCustomerPaymentInstrumentsListGoneBodyErrorsItems0DetailsItems0 struct {

	// The location of the field that caused the error.
	// Read Only: true
	Location string `json:"location,omitempty"`

	// The name of the field that caused the error.
	// Read Only: true
	Name string `json:"name,omitempty"`
}

// Validate validates this get customer payment instruments list gone body errors items0 details items0
func (o *GetCustomerPaymentInstrumentsListGoneBodyErrorsItems0DetailsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this get customer payment instruments list gone body errors items0 details items0 based on the context it is used
func (o *GetCustomerPaymentInstrumentsListGoneBodyErrorsItems0DetailsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateLocation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListGoneBodyErrorsItems0DetailsItems0) contextValidateLocation(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "location", "body", string(o.Location)); err != nil {
		return err
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListGoneBodyErrorsItems0DetailsItems0) contextValidateName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "name", "body", string(o.Name)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListGoneBodyErrorsItems0DetailsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListGoneBodyErrorsItems0DetailsItems0) UnmarshalBinary(b []byte) error {
	var res GetCustomerPaymentInstrumentsListGoneBodyErrorsItems0DetailsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetCustomerPaymentInstrumentsListInternalServerErrorBody get customer payment instruments list internal server error body
swagger:model GetCustomerPaymentInstrumentsListInternalServerErrorBody
*/
type GetCustomerPaymentInstrumentsListInternalServerErrorBody struct {

	// errors
	// Read Only: true
	Errors []*GetCustomerPaymentInstrumentsListInternalServerErrorBodyErrorsItems0 `json:"errors"`
}

// Validate validates this get customer payment instruments list internal server error body
func (o *GetCustomerPaymentInstrumentsListInternalServerErrorBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateErrors(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListInternalServerErrorBody) validateErrors(formats strfmt.Registry) error {
	if swag.IsZero(o.Errors) { // not required
		return nil
	}

	for i := 0; i < len(o.Errors); i++ {
		if swag.IsZero(o.Errors[i]) { // not required
			continue
		}

		if o.Errors[i] != nil {
			if err := o.Errors[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("getCustomerPaymentInstrumentsListInternalServerError" + "." + "errors" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("getCustomerPaymentInstrumentsListInternalServerError" + "." + "errors" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this get customer payment instruments list internal server error body based on the context it is used
func (o *GetCustomerPaymentInstrumentsListInternalServerErrorBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateErrors(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListInternalServerErrorBody) contextValidateErrors(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "getCustomerPaymentInstrumentsListInternalServerError"+"."+"errors", "body", []*GetCustomerPaymentInstrumentsListInternalServerErrorBodyErrorsItems0(o.Errors)); err != nil {
		return err
	}

	for i := 0; i < len(o.Errors); i++ {

		if o.Errors[i] != nil {
			if err := o.Errors[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("getCustomerPaymentInstrumentsListInternalServerError" + "." + "errors" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("getCustomerPaymentInstrumentsListInternalServerError" + "." + "errors" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListInternalServerErrorBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListInternalServerErrorBody) UnmarshalBinary(b []byte) error {
	var res GetCustomerPaymentInstrumentsListInternalServerErrorBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetCustomerPaymentInstrumentsListInternalServerErrorBodyErrorsItems0 get customer payment instruments list internal server error body errors items0
swagger:model GetCustomerPaymentInstrumentsListInternalServerErrorBodyErrorsItems0
*/
type GetCustomerPaymentInstrumentsListInternalServerErrorBodyErrorsItems0 struct {

	// details
	// Read Only: true
	Details []*GetCustomerPaymentInstrumentsListInternalServerErrorBodyErrorsItems0DetailsItems0 `json:"details"`

	// The detailed message related to the type stated above.
	// Read Only: true
	Message string `json:"message,omitempty"`

	// The type of error.
	// Read Only: true
	Type string `json:"type,omitempty"`
}

// Validate validates this get customer payment instruments list internal server error body errors items0
func (o *GetCustomerPaymentInstrumentsListInternalServerErrorBodyErrorsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListInternalServerErrorBodyErrorsItems0) validateDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.Details) { // not required
		return nil
	}

	for i := 0; i < len(o.Details); i++ {
		if swag.IsZero(o.Details[i]) { // not required
			continue
		}

		if o.Details[i] != nil {
			if err := o.Details[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this get customer payment instruments list internal server error body errors items0 based on the context it is used
func (o *GetCustomerPaymentInstrumentsListInternalServerErrorBodyErrorsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateMessage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListInternalServerErrorBodyErrorsItems0) contextValidateDetails(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "details", "body", []*GetCustomerPaymentInstrumentsListInternalServerErrorBodyErrorsItems0DetailsItems0(o.Details)); err != nil {
		return err
	}

	for i := 0; i < len(o.Details); i++ {

		if o.Details[i] != nil {
			if err := o.Details[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListInternalServerErrorBodyErrorsItems0) contextValidateMessage(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "message", "body", string(o.Message)); err != nil {
		return err
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListInternalServerErrorBodyErrorsItems0) contextValidateType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "type", "body", string(o.Type)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListInternalServerErrorBodyErrorsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListInternalServerErrorBodyErrorsItems0) UnmarshalBinary(b []byte) error {
	var res GetCustomerPaymentInstrumentsListInternalServerErrorBodyErrorsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetCustomerPaymentInstrumentsListInternalServerErrorBodyErrorsItems0DetailsItems0 get customer payment instruments list internal server error body errors items0 details items0
swagger:model GetCustomerPaymentInstrumentsListInternalServerErrorBodyErrorsItems0DetailsItems0
*/
type GetCustomerPaymentInstrumentsListInternalServerErrorBodyErrorsItems0DetailsItems0 struct {

	// The location of the field that caused the error.
	// Read Only: true
	Location string `json:"location,omitempty"`

	// The name of the field that caused the error.
	// Read Only: true
	Name string `json:"name,omitempty"`
}

// Validate validates this get customer payment instruments list internal server error body errors items0 details items0
func (o *GetCustomerPaymentInstrumentsListInternalServerErrorBodyErrorsItems0DetailsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this get customer payment instruments list internal server error body errors items0 details items0 based on the context it is used
func (o *GetCustomerPaymentInstrumentsListInternalServerErrorBodyErrorsItems0DetailsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateLocation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListInternalServerErrorBodyErrorsItems0DetailsItems0) contextValidateLocation(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "location", "body", string(o.Location)); err != nil {
		return err
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListInternalServerErrorBodyErrorsItems0DetailsItems0) contextValidateName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "name", "body", string(o.Name)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListInternalServerErrorBodyErrorsItems0DetailsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListInternalServerErrorBodyErrorsItems0DetailsItems0) UnmarshalBinary(b []byte) error {
	var res GetCustomerPaymentInstrumentsListInternalServerErrorBodyErrorsItems0DetailsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetCustomerPaymentInstrumentsListNotFoundBody get customer payment instruments list not found body
swagger:model GetCustomerPaymentInstrumentsListNotFoundBody
*/
type GetCustomerPaymentInstrumentsListNotFoundBody struct {

	// errors
	// Read Only: true
	Errors []*GetCustomerPaymentInstrumentsListNotFoundBodyErrorsItems0 `json:"errors"`
}

// Validate validates this get customer payment instruments list not found body
func (o *GetCustomerPaymentInstrumentsListNotFoundBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateErrors(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListNotFoundBody) validateErrors(formats strfmt.Registry) error {
	if swag.IsZero(o.Errors) { // not required
		return nil
	}

	for i := 0; i < len(o.Errors); i++ {
		if swag.IsZero(o.Errors[i]) { // not required
			continue
		}

		if o.Errors[i] != nil {
			if err := o.Errors[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("getCustomerPaymentInstrumentsListNotFound" + "." + "errors" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("getCustomerPaymentInstrumentsListNotFound" + "." + "errors" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this get customer payment instruments list not found body based on the context it is used
func (o *GetCustomerPaymentInstrumentsListNotFoundBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateErrors(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListNotFoundBody) contextValidateErrors(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "getCustomerPaymentInstrumentsListNotFound"+"."+"errors", "body", []*GetCustomerPaymentInstrumentsListNotFoundBodyErrorsItems0(o.Errors)); err != nil {
		return err
	}

	for i := 0; i < len(o.Errors); i++ {

		if o.Errors[i] != nil {
			if err := o.Errors[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("getCustomerPaymentInstrumentsListNotFound" + "." + "errors" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("getCustomerPaymentInstrumentsListNotFound" + "." + "errors" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListNotFoundBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListNotFoundBody) UnmarshalBinary(b []byte) error {
	var res GetCustomerPaymentInstrumentsListNotFoundBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetCustomerPaymentInstrumentsListNotFoundBodyErrorsItems0 get customer payment instruments list not found body errors items0
swagger:model GetCustomerPaymentInstrumentsListNotFoundBodyErrorsItems0
*/
type GetCustomerPaymentInstrumentsListNotFoundBodyErrorsItems0 struct {

	// details
	// Read Only: true
	Details []*GetCustomerPaymentInstrumentsListNotFoundBodyErrorsItems0DetailsItems0 `json:"details"`

	// The detailed message related to the type stated above.
	// Read Only: true
	Message string `json:"message,omitempty"`

	// The type of error.
	// Read Only: true
	Type string `json:"type,omitempty"`
}

// Validate validates this get customer payment instruments list not found body errors items0
func (o *GetCustomerPaymentInstrumentsListNotFoundBodyErrorsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListNotFoundBodyErrorsItems0) validateDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.Details) { // not required
		return nil
	}

	for i := 0; i < len(o.Details); i++ {
		if swag.IsZero(o.Details[i]) { // not required
			continue
		}

		if o.Details[i] != nil {
			if err := o.Details[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this get customer payment instruments list not found body errors items0 based on the context it is used
func (o *GetCustomerPaymentInstrumentsListNotFoundBodyErrorsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateMessage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListNotFoundBodyErrorsItems0) contextValidateDetails(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "details", "body", []*GetCustomerPaymentInstrumentsListNotFoundBodyErrorsItems0DetailsItems0(o.Details)); err != nil {
		return err
	}

	for i := 0; i < len(o.Details); i++ {

		if o.Details[i] != nil {
			if err := o.Details[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListNotFoundBodyErrorsItems0) contextValidateMessage(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "message", "body", string(o.Message)); err != nil {
		return err
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListNotFoundBodyErrorsItems0) contextValidateType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "type", "body", string(o.Type)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListNotFoundBodyErrorsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListNotFoundBodyErrorsItems0) UnmarshalBinary(b []byte) error {
	var res GetCustomerPaymentInstrumentsListNotFoundBodyErrorsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetCustomerPaymentInstrumentsListNotFoundBodyErrorsItems0DetailsItems0 get customer payment instruments list not found body errors items0 details items0
swagger:model GetCustomerPaymentInstrumentsListNotFoundBodyErrorsItems0DetailsItems0
*/
type GetCustomerPaymentInstrumentsListNotFoundBodyErrorsItems0DetailsItems0 struct {

	// The location of the field that caused the error.
	// Read Only: true
	Location string `json:"location,omitempty"`

	// The name of the field that caused the error.
	// Read Only: true
	Name string `json:"name,omitempty"`
}

// Validate validates this get customer payment instruments list not found body errors items0 details items0
func (o *GetCustomerPaymentInstrumentsListNotFoundBodyErrorsItems0DetailsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this get customer payment instruments list not found body errors items0 details items0 based on the context it is used
func (o *GetCustomerPaymentInstrumentsListNotFoundBodyErrorsItems0DetailsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateLocation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListNotFoundBodyErrorsItems0DetailsItems0) contextValidateLocation(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "location", "body", string(o.Location)); err != nil {
		return err
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListNotFoundBodyErrorsItems0DetailsItems0) contextValidateName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "name", "body", string(o.Name)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListNotFoundBodyErrorsItems0DetailsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListNotFoundBodyErrorsItems0DetailsItems0) UnmarshalBinary(b []byte) error {
	var res GetCustomerPaymentInstrumentsListNotFoundBodyErrorsItems0DetailsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetCustomerPaymentInstrumentsListOKBody PaymentInstrumentList
swagger:model GetCustomerPaymentInstrumentsListOKBody
*/
type GetCustomerPaymentInstrumentsListOKBody struct {

	// embedded
	Embedded *GetCustomerPaymentInstrumentsListOKBodyEmbedded `json:"_embedded,omitempty"`

	// links
	Links *GetCustomerPaymentInstrumentsListOKBodyLinks `json:"_links,omitempty"`

	// The number of Payment Instruments returned in the array.
	// Example: 1
	// Read Only: true
	Count int64 `json:"count,omitempty"`

	// The limit parameter supplied in the request.
	// Example: 20
	// Read Only: true
	Limit int64 `json:"limit,omitempty"`

	// The offset parameter supplied in the request.
	// Example: 0
	// Read Only: true
	Offset int64 `json:"offset,omitempty"`

	// The total number of Payment Instruments associated with the Customer or Instrument Identifier.
	// Example: 1
	// Read Only: true
	Total int64 `json:"total,omitempty"`
}

// Validate validates this get customer payment instruments list o k body
func (o *GetCustomerPaymentInstrumentsListOKBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateEmbedded(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBody) validateEmbedded(formats strfmt.Registry) error {
	if swag.IsZero(o.Embedded) { // not required
		return nil
	}

	if o.Embedded != nil {
		if err := o.Embedded.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getCustomerPaymentInstrumentsListOK" + "." + "_embedded")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getCustomerPaymentInstrumentsListOK" + "." + "_embedded")
			}
			return err
		}
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBody) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(o.Links) { // not required
		return nil
	}

	if o.Links != nil {
		if err := o.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getCustomerPaymentInstrumentsListOK" + "." + "_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getCustomerPaymentInstrumentsListOK" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this get customer payment instruments list o k body based on the context it is used
func (o *GetCustomerPaymentInstrumentsListOKBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateEmbedded(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateCount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateLimit(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateOffset(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateTotal(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBody) contextValidateEmbedded(ctx context.Context, formats strfmt.Registry) error {

	if o.Embedded != nil {
		if err := o.Embedded.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getCustomerPaymentInstrumentsListOK" + "." + "_embedded")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getCustomerPaymentInstrumentsListOK" + "." + "_embedded")
			}
			return err
		}
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBody) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if o.Links != nil {
		if err := o.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getCustomerPaymentInstrumentsListOK" + "." + "_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getCustomerPaymentInstrumentsListOK" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBody) contextValidateCount(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "getCustomerPaymentInstrumentsListOK"+"."+"count", "body", int64(o.Count)); err != nil {
		return err
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBody) contextValidateLimit(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "getCustomerPaymentInstrumentsListOK"+"."+"limit", "body", int64(o.Limit)); err != nil {
		return err
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBody) contextValidateOffset(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "getCustomerPaymentInstrumentsListOK"+"."+"offset", "body", int64(o.Offset)); err != nil {
		return err
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBody) contextValidateTotal(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "getCustomerPaymentInstrumentsListOK"+"."+"total", "body", int64(o.Total)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBody) UnmarshalBinary(b []byte) error {
	var res GetCustomerPaymentInstrumentsListOKBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetCustomerPaymentInstrumentsListOKBodyEmbedded Payment Instrument Resources.
//
swagger:model GetCustomerPaymentInstrumentsListOKBodyEmbedded
*/
type GetCustomerPaymentInstrumentsListOKBodyEmbedded struct {

	// payment instruments
	// Read Only: true
	PaymentInstruments []*GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0 `json:"paymentInstruments"`
}

// Validate validates this get customer payment instruments list o k body embedded
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbedded) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validatePaymentInstruments(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbedded) validatePaymentInstruments(formats strfmt.Registry) error {
	if swag.IsZero(o.PaymentInstruments) { // not required
		return nil
	}

	for i := 0; i < len(o.PaymentInstruments); i++ {
		if swag.IsZero(o.PaymentInstruments[i]) { // not required
			continue
		}

		if o.PaymentInstruments[i] != nil {
			if err := o.PaymentInstruments[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("getCustomerPaymentInstrumentsListOK" + "." + "_embedded" + "." + "paymentInstruments" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("getCustomerPaymentInstrumentsListOK" + "." + "_embedded" + "." + "paymentInstruments" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this get customer payment instruments list o k body embedded based on the context it is used
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbedded) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidatePaymentInstruments(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbedded) contextValidatePaymentInstruments(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "getCustomerPaymentInstrumentsListOK"+"."+"_embedded"+"."+"paymentInstruments", "body", []*GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0(o.PaymentInstruments)); err != nil {
		return err
	}

	for i := 0; i < len(o.PaymentInstruments); i++ {

		if o.PaymentInstruments[i] != nil {
			if err := o.PaymentInstruments[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("getCustomerPaymentInstrumentsListOK" + "." + "_embedded" + "." + "paymentInstruments" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("getCustomerPaymentInstrumentsListOK" + "." + "_embedded" + "." + "paymentInstruments" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbedded) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbedded) UnmarshalBinary(b []byte) error {
	var res GetCustomerPaymentInstrumentsListOKBodyEmbedded
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0 get customer payment instruments list o k body embedded payment instruments items0
swagger:model GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0
*/
type GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0 struct {

	// embedded
	Embedded *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0Embedded `json:"_embedded,omitempty"`

	// links
	Links *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0Links `json:"_links,omitempty"`

	// bank account
	BankAccount *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0BankAccount `json:"bankAccount,omitempty"`

	// bill to
	BillTo *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0BillTo `json:"billTo,omitempty"`

	// buyer information
	BuyerInformation *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0BuyerInformation `json:"buyerInformation,omitempty"`

	// card
	Card *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0Card `json:"card,omitempty"`

	// Flag that indicates whether customer payment instrument is the dafault.
	// Valid values:
	//  - `true`: Payment instrument is customer's default.
	//  - `false`: Payment instrument is not customer's default.
	//
	Default bool `json:"default,omitempty"`

	// The id of the Payment Instrument Token.
	// Max Length: 32
	// Min Length: 1
	ID string `json:"id,omitempty"`

	// instrument identifier
	InstrumentIdentifier *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0InstrumentIdentifier `json:"instrumentIdentifier,omitempty"`

	// merchant information
	MerchantInformation *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0MerchantInformation `json:"merchantInformation,omitempty"`

	// metadata
	Metadata *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0Metadata `json:"metadata,omitempty"`

	// The type of token.
	//
	// Valid values:
	// - paymentInstrument
	//
	// Example: paymentInstrument
	// Read Only: true
	Object string `json:"object,omitempty"`

	// processing information
	ProcessingInformation *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0ProcessingInformation `json:"processingInformation,omitempty"`

	// Issuers state for the card number.
	// Valid values:
	// - ACTIVE
	// - CLOSED : The account has been closed.
	//
	// Example: ACTIVE
	// Read Only: true
	State string `json:"state,omitempty"`
}

// Validate validates this get customer payment instruments list o k body embedded payment instruments items0
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateEmbedded(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBankAccount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBillTo(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBuyerInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCard(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateInstrumentIdentifier(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMerchantInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMetadata(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProcessingInformation(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0) validateEmbedded(formats strfmt.Registry) error {
	if swag.IsZero(o.Embedded) { // not required
		return nil
	}

	if o.Embedded != nil {
		if err := o.Embedded.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_embedded")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("_embedded")
			}
			return err
		}
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(o.Links) { // not required
		return nil
	}

	if o.Links != nil {
		if err := o.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0) validateBankAccount(formats strfmt.Registry) error {
	if swag.IsZero(o.BankAccount) { // not required
		return nil
	}

	if o.BankAccount != nil {
		if err := o.BankAccount.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("bankAccount")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("bankAccount")
			}
			return err
		}
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0) validateBillTo(formats strfmt.Registry) error {
	if swag.IsZero(o.BillTo) { // not required
		return nil
	}

	if o.BillTo != nil {
		if err := o.BillTo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("billTo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("billTo")
			}
			return err
		}
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0) validateBuyerInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.BuyerInformation) { // not required
		return nil
	}

	if o.BuyerInformation != nil {
		if err := o.BuyerInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("buyerInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("buyerInformation")
			}
			return err
		}
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0) validateCard(formats strfmt.Registry) error {
	if swag.IsZero(o.Card) { // not required
		return nil
	}

	if o.Card != nil {
		if err := o.Card.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("card")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("card")
			}
			return err
		}
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MinLength("id", "body", o.ID, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("id", "body", o.ID, 32); err != nil {
		return err
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0) validateInstrumentIdentifier(formats strfmt.Registry) error {
	if swag.IsZero(o.InstrumentIdentifier) { // not required
		return nil
	}

	if o.InstrumentIdentifier != nil {
		if err := o.InstrumentIdentifier.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("instrumentIdentifier")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("instrumentIdentifier")
			}
			return err
		}
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0) validateMerchantInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.MerchantInformation) { // not required
		return nil
	}

	if o.MerchantInformation != nil {
		if err := o.MerchantInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("merchantInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("merchantInformation")
			}
			return err
		}
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0) validateMetadata(formats strfmt.Registry) error {
	if swag.IsZero(o.Metadata) { // not required
		return nil
	}

	if o.Metadata != nil {
		if err := o.Metadata.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("metadata")
			}
			return err
		}
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0) validateProcessingInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ProcessingInformation) { // not required
		return nil
	}

	if o.ProcessingInformation != nil {
		if err := o.ProcessingInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("processingInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("processingInformation")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this get customer payment instruments list o k body embedded payment instruments items0 based on the context it is used
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateEmbedded(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateBankAccount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateBillTo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateBuyerInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateCard(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateInstrumentIdentifier(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateMerchantInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateMetadata(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateObject(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateProcessingInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0) contextValidateEmbedded(ctx context.Context, formats strfmt.Registry) error {

	if o.Embedded != nil {
		if err := o.Embedded.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_embedded")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("_embedded")
			}
			return err
		}
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if o.Links != nil {
		if err := o.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("_links")
			}
			return err
		}
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0) contextValidateBankAccount(ctx context.Context, formats strfmt.Registry) error {

	if o.BankAccount != nil {
		if err := o.BankAccount.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("bankAccount")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("bankAccount")
			}
			return err
		}
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0) contextValidateBillTo(ctx context.Context, formats strfmt.Registry) error {

	if o.BillTo != nil {
		if err := o.BillTo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("billTo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("billTo")
			}
			return err
		}
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0) contextValidateBuyerInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.BuyerInformation != nil {
		if err := o.BuyerInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("buyerInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("buyerInformation")
			}
			return err
		}
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0) contextValidateCard(ctx context.Context, formats strfmt.Registry) error {

	if o.Card != nil {
		if err := o.Card.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("card")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("card")
			}
			return err
		}
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0) contextValidateInstrumentIdentifier(ctx context.Context, formats strfmt.Registry) error {

	if o.InstrumentIdentifier != nil {
		if err := o.InstrumentIdentifier.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("instrumentIdentifier")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("instrumentIdentifier")
			}
			return err
		}
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0) contextValidateMerchantInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.MerchantInformation != nil {
		if err := o.MerchantInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("merchantInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("merchantInformation")
			}
			return err
		}
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0) contextValidateMetadata(ctx context.Context, formats strfmt.Registry) error {

	if o.Metadata != nil {
		if err := o.Metadata.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("metadata")
			}
			return err
		}
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0) contextValidateObject(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "object", "body", string(o.Object)); err != nil {
		return err
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0) contextValidateProcessingInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ProcessingInformation != nil {
		if err := o.ProcessingInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("processingInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("processingInformation")
			}
			return err
		}
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "state", "body", string(o.State)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0) UnmarshalBinary(b []byte) error {
	var res GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0BankAccount get customer payment instruments list o k body embedded payment instruments items0 bank account
swagger:model GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0BankAccount
*/
type GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0BankAccount struct {

	// Account type.
	//
	// Valid values:
	//  - checking : C
	//  - general ledger : G This value is supported only on Wells Fargo ACH
	//  - savings : S (U.S. dollars only)
	//  - corporate checking : X (U.S. dollars only)
	//
	// Max Length: 18
	Type string `json:"type,omitempty"`
}

// Validate validates this get customer payment instruments list o k body embedded payment instruments items0 bank account
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0BankAccount) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0BankAccount) validateType(formats strfmt.Registry) error {
	if swag.IsZero(o.Type) { // not required
		return nil
	}

	if err := validate.MaxLength("bankAccount"+"."+"type", "body", o.Type, 18); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this get customer payment instruments list o k body embedded payment instruments items0 bank account based on context it is used
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0BankAccount) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0BankAccount) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0BankAccount) UnmarshalBinary(b []byte) error {
	var res GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0BankAccount
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0BillTo get customer payment instruments list o k body embedded payment instruments items0 bill to
swagger:model GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0BillTo
*/
type GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0BillTo struct {

	// Payment card billing street address as it appears on the credit card issuers records.
	//
	// Max Length: 60
	Address1 string `json:"address1,omitempty"`

	// Additional address information.
	//
	// Max Length: 60
	Address2 string `json:"address2,omitempty"`

	// State or province of the billing address. Use the State, Province, and Territory Codes for the United States
	// and Canada.
	//
	// Max Length: 20
	AdministrativeArea string `json:"administrativeArea,omitempty"`

	// Name of the customers company.
	//
	// Max Length: 60
	Company string `json:"company,omitempty"`

	// Payment card billing country. Use the two-character ISO Standard Country Codes.
	//
	// Max Length: 2
	Country string `json:"country,omitempty"`

	// Customer's email address, including the full domain name.
	//
	// Max Length: 255
	Email string `json:"email,omitempty"`

	// Customers first name. This name must be the same as the name on the card.
	//
	// Max Length: 60
	FirstName string `json:"firstName,omitempty"`

	// Customers last name. This name must be the same as the name on the card.
	//
	// Max Length: 60
	LastName string `json:"lastName,omitempty"`

	// Payment card billing city.
	//
	// Max Length: 50
	Locality string `json:"locality,omitempty"`

	// Customers phone number.
	//
	// Max Length: 15
	PhoneNumber string `json:"phoneNumber,omitempty"`

	// Postal code for the billing address. The postal code must consist of 5 to 9 digits.
	//
	// When the billing country is the U.S., the 9-digit postal code must follow this format:
	// [5 digits][dash][4 digits]
	//
	// **Example** `12345-6789`
	//
	// When the billing country is Canada, the 6-digit postal code must follow this format:
	// [alpha][numeric][alpha][space][numeric][alpha][numeric]
	//
	// **Example** `A1B 2C3`
	//
	// Max Length: 10
	PostalCode string `json:"postalCode,omitempty"`
}

// Validate validates this get customer payment instruments list o k body embedded payment instruments items0 bill to
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0BillTo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAddress1(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAddress2(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAdministrativeArea(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCompany(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEmail(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFirstName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLastName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocality(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePhoneNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0BillTo) validateAddress1(formats strfmt.Registry) error {
	if swag.IsZero(o.Address1) { // not required
		return nil
	}

	if err := validate.MaxLength("billTo"+"."+"address1", "body", o.Address1, 60); err != nil {
		return err
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0BillTo) validateAddress2(formats strfmt.Registry) error {
	if swag.IsZero(o.Address2) { // not required
		return nil
	}

	if err := validate.MaxLength("billTo"+"."+"address2", "body", o.Address2, 60); err != nil {
		return err
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0BillTo) validateAdministrativeArea(formats strfmt.Registry) error {
	if swag.IsZero(o.AdministrativeArea) { // not required
		return nil
	}

	if err := validate.MaxLength("billTo"+"."+"administrativeArea", "body", o.AdministrativeArea, 20); err != nil {
		return err
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0BillTo) validateCompany(formats strfmt.Registry) error {
	if swag.IsZero(o.Company) { // not required
		return nil
	}

	if err := validate.MaxLength("billTo"+"."+"company", "body", o.Company, 60); err != nil {
		return err
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0BillTo) validateCountry(formats strfmt.Registry) error {
	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("billTo"+"."+"country", "body", o.Country, 2); err != nil {
		return err
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0BillTo) validateEmail(formats strfmt.Registry) error {
	if swag.IsZero(o.Email) { // not required
		return nil
	}

	if err := validate.MaxLength("billTo"+"."+"email", "body", o.Email, 255); err != nil {
		return err
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0BillTo) validateFirstName(formats strfmt.Registry) error {
	if swag.IsZero(o.FirstName) { // not required
		return nil
	}

	if err := validate.MaxLength("billTo"+"."+"firstName", "body", o.FirstName, 60); err != nil {
		return err
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0BillTo) validateLastName(formats strfmt.Registry) error {
	if swag.IsZero(o.LastName) { // not required
		return nil
	}

	if err := validate.MaxLength("billTo"+"."+"lastName", "body", o.LastName, 60); err != nil {
		return err
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0BillTo) validateLocality(formats strfmt.Registry) error {
	if swag.IsZero(o.Locality) { // not required
		return nil
	}

	if err := validate.MaxLength("billTo"+"."+"locality", "body", o.Locality, 50); err != nil {
		return err
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0BillTo) validatePhoneNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.PhoneNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("billTo"+"."+"phoneNumber", "body", o.PhoneNumber, 15); err != nil {
		return err
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0BillTo) validatePostalCode(formats strfmt.Registry) error {
	if swag.IsZero(o.PostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("billTo"+"."+"postalCode", "body", o.PostalCode, 10); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this get customer payment instruments list o k body embedded payment instruments items0 bill to based on context it is used
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0BillTo) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0BillTo) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0BillTo) UnmarshalBinary(b []byte) error {
	var res GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0BillTo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0BuyerInformation get customer payment instruments list o k body embedded payment instruments items0 buyer information
swagger:model GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0BuyerInformation
*/
type GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0BuyerInformation struct {

	// Companys tax identifier. This is only used for eCheck service.
	//
	// Max Length: 9
	CompanyTaxID string `json:"companyTaxID,omitempty"`

	// Currency used for the order. Use the three-character I[ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)
	//
	// For details about currency as used in partial authorizations, see "Features for Debit Cards and Prepaid Cards" in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// For an authorization reversal (`reversalInformation`) or a capture (`processingOptions.capture` is set to `true`), you must use the same currency that you used in your payment authorization request.
	//
	// #### DCC for First Data
	// Your local currency. For details, see the `currency` field description in [Dynamic Currency Conversion For First Data Using the SCMP API](http://apps.cybersource.com/library/documentation/dev_guides/DCC_FirstData_SCMP/DCC_FirstData_SCMP_API.pdf).
	//
	// Max Length: 3
	Currency string `json:"currency,omitempty"`

	// Date of birth of the customer. Format: YYYY-MM-DD
	//
	// Example: 1960-12-30
	// Format: date
	DateOfBirth strfmt.Date `json:"dateOfBirth,omitempty"`

	// personal identification
	PersonalIdentification []*GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0BuyerInformationPersonalIdentificationItems0 `json:"personalIdentification"`
}

// Validate validates this get customer payment instruments list o k body embedded payment instruments items0 buyer information
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0BuyerInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCompanyTaxID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCurrency(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDateOfBirth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePersonalIdentification(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0BuyerInformation) validateCompanyTaxID(formats strfmt.Registry) error {
	if swag.IsZero(o.CompanyTaxID) { // not required
		return nil
	}

	if err := validate.MaxLength("buyerInformation"+"."+"companyTaxID", "body", o.CompanyTaxID, 9); err != nil {
		return err
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0BuyerInformation) validateCurrency(formats strfmt.Registry) error {
	if swag.IsZero(o.Currency) { // not required
		return nil
	}

	if err := validate.MaxLength("buyerInformation"+"."+"currency", "body", o.Currency, 3); err != nil {
		return err
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0BuyerInformation) validateDateOfBirth(formats strfmt.Registry) error {
	if swag.IsZero(o.DateOfBirth) { // not required
		return nil
	}

	if err := validate.FormatOf("buyerInformation"+"."+"dateOfBirth", "body", "date", o.DateOfBirth.String(), formats); err != nil {
		return err
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0BuyerInformation) validatePersonalIdentification(formats strfmt.Registry) error {
	if swag.IsZero(o.PersonalIdentification) { // not required
		return nil
	}

	for i := 0; i < len(o.PersonalIdentification); i++ {
		if swag.IsZero(o.PersonalIdentification[i]) { // not required
			continue
		}

		if o.PersonalIdentification[i] != nil {
			if err := o.PersonalIdentification[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("buyerInformation" + "." + "personalIdentification" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("buyerInformation" + "." + "personalIdentification" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this get customer payment instruments list o k body embedded payment instruments items0 buyer information based on the context it is used
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0BuyerInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidatePersonalIdentification(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0BuyerInformation) contextValidatePersonalIdentification(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.PersonalIdentification); i++ {

		if o.PersonalIdentification[i] != nil {
			if err := o.PersonalIdentification[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("buyerInformation" + "." + "personalIdentification" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("buyerInformation" + "." + "personalIdentification" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0BuyerInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0BuyerInformation) UnmarshalBinary(b []byte) error {
	var res GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0BuyerInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0BuyerInformationPersonalIdentificationItems0 get customer payment instruments list o k body embedded payment instruments items0 buyer information personal identification items0
swagger:model GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0BuyerInformationPersonalIdentificationItems0
*/
type GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0BuyerInformationPersonalIdentificationItems0 struct {

	// The value of the identification type.
	//
	// Max Length: 26
	ID string `json:"id,omitempty"`

	// issued by
	IssuedBy *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0BuyerInformationPersonalIdentificationItems0IssuedBy `json:"issuedBy,omitempty"`

	// The type of the identification.
	//
	// Valid values:
	//   - driver license
	//
	Type string `json:"type,omitempty"`
}

// Validate validates this get customer payment instruments list o k body embedded payment instruments items0 buyer information personal identification items0
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0BuyerInformationPersonalIdentificationItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateIssuedBy(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0BuyerInformationPersonalIdentificationItems0) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MaxLength("id", "body", o.ID, 26); err != nil {
		return err
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0BuyerInformationPersonalIdentificationItems0) validateIssuedBy(formats strfmt.Registry) error {
	if swag.IsZero(o.IssuedBy) { // not required
		return nil
	}

	if o.IssuedBy != nil {
		if err := o.IssuedBy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("issuedBy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("issuedBy")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this get customer payment instruments list o k body embedded payment instruments items0 buyer information personal identification items0 based on the context it is used
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0BuyerInformationPersonalIdentificationItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateIssuedBy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0BuyerInformationPersonalIdentificationItems0) contextValidateIssuedBy(ctx context.Context, formats strfmt.Registry) error {

	if o.IssuedBy != nil {
		if err := o.IssuedBy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("issuedBy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("issuedBy")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0BuyerInformationPersonalIdentificationItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0BuyerInformationPersonalIdentificationItems0) UnmarshalBinary(b []byte) error {
	var res GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0BuyerInformationPersonalIdentificationItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0BuyerInformationPersonalIdentificationItems0IssuedBy get customer payment instruments list o k body embedded payment instruments items0 buyer information personal identification items0 issued by
swagger:model GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0BuyerInformationPersonalIdentificationItems0IssuedBy
*/
type GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0BuyerInformationPersonalIdentificationItems0IssuedBy struct {

	// The State or province where the customers drivers license was issued.
	//
	// Use the two-character State, Province, and Territory Codes for the United States and Canada.
	//
	// Max Length: 20
	AdministrativeArea string `json:"administrativeArea,omitempty"`
}

// Validate validates this get customer payment instruments list o k body embedded payment instruments items0 buyer information personal identification items0 issued by
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0BuyerInformationPersonalIdentificationItems0IssuedBy) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAdministrativeArea(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0BuyerInformationPersonalIdentificationItems0IssuedBy) validateAdministrativeArea(formats strfmt.Registry) error {
	if swag.IsZero(o.AdministrativeArea) { // not required
		return nil
	}

	if err := validate.MaxLength("issuedBy"+"."+"administrativeArea", "body", o.AdministrativeArea, 20); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this get customer payment instruments list o k body embedded payment instruments items0 buyer information personal identification items0 issued by based on context it is used
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0BuyerInformationPersonalIdentificationItems0IssuedBy) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0BuyerInformationPersonalIdentificationItems0IssuedBy) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0BuyerInformationPersonalIdentificationItems0IssuedBy) UnmarshalBinary(b []byte) error {
	var res GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0BuyerInformationPersonalIdentificationItems0IssuedBy
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0Card get customer payment instruments list o k body embedded payment instruments items0 card
swagger:model GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0Card
*/
type GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0Card struct {

	// Two-digit month in which the payment card expires.
	//
	// Format: `MM`.
	//
	// Valid values: `01` through `12`.
	//
	// Max Length: 2
	ExpirationMonth string `json:"expirationMonth,omitempty"`

	// Four-digit year in which the credit card expires.
	//
	// Format: `YYYY`.
	//
	// Max Length: 4
	ExpirationYear string `json:"expirationYear,omitempty"`

	// Number of times a Maestro (UK Domestic) card has been issued to the account holder. The card might or might not have an issue number. The number can consist of one or two digits, and the first digit might be a zero. When you include this value in your request, include exactly what is printed on the card. A value of 2 is different than a value of 02. Do not include the field, even with a blank value, if the card is not a Maestro (UK Domestic) card.
	//
	// **Note** The issue number is not required for Maestro (UK Domestic) transactions.
	//
	// Max Length: 2
	IssueNumber string `json:"issueNumber,omitempty"`

	// Month of the start of the Maestro (UK Domestic) card validity period. Do not include the field, even with a blank value, if the card is not a Maestro (UK Domestic) card. `Format: MM`.
	// Valid values: 01 through 12.
	//
	// **Note** The start date is not required for Maestro (UK Domestic) transactions.
	//
	// Max Length: 2
	StartMonth string `json:"startMonth,omitempty"`

	// Year of the start of the Maestro (UK Domestic) card validity period. Do not include the field, even with a blank value, if the card is not a Maestro (UK Domestic) card. `Format: YYYY`.
	//
	// **Note** The start date is not required for Maestro (UK Domestic) transactions.
	//
	// Max Length: 4
	StartYear string `json:"startYear,omitempty"`

	// tokenized information
	TokenizedInformation *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0CardTokenizedInformation `json:"tokenizedInformation,omitempty"`

	// Value that indicates the card type. Valid v2 : v1 - description values:
	//   * 001 : visa
	//   * 002 : mastercard - EurocardEuropean regional brand of Mastercard
	//   * 003 : american express
	//   * 004 : discover
	//   * 005 : diners club
	//   * 006 : carte blanche
	//   * 007 : jcb
	//   * 008 : optima
	//   * 011 : twinpay credit
	//   * 012 : twinpay debit
	//   * 013 : walmart
	//   * 014 : enRoute
	//   * 015 : lowes consumer
	//   * 016 : home depot consumer
	//   * 017 : mbna
	//   * 018 : dicks sportswear
	//   * 019 : casual corner
	//   * 020 : sears
	//   * 021 : jal
	//   * 023 : disney
	//   * 024 : maestro uk domestic
	//   * 025 : sams club consumer
	//   * 026 : sams club business
	//   * 028 : bill me later
	//   * 029 : bebe
	//   * 030 : restoration hardware
	//   * 031 : delta online  use this value only for Ingenico ePayments. For other processors, use 001 for all Visa card types.
	//   * 032 : solo
	//   * 033 : visa electron
	//   * 034 : dankort
	//   * 035 : laser
	//   * 036 : carte bleue  formerly Cartes Bancaires
	//   * 037 : carta si
	//   * 038 : pinless debit
	//   * 039 : encoded account
	//   * 040 : uatp
	//   * 041 : household
	//   * 042 : maestro international
	//   * 043 : ge money uk
	//   * 044 : korean cards
	//   * 045 : style
	//   * 046 : jcrew
	//   * 047 : payease china processing ewallet
	//   * 048 : payease china processing bank transfer
	//   * 049 : meijer private label
	//   * 050 : hipercard  supported only by the Comercio Latino processor.
	//   * 051 : aura  supported only by the Comercio Latino processor.
	//   * 052 : redecard
	//   * 054 : elo  supported only by the Comercio Latino processor.
	//   * 055 : capital one private label
	//   * 056 : synchrony private label
	//   * 057 : costco private label
	//   * 060 : mada
	//   * 062 : china union pay
	//   * 063 : falabella private label
	//
	Type string `json:"type,omitempty"`

	// 'Payment Instrument was created / updated as part of a pinless debit transaction.'
	//
	// Example: pinless debit
	UseAs string `json:"useAs,omitempty"`
}

// Validate validates this get customer payment instruments list o k body embedded payment instruments items0 card
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0Card) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateExpirationMonth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpirationYear(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateIssueNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateStartMonth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateStartYear(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTokenizedInformation(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0Card) validateExpirationMonth(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationMonth) { // not required
		return nil
	}

	if err := validate.MaxLength("card"+"."+"expirationMonth", "body", o.ExpirationMonth, 2); err != nil {
		return err
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0Card) validateExpirationYear(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationYear) { // not required
		return nil
	}

	if err := validate.MaxLength("card"+"."+"expirationYear", "body", o.ExpirationYear, 4); err != nil {
		return err
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0Card) validateIssueNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.IssueNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("card"+"."+"issueNumber", "body", o.IssueNumber, 2); err != nil {
		return err
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0Card) validateStartMonth(formats strfmt.Registry) error {
	if swag.IsZero(o.StartMonth) { // not required
		return nil
	}

	if err := validate.MaxLength("card"+"."+"startMonth", "body", o.StartMonth, 2); err != nil {
		return err
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0Card) validateStartYear(formats strfmt.Registry) error {
	if swag.IsZero(o.StartYear) { // not required
		return nil
	}

	if err := validate.MaxLength("card"+"."+"startYear", "body", o.StartYear, 4); err != nil {
		return err
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0Card) validateTokenizedInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.TokenizedInformation) { // not required
		return nil
	}

	if o.TokenizedInformation != nil {
		if err := o.TokenizedInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("card" + "." + "tokenizedInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("card" + "." + "tokenizedInformation")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this get customer payment instruments list o k body embedded payment instruments items0 card based on the context it is used
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0Card) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateTokenizedInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0Card) contextValidateTokenizedInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.TokenizedInformation != nil {
		if err := o.TokenizedInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("card" + "." + "tokenizedInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("card" + "." + "tokenizedInformation")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0Card) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0Card) UnmarshalBinary(b []byte) error {
	var res GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0Card
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0CardTokenizedInformation get customer payment instruments list o k body embedded payment instruments items0 card tokenized information
swagger:model GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0CardTokenizedInformation
*/
type GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0CardTokenizedInformation struct {

	// Value that identifies your business and indicates that the cardholders account number is tokenized. This value
	// is assigned by the token service provider and is unique within the token service providers database.
	//
	// **Note** This field is supported only for **CyberSource through VisaNet** and **FDC Nashville Global**.
	//
	// Max Length: 11
	RequestorID string `json:"requestorID,omitempty"`

	// Type of transaction that provided the token data. This value does not specify the token service provider; it
	// specifies the entity that provided you with information about the token.
	//
	// Set the value for this field to 1. An application on the customers mobile device provided the token data.
	//
	// Max Length: 1
	TransactionType string `json:"transactionType,omitempty"`
}

// Validate validates this get customer payment instruments list o k body embedded payment instruments items0 card tokenized information
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0CardTokenizedInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateRequestorID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTransactionType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0CardTokenizedInformation) validateRequestorID(formats strfmt.Registry) error {
	if swag.IsZero(o.RequestorID) { // not required
		return nil
	}

	if err := validate.MaxLength("card"+"."+"tokenizedInformation"+"."+"requestorID", "body", o.RequestorID, 11); err != nil {
		return err
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0CardTokenizedInformation) validateTransactionType(formats strfmt.Registry) error {
	if swag.IsZero(o.TransactionType) { // not required
		return nil
	}

	if err := validate.MaxLength("card"+"."+"tokenizedInformation"+"."+"transactionType", "body", o.TransactionType, 1); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this get customer payment instruments list o k body embedded payment instruments items0 card tokenized information based on context it is used
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0CardTokenizedInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0CardTokenizedInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0CardTokenizedInformation) UnmarshalBinary(b []byte) error {
	var res GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0CardTokenizedInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0Embedded Additional resources for the Payment Instrument token.
//
swagger:model GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0Embedded
*/
type GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0Embedded struct {

	// instrument identifier
	InstrumentIdentifier *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifier `json:"instrumentIdentifier,omitempty"`
}

// Validate validates this get customer payment instruments list o k body embedded payment instruments items0 embedded
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0Embedded) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateInstrumentIdentifier(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0Embedded) validateInstrumentIdentifier(formats strfmt.Registry) error {
	if swag.IsZero(o.InstrumentIdentifier) { // not required
		return nil
	}

	if o.InstrumentIdentifier != nil {
		if err := o.InstrumentIdentifier.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_embedded" + "." + "instrumentIdentifier")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("_embedded" + "." + "instrumentIdentifier")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this get customer payment instruments list o k body embedded payment instruments items0 embedded based on the context it is used
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0Embedded) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateInstrumentIdentifier(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0Embedded) contextValidateInstrumentIdentifier(ctx context.Context, formats strfmt.Registry) error {

	if o.InstrumentIdentifier != nil {
		if err := o.InstrumentIdentifier.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_embedded" + "." + "instrumentIdentifier")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("_embedded" + "." + "instrumentIdentifier")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0Embedded) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0Embedded) UnmarshalBinary(b []byte) error {
	var res GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0Embedded
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifier get customer payment instruments list o k body embedded payment instruments items0 embedded instrument identifier
swagger:model GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifier
*/
type GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifier struct {

	// links
	Links *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierLinks `json:"_links,omitempty"`

	// bank account
	BankAccount *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierBankAccount `json:"bankAccount,omitempty"`

	// bill to
	BillTo *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierBillTo `json:"billTo,omitempty"`

	// card
	Card *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierCard `json:"card,omitempty"`

	// The id of the Instrument Identifier Token.
	//
	ID string `json:"id,omitempty"`

	// issuer
	Issuer *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierIssuer `json:"issuer,omitempty"`

	// metadata
	Metadata *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierMetadata `json:"metadata,omitempty"`

	// The type of token.
	//
	// Valid values:
	// - instrumentIdentifier
	//
	// Example: instrumentIdentifier
	// Read Only: true
	Object string `json:"object,omitempty"`

	// processing information
	ProcessingInformation *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierProcessingInformation `json:"processingInformation,omitempty"`

	// Issuers state for the card number.
	// Valid values:
	// - ACTIVE
	// - CLOSED : The account has been closed.
	//
	// Example: ACTIVE
	// Read Only: true
	State string `json:"state,omitempty"`

	// tokenized card
	TokenizedCard *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierTokenizedCard `json:"tokenizedCard,omitempty"`

	// The type of Instrument Identifier.
	// Valid values:
	// - enrollable card
	//
	Type string `json:"type,omitempty"`
}

// Validate validates this get customer payment instruments list o k body embedded payment instruments items0 embedded instrument identifier
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifier) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBankAccount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBillTo(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCard(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateIssuer(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMetadata(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProcessingInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTokenizedCard(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifier) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(o.Links) { // not required
		return nil
	}

	if o.Links != nil {
		if err := o.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_embedded" + "." + "instrumentIdentifier" + "." + "_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("_embedded" + "." + "instrumentIdentifier" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifier) validateBankAccount(formats strfmt.Registry) error {
	if swag.IsZero(o.BankAccount) { // not required
		return nil
	}

	if o.BankAccount != nil {
		if err := o.BankAccount.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_embedded" + "." + "instrumentIdentifier" + "." + "bankAccount")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("_embedded" + "." + "instrumentIdentifier" + "." + "bankAccount")
			}
			return err
		}
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifier) validateBillTo(formats strfmt.Registry) error {
	if swag.IsZero(o.BillTo) { // not required
		return nil
	}

	if o.BillTo != nil {
		if err := o.BillTo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_embedded" + "." + "instrumentIdentifier" + "." + "billTo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("_embedded" + "." + "instrumentIdentifier" + "." + "billTo")
			}
			return err
		}
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifier) validateCard(formats strfmt.Registry) error {
	if swag.IsZero(o.Card) { // not required
		return nil
	}

	if o.Card != nil {
		if err := o.Card.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_embedded" + "." + "instrumentIdentifier" + "." + "card")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("_embedded" + "." + "instrumentIdentifier" + "." + "card")
			}
			return err
		}
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifier) validateIssuer(formats strfmt.Registry) error {
	if swag.IsZero(o.Issuer) { // not required
		return nil
	}

	if o.Issuer != nil {
		if err := o.Issuer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_embedded" + "." + "instrumentIdentifier" + "." + "issuer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("_embedded" + "." + "instrumentIdentifier" + "." + "issuer")
			}
			return err
		}
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifier) validateMetadata(formats strfmt.Registry) error {
	if swag.IsZero(o.Metadata) { // not required
		return nil
	}

	if o.Metadata != nil {
		if err := o.Metadata.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_embedded" + "." + "instrumentIdentifier" + "." + "metadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("_embedded" + "." + "instrumentIdentifier" + "." + "metadata")
			}
			return err
		}
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifier) validateProcessingInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ProcessingInformation) { // not required
		return nil
	}

	if o.ProcessingInformation != nil {
		if err := o.ProcessingInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation")
			}
			return err
		}
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifier) validateTokenizedCard(formats strfmt.Registry) error {
	if swag.IsZero(o.TokenizedCard) { // not required
		return nil
	}

	if o.TokenizedCard != nil {
		if err := o.TokenizedCard.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_embedded" + "." + "instrumentIdentifier" + "." + "tokenizedCard")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("_embedded" + "." + "instrumentIdentifier" + "." + "tokenizedCard")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this get customer payment instruments list o k body embedded payment instruments items0 embedded instrument identifier based on the context it is used
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifier) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateBankAccount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateBillTo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateCard(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateIssuer(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateMetadata(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateObject(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateProcessingInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateTokenizedCard(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifier) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if o.Links != nil {
		if err := o.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_embedded" + "." + "instrumentIdentifier" + "." + "_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("_embedded" + "." + "instrumentIdentifier" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifier) contextValidateBankAccount(ctx context.Context, formats strfmt.Registry) error {

	if o.BankAccount != nil {
		if err := o.BankAccount.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_embedded" + "." + "instrumentIdentifier" + "." + "bankAccount")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("_embedded" + "." + "instrumentIdentifier" + "." + "bankAccount")
			}
			return err
		}
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifier) contextValidateBillTo(ctx context.Context, formats strfmt.Registry) error {

	if o.BillTo != nil {
		if err := o.BillTo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_embedded" + "." + "instrumentIdentifier" + "." + "billTo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("_embedded" + "." + "instrumentIdentifier" + "." + "billTo")
			}
			return err
		}
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifier) contextValidateCard(ctx context.Context, formats strfmt.Registry) error {

	if o.Card != nil {
		if err := o.Card.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_embedded" + "." + "instrumentIdentifier" + "." + "card")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("_embedded" + "." + "instrumentIdentifier" + "." + "card")
			}
			return err
		}
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifier) contextValidateIssuer(ctx context.Context, formats strfmt.Registry) error {

	if o.Issuer != nil {
		if err := o.Issuer.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_embedded" + "." + "instrumentIdentifier" + "." + "issuer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("_embedded" + "." + "instrumentIdentifier" + "." + "issuer")
			}
			return err
		}
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifier) contextValidateMetadata(ctx context.Context, formats strfmt.Registry) error {

	if o.Metadata != nil {
		if err := o.Metadata.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_embedded" + "." + "instrumentIdentifier" + "." + "metadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("_embedded" + "." + "instrumentIdentifier" + "." + "metadata")
			}
			return err
		}
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifier) contextValidateObject(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "_embedded"+"."+"instrumentIdentifier"+"."+"object", "body", string(o.Object)); err != nil {
		return err
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifier) contextValidateProcessingInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ProcessingInformation != nil {
		if err := o.ProcessingInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation")
			}
			return err
		}
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifier) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "_embedded"+"."+"instrumentIdentifier"+"."+"state", "body", string(o.State)); err != nil {
		return err
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifier) contextValidateTokenizedCard(ctx context.Context, formats strfmt.Registry) error {

	if o.TokenizedCard != nil {
		if err := o.TokenizedCard.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_embedded" + "." + "instrumentIdentifier" + "." + "tokenizedCard")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("_embedded" + "." + "instrumentIdentifier" + "." + "tokenizedCard")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifier) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifier) UnmarshalBinary(b []byte) error {
	var res GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifier
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierBankAccount get customer payment instruments list o k body embedded payment instruments items0 embedded instrument identifier bank account
swagger:model GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierBankAccount
*/
type GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierBankAccount struct {

	// Account number.
	//
	// When processing encoded account numbers, use this field for the encoded account number.
	//
	// Max Length: 17
	Number string `json:"number,omitempty"`

	// Bank routing number. This is also called the transit number.
	//
	// For details, see `ecp_rdfi` field description in the [Electronic Check Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/EChecks_SCMP_API/html/)
	//
	RoutingNumber string `json:"routingNumber,omitempty"`
}

// Validate validates this get customer payment instruments list o k body embedded payment instruments items0 embedded instrument identifier bank account
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierBankAccount) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateNumber(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierBankAccount) validateNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.Number) { // not required
		return nil
	}

	if err := validate.MaxLength("_embedded"+"."+"instrumentIdentifier"+"."+"bankAccount"+"."+"number", "body", o.Number, 17); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this get customer payment instruments list o k body embedded payment instruments items0 embedded instrument identifier bank account based on context it is used
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierBankAccount) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierBankAccount) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierBankAccount) UnmarshalBinary(b []byte) error {
	var res GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierBankAccount
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierBillTo This information is sent to the issuer as part of network token enrollment and is not stored under the Instrument Identifier token.
//
swagger:model GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierBillTo
*/
type GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierBillTo struct {

	// Payment card billing street address as it appears on the credit card issuers records.
	//
	// Max Length: 60
	Address1 string `json:"address1,omitempty"`

	// Additional address information.
	//
	// Max Length: 60
	Address2 string `json:"address2,omitempty"`

	// State or province of the billing address. Use the State, Province, and Territory Codes for the United States
	// and Canada.
	//
	// Max Length: 20
	AdministrativeArea string `json:"administrativeArea,omitempty"`

	// Payment card billing country. Use the two-character ISO Standard Country Codes.
	//
	// Max Length: 2
	Country string `json:"country,omitempty"`

	// Payment card billing city.
	//
	// Max Length: 50
	Locality string `json:"locality,omitempty"`

	// Postal code for the billing address. The postal code must consist of 5 to 9 digits.
	//
	// When the billing country is the U.S., the 9-digit postal code must follow this format:
	// [5 digits][dash][4 digits]
	//
	// **Example** `12345-6789`
	//
	// When the billing country is Canada, the 6-digit postal code must follow this format:
	// [alpha][numeric][alpha][space][numeric][alpha][numeric]
	//
	// **Example** `A1B 2C3`
	//
	// Max Length: 10
	PostalCode string `json:"postalCode,omitempty"`
}

// Validate validates this get customer payment instruments list o k body embedded payment instruments items0 embedded instrument identifier bill to
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierBillTo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAddress1(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAddress2(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAdministrativeArea(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocality(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierBillTo) validateAddress1(formats strfmt.Registry) error {
	if swag.IsZero(o.Address1) { // not required
		return nil
	}

	if err := validate.MaxLength("_embedded"+"."+"instrumentIdentifier"+"."+"billTo"+"."+"address1", "body", o.Address1, 60); err != nil {
		return err
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierBillTo) validateAddress2(formats strfmt.Registry) error {
	if swag.IsZero(o.Address2) { // not required
		return nil
	}

	if err := validate.MaxLength("_embedded"+"."+"instrumentIdentifier"+"."+"billTo"+"."+"address2", "body", o.Address2, 60); err != nil {
		return err
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierBillTo) validateAdministrativeArea(formats strfmt.Registry) error {
	if swag.IsZero(o.AdministrativeArea) { // not required
		return nil
	}

	if err := validate.MaxLength("_embedded"+"."+"instrumentIdentifier"+"."+"billTo"+"."+"administrativeArea", "body", o.AdministrativeArea, 20); err != nil {
		return err
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierBillTo) validateCountry(formats strfmt.Registry) error {
	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("_embedded"+"."+"instrumentIdentifier"+"."+"billTo"+"."+"country", "body", o.Country, 2); err != nil {
		return err
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierBillTo) validateLocality(formats strfmt.Registry) error {
	if swag.IsZero(o.Locality) { // not required
		return nil
	}

	if err := validate.MaxLength("_embedded"+"."+"instrumentIdentifier"+"."+"billTo"+"."+"locality", "body", o.Locality, 50); err != nil {
		return err
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierBillTo) validatePostalCode(formats strfmt.Registry) error {
	if swag.IsZero(o.PostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("_embedded"+"."+"instrumentIdentifier"+"."+"billTo"+"."+"postalCode", "body", o.PostalCode, 10); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this get customer payment instruments list o k body embedded payment instruments items0 embedded instrument identifier bill to based on context it is used
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierBillTo) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierBillTo) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierBillTo) UnmarshalBinary(b []byte) error {
	var res GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierBillTo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierCard The expirationMonth, expirationYear and securityCode is sent to the issuer as part of network token enrollment and is not stored under the Instrument Identifier token.
//
swagger:model GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierCard
*/
type GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierCard struct {

	// Two-digit month in which the payment card expires.
	//
	// Format: `MM`.
	//
	// Valid values: `01` through `12`.
	//
	// Max Length: 2
	ExpirationMonth string `json:"expirationMonth,omitempty"`

	// Four-digit year in which the credit card expires.
	//
	// Format: `YYYY`.
	//
	// Max Length: 4
	ExpirationYear string `json:"expirationYear,omitempty"`

	// The customers payment card number, also known as the Primary Account Number (PAN). You can also use this field
	// for encoded account numbers.
	//
	// Max Length: 19
	// Min Length: 12
	Number string `json:"number,omitempty"`

	// Card Verification Number.
	//
	// Max Length: 4
	SecurityCode string `json:"securityCode,omitempty"`
}

// Validate validates this get customer payment instruments list o k body embedded payment instruments items0 embedded instrument identifier card
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierCard) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateExpirationMonth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpirationYear(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSecurityCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierCard) validateExpirationMonth(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationMonth) { // not required
		return nil
	}

	if err := validate.MaxLength("_embedded"+"."+"instrumentIdentifier"+"."+"card"+"."+"expirationMonth", "body", o.ExpirationMonth, 2); err != nil {
		return err
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierCard) validateExpirationYear(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationYear) { // not required
		return nil
	}

	if err := validate.MaxLength("_embedded"+"."+"instrumentIdentifier"+"."+"card"+"."+"expirationYear", "body", o.ExpirationYear, 4); err != nil {
		return err
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierCard) validateNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.Number) { // not required
		return nil
	}

	if err := validate.MinLength("_embedded"+"."+"instrumentIdentifier"+"."+"card"+"."+"number", "body", o.Number, 12); err != nil {
		return err
	}

	if err := validate.MaxLength("_embedded"+"."+"instrumentIdentifier"+"."+"card"+"."+"number", "body", o.Number, 19); err != nil {
		return err
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierCard) validateSecurityCode(formats strfmt.Registry) error {
	if swag.IsZero(o.SecurityCode) { // not required
		return nil
	}

	if err := validate.MaxLength("_embedded"+"."+"instrumentIdentifier"+"."+"card"+"."+"securityCode", "body", o.SecurityCode, 4); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this get customer payment instruments list o k body embedded payment instruments items0 embedded instrument identifier card based on context it is used
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierCard) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierCard) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierCard) UnmarshalBinary(b []byte) error {
	var res GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierCard
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierIssuer get customer payment instruments list o k body embedded payment instruments items0 embedded instrument identifier issuer
swagger:model GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierIssuer
*/
type GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierIssuer struct {

	// This reference number serves as a link to the cardholder account and to all transactions for that account.
	//
	// Read Only: true
	// Max Length: 32
	PaymentAccountReference string `json:"paymentAccountReference,omitempty"`
}

// Validate validates this get customer payment instruments list o k body embedded payment instruments items0 embedded instrument identifier issuer
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierIssuer) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validatePaymentAccountReference(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierIssuer) validatePaymentAccountReference(formats strfmt.Registry) error {
	if swag.IsZero(o.PaymentAccountReference) { // not required
		return nil
	}

	if err := validate.MaxLength("_embedded"+"."+"instrumentIdentifier"+"."+"issuer"+"."+"paymentAccountReference", "body", o.PaymentAccountReference, 32); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this get customer payment instruments list o k body embedded payment instruments items0 embedded instrument identifier issuer based on the context it is used
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierIssuer) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidatePaymentAccountReference(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierIssuer) contextValidatePaymentAccountReference(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "_embedded"+"."+"instrumentIdentifier"+"."+"issuer"+"."+"paymentAccountReference", "body", string(o.PaymentAccountReference)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierIssuer) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierIssuer) UnmarshalBinary(b []byte) error {
	var res GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierIssuer
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierLinks get customer payment instruments list o k body embedded payment instruments items0 embedded instrument identifier links
swagger:model GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierLinks
*/
type GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierLinks struct {

	// payment instruments
	PaymentInstruments *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierLinksPaymentInstruments `json:"paymentInstruments,omitempty"`

	// self
	Self *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierLinksSelf `json:"self,omitempty"`
}

// Validate validates this get customer payment instruments list o k body embedded payment instruments items0 embedded instrument identifier links
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validatePaymentInstruments(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierLinks) validatePaymentInstruments(formats strfmt.Registry) error {
	if swag.IsZero(o.PaymentInstruments) { // not required
		return nil
	}

	if o.PaymentInstruments != nil {
		if err := o.PaymentInstruments.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_embedded" + "." + "instrumentIdentifier" + "." + "_links" + "." + "paymentInstruments")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("_embedded" + "." + "instrumentIdentifier" + "." + "_links" + "." + "paymentInstruments")
			}
			return err
		}
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(o.Self) { // not required
		return nil
	}

	if o.Self != nil {
		if err := o.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_embedded" + "." + "instrumentIdentifier" + "." + "_links" + "." + "self")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("_embedded" + "." + "instrumentIdentifier" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this get customer payment instruments list o k body embedded payment instruments items0 embedded instrument identifier links based on the context it is used
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidatePaymentInstruments(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierLinks) contextValidatePaymentInstruments(ctx context.Context, formats strfmt.Registry) error {

	if o.PaymentInstruments != nil {
		if err := o.PaymentInstruments.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_embedded" + "." + "instrumentIdentifier" + "." + "_links" + "." + "paymentInstruments")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("_embedded" + "." + "instrumentIdentifier" + "." + "_links" + "." + "paymentInstruments")
			}
			return err
		}
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if o.Self != nil {
		if err := o.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_embedded" + "." + "instrumentIdentifier" + "." + "_links" + "." + "self")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("_embedded" + "." + "instrumentIdentifier" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierLinks) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierLinks) UnmarshalBinary(b []byte) error {
	var res GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierLinksPaymentInstruments get customer payment instruments list o k body embedded payment instruments items0 embedded instrument identifier links payment instruments
swagger:model GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierLinksPaymentInstruments
*/
type GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierLinksPaymentInstruments struct {

	// Link to the Instrument Identifiers Payment Instruments.
	//
	// Example: tms/v1/instrumentidentifiers/9B8D20D13FF328CCE0539399D30A70N4/paymentinstruments
	// Read Only: true
	Href string `json:"href,omitempty"`
}

// Validate validates this get customer payment instruments list o k body embedded payment instruments items0 embedded instrument identifier links payment instruments
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierLinksPaymentInstruments) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this get customer payment instruments list o k body embedded payment instruments items0 embedded instrument identifier links payment instruments based on the context it is used
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierLinksPaymentInstruments) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateHref(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierLinksPaymentInstruments) contextValidateHref(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "_embedded"+"."+"instrumentIdentifier"+"."+"_links"+"."+"paymentInstruments"+"."+"href", "body", string(o.Href)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierLinksPaymentInstruments) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierLinksPaymentInstruments) UnmarshalBinary(b []byte) error {
	var res GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierLinksPaymentInstruments
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierLinksSelf get customer payment instruments list o k body embedded payment instruments items0 embedded instrument identifier links self
swagger:model GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierLinksSelf
*/
type GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierLinksSelf struct {

	// Link to the Instrument Identifier.
	//
	// Example: tms/v1/instrumentidentifiers/9B8D20D13FF328CCE0539399D30A70N4
	// Read Only: true
	Href string `json:"href,omitempty"`
}

// Validate validates this get customer payment instruments list o k body embedded payment instruments items0 embedded instrument identifier links self
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierLinksSelf) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this get customer payment instruments list o k body embedded payment instruments items0 embedded instrument identifier links self based on the context it is used
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierLinksSelf) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateHref(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierLinksSelf) contextValidateHref(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "_embedded"+"."+"instrumentIdentifier"+"."+"_links"+"."+"self"+"."+"href", "body", string(o.Href)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierLinksSelf) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierLinksSelf) UnmarshalBinary(b []byte) error {
	var res GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierLinksSelf
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierMetadata get customer payment instruments list o k body embedded payment instruments items0 embedded instrument identifier metadata
swagger:model GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierMetadata
*/
type GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierMetadata struct {

	// The creator of the Instrument Identifier token.
	// Read Only: true
	Creator string `json:"creator,omitempty"`
}

// Validate validates this get customer payment instruments list o k body embedded payment instruments items0 embedded instrument identifier metadata
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierMetadata) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this get customer payment instruments list o k body embedded payment instruments items0 embedded instrument identifier metadata based on the context it is used
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierMetadata) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateCreator(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierMetadata) contextValidateCreator(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "_embedded"+"."+"instrumentIdentifier"+"."+"metadata"+"."+"creator", "body", string(o.Creator)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierMetadata) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierMetadata) UnmarshalBinary(b []byte) error {
	var res GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierMetadata
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierProcessingInformation get customer payment instruments list o k body embedded payment instruments items0 embedded instrument identifier processing information
swagger:model GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierProcessingInformation
*/
type GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierProcessingInformation struct {

	// authorization options
	AuthorizationOptions *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions `json:"authorizationOptions,omitempty"`
}

// Validate validates this get customer payment instruments list o k body embedded payment instruments items0 embedded instrument identifier processing information
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierProcessingInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAuthorizationOptions(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierProcessingInformation) validateAuthorizationOptions(formats strfmt.Registry) error {
	if swag.IsZero(o.AuthorizationOptions) { // not required
		return nil
	}

	if o.AuthorizationOptions != nil {
		if err := o.AuthorizationOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this get customer payment instruments list o k body embedded payment instruments items0 embedded instrument identifier processing information based on the context it is used
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierProcessingInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateAuthorizationOptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierProcessingInformation) contextValidateAuthorizationOptions(ctx context.Context, formats strfmt.Registry) error {

	if o.AuthorizationOptions != nil {
		if err := o.AuthorizationOptions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierProcessingInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierProcessingInformation) UnmarshalBinary(b []byte) error {
	var res GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierProcessingInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions get customer payment instruments list o k body embedded payment instruments items0 embedded instrument identifier processing information authorization options
swagger:model GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions
*/
type GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions struct {

	// initiator
	Initiator *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator `json:"initiator,omitempty"`
}

// Validate validates this get customer payment instruments list o k body embedded payment instruments items0 embedded instrument identifier processing information authorization options
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateInitiator(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions) validateInitiator(formats strfmt.Registry) error {
	if swag.IsZero(o.Initiator) { // not required
		return nil
	}

	if o.Initiator != nil {
		if err := o.Initiator.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this get customer payment instruments list o k body embedded payment instruments items0 embedded instrument identifier processing information authorization options based on the context it is used
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateInitiator(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions) contextValidateInitiator(ctx context.Context, formats strfmt.Registry) error {

	if o.Initiator != nil {
		if err := o.Initiator.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions) UnmarshalBinary(b []byte) error {
	var res GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator get customer payment instruments list o k body embedded payment instruments items0 embedded instrument identifier processing information authorization options initiator
swagger:model GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator
*/
type GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator struct {

	// merchant initiated transaction
	MerchantInitiatedTransaction *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction `json:"merchantInitiatedTransaction,omitempty"`
}

// Validate validates this get customer payment instruments list o k body embedded payment instruments items0 embedded instrument identifier processing information authorization options initiator
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateMerchantInitiatedTransaction(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator) validateMerchantInitiatedTransaction(formats strfmt.Registry) error {
	if swag.IsZero(o.MerchantInitiatedTransaction) { // not required
		return nil
	}

	if o.MerchantInitiatedTransaction != nil {
		if err := o.MerchantInitiatedTransaction.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator" + "." + "merchantInitiatedTransaction")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator" + "." + "merchantInitiatedTransaction")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this get customer payment instruments list o k body embedded payment instruments items0 embedded instrument identifier processing information authorization options initiator based on the context it is used
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateMerchantInitiatedTransaction(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator) contextValidateMerchantInitiatedTransaction(ctx context.Context, formats strfmt.Registry) error {

	if o.MerchantInitiatedTransaction != nil {
		if err := o.MerchantInitiatedTransaction.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator" + "." + "merchantInitiatedTransaction")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator" + "." + "merchantInitiatedTransaction")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator) UnmarshalBinary(b []byte) error {
	var res GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction get customer payment instruments list o k body embedded payment instruments items0 embedded instrument identifier processing information authorization options initiator merchant initiated transaction
swagger:model GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction
*/
type GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction struct {

	// Network transaction identifier that was returned in the payment response field _processorInformation.transactionID_
	// in the reply message for either the original merchant-initiated payment in the series or the previous
	// merchant-initiated payment in the series.
	//
	// Max Length: 15
	PreviousTransactionID string `json:"previousTransactionId,omitempty"`
}

// Validate validates this get customer payment instruments list o k body embedded payment instruments items0 embedded instrument identifier processing information authorization options initiator merchant initiated transaction
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validatePreviousTransactionID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction) validatePreviousTransactionID(formats strfmt.Registry) error {
	if swag.IsZero(o.PreviousTransactionID) { // not required
		return nil
	}

	if err := validate.MaxLength("_embedded"+"."+"instrumentIdentifier"+"."+"processingInformation"+"."+"authorizationOptions"+"."+"initiator"+"."+"merchantInitiatedTransaction"+"."+"previousTransactionId", "body", o.PreviousTransactionID, 15); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this get customer payment instruments list o k body embedded payment instruments items0 embedded instrument identifier processing information authorization options initiator merchant initiated transaction based on context it is used
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction) UnmarshalBinary(b []byte) error {
	var res GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierTokenizedCard get customer payment instruments list o k body embedded payment instruments items0 embedded instrument identifier tokenized card
swagger:model GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierTokenizedCard
*/
type GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierTokenizedCard struct {

	// card
	Card *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierTokenizedCardCard `json:"card,omitempty"`

	// Generated value used in conjunction with the network token for making a payment.
	//
	// Example: CgAFRFYFPTFOfg5rj2ais9wQAAAAAM=
	// Read Only: true
	Cryptogram string `json:"cryptogram,omitempty"`

	// Two-digit month in which the network token expires.
	//
	// Format: `MM`.
	//
	// Valid values: `01` through `12`.
	//
	// Read Only: true
	// Max Length: 2
	ExpirationMonth string `json:"expirationMonth,omitempty"`

	// Four-digit year in which the network token expires.
	//
	// Format: `YYYY`.
	//
	// Read Only: true
	// Max Length: 4
	ExpirationYear string `json:"expirationYear,omitempty"`

	// The token requestors customers payment network token
	//
	// Read Only: true
	Number string `json:"number,omitempty"`

	// Issuers state for the network token
	// Valid values:
	// - ACTIVE
	// - SUSPENDED : This state can change to ACTIVE or DELETED.
	// - DELETED : This is a final state for the network token.
	//
	// Example: ACTIVE
	// Read Only: true
	State string `json:"state,omitempty"`

	// The network token card association brand
	// Valid values:
	// - visa
	// - mastercard
	//
	// Example: visa
	// Read Only: true
	Type string `json:"type,omitempty"`
}

// Validate validates this get customer payment instruments list o k body embedded payment instruments items0 embedded instrument identifier tokenized card
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierTokenizedCard) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCard(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpirationMonth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpirationYear(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierTokenizedCard) validateCard(formats strfmt.Registry) error {
	if swag.IsZero(o.Card) { // not required
		return nil
	}

	if o.Card != nil {
		if err := o.Card.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_embedded" + "." + "instrumentIdentifier" + "." + "tokenizedCard" + "." + "card")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("_embedded" + "." + "instrumentIdentifier" + "." + "tokenizedCard" + "." + "card")
			}
			return err
		}
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierTokenizedCard) validateExpirationMonth(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationMonth) { // not required
		return nil
	}

	if err := validate.MaxLength("_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"expirationMonth", "body", o.ExpirationMonth, 2); err != nil {
		return err
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierTokenizedCard) validateExpirationYear(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationYear) { // not required
		return nil
	}

	if err := validate.MaxLength("_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"expirationYear", "body", o.ExpirationYear, 4); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this get customer payment instruments list o k body embedded payment instruments items0 embedded instrument identifier tokenized card based on the context it is used
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierTokenizedCard) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateCard(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateCryptogram(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateExpirationMonth(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateExpirationYear(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateNumber(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierTokenizedCard) contextValidateCard(ctx context.Context, formats strfmt.Registry) error {

	if o.Card != nil {
		if err := o.Card.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_embedded" + "." + "instrumentIdentifier" + "." + "tokenizedCard" + "." + "card")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("_embedded" + "." + "instrumentIdentifier" + "." + "tokenizedCard" + "." + "card")
			}
			return err
		}
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierTokenizedCard) contextValidateCryptogram(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"cryptogram", "body", string(o.Cryptogram)); err != nil {
		return err
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierTokenizedCard) contextValidateExpirationMonth(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"expirationMonth", "body", string(o.ExpirationMonth)); err != nil {
		return err
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierTokenizedCard) contextValidateExpirationYear(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"expirationYear", "body", string(o.ExpirationYear)); err != nil {
		return err
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierTokenizedCard) contextValidateNumber(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"number", "body", string(o.Number)); err != nil {
		return err
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierTokenizedCard) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"state", "body", string(o.State)); err != nil {
		return err
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierTokenizedCard) contextValidateType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"type", "body", string(o.Type)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierTokenizedCard) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierTokenizedCard) UnmarshalBinary(b []byte) error {
	var res GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierTokenizedCard
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierTokenizedCardCard The latest card details associated with the network token
swagger:model GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierTokenizedCardCard
*/
type GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierTokenizedCardCard struct {

	//
	// Two-digit month in which the customers latest payment card expires.
	//
	// Format: `MM`.
	//
	// Valid values: `01` through `12`.
	//
	// Read Only: true
	// Max Length: 2
	ExpirationMonth string `json:"expirationMonth,omitempty"`

	// Four-digit year in which the customers latest payment card expires.
	//
	// Format: `YYYY`.
	//
	// Read Only: true
	// Max Length: 4
	ExpirationYear string `json:"expirationYear,omitempty"`

	// The customers latest payment card number suffix
	//
	// Example: 1111
	// Read Only: true
	Suffix string `json:"suffix,omitempty"`
}

// Validate validates this get customer payment instruments list o k body embedded payment instruments items0 embedded instrument identifier tokenized card card
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierTokenizedCardCard) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateExpirationMonth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpirationYear(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierTokenizedCardCard) validateExpirationMonth(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationMonth) { // not required
		return nil
	}

	if err := validate.MaxLength("_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"card"+"."+"expirationMonth", "body", o.ExpirationMonth, 2); err != nil {
		return err
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierTokenizedCardCard) validateExpirationYear(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationYear) { // not required
		return nil
	}

	if err := validate.MaxLength("_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"card"+"."+"expirationYear", "body", o.ExpirationYear, 4); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this get customer payment instruments list o k body embedded payment instruments items0 embedded instrument identifier tokenized card card based on the context it is used
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierTokenizedCardCard) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateExpirationMonth(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateExpirationYear(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateSuffix(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierTokenizedCardCard) contextValidateExpirationMonth(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"card"+"."+"expirationMonth", "body", string(o.ExpirationMonth)); err != nil {
		return err
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierTokenizedCardCard) contextValidateExpirationYear(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"card"+"."+"expirationYear", "body", string(o.ExpirationYear)); err != nil {
		return err
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierTokenizedCardCard) contextValidateSuffix(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"card"+"."+"suffix", "body", string(o.Suffix)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierTokenizedCardCard) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierTokenizedCardCard) UnmarshalBinary(b []byte) error {
	var res GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0EmbeddedInstrumentIdentifierTokenizedCardCard
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0InstrumentIdentifier get customer payment instruments list o k body embedded payment instruments items0 instrument identifier
swagger:model GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0InstrumentIdentifier
*/
type GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0InstrumentIdentifier struct {

	// The id of the Instrument Identifier token linked to the Payment Instrument.
	//
	// Max Length: 32
	// Min Length: 12
	ID string `json:"id,omitempty"`
}

// Validate validates this get customer payment instruments list o k body embedded payment instruments items0 instrument identifier
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0InstrumentIdentifier) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0InstrumentIdentifier) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MinLength("instrumentIdentifier"+"."+"id", "body", o.ID, 12); err != nil {
		return err
	}

	if err := validate.MaxLength("instrumentIdentifier"+"."+"id", "body", o.ID, 32); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this get customer payment instruments list o k body embedded payment instruments items0 instrument identifier based on context it is used
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0InstrumentIdentifier) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0InstrumentIdentifier) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0InstrumentIdentifier) UnmarshalBinary(b []byte) error {
	var res GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0InstrumentIdentifier
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0Links get customer payment instruments list o k body embedded payment instruments items0 links
swagger:model GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0Links
*/
type GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0Links struct {

	// customer
	Customer *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0LinksCustomer `json:"customer,omitempty"`

	// self
	Self *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0LinksSelf `json:"self,omitempty"`
}

// Validate validates this get customer payment instruments list o k body embedded payment instruments items0 links
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0Links) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCustomer(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0Links) validateCustomer(formats strfmt.Registry) error {
	if swag.IsZero(o.Customer) { // not required
		return nil
	}

	if o.Customer != nil {
		if err := o.Customer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "customer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("_links" + "." + "customer")
			}
			return err
		}
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0Links) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(o.Self) { // not required
		return nil
	}

	if o.Self != nil {
		if err := o.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this get customer payment instruments list o k body embedded payment instruments items0 links based on the context it is used
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0Links) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateCustomer(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0Links) contextValidateCustomer(ctx context.Context, formats strfmt.Registry) error {

	if o.Customer != nil {
		if err := o.Customer.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "customer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("_links" + "." + "customer")
			}
			return err
		}
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0Links) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if o.Self != nil {
		if err := o.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("_links" + "." + "self")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0Links) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0Links) UnmarshalBinary(b []byte) error {
	var res GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0Links
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0LinksCustomer get customer payment instruments list o k body embedded payment instruments items0 links customer
swagger:model GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0LinksCustomer
*/
type GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0LinksCustomer struct {

	// Link to the Customer.
	//
	// Example: /tms/v2/customers/1234567890123456789
	// Read Only: true
	Href string `json:"href,omitempty"`
}

// Validate validates this get customer payment instruments list o k body embedded payment instruments items0 links customer
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0LinksCustomer) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this get customer payment instruments list o k body embedded payment instruments items0 links customer based on the context it is used
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0LinksCustomer) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateHref(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0LinksCustomer) contextValidateHref(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "_links"+"."+"customer"+"."+"href", "body", string(o.Href)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0LinksCustomer) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0LinksCustomer) UnmarshalBinary(b []byte) error {
	var res GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0LinksCustomer
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0LinksSelf get customer payment instruments list o k body embedded payment instruments items0 links self
swagger:model GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0LinksSelf
*/
type GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0LinksSelf struct {

	// Link to the Payment Instrument.
	//
	// Example: /tms/v2/customers/1234567890123456789/payment-instruments
	// Read Only: true
	Href string `json:"href,omitempty"`
}

// Validate validates this get customer payment instruments list o k body embedded payment instruments items0 links self
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0LinksSelf) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this get customer payment instruments list o k body embedded payment instruments items0 links self based on the context it is used
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0LinksSelf) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateHref(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0LinksSelf) contextValidateHref(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "_links"+"."+"self"+"."+"href", "body", string(o.Href)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0LinksSelf) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0LinksSelf) UnmarshalBinary(b []byte) error {
	var res GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0LinksSelf
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0MerchantInformation get customer payment instruments list o k body embedded payment instruments items0 merchant information
swagger:model GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0MerchantInformation
*/
type GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0MerchantInformation struct {

	// merchant descriptor
	MerchantDescriptor *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0MerchantInformationMerchantDescriptor `json:"merchantDescriptor,omitempty"`
}

// Validate validates this get customer payment instruments list o k body embedded payment instruments items0 merchant information
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0MerchantInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateMerchantDescriptor(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0MerchantInformation) validateMerchantDescriptor(formats strfmt.Registry) error {
	if swag.IsZero(o.MerchantDescriptor) { // not required
		return nil
	}

	if o.MerchantDescriptor != nil {
		if err := o.MerchantDescriptor.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("merchantInformation" + "." + "merchantDescriptor")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("merchantInformation" + "." + "merchantDescriptor")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this get customer payment instruments list o k body embedded payment instruments items0 merchant information based on the context it is used
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0MerchantInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateMerchantDescriptor(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0MerchantInformation) contextValidateMerchantDescriptor(ctx context.Context, formats strfmt.Registry) error {

	if o.MerchantDescriptor != nil {
		if err := o.MerchantDescriptor.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("merchantInformation" + "." + "merchantDescriptor")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("merchantInformation" + "." + "merchantDescriptor")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0MerchantInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0MerchantInformation) UnmarshalBinary(b []byte) error {
	var res GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0MerchantInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0MerchantInformationMerchantDescriptor get customer payment instruments list o k body embedded payment instruments items0 merchant information merchant descriptor
swagger:model GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0MerchantInformationMerchantDescriptor
*/
type GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0MerchantInformationMerchantDescriptor struct {

	// Alternate contact information for your business,such as an email address or URL.
	// This value might be displayed on the cardholders statement.
	// When you do not include this value in your capture or credit request, CyberSource uses the merchant URL from your CyberSource account.
	// Important This value must consist of English characters
	//
	// Max Length: 13
	AlternateName string `json:"alternateName,omitempty"`
}

// Validate validates this get customer payment instruments list o k body embedded payment instruments items0 merchant information merchant descriptor
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0MerchantInformationMerchantDescriptor) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAlternateName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0MerchantInformationMerchantDescriptor) validateAlternateName(formats strfmt.Registry) error {
	if swag.IsZero(o.AlternateName) { // not required
		return nil
	}

	if err := validate.MaxLength("merchantInformation"+"."+"merchantDescriptor"+"."+"alternateName", "body", o.AlternateName, 13); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this get customer payment instruments list o k body embedded payment instruments items0 merchant information merchant descriptor based on context it is used
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0MerchantInformationMerchantDescriptor) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0MerchantInformationMerchantDescriptor) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0MerchantInformationMerchantDescriptor) UnmarshalBinary(b []byte) error {
	var res GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0MerchantInformationMerchantDescriptor
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0Metadata get customer payment instruments list o k body embedded payment instruments items0 metadata
swagger:model GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0Metadata
*/
type GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0Metadata struct {

	// The creator of the Payment Instrument token.
	//
	// Read Only: true
	Creator string `json:"creator,omitempty"`
}

// Validate validates this get customer payment instruments list o k body embedded payment instruments items0 metadata
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0Metadata) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this get customer payment instruments list o k body embedded payment instruments items0 metadata based on the context it is used
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0Metadata) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateCreator(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0Metadata) contextValidateCreator(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "metadata"+"."+"creator", "body", string(o.Creator)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0Metadata) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0Metadata) UnmarshalBinary(b []byte) error {
	var res GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0Metadata
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0ProcessingInformation get customer payment instruments list o k body embedded payment instruments items0 processing information
swagger:model GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0ProcessingInformation
*/
type GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0ProcessingInformation struct {

	// bank transfer options
	BankTransferOptions *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0ProcessingInformationBankTransferOptions `json:"bankTransferOptions,omitempty"`

	// Flag that indicates that this is a payment for a bill or for an existing contractual loan.
	// For processor-specific details, see the `bill_payment` field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// Valid values:
	// - `true`: Bill payment or loan payment.
	// - `false` (default): Not a bill payment or loan payment.
	//
	BillPaymentProgramEnabled bool `json:"billPaymentProgramEnabled,omitempty"`
}

// Validate validates this get customer payment instruments list o k body embedded payment instruments items0 processing information
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0ProcessingInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateBankTransferOptions(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0ProcessingInformation) validateBankTransferOptions(formats strfmt.Registry) error {
	if swag.IsZero(o.BankTransferOptions) { // not required
		return nil
	}

	if o.BankTransferOptions != nil {
		if err := o.BankTransferOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("processingInformation" + "." + "bankTransferOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("processingInformation" + "." + "bankTransferOptions")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this get customer payment instruments list o k body embedded payment instruments items0 processing information based on the context it is used
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0ProcessingInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateBankTransferOptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0ProcessingInformation) contextValidateBankTransferOptions(ctx context.Context, formats strfmt.Registry) error {

	if o.BankTransferOptions != nil {
		if err := o.BankTransferOptions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("processingInformation" + "." + "bankTransferOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("processingInformation" + "." + "bankTransferOptions")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0ProcessingInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0ProcessingInformation) UnmarshalBinary(b []byte) error {
	var res GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0ProcessingInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0ProcessingInformationBankTransferOptions get customer payment instruments list o k body embedded payment instruments items0 processing information bank transfer options
swagger:model GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0ProcessingInformationBankTransferOptions
*/
type GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0ProcessingInformationBankTransferOptions struct {

	// Specifies the authorization method for the transaction.
	//
	// #### TeleCheck
	// Valid values:
	// - `ARC`: account receivable conversion
	// - `CCD`: corporate cash disbursement
	// - `POP`: point of purchase conversion
	// - `PPD`: prearranged payment and deposit entry
	// - `TEL`: telephone-initiated entry
	// - `WEB`: internet-initiated entry
	//
	// For details, see `ecp_sec_code` field description in the [Electronic Check Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/EChecks_SCMP_API/html/)
	//
	// Max Length: 3
	SECCode string `json:"SECCode,omitempty"`
}

// Validate validates this get customer payment instruments list o k body embedded payment instruments items0 processing information bank transfer options
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0ProcessingInformationBankTransferOptions) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateSECCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0ProcessingInformationBankTransferOptions) validateSECCode(formats strfmt.Registry) error {
	if swag.IsZero(o.SECCode) { // not required
		return nil
	}

	if err := validate.MaxLength("processingInformation"+"."+"bankTransferOptions"+"."+"SECCode", "body", o.SECCode, 3); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this get customer payment instruments list o k body embedded payment instruments items0 processing information bank transfer options based on context it is used
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0ProcessingInformationBankTransferOptions) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0ProcessingInformationBankTransferOptions) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0ProcessingInformationBankTransferOptions) UnmarshalBinary(b []byte) error {
	var res GetCustomerPaymentInstrumentsListOKBodyEmbeddedPaymentInstrumentsItems0ProcessingInformationBankTransferOptions
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetCustomerPaymentInstrumentsListOKBodyLinks get customer payment instruments list o k body links
swagger:model GetCustomerPaymentInstrumentsListOKBodyLinks
*/
type GetCustomerPaymentInstrumentsListOKBodyLinks struct {

	// first
	First *GetCustomerPaymentInstrumentsListOKBodyLinksFirst `json:"first,omitempty"`

	// last
	Last *GetCustomerPaymentInstrumentsListOKBodyLinksLast `json:"last,omitempty"`

	// next
	Next *GetCustomerPaymentInstrumentsListOKBodyLinksNext `json:"next,omitempty"`

	// prev
	Prev *GetCustomerPaymentInstrumentsListOKBodyLinksPrev `json:"prev,omitempty"`

	// self
	Self *GetCustomerPaymentInstrumentsListOKBodyLinksSelf `json:"self,omitempty"`
}

// Validate validates this get customer payment instruments list o k body links
func (o *GetCustomerPaymentInstrumentsListOKBodyLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateFirst(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLast(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNext(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePrev(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyLinks) validateFirst(formats strfmt.Registry) error {
	if swag.IsZero(o.First) { // not required
		return nil
	}

	if o.First != nil {
		if err := o.First.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getCustomerPaymentInstrumentsListOK" + "." + "_links" + "." + "first")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getCustomerPaymentInstrumentsListOK" + "." + "_links" + "." + "first")
			}
			return err
		}
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyLinks) validateLast(formats strfmt.Registry) error {
	if swag.IsZero(o.Last) { // not required
		return nil
	}

	if o.Last != nil {
		if err := o.Last.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getCustomerPaymentInstrumentsListOK" + "." + "_links" + "." + "last")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getCustomerPaymentInstrumentsListOK" + "." + "_links" + "." + "last")
			}
			return err
		}
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyLinks) validateNext(formats strfmt.Registry) error {
	if swag.IsZero(o.Next) { // not required
		return nil
	}

	if o.Next != nil {
		if err := o.Next.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getCustomerPaymentInstrumentsListOK" + "." + "_links" + "." + "next")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getCustomerPaymentInstrumentsListOK" + "." + "_links" + "." + "next")
			}
			return err
		}
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyLinks) validatePrev(formats strfmt.Registry) error {
	if swag.IsZero(o.Prev) { // not required
		return nil
	}

	if o.Prev != nil {
		if err := o.Prev.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getCustomerPaymentInstrumentsListOK" + "." + "_links" + "." + "prev")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getCustomerPaymentInstrumentsListOK" + "." + "_links" + "." + "prev")
			}
			return err
		}
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(o.Self) { // not required
		return nil
	}

	if o.Self != nil {
		if err := o.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getCustomerPaymentInstrumentsListOK" + "." + "_links" + "." + "self")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getCustomerPaymentInstrumentsListOK" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this get customer payment instruments list o k body links based on the context it is used
func (o *GetCustomerPaymentInstrumentsListOKBodyLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateFirst(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateLast(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateNext(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidatePrev(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyLinks) contextValidateFirst(ctx context.Context, formats strfmt.Registry) error {

	if o.First != nil {
		if err := o.First.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getCustomerPaymentInstrumentsListOK" + "." + "_links" + "." + "first")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getCustomerPaymentInstrumentsListOK" + "." + "_links" + "." + "first")
			}
			return err
		}
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyLinks) contextValidateLast(ctx context.Context, formats strfmt.Registry) error {

	if o.Last != nil {
		if err := o.Last.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getCustomerPaymentInstrumentsListOK" + "." + "_links" + "." + "last")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getCustomerPaymentInstrumentsListOK" + "." + "_links" + "." + "last")
			}
			return err
		}
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyLinks) contextValidateNext(ctx context.Context, formats strfmt.Registry) error {

	if o.Next != nil {
		if err := o.Next.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getCustomerPaymentInstrumentsListOK" + "." + "_links" + "." + "next")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getCustomerPaymentInstrumentsListOK" + "." + "_links" + "." + "next")
			}
			return err
		}
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyLinks) contextValidatePrev(ctx context.Context, formats strfmt.Registry) error {

	if o.Prev != nil {
		if err := o.Prev.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getCustomerPaymentInstrumentsListOK" + "." + "_links" + "." + "prev")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getCustomerPaymentInstrumentsListOK" + "." + "_links" + "." + "prev")
			}
			return err
		}
	}

	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if o.Self != nil {
		if err := o.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getCustomerPaymentInstrumentsListOK" + "." + "_links" + "." + "self")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getCustomerPaymentInstrumentsListOK" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyLinks) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyLinks) UnmarshalBinary(b []byte) error {
	var res GetCustomerPaymentInstrumentsListOKBodyLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetCustomerPaymentInstrumentsListOKBodyLinksFirst get customer payment instruments list o k body links first
swagger:model GetCustomerPaymentInstrumentsListOKBodyLinksFirst
*/
type GetCustomerPaymentInstrumentsListOKBodyLinksFirst struct {

	// Link to the first page.
	//
	// Example: /tms/v2/customers/1234567890123456789/payment-instruments?offset=0\u0026limit=1
	// Read Only: true
	Href string `json:"href,omitempty"`
}

// Validate validates this get customer payment instruments list o k body links first
func (o *GetCustomerPaymentInstrumentsListOKBodyLinksFirst) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this get customer payment instruments list o k body links first based on the context it is used
func (o *GetCustomerPaymentInstrumentsListOKBodyLinksFirst) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateHref(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyLinksFirst) contextValidateHref(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "getCustomerPaymentInstrumentsListOK"+"."+"_links"+"."+"first"+"."+"href", "body", string(o.Href)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyLinksFirst) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyLinksFirst) UnmarshalBinary(b []byte) error {
	var res GetCustomerPaymentInstrumentsListOKBodyLinksFirst
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetCustomerPaymentInstrumentsListOKBodyLinksLast get customer payment instruments list o k body links last
swagger:model GetCustomerPaymentInstrumentsListOKBodyLinksLast
*/
type GetCustomerPaymentInstrumentsListOKBodyLinksLast struct {

	// Link to the last page.
	//
	// Example: /tms/v2/customers/1234567890123456789/payment-instruments?offset=0\u0026limit=1
	// Read Only: true
	Href string `json:"href,omitempty"`
}

// Validate validates this get customer payment instruments list o k body links last
func (o *GetCustomerPaymentInstrumentsListOKBodyLinksLast) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this get customer payment instruments list o k body links last based on the context it is used
func (o *GetCustomerPaymentInstrumentsListOKBodyLinksLast) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateHref(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyLinksLast) contextValidateHref(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "getCustomerPaymentInstrumentsListOK"+"."+"_links"+"."+"last"+"."+"href", "body", string(o.Href)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyLinksLast) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyLinksLast) UnmarshalBinary(b []byte) error {
	var res GetCustomerPaymentInstrumentsListOKBodyLinksLast
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetCustomerPaymentInstrumentsListOKBodyLinksNext get customer payment instruments list o k body links next
swagger:model GetCustomerPaymentInstrumentsListOKBodyLinksNext
*/
type GetCustomerPaymentInstrumentsListOKBodyLinksNext struct {

	// Link to the next page.
	//
	// Example: /tms/v2/customers/1234567890123456789/payment-instruments?offset=0\u0026limit=1
	// Read Only: true
	Href string `json:"href,omitempty"`
}

// Validate validates this get customer payment instruments list o k body links next
func (o *GetCustomerPaymentInstrumentsListOKBodyLinksNext) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this get customer payment instruments list o k body links next based on the context it is used
func (o *GetCustomerPaymentInstrumentsListOKBodyLinksNext) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateHref(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyLinksNext) contextValidateHref(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "getCustomerPaymentInstrumentsListOK"+"."+"_links"+"."+"next"+"."+"href", "body", string(o.Href)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyLinksNext) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyLinksNext) UnmarshalBinary(b []byte) error {
	var res GetCustomerPaymentInstrumentsListOKBodyLinksNext
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetCustomerPaymentInstrumentsListOKBodyLinksPrev get customer payment instruments list o k body links prev
swagger:model GetCustomerPaymentInstrumentsListOKBodyLinksPrev
*/
type GetCustomerPaymentInstrumentsListOKBodyLinksPrev struct {

	// Link to the previous page.
	//
	// Example: /tms/v2/customers/1234567890123456789/payment-instruments?offset=0\u0026limit=1
	// Read Only: true
	Href string `json:"href,omitempty"`
}

// Validate validates this get customer payment instruments list o k body links prev
func (o *GetCustomerPaymentInstrumentsListOKBodyLinksPrev) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this get customer payment instruments list o k body links prev based on the context it is used
func (o *GetCustomerPaymentInstrumentsListOKBodyLinksPrev) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateHref(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyLinksPrev) contextValidateHref(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "getCustomerPaymentInstrumentsListOK"+"."+"_links"+"."+"prev"+"."+"href", "body", string(o.Href)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyLinksPrev) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyLinksPrev) UnmarshalBinary(b []byte) error {
	var res GetCustomerPaymentInstrumentsListOKBodyLinksPrev
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetCustomerPaymentInstrumentsListOKBodyLinksSelf get customer payment instruments list o k body links self
swagger:model GetCustomerPaymentInstrumentsListOKBodyLinksSelf
*/
type GetCustomerPaymentInstrumentsListOKBodyLinksSelf struct {

	// Link to the current page.
	//
	// Example: /tms/v2/customers/1234567890123456789/payment-instruments?offset=0\u0026limit=1
	// Read Only: true
	Href string `json:"href,omitempty"`
}

// Validate validates this get customer payment instruments list o k body links self
func (o *GetCustomerPaymentInstrumentsListOKBodyLinksSelf) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this get customer payment instruments list o k body links self based on the context it is used
func (o *GetCustomerPaymentInstrumentsListOKBodyLinksSelf) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateHref(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetCustomerPaymentInstrumentsListOKBodyLinksSelf) contextValidateHref(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "getCustomerPaymentInstrumentsListOK"+"."+"_links"+"."+"self"+"."+"href", "body", string(o.Href)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyLinksSelf) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetCustomerPaymentInstrumentsListOKBodyLinksSelf) UnmarshalBinary(b []byte) error {
	var res GetCustomerPaymentInstrumentsListOKBodyLinksSelf
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}
