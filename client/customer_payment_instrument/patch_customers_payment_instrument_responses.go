// Code generated by go-swagger; DO NOT EDIT.

package customer_payment_instrument

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"fmt"
	"io"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// PatchCustomersPaymentInstrumentReader is a Reader for the PatchCustomersPaymentInstrument structure.
type PatchCustomersPaymentInstrumentReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *PatchCustomersPaymentInstrumentReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 200:
		result := NewPatchCustomersPaymentInstrumentOK()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	case 400:
		result := NewPatchCustomersPaymentInstrumentBadRequest()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 403:
		result := NewPatchCustomersPaymentInstrumentForbidden()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 404:
		result := NewPatchCustomersPaymentInstrumentNotFound()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 410:
		result := NewPatchCustomersPaymentInstrumentGone()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 412:
		result := NewPatchCustomersPaymentInstrumentPreconditionFailed()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 424:
		result := NewPatchCustomersPaymentInstrumentFailedDependency()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 500:
		result := NewPatchCustomersPaymentInstrumentInternalServerError()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	default:
		return nil, runtime.NewAPIError("response status code does not match any response statuses defined for this endpoint in the swagger spec", response, response.Code())
	}
}

// NewPatchCustomersPaymentInstrumentOK creates a PatchCustomersPaymentInstrumentOK with default headers values
func NewPatchCustomersPaymentInstrumentOK() *PatchCustomersPaymentInstrumentOK {
	return &PatchCustomersPaymentInstrumentOK{}
}

/* PatchCustomersPaymentInstrumentOK describes a response with status code 200, with default header values.

Returns an existing Payment Instrument associated with the supplied token id.
*/
type PatchCustomersPaymentInstrumentOK struct {

	/* An ETag is an identifier assigned to a specific version of a resource.
	 */
	ETag string

	/* A globally-unique ID associated with your request.
	 */
	UniqueTransactionID string

	/* The mandatory correlation id passed by upstream (calling) system.
	 */
	VcCorrelationID string

	Payload *PatchCustomersPaymentInstrumentOKBody
}

func (o *PatchCustomersPaymentInstrumentOK) Error() string {
	return fmt.Sprintf("[PATCH /tms/v2/customers/{customerTokenId}/payment-instruments/{paymentInstrumentTokenId}][%d] patchCustomersPaymentInstrumentOK  %+v", 200, o.Payload)
}
func (o *PatchCustomersPaymentInstrumentOK) GetPayload() *PatchCustomersPaymentInstrumentOKBody {
	return o.Payload
}

func (o *PatchCustomersPaymentInstrumentOK) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	// hydrates response header ETag
	hdrETag := response.GetHeader("ETag")

	if hdrETag != "" {
		o.ETag = hdrETag
	}

	// hydrates response header uniqueTransactionID
	hdrUniqueTransactionID := response.GetHeader("uniqueTransactionID")

	if hdrUniqueTransactionID != "" {
		o.UniqueTransactionID = hdrUniqueTransactionID
	}

	// hydrates response header v-c-correlation-id
	hdrVcCorrelationID := response.GetHeader("v-c-correlation-id")

	if hdrVcCorrelationID != "" {
		o.VcCorrelationID = hdrVcCorrelationID
	}

	o.Payload = new(PatchCustomersPaymentInstrumentOKBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPatchCustomersPaymentInstrumentBadRequest creates a PatchCustomersPaymentInstrumentBadRequest with default headers values
func NewPatchCustomersPaymentInstrumentBadRequest() *PatchCustomersPaymentInstrumentBadRequest {
	return &PatchCustomersPaymentInstrumentBadRequest{}
}

/* PatchCustomersPaymentInstrumentBadRequest describes a response with status code 400, with default header values.

Bad Request: e.g. A required header value could be missing.
*/
type PatchCustomersPaymentInstrumentBadRequest struct {

	/* A globally unique id associated with your request.
	 */
	UniqueTransactionID string

	/* The mandatory correlation id passed by upstream (calling) system.
	 */
	VcCorrelationID string

	Payload *PatchCustomersPaymentInstrumentBadRequestBody
}

func (o *PatchCustomersPaymentInstrumentBadRequest) Error() string {
	return fmt.Sprintf("[PATCH /tms/v2/customers/{customerTokenId}/payment-instruments/{paymentInstrumentTokenId}][%d] patchCustomersPaymentInstrumentBadRequest  %+v", 400, o.Payload)
}
func (o *PatchCustomersPaymentInstrumentBadRequest) GetPayload() *PatchCustomersPaymentInstrumentBadRequestBody {
	return o.Payload
}

func (o *PatchCustomersPaymentInstrumentBadRequest) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	// hydrates response header uniqueTransactionID
	hdrUniqueTransactionID := response.GetHeader("uniqueTransactionID")

	if hdrUniqueTransactionID != "" {
		o.UniqueTransactionID = hdrUniqueTransactionID
	}

	// hydrates response header v-c-correlation-id
	hdrVcCorrelationID := response.GetHeader("v-c-correlation-id")

	if hdrVcCorrelationID != "" {
		o.VcCorrelationID = hdrVcCorrelationID
	}

	o.Payload = new(PatchCustomersPaymentInstrumentBadRequestBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPatchCustomersPaymentInstrumentForbidden creates a PatchCustomersPaymentInstrumentForbidden with default headers values
func NewPatchCustomersPaymentInstrumentForbidden() *PatchCustomersPaymentInstrumentForbidden {
	return &PatchCustomersPaymentInstrumentForbidden{}
}

/* PatchCustomersPaymentInstrumentForbidden describes a response with status code 403, with default header values.

403ForbiddenResponse: e.g. The profile might not have permission to perform the operation.
*/
type PatchCustomersPaymentInstrumentForbidden struct {

	/* A globally unique id associated with your request.
	 */
	UniqueTransactionID string

	/* The mandatory correlation id passed by upstream (calling) system.
	 */
	VcCorrelationID string

	Payload *PatchCustomersPaymentInstrumentForbiddenBody
}

func (o *PatchCustomersPaymentInstrumentForbidden) Error() string {
	return fmt.Sprintf("[PATCH /tms/v2/customers/{customerTokenId}/payment-instruments/{paymentInstrumentTokenId}][%d] patchCustomersPaymentInstrumentForbidden  %+v", 403, o.Payload)
}
func (o *PatchCustomersPaymentInstrumentForbidden) GetPayload() *PatchCustomersPaymentInstrumentForbiddenBody {
	return o.Payload
}

func (o *PatchCustomersPaymentInstrumentForbidden) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	// hydrates response header uniqueTransactionID
	hdrUniqueTransactionID := response.GetHeader("uniqueTransactionID")

	if hdrUniqueTransactionID != "" {
		o.UniqueTransactionID = hdrUniqueTransactionID
	}

	// hydrates response header v-c-correlation-id
	hdrVcCorrelationID := response.GetHeader("v-c-correlation-id")

	if hdrVcCorrelationID != "" {
		o.VcCorrelationID = hdrVcCorrelationID
	}

	o.Payload = new(PatchCustomersPaymentInstrumentForbiddenBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPatchCustomersPaymentInstrumentNotFound creates a PatchCustomersPaymentInstrumentNotFound with default headers values
func NewPatchCustomersPaymentInstrumentNotFound() *PatchCustomersPaymentInstrumentNotFound {
	return &PatchCustomersPaymentInstrumentNotFound{}
}

/* PatchCustomersPaymentInstrumentNotFound describes a response with status code 404, with default header values.

Token Not Found. The `tokenid` may not exist or was entered incorrectly.
*/
type PatchCustomersPaymentInstrumentNotFound struct {

	/* A globally unique ID associated with your request.
	 */
	UniqueTransactionID string

	/* The mandatory correlation id passed by upstream (calling) system.
	 */
	VcCorrelationID string

	Payload *PatchCustomersPaymentInstrumentNotFoundBody
}

func (o *PatchCustomersPaymentInstrumentNotFound) Error() string {
	return fmt.Sprintf("[PATCH /tms/v2/customers/{customerTokenId}/payment-instruments/{paymentInstrumentTokenId}][%d] patchCustomersPaymentInstrumentNotFound  %+v", 404, o.Payload)
}
func (o *PatchCustomersPaymentInstrumentNotFound) GetPayload() *PatchCustomersPaymentInstrumentNotFoundBody {
	return o.Payload
}

func (o *PatchCustomersPaymentInstrumentNotFound) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	// hydrates response header uniqueTransactionID
	hdrUniqueTransactionID := response.GetHeader("uniqueTransactionID")

	if hdrUniqueTransactionID != "" {
		o.UniqueTransactionID = hdrUniqueTransactionID
	}

	// hydrates response header v-c-correlation-id
	hdrVcCorrelationID := response.GetHeader("v-c-correlation-id")

	if hdrVcCorrelationID != "" {
		o.VcCorrelationID = hdrVcCorrelationID
	}

	o.Payload = new(PatchCustomersPaymentInstrumentNotFoundBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPatchCustomersPaymentInstrumentGone creates a PatchCustomersPaymentInstrumentGone with default headers values
func NewPatchCustomersPaymentInstrumentGone() *PatchCustomersPaymentInstrumentGone {
	return &PatchCustomersPaymentInstrumentGone{}
}

/* PatchCustomersPaymentInstrumentGone describes a response with status code 410, with default header values.

Token Not Available. The token has been deleted.
*/
type PatchCustomersPaymentInstrumentGone struct {

	/* A globally unique ID associated with your request.
	 */
	UniqueTransactionID string

	/* The mandatory correlation id passed by upstream (calling) system.
	 */
	VcCorrelationID string

	Payload *PatchCustomersPaymentInstrumentGoneBody
}

func (o *PatchCustomersPaymentInstrumentGone) Error() string {
	return fmt.Sprintf("[PATCH /tms/v2/customers/{customerTokenId}/payment-instruments/{paymentInstrumentTokenId}][%d] patchCustomersPaymentInstrumentGone  %+v", 410, o.Payload)
}
func (o *PatchCustomersPaymentInstrumentGone) GetPayload() *PatchCustomersPaymentInstrumentGoneBody {
	return o.Payload
}

func (o *PatchCustomersPaymentInstrumentGone) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	// hydrates response header uniqueTransactionID
	hdrUniqueTransactionID := response.GetHeader("uniqueTransactionID")

	if hdrUniqueTransactionID != "" {
		o.UniqueTransactionID = hdrUniqueTransactionID
	}

	// hydrates response header v-c-correlation-id
	hdrVcCorrelationID := response.GetHeader("v-c-correlation-id")

	if hdrVcCorrelationID != "" {
		o.VcCorrelationID = hdrVcCorrelationID
	}

	o.Payload = new(PatchCustomersPaymentInstrumentGoneBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPatchCustomersPaymentInstrumentPreconditionFailed creates a PatchCustomersPaymentInstrumentPreconditionFailed with default headers values
func NewPatchCustomersPaymentInstrumentPreconditionFailed() *PatchCustomersPaymentInstrumentPreconditionFailed {
	return &PatchCustomersPaymentInstrumentPreconditionFailed{}
}

/* PatchCustomersPaymentInstrumentPreconditionFailed describes a response with status code 412, with default header values.

Precondition Failed: The If-Match request header value does not match the current resources ETag
*/
type PatchCustomersPaymentInstrumentPreconditionFailed struct {

	/* A globally unique id associated with your request.
	 */
	UniqueTransactionID string

	/* The mandatory correlation id passed by upstream (calling) system.
	 */
	VcCorrelationID string

	Payload *PatchCustomersPaymentInstrumentPreconditionFailedBody
}

func (o *PatchCustomersPaymentInstrumentPreconditionFailed) Error() string {
	return fmt.Sprintf("[PATCH /tms/v2/customers/{customerTokenId}/payment-instruments/{paymentInstrumentTokenId}][%d] patchCustomersPaymentInstrumentPreconditionFailed  %+v", 412, o.Payload)
}
func (o *PatchCustomersPaymentInstrumentPreconditionFailed) GetPayload() *PatchCustomersPaymentInstrumentPreconditionFailedBody {
	return o.Payload
}

func (o *PatchCustomersPaymentInstrumentPreconditionFailed) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	// hydrates response header uniqueTransactionID
	hdrUniqueTransactionID := response.GetHeader("uniqueTransactionID")

	if hdrUniqueTransactionID != "" {
		o.UniqueTransactionID = hdrUniqueTransactionID
	}

	// hydrates response header v-c-correlation-id
	hdrVcCorrelationID := response.GetHeader("v-c-correlation-id")

	if hdrVcCorrelationID != "" {
		o.VcCorrelationID = hdrVcCorrelationID
	}

	o.Payload = new(PatchCustomersPaymentInstrumentPreconditionFailedBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPatchCustomersPaymentInstrumentFailedDependency creates a PatchCustomersPaymentInstrumentFailedDependency with default headers values
func NewPatchCustomersPaymentInstrumentFailedDependency() *PatchCustomersPaymentInstrumentFailedDependency {
	return &PatchCustomersPaymentInstrumentFailedDependency{}
}

/* PatchCustomersPaymentInstrumentFailedDependency describes a response with status code 424, with default header values.

Failed Dependency: e.g. The profile represented by the profile-id may not exist or the profile-id was entered incorrectly.
*/
type PatchCustomersPaymentInstrumentFailedDependency struct {

	/* A globally unique id associated with your request.
	 */
	UniqueTransactionID string

	/* The mandatory correlation id passed by upstream (calling) system.
	 */
	VcCorrelationID string

	Payload *PatchCustomersPaymentInstrumentFailedDependencyBody
}

func (o *PatchCustomersPaymentInstrumentFailedDependency) Error() string {
	return fmt.Sprintf("[PATCH /tms/v2/customers/{customerTokenId}/payment-instruments/{paymentInstrumentTokenId}][%d] patchCustomersPaymentInstrumentFailedDependency  %+v", 424, o.Payload)
}
func (o *PatchCustomersPaymentInstrumentFailedDependency) GetPayload() *PatchCustomersPaymentInstrumentFailedDependencyBody {
	return o.Payload
}

func (o *PatchCustomersPaymentInstrumentFailedDependency) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	// hydrates response header uniqueTransactionID
	hdrUniqueTransactionID := response.GetHeader("uniqueTransactionID")

	if hdrUniqueTransactionID != "" {
		o.UniqueTransactionID = hdrUniqueTransactionID
	}

	// hydrates response header v-c-correlation-id
	hdrVcCorrelationID := response.GetHeader("v-c-correlation-id")

	if hdrVcCorrelationID != "" {
		o.VcCorrelationID = hdrVcCorrelationID
	}

	o.Payload = new(PatchCustomersPaymentInstrumentFailedDependencyBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPatchCustomersPaymentInstrumentInternalServerError creates a PatchCustomersPaymentInstrumentInternalServerError with default headers values
func NewPatchCustomersPaymentInstrumentInternalServerError() *PatchCustomersPaymentInstrumentInternalServerError {
	return &PatchCustomersPaymentInstrumentInternalServerError{}
}

/* PatchCustomersPaymentInstrumentInternalServerError describes a response with status code 500, with default header values.

Unexpected error.
*/
type PatchCustomersPaymentInstrumentInternalServerError struct {

	/* A globally unique id associated with your request.
	 */
	UniqueTransactionID string

	/* The mandatory correlation id passed by upstream (calling) system.
	 */
	VcCorrelationID string

	Payload *PatchCustomersPaymentInstrumentInternalServerErrorBody
}

func (o *PatchCustomersPaymentInstrumentInternalServerError) Error() string {
	return fmt.Sprintf("[PATCH /tms/v2/customers/{customerTokenId}/payment-instruments/{paymentInstrumentTokenId}][%d] patchCustomersPaymentInstrumentInternalServerError  %+v", 500, o.Payload)
}
func (o *PatchCustomersPaymentInstrumentInternalServerError) GetPayload() *PatchCustomersPaymentInstrumentInternalServerErrorBody {
	return o.Payload
}

func (o *PatchCustomersPaymentInstrumentInternalServerError) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	// hydrates response header uniqueTransactionID
	hdrUniqueTransactionID := response.GetHeader("uniqueTransactionID")

	if hdrUniqueTransactionID != "" {
		o.UniqueTransactionID = hdrUniqueTransactionID
	}

	// hydrates response header v-c-correlation-id
	hdrVcCorrelationID := response.GetHeader("v-c-correlation-id")

	if hdrVcCorrelationID != "" {
		o.VcCorrelationID = hdrVcCorrelationID
	}

	o.Payload = new(PatchCustomersPaymentInstrumentInternalServerErrorBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

/*PatchCustomersPaymentInstrumentBadRequestBody patch customers payment instrument bad request body
swagger:model PatchCustomersPaymentInstrumentBadRequestBody
*/
type PatchCustomersPaymentInstrumentBadRequestBody struct {

	// errors
	// Read Only: true
	Errors []*PatchCustomersPaymentInstrumentBadRequestBodyErrorsItems0 `json:"errors"`
}

// Validate validates this patch customers payment instrument bad request body
func (o *PatchCustomersPaymentInstrumentBadRequestBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateErrors(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentBadRequestBody) validateErrors(formats strfmt.Registry) error {
	if swag.IsZero(o.Errors) { // not required
		return nil
	}

	for i := 0; i < len(o.Errors); i++ {
		if swag.IsZero(o.Errors[i]) { // not required
			continue
		}

		if o.Errors[i] != nil {
			if err := o.Errors[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("patchCustomersPaymentInstrumentBadRequest" + "." + "errors" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("patchCustomersPaymentInstrumentBadRequest" + "." + "errors" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this patch customers payment instrument bad request body based on the context it is used
func (o *PatchCustomersPaymentInstrumentBadRequestBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateErrors(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentBadRequestBody) contextValidateErrors(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomersPaymentInstrumentBadRequest"+"."+"errors", "body", []*PatchCustomersPaymentInstrumentBadRequestBodyErrorsItems0(o.Errors)); err != nil {
		return err
	}

	for i := 0; i < len(o.Errors); i++ {

		if o.Errors[i] != nil {
			if err := o.Errors[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("patchCustomersPaymentInstrumentBadRequest" + "." + "errors" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("patchCustomersPaymentInstrumentBadRequest" + "." + "errors" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentBadRequestBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentBadRequestBody) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentBadRequestBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentBadRequestBodyErrorsItems0 patch customers payment instrument bad request body errors items0
swagger:model PatchCustomersPaymentInstrumentBadRequestBodyErrorsItems0
*/
type PatchCustomersPaymentInstrumentBadRequestBodyErrorsItems0 struct {

	// details
	// Read Only: true
	Details []*PatchCustomersPaymentInstrumentBadRequestBodyErrorsItems0DetailsItems0 `json:"details"`

	// The detailed message related to the type stated above.
	// Read Only: true
	Message string `json:"message,omitempty"`

	// The type of error.
	// Read Only: true
	Type string `json:"type,omitempty"`
}

// Validate validates this patch customers payment instrument bad request body errors items0
func (o *PatchCustomersPaymentInstrumentBadRequestBodyErrorsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentBadRequestBodyErrorsItems0) validateDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.Details) { // not required
		return nil
	}

	for i := 0; i < len(o.Details); i++ {
		if swag.IsZero(o.Details[i]) { // not required
			continue
		}

		if o.Details[i] != nil {
			if err := o.Details[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this patch customers payment instrument bad request body errors items0 based on the context it is used
func (o *PatchCustomersPaymentInstrumentBadRequestBodyErrorsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateMessage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentBadRequestBodyErrorsItems0) contextValidateDetails(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "details", "body", []*PatchCustomersPaymentInstrumentBadRequestBodyErrorsItems0DetailsItems0(o.Details)); err != nil {
		return err
	}

	for i := 0; i < len(o.Details); i++ {

		if o.Details[i] != nil {
			if err := o.Details[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentBadRequestBodyErrorsItems0) contextValidateMessage(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "message", "body", string(o.Message)); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentBadRequestBodyErrorsItems0) contextValidateType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "type", "body", string(o.Type)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentBadRequestBodyErrorsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentBadRequestBodyErrorsItems0) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentBadRequestBodyErrorsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentBadRequestBodyErrorsItems0DetailsItems0 patch customers payment instrument bad request body errors items0 details items0
swagger:model PatchCustomersPaymentInstrumentBadRequestBodyErrorsItems0DetailsItems0
*/
type PatchCustomersPaymentInstrumentBadRequestBodyErrorsItems0DetailsItems0 struct {

	// The location of the field that caused the error.
	// Read Only: true
	Location string `json:"location,omitempty"`

	// The name of the field that caused the error.
	// Read Only: true
	Name string `json:"name,omitempty"`
}

// Validate validates this patch customers payment instrument bad request body errors items0 details items0
func (o *PatchCustomersPaymentInstrumentBadRequestBodyErrorsItems0DetailsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this patch customers payment instrument bad request body errors items0 details items0 based on the context it is used
func (o *PatchCustomersPaymentInstrumentBadRequestBodyErrorsItems0DetailsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateLocation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentBadRequestBodyErrorsItems0DetailsItems0) contextValidateLocation(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "location", "body", string(o.Location)); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentBadRequestBodyErrorsItems0DetailsItems0) contextValidateName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "name", "body", string(o.Name)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentBadRequestBodyErrorsItems0DetailsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentBadRequestBodyErrorsItems0DetailsItems0) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentBadRequestBodyErrorsItems0DetailsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentBody patch customers payment instrument body
swagger:model PatchCustomersPaymentInstrumentBody
*/
type PatchCustomersPaymentInstrumentBody struct {

	// embedded
	Embedded *PatchCustomersPaymentInstrumentParamsBodyEmbedded `json:"_embedded,omitempty"`

	// links
	Links *PatchCustomersPaymentInstrumentParamsBodyLinks `json:"_links,omitempty"`

	// bank account
	BankAccount *PatchCustomersPaymentInstrumentParamsBodyBankAccount `json:"bankAccount,omitempty"`

	// bill to
	BillTo *PatchCustomersPaymentInstrumentParamsBodyBillTo `json:"billTo,omitempty"`

	// buyer information
	BuyerInformation *PatchCustomersPaymentInstrumentParamsBodyBuyerInformation `json:"buyerInformation,omitempty"`

	// card
	Card *PatchCustomersPaymentInstrumentParamsBodyCard `json:"card,omitempty"`

	// Flag that indicates whether customer payment instrument is the dafault.
	// Valid values:
	//  - `true`: Payment instrument is customer's default.
	//  - `false`: Payment instrument is not customer's default.
	//
	Default bool `json:"default,omitempty"`

	// The id of the Payment Instrument Token.
	// Max Length: 32
	// Min Length: 1
	ID string `json:"id,omitempty"`

	// instrument identifier
	InstrumentIdentifier *PatchCustomersPaymentInstrumentParamsBodyInstrumentIdentifier `json:"instrumentIdentifier,omitempty"`

	// merchant information
	MerchantInformation *PatchCustomersPaymentInstrumentParamsBodyMerchantInformation `json:"merchantInformation,omitempty"`

	// metadata
	Metadata *PatchCustomersPaymentInstrumentParamsBodyMetadata `json:"metadata,omitempty"`

	// The type of token.
	//
	// Valid values:
	// - paymentInstrument
	//
	// Example: paymentInstrument
	// Read Only: true
	Object string `json:"object,omitempty"`

	// processing information
	ProcessingInformation *PatchCustomersPaymentInstrumentParamsBodyProcessingInformation `json:"processingInformation,omitempty"`

	// Issuers state for the card number.
	// Valid values:
	// - ACTIVE
	// - CLOSED : The account has been closed.
	//
	// Example: ACTIVE
	// Read Only: true
	State string `json:"state,omitempty"`
}

// Validate validates this patch customers payment instrument body
func (o *PatchCustomersPaymentInstrumentBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateEmbedded(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBankAccount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBillTo(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBuyerInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCard(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateInstrumentIdentifier(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMerchantInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMetadata(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProcessingInformation(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentBody) validateEmbedded(formats strfmt.Registry) error {
	if swag.IsZero(o.Embedded) { // not required
		return nil
	}

	if o.Embedded != nil {
		if err := o.Embedded.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_embedded")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_embedded")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentBody) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(o.Links) { // not required
		return nil
	}

	if o.Links != nil {
		if err := o.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentBody) validateBankAccount(formats strfmt.Registry) error {
	if swag.IsZero(o.BankAccount) { // not required
		return nil
	}

	if o.BankAccount != nil {
		if err := o.BankAccount.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "bankAccount")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "bankAccount")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentBody) validateBillTo(formats strfmt.Registry) error {
	if swag.IsZero(o.BillTo) { // not required
		return nil
	}

	if o.BillTo != nil {
		if err := o.BillTo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "billTo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "billTo")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentBody) validateBuyerInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.BuyerInformation) { // not required
		return nil
	}

	if o.BuyerInformation != nil {
		if err := o.BuyerInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "buyerInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "buyerInformation")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentBody) validateCard(formats strfmt.Registry) error {
	if swag.IsZero(o.Card) { // not required
		return nil
	}

	if o.Card != nil {
		if err := o.Card.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "card")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "card")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentBody) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MinLength("patchCustomerPaymentInstrumentRequest"+"."+"id", "body", o.ID, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("patchCustomerPaymentInstrumentRequest"+"."+"id", "body", o.ID, 32); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentBody) validateInstrumentIdentifier(formats strfmt.Registry) error {
	if swag.IsZero(o.InstrumentIdentifier) { // not required
		return nil
	}

	if o.InstrumentIdentifier != nil {
		if err := o.InstrumentIdentifier.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "instrumentIdentifier")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "instrumentIdentifier")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentBody) validateMerchantInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.MerchantInformation) { // not required
		return nil
	}

	if o.MerchantInformation != nil {
		if err := o.MerchantInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "merchantInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "merchantInformation")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentBody) validateMetadata(formats strfmt.Registry) error {
	if swag.IsZero(o.Metadata) { // not required
		return nil
	}

	if o.Metadata != nil {
		if err := o.Metadata.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "metadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "metadata")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentBody) validateProcessingInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ProcessingInformation) { // not required
		return nil
	}

	if o.ProcessingInformation != nil {
		if err := o.ProcessingInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "processingInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "processingInformation")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch customers payment instrument body based on the context it is used
func (o *PatchCustomersPaymentInstrumentBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateEmbedded(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateBankAccount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateBillTo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateBuyerInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateCard(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateInstrumentIdentifier(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateMerchantInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateMetadata(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateObject(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateProcessingInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentBody) contextValidateEmbedded(ctx context.Context, formats strfmt.Registry) error {

	if o.Embedded != nil {
		if err := o.Embedded.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_embedded")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_embedded")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentBody) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if o.Links != nil {
		if err := o.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentBody) contextValidateBankAccount(ctx context.Context, formats strfmt.Registry) error {

	if o.BankAccount != nil {
		if err := o.BankAccount.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "bankAccount")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "bankAccount")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentBody) contextValidateBillTo(ctx context.Context, formats strfmt.Registry) error {

	if o.BillTo != nil {
		if err := o.BillTo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "billTo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "billTo")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentBody) contextValidateBuyerInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.BuyerInformation != nil {
		if err := o.BuyerInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "buyerInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "buyerInformation")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentBody) contextValidateCard(ctx context.Context, formats strfmt.Registry) error {

	if o.Card != nil {
		if err := o.Card.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "card")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "card")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentBody) contextValidateInstrumentIdentifier(ctx context.Context, formats strfmt.Registry) error {

	if o.InstrumentIdentifier != nil {
		if err := o.InstrumentIdentifier.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "instrumentIdentifier")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "instrumentIdentifier")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentBody) contextValidateMerchantInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.MerchantInformation != nil {
		if err := o.MerchantInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "merchantInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "merchantInformation")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentBody) contextValidateMetadata(ctx context.Context, formats strfmt.Registry) error {

	if o.Metadata != nil {
		if err := o.Metadata.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "metadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "metadata")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentBody) contextValidateObject(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerPaymentInstrumentRequest"+"."+"object", "body", string(o.Object)); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentBody) contextValidateProcessingInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ProcessingInformation != nil {
		if err := o.ProcessingInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "processingInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "processingInformation")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentBody) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerPaymentInstrumentRequest"+"."+"state", "body", string(o.State)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentBody) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentFailedDependencyBody patch customers payment instrument failed dependency body
swagger:model PatchCustomersPaymentInstrumentFailedDependencyBody
*/
type PatchCustomersPaymentInstrumentFailedDependencyBody struct {

	// errors
	// Read Only: true
	Errors []*PatchCustomersPaymentInstrumentFailedDependencyBodyErrorsItems0 `json:"errors"`
}

// Validate validates this patch customers payment instrument failed dependency body
func (o *PatchCustomersPaymentInstrumentFailedDependencyBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateErrors(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentFailedDependencyBody) validateErrors(formats strfmt.Registry) error {
	if swag.IsZero(o.Errors) { // not required
		return nil
	}

	for i := 0; i < len(o.Errors); i++ {
		if swag.IsZero(o.Errors[i]) { // not required
			continue
		}

		if o.Errors[i] != nil {
			if err := o.Errors[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("patchCustomersPaymentInstrumentFailedDependency" + "." + "errors" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("patchCustomersPaymentInstrumentFailedDependency" + "." + "errors" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this patch customers payment instrument failed dependency body based on the context it is used
func (o *PatchCustomersPaymentInstrumentFailedDependencyBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateErrors(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentFailedDependencyBody) contextValidateErrors(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomersPaymentInstrumentFailedDependency"+"."+"errors", "body", []*PatchCustomersPaymentInstrumentFailedDependencyBodyErrorsItems0(o.Errors)); err != nil {
		return err
	}

	for i := 0; i < len(o.Errors); i++ {

		if o.Errors[i] != nil {
			if err := o.Errors[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("patchCustomersPaymentInstrumentFailedDependency" + "." + "errors" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("patchCustomersPaymentInstrumentFailedDependency" + "." + "errors" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentFailedDependencyBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentFailedDependencyBody) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentFailedDependencyBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentFailedDependencyBodyErrorsItems0 patch customers payment instrument failed dependency body errors items0
swagger:model PatchCustomersPaymentInstrumentFailedDependencyBodyErrorsItems0
*/
type PatchCustomersPaymentInstrumentFailedDependencyBodyErrorsItems0 struct {

	// details
	// Read Only: true
	Details []*PatchCustomersPaymentInstrumentFailedDependencyBodyErrorsItems0DetailsItems0 `json:"details"`

	// The detailed message related to the type stated above.
	// Read Only: true
	Message string `json:"message,omitempty"`

	// The type of error.
	// Read Only: true
	Type string `json:"type,omitempty"`
}

// Validate validates this patch customers payment instrument failed dependency body errors items0
func (o *PatchCustomersPaymentInstrumentFailedDependencyBodyErrorsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentFailedDependencyBodyErrorsItems0) validateDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.Details) { // not required
		return nil
	}

	for i := 0; i < len(o.Details); i++ {
		if swag.IsZero(o.Details[i]) { // not required
			continue
		}

		if o.Details[i] != nil {
			if err := o.Details[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this patch customers payment instrument failed dependency body errors items0 based on the context it is used
func (o *PatchCustomersPaymentInstrumentFailedDependencyBodyErrorsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateMessage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentFailedDependencyBodyErrorsItems0) contextValidateDetails(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "details", "body", []*PatchCustomersPaymentInstrumentFailedDependencyBodyErrorsItems0DetailsItems0(o.Details)); err != nil {
		return err
	}

	for i := 0; i < len(o.Details); i++ {

		if o.Details[i] != nil {
			if err := o.Details[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentFailedDependencyBodyErrorsItems0) contextValidateMessage(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "message", "body", string(o.Message)); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentFailedDependencyBodyErrorsItems0) contextValidateType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "type", "body", string(o.Type)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentFailedDependencyBodyErrorsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentFailedDependencyBodyErrorsItems0) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentFailedDependencyBodyErrorsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentFailedDependencyBodyErrorsItems0DetailsItems0 patch customers payment instrument failed dependency body errors items0 details items0
swagger:model PatchCustomersPaymentInstrumentFailedDependencyBodyErrorsItems0DetailsItems0
*/
type PatchCustomersPaymentInstrumentFailedDependencyBodyErrorsItems0DetailsItems0 struct {

	// The location of the field that caused the error.
	// Read Only: true
	Location string `json:"location,omitempty"`

	// The name of the field that caused the error.
	// Read Only: true
	Name string `json:"name,omitempty"`
}

// Validate validates this patch customers payment instrument failed dependency body errors items0 details items0
func (o *PatchCustomersPaymentInstrumentFailedDependencyBodyErrorsItems0DetailsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this patch customers payment instrument failed dependency body errors items0 details items0 based on the context it is used
func (o *PatchCustomersPaymentInstrumentFailedDependencyBodyErrorsItems0DetailsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateLocation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentFailedDependencyBodyErrorsItems0DetailsItems0) contextValidateLocation(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "location", "body", string(o.Location)); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentFailedDependencyBodyErrorsItems0DetailsItems0) contextValidateName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "name", "body", string(o.Name)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentFailedDependencyBodyErrorsItems0DetailsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentFailedDependencyBodyErrorsItems0DetailsItems0) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentFailedDependencyBodyErrorsItems0DetailsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentForbiddenBody patch customers payment instrument forbidden body
swagger:model PatchCustomersPaymentInstrumentForbiddenBody
*/
type PatchCustomersPaymentInstrumentForbiddenBody struct {

	// errors
	// Read Only: true
	Errors []*PatchCustomersPaymentInstrumentForbiddenBodyErrorsItems0 `json:"errors"`
}

// Validate validates this patch customers payment instrument forbidden body
func (o *PatchCustomersPaymentInstrumentForbiddenBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateErrors(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentForbiddenBody) validateErrors(formats strfmt.Registry) error {
	if swag.IsZero(o.Errors) { // not required
		return nil
	}

	for i := 0; i < len(o.Errors); i++ {
		if swag.IsZero(o.Errors[i]) { // not required
			continue
		}

		if o.Errors[i] != nil {
			if err := o.Errors[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("patchCustomersPaymentInstrumentForbidden" + "." + "errors" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("patchCustomersPaymentInstrumentForbidden" + "." + "errors" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this patch customers payment instrument forbidden body based on the context it is used
func (o *PatchCustomersPaymentInstrumentForbiddenBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateErrors(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentForbiddenBody) contextValidateErrors(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomersPaymentInstrumentForbidden"+"."+"errors", "body", []*PatchCustomersPaymentInstrumentForbiddenBodyErrorsItems0(o.Errors)); err != nil {
		return err
	}

	for i := 0; i < len(o.Errors); i++ {

		if o.Errors[i] != nil {
			if err := o.Errors[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("patchCustomersPaymentInstrumentForbidden" + "." + "errors" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("patchCustomersPaymentInstrumentForbidden" + "." + "errors" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentForbiddenBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentForbiddenBody) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentForbiddenBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentForbiddenBodyErrorsItems0 patch customers payment instrument forbidden body errors items0
swagger:model PatchCustomersPaymentInstrumentForbiddenBodyErrorsItems0
*/
type PatchCustomersPaymentInstrumentForbiddenBodyErrorsItems0 struct {

	// details
	// Read Only: true
	Details []*PatchCustomersPaymentInstrumentForbiddenBodyErrorsItems0DetailsItems0 `json:"details"`

	// The detailed message related to the type stated above.
	// Read Only: true
	Message string `json:"message,omitempty"`

	// The type of error.
	// Read Only: true
	Type string `json:"type,omitempty"`
}

// Validate validates this patch customers payment instrument forbidden body errors items0
func (o *PatchCustomersPaymentInstrumentForbiddenBodyErrorsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentForbiddenBodyErrorsItems0) validateDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.Details) { // not required
		return nil
	}

	for i := 0; i < len(o.Details); i++ {
		if swag.IsZero(o.Details[i]) { // not required
			continue
		}

		if o.Details[i] != nil {
			if err := o.Details[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this patch customers payment instrument forbidden body errors items0 based on the context it is used
func (o *PatchCustomersPaymentInstrumentForbiddenBodyErrorsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateMessage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentForbiddenBodyErrorsItems0) contextValidateDetails(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "details", "body", []*PatchCustomersPaymentInstrumentForbiddenBodyErrorsItems0DetailsItems0(o.Details)); err != nil {
		return err
	}

	for i := 0; i < len(o.Details); i++ {

		if o.Details[i] != nil {
			if err := o.Details[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentForbiddenBodyErrorsItems0) contextValidateMessage(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "message", "body", string(o.Message)); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentForbiddenBodyErrorsItems0) contextValidateType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "type", "body", string(o.Type)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentForbiddenBodyErrorsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentForbiddenBodyErrorsItems0) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentForbiddenBodyErrorsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentForbiddenBodyErrorsItems0DetailsItems0 patch customers payment instrument forbidden body errors items0 details items0
swagger:model PatchCustomersPaymentInstrumentForbiddenBodyErrorsItems0DetailsItems0
*/
type PatchCustomersPaymentInstrumentForbiddenBodyErrorsItems0DetailsItems0 struct {

	// The location of the field that caused the error.
	// Read Only: true
	Location string `json:"location,omitempty"`

	// The name of the field that caused the error.
	// Read Only: true
	Name string `json:"name,omitempty"`
}

// Validate validates this patch customers payment instrument forbidden body errors items0 details items0
func (o *PatchCustomersPaymentInstrumentForbiddenBodyErrorsItems0DetailsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this patch customers payment instrument forbidden body errors items0 details items0 based on the context it is used
func (o *PatchCustomersPaymentInstrumentForbiddenBodyErrorsItems0DetailsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateLocation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentForbiddenBodyErrorsItems0DetailsItems0) contextValidateLocation(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "location", "body", string(o.Location)); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentForbiddenBodyErrorsItems0DetailsItems0) contextValidateName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "name", "body", string(o.Name)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentForbiddenBodyErrorsItems0DetailsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentForbiddenBodyErrorsItems0DetailsItems0) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentForbiddenBodyErrorsItems0DetailsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentGoneBody patch customers payment instrument gone body
swagger:model PatchCustomersPaymentInstrumentGoneBody
*/
type PatchCustomersPaymentInstrumentGoneBody struct {

	// errors
	// Read Only: true
	Errors []*PatchCustomersPaymentInstrumentGoneBodyErrorsItems0 `json:"errors"`
}

// Validate validates this patch customers payment instrument gone body
func (o *PatchCustomersPaymentInstrumentGoneBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateErrors(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentGoneBody) validateErrors(formats strfmt.Registry) error {
	if swag.IsZero(o.Errors) { // not required
		return nil
	}

	for i := 0; i < len(o.Errors); i++ {
		if swag.IsZero(o.Errors[i]) { // not required
			continue
		}

		if o.Errors[i] != nil {
			if err := o.Errors[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("patchCustomersPaymentInstrumentGone" + "." + "errors" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("patchCustomersPaymentInstrumentGone" + "." + "errors" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this patch customers payment instrument gone body based on the context it is used
func (o *PatchCustomersPaymentInstrumentGoneBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateErrors(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentGoneBody) contextValidateErrors(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomersPaymentInstrumentGone"+"."+"errors", "body", []*PatchCustomersPaymentInstrumentGoneBodyErrorsItems0(o.Errors)); err != nil {
		return err
	}

	for i := 0; i < len(o.Errors); i++ {

		if o.Errors[i] != nil {
			if err := o.Errors[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("patchCustomersPaymentInstrumentGone" + "." + "errors" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("patchCustomersPaymentInstrumentGone" + "." + "errors" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentGoneBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentGoneBody) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentGoneBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentGoneBodyErrorsItems0 patch customers payment instrument gone body errors items0
swagger:model PatchCustomersPaymentInstrumentGoneBodyErrorsItems0
*/
type PatchCustomersPaymentInstrumentGoneBodyErrorsItems0 struct {

	// details
	// Read Only: true
	Details []*PatchCustomersPaymentInstrumentGoneBodyErrorsItems0DetailsItems0 `json:"details"`

	// The detailed message related to the type stated above.
	// Read Only: true
	Message string `json:"message,omitempty"`

	// The type of error.
	// Read Only: true
	Type string `json:"type,omitempty"`
}

// Validate validates this patch customers payment instrument gone body errors items0
func (o *PatchCustomersPaymentInstrumentGoneBodyErrorsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentGoneBodyErrorsItems0) validateDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.Details) { // not required
		return nil
	}

	for i := 0; i < len(o.Details); i++ {
		if swag.IsZero(o.Details[i]) { // not required
			continue
		}

		if o.Details[i] != nil {
			if err := o.Details[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this patch customers payment instrument gone body errors items0 based on the context it is used
func (o *PatchCustomersPaymentInstrumentGoneBodyErrorsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateMessage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentGoneBodyErrorsItems0) contextValidateDetails(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "details", "body", []*PatchCustomersPaymentInstrumentGoneBodyErrorsItems0DetailsItems0(o.Details)); err != nil {
		return err
	}

	for i := 0; i < len(o.Details); i++ {

		if o.Details[i] != nil {
			if err := o.Details[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentGoneBodyErrorsItems0) contextValidateMessage(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "message", "body", string(o.Message)); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentGoneBodyErrorsItems0) contextValidateType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "type", "body", string(o.Type)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentGoneBodyErrorsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentGoneBodyErrorsItems0) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentGoneBodyErrorsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentGoneBodyErrorsItems0DetailsItems0 patch customers payment instrument gone body errors items0 details items0
swagger:model PatchCustomersPaymentInstrumentGoneBodyErrorsItems0DetailsItems0
*/
type PatchCustomersPaymentInstrumentGoneBodyErrorsItems0DetailsItems0 struct {

	// The location of the field that caused the error.
	// Read Only: true
	Location string `json:"location,omitempty"`

	// The name of the field that caused the error.
	// Read Only: true
	Name string `json:"name,omitempty"`
}

// Validate validates this patch customers payment instrument gone body errors items0 details items0
func (o *PatchCustomersPaymentInstrumentGoneBodyErrorsItems0DetailsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this patch customers payment instrument gone body errors items0 details items0 based on the context it is used
func (o *PatchCustomersPaymentInstrumentGoneBodyErrorsItems0DetailsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateLocation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentGoneBodyErrorsItems0DetailsItems0) contextValidateLocation(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "location", "body", string(o.Location)); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentGoneBodyErrorsItems0DetailsItems0) contextValidateName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "name", "body", string(o.Name)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentGoneBodyErrorsItems0DetailsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentGoneBodyErrorsItems0DetailsItems0) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentGoneBodyErrorsItems0DetailsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentInternalServerErrorBody patch customers payment instrument internal server error body
swagger:model PatchCustomersPaymentInstrumentInternalServerErrorBody
*/
type PatchCustomersPaymentInstrumentInternalServerErrorBody struct {

	// errors
	// Read Only: true
	Errors []*PatchCustomersPaymentInstrumentInternalServerErrorBodyErrorsItems0 `json:"errors"`
}

// Validate validates this patch customers payment instrument internal server error body
func (o *PatchCustomersPaymentInstrumentInternalServerErrorBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateErrors(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentInternalServerErrorBody) validateErrors(formats strfmt.Registry) error {
	if swag.IsZero(o.Errors) { // not required
		return nil
	}

	for i := 0; i < len(o.Errors); i++ {
		if swag.IsZero(o.Errors[i]) { // not required
			continue
		}

		if o.Errors[i] != nil {
			if err := o.Errors[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("patchCustomersPaymentInstrumentInternalServerError" + "." + "errors" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("patchCustomersPaymentInstrumentInternalServerError" + "." + "errors" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this patch customers payment instrument internal server error body based on the context it is used
func (o *PatchCustomersPaymentInstrumentInternalServerErrorBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateErrors(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentInternalServerErrorBody) contextValidateErrors(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomersPaymentInstrumentInternalServerError"+"."+"errors", "body", []*PatchCustomersPaymentInstrumentInternalServerErrorBodyErrorsItems0(o.Errors)); err != nil {
		return err
	}

	for i := 0; i < len(o.Errors); i++ {

		if o.Errors[i] != nil {
			if err := o.Errors[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("patchCustomersPaymentInstrumentInternalServerError" + "." + "errors" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("patchCustomersPaymentInstrumentInternalServerError" + "." + "errors" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentInternalServerErrorBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentInternalServerErrorBody) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentInternalServerErrorBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentInternalServerErrorBodyErrorsItems0 patch customers payment instrument internal server error body errors items0
swagger:model PatchCustomersPaymentInstrumentInternalServerErrorBodyErrorsItems0
*/
type PatchCustomersPaymentInstrumentInternalServerErrorBodyErrorsItems0 struct {

	// details
	// Read Only: true
	Details []*PatchCustomersPaymentInstrumentInternalServerErrorBodyErrorsItems0DetailsItems0 `json:"details"`

	// The detailed message related to the type stated above.
	// Read Only: true
	Message string `json:"message,omitempty"`

	// The type of error.
	// Read Only: true
	Type string `json:"type,omitempty"`
}

// Validate validates this patch customers payment instrument internal server error body errors items0
func (o *PatchCustomersPaymentInstrumentInternalServerErrorBodyErrorsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentInternalServerErrorBodyErrorsItems0) validateDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.Details) { // not required
		return nil
	}

	for i := 0; i < len(o.Details); i++ {
		if swag.IsZero(o.Details[i]) { // not required
			continue
		}

		if o.Details[i] != nil {
			if err := o.Details[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this patch customers payment instrument internal server error body errors items0 based on the context it is used
func (o *PatchCustomersPaymentInstrumentInternalServerErrorBodyErrorsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateMessage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentInternalServerErrorBodyErrorsItems0) contextValidateDetails(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "details", "body", []*PatchCustomersPaymentInstrumentInternalServerErrorBodyErrorsItems0DetailsItems0(o.Details)); err != nil {
		return err
	}

	for i := 0; i < len(o.Details); i++ {

		if o.Details[i] != nil {
			if err := o.Details[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentInternalServerErrorBodyErrorsItems0) contextValidateMessage(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "message", "body", string(o.Message)); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentInternalServerErrorBodyErrorsItems0) contextValidateType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "type", "body", string(o.Type)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentInternalServerErrorBodyErrorsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentInternalServerErrorBodyErrorsItems0) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentInternalServerErrorBodyErrorsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentInternalServerErrorBodyErrorsItems0DetailsItems0 patch customers payment instrument internal server error body errors items0 details items0
swagger:model PatchCustomersPaymentInstrumentInternalServerErrorBodyErrorsItems0DetailsItems0
*/
type PatchCustomersPaymentInstrumentInternalServerErrorBodyErrorsItems0DetailsItems0 struct {

	// The location of the field that caused the error.
	// Read Only: true
	Location string `json:"location,omitempty"`

	// The name of the field that caused the error.
	// Read Only: true
	Name string `json:"name,omitempty"`
}

// Validate validates this patch customers payment instrument internal server error body errors items0 details items0
func (o *PatchCustomersPaymentInstrumentInternalServerErrorBodyErrorsItems0DetailsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this patch customers payment instrument internal server error body errors items0 details items0 based on the context it is used
func (o *PatchCustomersPaymentInstrumentInternalServerErrorBodyErrorsItems0DetailsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateLocation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentInternalServerErrorBodyErrorsItems0DetailsItems0) contextValidateLocation(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "location", "body", string(o.Location)); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentInternalServerErrorBodyErrorsItems0DetailsItems0) contextValidateName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "name", "body", string(o.Name)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentInternalServerErrorBodyErrorsItems0DetailsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentInternalServerErrorBodyErrorsItems0DetailsItems0) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentInternalServerErrorBodyErrorsItems0DetailsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentNotFoundBody patch customers payment instrument not found body
swagger:model PatchCustomersPaymentInstrumentNotFoundBody
*/
type PatchCustomersPaymentInstrumentNotFoundBody struct {

	// errors
	// Read Only: true
	Errors []*PatchCustomersPaymentInstrumentNotFoundBodyErrorsItems0 `json:"errors"`
}

// Validate validates this patch customers payment instrument not found body
func (o *PatchCustomersPaymentInstrumentNotFoundBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateErrors(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentNotFoundBody) validateErrors(formats strfmt.Registry) error {
	if swag.IsZero(o.Errors) { // not required
		return nil
	}

	for i := 0; i < len(o.Errors); i++ {
		if swag.IsZero(o.Errors[i]) { // not required
			continue
		}

		if o.Errors[i] != nil {
			if err := o.Errors[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("patchCustomersPaymentInstrumentNotFound" + "." + "errors" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("patchCustomersPaymentInstrumentNotFound" + "." + "errors" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this patch customers payment instrument not found body based on the context it is used
func (o *PatchCustomersPaymentInstrumentNotFoundBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateErrors(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentNotFoundBody) contextValidateErrors(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomersPaymentInstrumentNotFound"+"."+"errors", "body", []*PatchCustomersPaymentInstrumentNotFoundBodyErrorsItems0(o.Errors)); err != nil {
		return err
	}

	for i := 0; i < len(o.Errors); i++ {

		if o.Errors[i] != nil {
			if err := o.Errors[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("patchCustomersPaymentInstrumentNotFound" + "." + "errors" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("patchCustomersPaymentInstrumentNotFound" + "." + "errors" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentNotFoundBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentNotFoundBody) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentNotFoundBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentNotFoundBodyErrorsItems0 patch customers payment instrument not found body errors items0
swagger:model PatchCustomersPaymentInstrumentNotFoundBodyErrorsItems0
*/
type PatchCustomersPaymentInstrumentNotFoundBodyErrorsItems0 struct {

	// details
	// Read Only: true
	Details []*PatchCustomersPaymentInstrumentNotFoundBodyErrorsItems0DetailsItems0 `json:"details"`

	// The detailed message related to the type stated above.
	// Read Only: true
	Message string `json:"message,omitempty"`

	// The type of error.
	// Read Only: true
	Type string `json:"type,omitempty"`
}

// Validate validates this patch customers payment instrument not found body errors items0
func (o *PatchCustomersPaymentInstrumentNotFoundBodyErrorsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentNotFoundBodyErrorsItems0) validateDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.Details) { // not required
		return nil
	}

	for i := 0; i < len(o.Details); i++ {
		if swag.IsZero(o.Details[i]) { // not required
			continue
		}

		if o.Details[i] != nil {
			if err := o.Details[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this patch customers payment instrument not found body errors items0 based on the context it is used
func (o *PatchCustomersPaymentInstrumentNotFoundBodyErrorsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateMessage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentNotFoundBodyErrorsItems0) contextValidateDetails(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "details", "body", []*PatchCustomersPaymentInstrumentNotFoundBodyErrorsItems0DetailsItems0(o.Details)); err != nil {
		return err
	}

	for i := 0; i < len(o.Details); i++ {

		if o.Details[i] != nil {
			if err := o.Details[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentNotFoundBodyErrorsItems0) contextValidateMessage(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "message", "body", string(o.Message)); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentNotFoundBodyErrorsItems0) contextValidateType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "type", "body", string(o.Type)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentNotFoundBodyErrorsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentNotFoundBodyErrorsItems0) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentNotFoundBodyErrorsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentNotFoundBodyErrorsItems0DetailsItems0 patch customers payment instrument not found body errors items0 details items0
swagger:model PatchCustomersPaymentInstrumentNotFoundBodyErrorsItems0DetailsItems0
*/
type PatchCustomersPaymentInstrumentNotFoundBodyErrorsItems0DetailsItems0 struct {

	// The location of the field that caused the error.
	// Read Only: true
	Location string `json:"location,omitempty"`

	// The name of the field that caused the error.
	// Read Only: true
	Name string `json:"name,omitempty"`
}

// Validate validates this patch customers payment instrument not found body errors items0 details items0
func (o *PatchCustomersPaymentInstrumentNotFoundBodyErrorsItems0DetailsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this patch customers payment instrument not found body errors items0 details items0 based on the context it is used
func (o *PatchCustomersPaymentInstrumentNotFoundBodyErrorsItems0DetailsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateLocation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentNotFoundBodyErrorsItems0DetailsItems0) contextValidateLocation(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "location", "body", string(o.Location)); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentNotFoundBodyErrorsItems0DetailsItems0) contextValidateName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "name", "body", string(o.Name)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentNotFoundBodyErrorsItems0DetailsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentNotFoundBodyErrorsItems0DetailsItems0) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentNotFoundBodyErrorsItems0DetailsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentOKBody patch customers payment instrument o k body
swagger:model PatchCustomersPaymentInstrumentOKBody
*/
type PatchCustomersPaymentInstrumentOKBody struct {

	// embedded
	Embedded *PatchCustomersPaymentInstrumentOKBodyEmbedded `json:"_embedded,omitempty"`

	// links
	Links *PatchCustomersPaymentInstrumentOKBodyLinks `json:"_links,omitempty"`

	// bank account
	BankAccount *PatchCustomersPaymentInstrumentOKBodyBankAccount `json:"bankAccount,omitempty"`

	// bill to
	BillTo *PatchCustomersPaymentInstrumentOKBodyBillTo `json:"billTo,omitempty"`

	// buyer information
	BuyerInformation *PatchCustomersPaymentInstrumentOKBodyBuyerInformation `json:"buyerInformation,omitempty"`

	// card
	Card *PatchCustomersPaymentInstrumentOKBodyCard `json:"card,omitempty"`

	// Flag that indicates whether customer payment instrument is the dafault.
	// Valid values:
	//  - `true`: Payment instrument is customer's default.
	//  - `false`: Payment instrument is not customer's default.
	//
	Default bool `json:"default,omitempty"`

	// The id of the Payment Instrument Token.
	// Max Length: 32
	// Min Length: 1
	ID string `json:"id,omitempty"`

	// instrument identifier
	InstrumentIdentifier *PatchCustomersPaymentInstrumentOKBodyInstrumentIdentifier `json:"instrumentIdentifier,omitempty"`

	// merchant information
	MerchantInformation *PatchCustomersPaymentInstrumentOKBodyMerchantInformation `json:"merchantInformation,omitempty"`

	// metadata
	Metadata *PatchCustomersPaymentInstrumentOKBodyMetadata `json:"metadata,omitempty"`

	// The type of token.
	//
	// Valid values:
	// - paymentInstrument
	//
	// Example: paymentInstrument
	// Read Only: true
	Object string `json:"object,omitempty"`

	// processing information
	ProcessingInformation *PatchCustomersPaymentInstrumentOKBodyProcessingInformation `json:"processingInformation,omitempty"`

	// Issuers state for the card number.
	// Valid values:
	// - ACTIVE
	// - CLOSED : The account has been closed.
	//
	// Example: ACTIVE
	// Read Only: true
	State string `json:"state,omitempty"`
}

// Validate validates this patch customers payment instrument o k body
func (o *PatchCustomersPaymentInstrumentOKBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateEmbedded(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBankAccount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBillTo(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBuyerInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCard(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateInstrumentIdentifier(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMerchantInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMetadata(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProcessingInformation(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBody) validateEmbedded(formats strfmt.Registry) error {
	if swag.IsZero(o.Embedded) { // not required
		return nil
	}

	if o.Embedded != nil {
		if err := o.Embedded.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_embedded")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_embedded")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBody) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(o.Links) { // not required
		return nil
	}

	if o.Links != nil {
		if err := o.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBody) validateBankAccount(formats strfmt.Registry) error {
	if swag.IsZero(o.BankAccount) { // not required
		return nil
	}

	if o.BankAccount != nil {
		if err := o.BankAccount.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "bankAccount")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "bankAccount")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBody) validateBillTo(formats strfmt.Registry) error {
	if swag.IsZero(o.BillTo) { // not required
		return nil
	}

	if o.BillTo != nil {
		if err := o.BillTo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "billTo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "billTo")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBody) validateBuyerInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.BuyerInformation) { // not required
		return nil
	}

	if o.BuyerInformation != nil {
		if err := o.BuyerInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "buyerInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "buyerInformation")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBody) validateCard(formats strfmt.Registry) error {
	if swag.IsZero(o.Card) { // not required
		return nil
	}

	if o.Card != nil {
		if err := o.Card.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "card")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "card")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBody) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MinLength("patchCustomersPaymentInstrumentOK"+"."+"id", "body", o.ID, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("patchCustomersPaymentInstrumentOK"+"."+"id", "body", o.ID, 32); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBody) validateInstrumentIdentifier(formats strfmt.Registry) error {
	if swag.IsZero(o.InstrumentIdentifier) { // not required
		return nil
	}

	if o.InstrumentIdentifier != nil {
		if err := o.InstrumentIdentifier.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "instrumentIdentifier")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "instrumentIdentifier")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBody) validateMerchantInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.MerchantInformation) { // not required
		return nil
	}

	if o.MerchantInformation != nil {
		if err := o.MerchantInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "merchantInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "merchantInformation")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBody) validateMetadata(formats strfmt.Registry) error {
	if swag.IsZero(o.Metadata) { // not required
		return nil
	}

	if o.Metadata != nil {
		if err := o.Metadata.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "metadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "metadata")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBody) validateProcessingInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ProcessingInformation) { // not required
		return nil
	}

	if o.ProcessingInformation != nil {
		if err := o.ProcessingInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "processingInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "processingInformation")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch customers payment instrument o k body based on the context it is used
func (o *PatchCustomersPaymentInstrumentOKBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateEmbedded(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateBankAccount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateBillTo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateBuyerInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateCard(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateInstrumentIdentifier(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateMerchantInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateMetadata(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateObject(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateProcessingInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBody) contextValidateEmbedded(ctx context.Context, formats strfmt.Registry) error {

	if o.Embedded != nil {
		if err := o.Embedded.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_embedded")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_embedded")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBody) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if o.Links != nil {
		if err := o.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBody) contextValidateBankAccount(ctx context.Context, formats strfmt.Registry) error {

	if o.BankAccount != nil {
		if err := o.BankAccount.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "bankAccount")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "bankAccount")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBody) contextValidateBillTo(ctx context.Context, formats strfmt.Registry) error {

	if o.BillTo != nil {
		if err := o.BillTo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "billTo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "billTo")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBody) contextValidateBuyerInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.BuyerInformation != nil {
		if err := o.BuyerInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "buyerInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "buyerInformation")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBody) contextValidateCard(ctx context.Context, formats strfmt.Registry) error {

	if o.Card != nil {
		if err := o.Card.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "card")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "card")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBody) contextValidateInstrumentIdentifier(ctx context.Context, formats strfmt.Registry) error {

	if o.InstrumentIdentifier != nil {
		if err := o.InstrumentIdentifier.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "instrumentIdentifier")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "instrumentIdentifier")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBody) contextValidateMerchantInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.MerchantInformation != nil {
		if err := o.MerchantInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "merchantInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "merchantInformation")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBody) contextValidateMetadata(ctx context.Context, formats strfmt.Registry) error {

	if o.Metadata != nil {
		if err := o.Metadata.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "metadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "metadata")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBody) contextValidateObject(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomersPaymentInstrumentOK"+"."+"object", "body", string(o.Object)); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBody) contextValidateProcessingInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ProcessingInformation != nil {
		if err := o.ProcessingInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "processingInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "processingInformation")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBody) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomersPaymentInstrumentOK"+"."+"state", "body", string(o.State)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentOKBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentOKBody) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentOKBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentOKBodyBankAccount patch customers payment instrument o k body bank account
swagger:model PatchCustomersPaymentInstrumentOKBodyBankAccount
*/
type PatchCustomersPaymentInstrumentOKBodyBankAccount struct {

	// Account type.
	//
	// Valid values:
	//  - checking : C
	//  - general ledger : G This value is supported only on Wells Fargo ACH
	//  - savings : S (U.S. dollars only)
	//  - corporate checking : X (U.S. dollars only)
	//
	// Max Length: 18
	Type string `json:"type,omitempty"`
}

// Validate validates this patch customers payment instrument o k body bank account
func (o *PatchCustomersPaymentInstrumentOKBodyBankAccount) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyBankAccount) validateType(formats strfmt.Registry) error {
	if swag.IsZero(o.Type) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomersPaymentInstrumentOK"+"."+"bankAccount"+"."+"type", "body", o.Type, 18); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this patch customers payment instrument o k body bank account based on context it is used
func (o *PatchCustomersPaymentInstrumentOKBodyBankAccount) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentOKBodyBankAccount) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentOKBodyBankAccount) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentOKBodyBankAccount
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentOKBodyBillTo patch customers payment instrument o k body bill to
swagger:model PatchCustomersPaymentInstrumentOKBodyBillTo
*/
type PatchCustomersPaymentInstrumentOKBodyBillTo struct {

	// Payment card billing street address as it appears on the credit card issuers records.
	//
	// Max Length: 60
	Address1 string `json:"address1,omitempty"`

	// Additional address information.
	//
	// Max Length: 60
	Address2 string `json:"address2,omitempty"`

	// State or province of the billing address. Use the State, Province, and Territory Codes for the United States
	// and Canada.
	//
	// Max Length: 20
	AdministrativeArea string `json:"administrativeArea,omitempty"`

	// Name of the customers company.
	//
	// Max Length: 60
	Company string `json:"company,omitempty"`

	// Payment card billing country. Use the two-character ISO Standard Country Codes.
	//
	// Max Length: 2
	Country string `json:"country,omitempty"`

	// Customer's email address, including the full domain name.
	//
	// Max Length: 255
	Email string `json:"email,omitempty"`

	// Customers first name. This name must be the same as the name on the card.
	//
	// Max Length: 60
	FirstName string `json:"firstName,omitempty"`

	// Customers last name. This name must be the same as the name on the card.
	//
	// Max Length: 60
	LastName string `json:"lastName,omitempty"`

	// Payment card billing city.
	//
	// Max Length: 50
	Locality string `json:"locality,omitempty"`

	// Customers phone number.
	//
	// Max Length: 15
	PhoneNumber string `json:"phoneNumber,omitempty"`

	// Postal code for the billing address. The postal code must consist of 5 to 9 digits.
	//
	// When the billing country is the U.S., the 9-digit postal code must follow this format:
	// [5 digits][dash][4 digits]
	//
	// **Example** `12345-6789`
	//
	// When the billing country is Canada, the 6-digit postal code must follow this format:
	// [alpha][numeric][alpha][space][numeric][alpha][numeric]
	//
	// **Example** `A1B 2C3`
	//
	// Max Length: 10
	PostalCode string `json:"postalCode,omitempty"`
}

// Validate validates this patch customers payment instrument o k body bill to
func (o *PatchCustomersPaymentInstrumentOKBodyBillTo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAddress1(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAddress2(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAdministrativeArea(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCompany(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEmail(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFirstName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLastName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocality(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePhoneNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyBillTo) validateAddress1(formats strfmt.Registry) error {
	if swag.IsZero(o.Address1) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomersPaymentInstrumentOK"+"."+"billTo"+"."+"address1", "body", o.Address1, 60); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyBillTo) validateAddress2(formats strfmt.Registry) error {
	if swag.IsZero(o.Address2) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomersPaymentInstrumentOK"+"."+"billTo"+"."+"address2", "body", o.Address2, 60); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyBillTo) validateAdministrativeArea(formats strfmt.Registry) error {
	if swag.IsZero(o.AdministrativeArea) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomersPaymentInstrumentOK"+"."+"billTo"+"."+"administrativeArea", "body", o.AdministrativeArea, 20); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyBillTo) validateCompany(formats strfmt.Registry) error {
	if swag.IsZero(o.Company) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomersPaymentInstrumentOK"+"."+"billTo"+"."+"company", "body", o.Company, 60); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyBillTo) validateCountry(formats strfmt.Registry) error {
	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomersPaymentInstrumentOK"+"."+"billTo"+"."+"country", "body", o.Country, 2); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyBillTo) validateEmail(formats strfmt.Registry) error {
	if swag.IsZero(o.Email) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomersPaymentInstrumentOK"+"."+"billTo"+"."+"email", "body", o.Email, 255); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyBillTo) validateFirstName(formats strfmt.Registry) error {
	if swag.IsZero(o.FirstName) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomersPaymentInstrumentOK"+"."+"billTo"+"."+"firstName", "body", o.FirstName, 60); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyBillTo) validateLastName(formats strfmt.Registry) error {
	if swag.IsZero(o.LastName) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomersPaymentInstrumentOK"+"."+"billTo"+"."+"lastName", "body", o.LastName, 60); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyBillTo) validateLocality(formats strfmt.Registry) error {
	if swag.IsZero(o.Locality) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomersPaymentInstrumentOK"+"."+"billTo"+"."+"locality", "body", o.Locality, 50); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyBillTo) validatePhoneNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.PhoneNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomersPaymentInstrumentOK"+"."+"billTo"+"."+"phoneNumber", "body", o.PhoneNumber, 15); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyBillTo) validatePostalCode(formats strfmt.Registry) error {
	if swag.IsZero(o.PostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomersPaymentInstrumentOK"+"."+"billTo"+"."+"postalCode", "body", o.PostalCode, 10); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this patch customers payment instrument o k body bill to based on context it is used
func (o *PatchCustomersPaymentInstrumentOKBodyBillTo) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentOKBodyBillTo) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentOKBodyBillTo) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentOKBodyBillTo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentOKBodyBuyerInformation patch customers payment instrument o k body buyer information
swagger:model PatchCustomersPaymentInstrumentOKBodyBuyerInformation
*/
type PatchCustomersPaymentInstrumentOKBodyBuyerInformation struct {

	// Companys tax identifier. This is only used for eCheck service.
	//
	// Max Length: 9
	CompanyTaxID string `json:"companyTaxID,omitempty"`

	// Currency used for the order. Use the three-character I[ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)
	//
	// For details about currency as used in partial authorizations, see "Features for Debit Cards and Prepaid Cards" in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// For an authorization reversal (`reversalInformation`) or a capture (`processingOptions.capture` is set to `true`), you must use the same currency that you used in your payment authorization request.
	//
	// #### DCC for First Data
	// Your local currency. For details, see the `currency` field description in [Dynamic Currency Conversion For First Data Using the SCMP API](http://apps.cybersource.com/library/documentation/dev_guides/DCC_FirstData_SCMP/DCC_FirstData_SCMP_API.pdf).
	//
	// Max Length: 3
	Currency string `json:"currency,omitempty"`

	// Date of birth of the customer. Format: YYYY-MM-DD
	//
	// Example: 1960-12-30
	// Format: date
	DateOfBirth strfmt.Date `json:"dateOfBirth,omitempty"`

	// personal identification
	PersonalIdentification []*PatchCustomersPaymentInstrumentOKBodyBuyerInformationPersonalIdentificationItems0 `json:"personalIdentification"`
}

// Validate validates this patch customers payment instrument o k body buyer information
func (o *PatchCustomersPaymentInstrumentOKBodyBuyerInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCompanyTaxID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCurrency(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDateOfBirth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePersonalIdentification(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyBuyerInformation) validateCompanyTaxID(formats strfmt.Registry) error {
	if swag.IsZero(o.CompanyTaxID) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomersPaymentInstrumentOK"+"."+"buyerInformation"+"."+"companyTaxID", "body", o.CompanyTaxID, 9); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyBuyerInformation) validateCurrency(formats strfmt.Registry) error {
	if swag.IsZero(o.Currency) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomersPaymentInstrumentOK"+"."+"buyerInformation"+"."+"currency", "body", o.Currency, 3); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyBuyerInformation) validateDateOfBirth(formats strfmt.Registry) error {
	if swag.IsZero(o.DateOfBirth) { // not required
		return nil
	}

	if err := validate.FormatOf("patchCustomersPaymentInstrumentOK"+"."+"buyerInformation"+"."+"dateOfBirth", "body", "date", o.DateOfBirth.String(), formats); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyBuyerInformation) validatePersonalIdentification(formats strfmt.Registry) error {
	if swag.IsZero(o.PersonalIdentification) { // not required
		return nil
	}

	for i := 0; i < len(o.PersonalIdentification); i++ {
		if swag.IsZero(o.PersonalIdentification[i]) { // not required
			continue
		}

		if o.PersonalIdentification[i] != nil {
			if err := o.PersonalIdentification[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "buyerInformation" + "." + "personalIdentification" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "buyerInformation" + "." + "personalIdentification" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this patch customers payment instrument o k body buyer information based on the context it is used
func (o *PatchCustomersPaymentInstrumentOKBodyBuyerInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidatePersonalIdentification(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyBuyerInformation) contextValidatePersonalIdentification(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.PersonalIdentification); i++ {

		if o.PersonalIdentification[i] != nil {
			if err := o.PersonalIdentification[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "buyerInformation" + "." + "personalIdentification" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "buyerInformation" + "." + "personalIdentification" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentOKBodyBuyerInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentOKBodyBuyerInformation) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentOKBodyBuyerInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentOKBodyBuyerInformationPersonalIdentificationItems0 patch customers payment instrument o k body buyer information personal identification items0
swagger:model PatchCustomersPaymentInstrumentOKBodyBuyerInformationPersonalIdentificationItems0
*/
type PatchCustomersPaymentInstrumentOKBodyBuyerInformationPersonalIdentificationItems0 struct {

	// The value of the identification type.
	//
	// Max Length: 26
	ID string `json:"id,omitempty"`

	// issued by
	IssuedBy *PatchCustomersPaymentInstrumentOKBodyBuyerInformationPersonalIdentificationItems0IssuedBy `json:"issuedBy,omitempty"`

	// The type of the identification.
	//
	// Valid values:
	//   - driver license
	//
	Type string `json:"type,omitempty"`
}

// Validate validates this patch customers payment instrument o k body buyer information personal identification items0
func (o *PatchCustomersPaymentInstrumentOKBodyBuyerInformationPersonalIdentificationItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateIssuedBy(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyBuyerInformationPersonalIdentificationItems0) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MaxLength("id", "body", o.ID, 26); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyBuyerInformationPersonalIdentificationItems0) validateIssuedBy(formats strfmt.Registry) error {
	if swag.IsZero(o.IssuedBy) { // not required
		return nil
	}

	if o.IssuedBy != nil {
		if err := o.IssuedBy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("issuedBy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("issuedBy")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch customers payment instrument o k body buyer information personal identification items0 based on the context it is used
func (o *PatchCustomersPaymentInstrumentOKBodyBuyerInformationPersonalIdentificationItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateIssuedBy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyBuyerInformationPersonalIdentificationItems0) contextValidateIssuedBy(ctx context.Context, formats strfmt.Registry) error {

	if o.IssuedBy != nil {
		if err := o.IssuedBy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("issuedBy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("issuedBy")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentOKBodyBuyerInformationPersonalIdentificationItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentOKBodyBuyerInformationPersonalIdentificationItems0) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentOKBodyBuyerInformationPersonalIdentificationItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentOKBodyBuyerInformationPersonalIdentificationItems0IssuedBy patch customers payment instrument o k body buyer information personal identification items0 issued by
swagger:model PatchCustomersPaymentInstrumentOKBodyBuyerInformationPersonalIdentificationItems0IssuedBy
*/
type PatchCustomersPaymentInstrumentOKBodyBuyerInformationPersonalIdentificationItems0IssuedBy struct {

	// The State or province where the customers drivers license was issued.
	//
	// Use the two-character State, Province, and Territory Codes for the United States and Canada.
	//
	// Max Length: 20
	AdministrativeArea string `json:"administrativeArea,omitempty"`
}

// Validate validates this patch customers payment instrument o k body buyer information personal identification items0 issued by
func (o *PatchCustomersPaymentInstrumentOKBodyBuyerInformationPersonalIdentificationItems0IssuedBy) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAdministrativeArea(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyBuyerInformationPersonalIdentificationItems0IssuedBy) validateAdministrativeArea(formats strfmt.Registry) error {
	if swag.IsZero(o.AdministrativeArea) { // not required
		return nil
	}

	if err := validate.MaxLength("issuedBy"+"."+"administrativeArea", "body", o.AdministrativeArea, 20); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this patch customers payment instrument o k body buyer information personal identification items0 issued by based on context it is used
func (o *PatchCustomersPaymentInstrumentOKBodyBuyerInformationPersonalIdentificationItems0IssuedBy) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentOKBodyBuyerInformationPersonalIdentificationItems0IssuedBy) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentOKBodyBuyerInformationPersonalIdentificationItems0IssuedBy) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentOKBodyBuyerInformationPersonalIdentificationItems0IssuedBy
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentOKBodyCard patch customers payment instrument o k body card
swagger:model PatchCustomersPaymentInstrumentOKBodyCard
*/
type PatchCustomersPaymentInstrumentOKBodyCard struct {

	// Two-digit month in which the payment card expires.
	//
	// Format: `MM`.
	//
	// Valid values: `01` through `12`.
	//
	// Max Length: 2
	ExpirationMonth string `json:"expirationMonth,omitempty"`

	// Four-digit year in which the credit card expires.
	//
	// Format: `YYYY`.
	//
	// Max Length: 4
	ExpirationYear string `json:"expirationYear,omitempty"`

	// Number of times a Maestro (UK Domestic) card has been issued to the account holder. The card might or might not have an issue number. The number can consist of one or two digits, and the first digit might be a zero. When you include this value in your request, include exactly what is printed on the card. A value of 2 is different than a value of 02. Do not include the field, even with a blank value, if the card is not a Maestro (UK Domestic) card.
	//
	// **Note** The issue number is not required for Maestro (UK Domestic) transactions.
	//
	// Max Length: 2
	IssueNumber string `json:"issueNumber,omitempty"`

	// Month of the start of the Maestro (UK Domestic) card validity period. Do not include the field, even with a blank value, if the card is not a Maestro (UK Domestic) card. `Format: MM`.
	// Valid values: 01 through 12.
	//
	// **Note** The start date is not required for Maestro (UK Domestic) transactions.
	//
	// Max Length: 2
	StartMonth string `json:"startMonth,omitempty"`

	// Year of the start of the Maestro (UK Domestic) card validity period. Do not include the field, even with a blank value, if the card is not a Maestro (UK Domestic) card. `Format: YYYY`.
	//
	// **Note** The start date is not required for Maestro (UK Domestic) transactions.
	//
	// Max Length: 4
	StartYear string `json:"startYear,omitempty"`

	// tokenized information
	TokenizedInformation *PatchCustomersPaymentInstrumentOKBodyCardTokenizedInformation `json:"tokenizedInformation,omitempty"`

	// Value that indicates the card type. Valid v2 : v1 - description values:
	//   * 001 : visa
	//   * 002 : mastercard - EurocardEuropean regional brand of Mastercard
	//   * 003 : american express
	//   * 004 : discover
	//   * 005 : diners club
	//   * 006 : carte blanche
	//   * 007 : jcb
	//   * 008 : optima
	//   * 011 : twinpay credit
	//   * 012 : twinpay debit
	//   * 013 : walmart
	//   * 014 : enRoute
	//   * 015 : lowes consumer
	//   * 016 : home depot consumer
	//   * 017 : mbna
	//   * 018 : dicks sportswear
	//   * 019 : casual corner
	//   * 020 : sears
	//   * 021 : jal
	//   * 023 : disney
	//   * 024 : maestro uk domestic
	//   * 025 : sams club consumer
	//   * 026 : sams club business
	//   * 028 : bill me later
	//   * 029 : bebe
	//   * 030 : restoration hardware
	//   * 031 : delta online  use this value only for Ingenico ePayments. For other processors, use 001 for all Visa card types.
	//   * 032 : solo
	//   * 033 : visa electron
	//   * 034 : dankort
	//   * 035 : laser
	//   * 036 : carte bleue  formerly Cartes Bancaires
	//   * 037 : carta si
	//   * 038 : pinless debit
	//   * 039 : encoded account
	//   * 040 : uatp
	//   * 041 : household
	//   * 042 : maestro international
	//   * 043 : ge money uk
	//   * 044 : korean cards
	//   * 045 : style
	//   * 046 : jcrew
	//   * 047 : payease china processing ewallet
	//   * 048 : payease china processing bank transfer
	//   * 049 : meijer private label
	//   * 050 : hipercard  supported only by the Comercio Latino processor.
	//   * 051 : aura  supported only by the Comercio Latino processor.
	//   * 052 : redecard
	//   * 054 : elo  supported only by the Comercio Latino processor.
	//   * 055 : capital one private label
	//   * 056 : synchrony private label
	//   * 057 : costco private label
	//   * 060 : mada
	//   * 062 : china union pay
	//   * 063 : falabella private label
	//
	Type string `json:"type,omitempty"`

	// 'Payment Instrument was created / updated as part of a pinless debit transaction.'
	//
	// Example: pinless debit
	UseAs string `json:"useAs,omitempty"`
}

// Validate validates this patch customers payment instrument o k body card
func (o *PatchCustomersPaymentInstrumentOKBodyCard) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateExpirationMonth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpirationYear(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateIssueNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateStartMonth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateStartYear(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTokenizedInformation(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyCard) validateExpirationMonth(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationMonth) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomersPaymentInstrumentOK"+"."+"card"+"."+"expirationMonth", "body", o.ExpirationMonth, 2); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyCard) validateExpirationYear(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationYear) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomersPaymentInstrumentOK"+"."+"card"+"."+"expirationYear", "body", o.ExpirationYear, 4); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyCard) validateIssueNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.IssueNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomersPaymentInstrumentOK"+"."+"card"+"."+"issueNumber", "body", o.IssueNumber, 2); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyCard) validateStartMonth(formats strfmt.Registry) error {
	if swag.IsZero(o.StartMonth) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomersPaymentInstrumentOK"+"."+"card"+"."+"startMonth", "body", o.StartMonth, 2); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyCard) validateStartYear(formats strfmt.Registry) error {
	if swag.IsZero(o.StartYear) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomersPaymentInstrumentOK"+"."+"card"+"."+"startYear", "body", o.StartYear, 4); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyCard) validateTokenizedInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.TokenizedInformation) { // not required
		return nil
	}

	if o.TokenizedInformation != nil {
		if err := o.TokenizedInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "card" + "." + "tokenizedInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "card" + "." + "tokenizedInformation")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch customers payment instrument o k body card based on the context it is used
func (o *PatchCustomersPaymentInstrumentOKBodyCard) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateTokenizedInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyCard) contextValidateTokenizedInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.TokenizedInformation != nil {
		if err := o.TokenizedInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "card" + "." + "tokenizedInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "card" + "." + "tokenizedInformation")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentOKBodyCard) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentOKBodyCard) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentOKBodyCard
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentOKBodyCardTokenizedInformation patch customers payment instrument o k body card tokenized information
swagger:model PatchCustomersPaymentInstrumentOKBodyCardTokenizedInformation
*/
type PatchCustomersPaymentInstrumentOKBodyCardTokenizedInformation struct {

	// Value that identifies your business and indicates that the cardholders account number is tokenized. This value
	// is assigned by the token service provider and is unique within the token service providers database.
	//
	// **Note** This field is supported only for **CyberSource through VisaNet** and **FDC Nashville Global**.
	//
	// Max Length: 11
	RequestorID string `json:"requestorID,omitempty"`

	// Type of transaction that provided the token data. This value does not specify the token service provider; it
	// specifies the entity that provided you with information about the token.
	//
	// Set the value for this field to 1. An application on the customers mobile device provided the token data.
	//
	// Max Length: 1
	TransactionType string `json:"transactionType,omitempty"`
}

// Validate validates this patch customers payment instrument o k body card tokenized information
func (o *PatchCustomersPaymentInstrumentOKBodyCardTokenizedInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateRequestorID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTransactionType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyCardTokenizedInformation) validateRequestorID(formats strfmt.Registry) error {
	if swag.IsZero(o.RequestorID) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomersPaymentInstrumentOK"+"."+"card"+"."+"tokenizedInformation"+"."+"requestorID", "body", o.RequestorID, 11); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyCardTokenizedInformation) validateTransactionType(formats strfmt.Registry) error {
	if swag.IsZero(o.TransactionType) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomersPaymentInstrumentOK"+"."+"card"+"."+"tokenizedInformation"+"."+"transactionType", "body", o.TransactionType, 1); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this patch customers payment instrument o k body card tokenized information based on context it is used
func (o *PatchCustomersPaymentInstrumentOKBodyCardTokenizedInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentOKBodyCardTokenizedInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentOKBodyCardTokenizedInformation) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentOKBodyCardTokenizedInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentOKBodyEmbedded Additional resources for the Payment Instrument token.
//
swagger:model PatchCustomersPaymentInstrumentOKBodyEmbedded
*/
type PatchCustomersPaymentInstrumentOKBodyEmbedded struct {

	// instrument identifier
	InstrumentIdentifier *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifier `json:"instrumentIdentifier,omitempty"`
}

// Validate validates this patch customers payment instrument o k body embedded
func (o *PatchCustomersPaymentInstrumentOKBodyEmbedded) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateInstrumentIdentifier(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyEmbedded) validateInstrumentIdentifier(formats strfmt.Registry) error {
	if swag.IsZero(o.InstrumentIdentifier) { // not required
		return nil
	}

	if o.InstrumentIdentifier != nil {
		if err := o.InstrumentIdentifier.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_embedded" + "." + "instrumentIdentifier")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_embedded" + "." + "instrumentIdentifier")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch customers payment instrument o k body embedded based on the context it is used
func (o *PatchCustomersPaymentInstrumentOKBodyEmbedded) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateInstrumentIdentifier(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyEmbedded) contextValidateInstrumentIdentifier(ctx context.Context, formats strfmt.Registry) error {

	if o.InstrumentIdentifier != nil {
		if err := o.InstrumentIdentifier.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_embedded" + "." + "instrumentIdentifier")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_embedded" + "." + "instrumentIdentifier")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentOKBodyEmbedded) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentOKBodyEmbedded) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentOKBodyEmbedded
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifier patch customers payment instrument o k body embedded instrument identifier
swagger:model PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifier
*/
type PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifier struct {

	// links
	Links *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierLinks `json:"_links,omitempty"`

	// bank account
	BankAccount *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierBankAccount `json:"bankAccount,omitempty"`

	// bill to
	BillTo *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierBillTo `json:"billTo,omitempty"`

	// card
	Card *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierCard `json:"card,omitempty"`

	// The id of the Instrument Identifier Token.
	//
	ID string `json:"id,omitempty"`

	// issuer
	Issuer *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierIssuer `json:"issuer,omitempty"`

	// metadata
	Metadata *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierMetadata `json:"metadata,omitempty"`

	// The type of token.
	//
	// Valid values:
	// - instrumentIdentifier
	//
	// Example: instrumentIdentifier
	// Read Only: true
	Object string `json:"object,omitempty"`

	// processing information
	ProcessingInformation *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierProcessingInformation `json:"processingInformation,omitempty"`

	// Issuers state for the card number.
	// Valid values:
	// - ACTIVE
	// - CLOSED : The account has been closed.
	//
	// Example: ACTIVE
	// Read Only: true
	State string `json:"state,omitempty"`

	// tokenized card
	TokenizedCard *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierTokenizedCard `json:"tokenizedCard,omitempty"`

	// The type of Instrument Identifier.
	// Valid values:
	// - enrollable card
	//
	Type string `json:"type,omitempty"`
}

// Validate validates this patch customers payment instrument o k body embedded instrument identifier
func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifier) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBankAccount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBillTo(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCard(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateIssuer(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMetadata(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProcessingInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTokenizedCard(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifier) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(o.Links) { // not required
		return nil
	}

	if o.Links != nil {
		if err := o.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifier) validateBankAccount(formats strfmt.Registry) error {
	if swag.IsZero(o.BankAccount) { // not required
		return nil
	}

	if o.BankAccount != nil {
		if err := o.BankAccount.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "bankAccount")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "bankAccount")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifier) validateBillTo(formats strfmt.Registry) error {
	if swag.IsZero(o.BillTo) { // not required
		return nil
	}

	if o.BillTo != nil {
		if err := o.BillTo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "billTo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "billTo")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifier) validateCard(formats strfmt.Registry) error {
	if swag.IsZero(o.Card) { // not required
		return nil
	}

	if o.Card != nil {
		if err := o.Card.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "card")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "card")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifier) validateIssuer(formats strfmt.Registry) error {
	if swag.IsZero(o.Issuer) { // not required
		return nil
	}

	if o.Issuer != nil {
		if err := o.Issuer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "issuer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "issuer")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifier) validateMetadata(formats strfmt.Registry) error {
	if swag.IsZero(o.Metadata) { // not required
		return nil
	}

	if o.Metadata != nil {
		if err := o.Metadata.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "metadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "metadata")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifier) validateProcessingInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ProcessingInformation) { // not required
		return nil
	}

	if o.ProcessingInformation != nil {
		if err := o.ProcessingInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifier) validateTokenizedCard(formats strfmt.Registry) error {
	if swag.IsZero(o.TokenizedCard) { // not required
		return nil
	}

	if o.TokenizedCard != nil {
		if err := o.TokenizedCard.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "tokenizedCard")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "tokenizedCard")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch customers payment instrument o k body embedded instrument identifier based on the context it is used
func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifier) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateBankAccount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateBillTo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateCard(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateIssuer(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateMetadata(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateObject(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateProcessingInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateTokenizedCard(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifier) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if o.Links != nil {
		if err := o.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifier) contextValidateBankAccount(ctx context.Context, formats strfmt.Registry) error {

	if o.BankAccount != nil {
		if err := o.BankAccount.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "bankAccount")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "bankAccount")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifier) contextValidateBillTo(ctx context.Context, formats strfmt.Registry) error {

	if o.BillTo != nil {
		if err := o.BillTo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "billTo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "billTo")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifier) contextValidateCard(ctx context.Context, formats strfmt.Registry) error {

	if o.Card != nil {
		if err := o.Card.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "card")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "card")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifier) contextValidateIssuer(ctx context.Context, formats strfmt.Registry) error {

	if o.Issuer != nil {
		if err := o.Issuer.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "issuer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "issuer")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifier) contextValidateMetadata(ctx context.Context, formats strfmt.Registry) error {

	if o.Metadata != nil {
		if err := o.Metadata.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "metadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "metadata")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifier) contextValidateObject(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomersPaymentInstrumentOK"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"object", "body", string(o.Object)); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifier) contextValidateProcessingInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ProcessingInformation != nil {
		if err := o.ProcessingInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifier) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomersPaymentInstrumentOK"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"state", "body", string(o.State)); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifier) contextValidateTokenizedCard(ctx context.Context, formats strfmt.Registry) error {

	if o.TokenizedCard != nil {
		if err := o.TokenizedCard.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "tokenizedCard")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "tokenizedCard")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifier) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifier) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifier
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierBankAccount patch customers payment instrument o k body embedded instrument identifier bank account
swagger:model PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierBankAccount
*/
type PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierBankAccount struct {

	// Account number.
	//
	// When processing encoded account numbers, use this field for the encoded account number.
	//
	// Max Length: 17
	Number string `json:"number,omitempty"`

	// Bank routing number. This is also called the transit number.
	//
	// For details, see `ecp_rdfi` field description in the [Electronic Check Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/EChecks_SCMP_API/html/)
	//
	RoutingNumber string `json:"routingNumber,omitempty"`
}

// Validate validates this patch customers payment instrument o k body embedded instrument identifier bank account
func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierBankAccount) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateNumber(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierBankAccount) validateNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.Number) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomersPaymentInstrumentOK"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"bankAccount"+"."+"number", "body", o.Number, 17); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this patch customers payment instrument o k body embedded instrument identifier bank account based on context it is used
func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierBankAccount) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierBankAccount) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierBankAccount) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierBankAccount
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierBillTo This information is sent to the issuer as part of network token enrollment and is not stored under the Instrument Identifier token.
//
swagger:model PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierBillTo
*/
type PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierBillTo struct {

	// Payment card billing street address as it appears on the credit card issuers records.
	//
	// Max Length: 60
	Address1 string `json:"address1,omitempty"`

	// Additional address information.
	//
	// Max Length: 60
	Address2 string `json:"address2,omitempty"`

	// State or province of the billing address. Use the State, Province, and Territory Codes for the United States
	// and Canada.
	//
	// Max Length: 20
	AdministrativeArea string `json:"administrativeArea,omitempty"`

	// Payment card billing country. Use the two-character ISO Standard Country Codes.
	//
	// Max Length: 2
	Country string `json:"country,omitempty"`

	// Payment card billing city.
	//
	// Max Length: 50
	Locality string `json:"locality,omitempty"`

	// Postal code for the billing address. The postal code must consist of 5 to 9 digits.
	//
	// When the billing country is the U.S., the 9-digit postal code must follow this format:
	// [5 digits][dash][4 digits]
	//
	// **Example** `12345-6789`
	//
	// When the billing country is Canada, the 6-digit postal code must follow this format:
	// [alpha][numeric][alpha][space][numeric][alpha][numeric]
	//
	// **Example** `A1B 2C3`
	//
	// Max Length: 10
	PostalCode string `json:"postalCode,omitempty"`
}

// Validate validates this patch customers payment instrument o k body embedded instrument identifier bill to
func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierBillTo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAddress1(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAddress2(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAdministrativeArea(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocality(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierBillTo) validateAddress1(formats strfmt.Registry) error {
	if swag.IsZero(o.Address1) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomersPaymentInstrumentOK"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"billTo"+"."+"address1", "body", o.Address1, 60); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierBillTo) validateAddress2(formats strfmt.Registry) error {
	if swag.IsZero(o.Address2) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomersPaymentInstrumentOK"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"billTo"+"."+"address2", "body", o.Address2, 60); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierBillTo) validateAdministrativeArea(formats strfmt.Registry) error {
	if swag.IsZero(o.AdministrativeArea) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomersPaymentInstrumentOK"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"billTo"+"."+"administrativeArea", "body", o.AdministrativeArea, 20); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierBillTo) validateCountry(formats strfmt.Registry) error {
	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomersPaymentInstrumentOK"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"billTo"+"."+"country", "body", o.Country, 2); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierBillTo) validateLocality(formats strfmt.Registry) error {
	if swag.IsZero(o.Locality) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomersPaymentInstrumentOK"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"billTo"+"."+"locality", "body", o.Locality, 50); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierBillTo) validatePostalCode(formats strfmt.Registry) error {
	if swag.IsZero(o.PostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomersPaymentInstrumentOK"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"billTo"+"."+"postalCode", "body", o.PostalCode, 10); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this patch customers payment instrument o k body embedded instrument identifier bill to based on context it is used
func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierBillTo) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierBillTo) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierBillTo) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierBillTo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierCard The expirationMonth, expirationYear and securityCode is sent to the issuer as part of network token enrollment and is not stored under the Instrument Identifier token.
//
swagger:model PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierCard
*/
type PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierCard struct {

	// Two-digit month in which the payment card expires.
	//
	// Format: `MM`.
	//
	// Valid values: `01` through `12`.
	//
	// Max Length: 2
	ExpirationMonth string `json:"expirationMonth,omitempty"`

	// Four-digit year in which the credit card expires.
	//
	// Format: `YYYY`.
	//
	// Max Length: 4
	ExpirationYear string `json:"expirationYear,omitempty"`

	// The customers payment card number, also known as the Primary Account Number (PAN). You can also use this field
	// for encoded account numbers.
	//
	// Max Length: 19
	// Min Length: 12
	Number string `json:"number,omitempty"`

	// Card Verification Number.
	//
	// Max Length: 4
	SecurityCode string `json:"securityCode,omitempty"`
}

// Validate validates this patch customers payment instrument o k body embedded instrument identifier card
func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierCard) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateExpirationMonth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpirationYear(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSecurityCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierCard) validateExpirationMonth(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationMonth) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomersPaymentInstrumentOK"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"card"+"."+"expirationMonth", "body", o.ExpirationMonth, 2); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierCard) validateExpirationYear(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationYear) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomersPaymentInstrumentOK"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"card"+"."+"expirationYear", "body", o.ExpirationYear, 4); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierCard) validateNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.Number) { // not required
		return nil
	}

	if err := validate.MinLength("patchCustomersPaymentInstrumentOK"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"card"+"."+"number", "body", o.Number, 12); err != nil {
		return err
	}

	if err := validate.MaxLength("patchCustomersPaymentInstrumentOK"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"card"+"."+"number", "body", o.Number, 19); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierCard) validateSecurityCode(formats strfmt.Registry) error {
	if swag.IsZero(o.SecurityCode) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomersPaymentInstrumentOK"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"card"+"."+"securityCode", "body", o.SecurityCode, 4); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this patch customers payment instrument o k body embedded instrument identifier card based on context it is used
func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierCard) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierCard) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierCard) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierCard
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierIssuer patch customers payment instrument o k body embedded instrument identifier issuer
swagger:model PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierIssuer
*/
type PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierIssuer struct {

	// This reference number serves as a link to the cardholder account and to all transactions for that account.
	//
	// Read Only: true
	// Max Length: 32
	PaymentAccountReference string `json:"paymentAccountReference,omitempty"`
}

// Validate validates this patch customers payment instrument o k body embedded instrument identifier issuer
func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierIssuer) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validatePaymentAccountReference(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierIssuer) validatePaymentAccountReference(formats strfmt.Registry) error {
	if swag.IsZero(o.PaymentAccountReference) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomersPaymentInstrumentOK"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"issuer"+"."+"paymentAccountReference", "body", o.PaymentAccountReference, 32); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this patch customers payment instrument o k body embedded instrument identifier issuer based on the context it is used
func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierIssuer) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidatePaymentAccountReference(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierIssuer) contextValidatePaymentAccountReference(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomersPaymentInstrumentOK"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"issuer"+"."+"paymentAccountReference", "body", string(o.PaymentAccountReference)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierIssuer) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierIssuer) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierIssuer
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierLinks patch customers payment instrument o k body embedded instrument identifier links
swagger:model PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierLinks
*/
type PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierLinks struct {

	// payment instruments
	PaymentInstruments *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierLinksPaymentInstruments `json:"paymentInstruments,omitempty"`

	// self
	Self *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierLinksSelf `json:"self,omitempty"`
}

// Validate validates this patch customers payment instrument o k body embedded instrument identifier links
func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validatePaymentInstruments(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierLinks) validatePaymentInstruments(formats strfmt.Registry) error {
	if swag.IsZero(o.PaymentInstruments) { // not required
		return nil
	}

	if o.PaymentInstruments != nil {
		if err := o.PaymentInstruments.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "_links" + "." + "paymentInstruments")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "_links" + "." + "paymentInstruments")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(o.Self) { // not required
		return nil
	}

	if o.Self != nil {
		if err := o.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "_links" + "." + "self")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch customers payment instrument o k body embedded instrument identifier links based on the context it is used
func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidatePaymentInstruments(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierLinks) contextValidatePaymentInstruments(ctx context.Context, formats strfmt.Registry) error {

	if o.PaymentInstruments != nil {
		if err := o.PaymentInstruments.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "_links" + "." + "paymentInstruments")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "_links" + "." + "paymentInstruments")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if o.Self != nil {
		if err := o.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "_links" + "." + "self")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierLinks) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierLinks) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierLinksPaymentInstruments patch customers payment instrument o k body embedded instrument identifier links payment instruments
swagger:model PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierLinksPaymentInstruments
*/
type PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierLinksPaymentInstruments struct {

	// Link to the Instrument Identifiers Payment Instruments.
	//
	// Example: tms/v1/instrumentidentifiers/9B8D20D13FF328CCE0539399D30A70N4/paymentinstruments
	// Read Only: true
	Href string `json:"href,omitempty"`
}

// Validate validates this patch customers payment instrument o k body embedded instrument identifier links payment instruments
func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierLinksPaymentInstruments) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this patch customers payment instrument o k body embedded instrument identifier links payment instruments based on the context it is used
func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierLinksPaymentInstruments) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateHref(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierLinksPaymentInstruments) contextValidateHref(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomersPaymentInstrumentOK"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"_links"+"."+"paymentInstruments"+"."+"href", "body", string(o.Href)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierLinksPaymentInstruments) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierLinksPaymentInstruments) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierLinksPaymentInstruments
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierLinksSelf patch customers payment instrument o k body embedded instrument identifier links self
swagger:model PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierLinksSelf
*/
type PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierLinksSelf struct {

	// Link to the Instrument Identifier.
	//
	// Example: tms/v1/instrumentidentifiers/9B8D20D13FF328CCE0539399D30A70N4
	// Read Only: true
	Href string `json:"href,omitempty"`
}

// Validate validates this patch customers payment instrument o k body embedded instrument identifier links self
func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierLinksSelf) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this patch customers payment instrument o k body embedded instrument identifier links self based on the context it is used
func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierLinksSelf) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateHref(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierLinksSelf) contextValidateHref(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomersPaymentInstrumentOK"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"_links"+"."+"self"+"."+"href", "body", string(o.Href)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierLinksSelf) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierLinksSelf) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierLinksSelf
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierMetadata patch customers payment instrument o k body embedded instrument identifier metadata
swagger:model PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierMetadata
*/
type PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierMetadata struct {

	// The creator of the Instrument Identifier token.
	// Read Only: true
	Creator string `json:"creator,omitempty"`
}

// Validate validates this patch customers payment instrument o k body embedded instrument identifier metadata
func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierMetadata) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this patch customers payment instrument o k body embedded instrument identifier metadata based on the context it is used
func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierMetadata) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateCreator(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierMetadata) contextValidateCreator(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomersPaymentInstrumentOK"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"metadata"+"."+"creator", "body", string(o.Creator)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierMetadata) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierMetadata) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierMetadata
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierProcessingInformation patch customers payment instrument o k body embedded instrument identifier processing information
swagger:model PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierProcessingInformation
*/
type PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierProcessingInformation struct {

	// authorization options
	AuthorizationOptions *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions `json:"authorizationOptions,omitempty"`
}

// Validate validates this patch customers payment instrument o k body embedded instrument identifier processing information
func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierProcessingInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAuthorizationOptions(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierProcessingInformation) validateAuthorizationOptions(formats strfmt.Registry) error {
	if swag.IsZero(o.AuthorizationOptions) { // not required
		return nil
	}

	if o.AuthorizationOptions != nil {
		if err := o.AuthorizationOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch customers payment instrument o k body embedded instrument identifier processing information based on the context it is used
func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierProcessingInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateAuthorizationOptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierProcessingInformation) contextValidateAuthorizationOptions(ctx context.Context, formats strfmt.Registry) error {

	if o.AuthorizationOptions != nil {
		if err := o.AuthorizationOptions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierProcessingInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierProcessingInformation) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierProcessingInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions patch customers payment instrument o k body embedded instrument identifier processing information authorization options
swagger:model PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions
*/
type PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions struct {

	// initiator
	Initiator *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator `json:"initiator,omitempty"`
}

// Validate validates this patch customers payment instrument o k body embedded instrument identifier processing information authorization options
func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateInitiator(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions) validateInitiator(formats strfmt.Registry) error {
	if swag.IsZero(o.Initiator) { // not required
		return nil
	}

	if o.Initiator != nil {
		if err := o.Initiator.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch customers payment instrument o k body embedded instrument identifier processing information authorization options based on the context it is used
func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateInitiator(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions) contextValidateInitiator(ctx context.Context, formats strfmt.Registry) error {

	if o.Initiator != nil {
		if err := o.Initiator.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator patch customers payment instrument o k body embedded instrument identifier processing information authorization options initiator
swagger:model PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator
*/
type PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator struct {

	// merchant initiated transaction
	MerchantInitiatedTransaction *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction `json:"merchantInitiatedTransaction,omitempty"`
}

// Validate validates this patch customers payment instrument o k body embedded instrument identifier processing information authorization options initiator
func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateMerchantInitiatedTransaction(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator) validateMerchantInitiatedTransaction(formats strfmt.Registry) error {
	if swag.IsZero(o.MerchantInitiatedTransaction) { // not required
		return nil
	}

	if o.MerchantInitiatedTransaction != nil {
		if err := o.MerchantInitiatedTransaction.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator" + "." + "merchantInitiatedTransaction")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator" + "." + "merchantInitiatedTransaction")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch customers payment instrument o k body embedded instrument identifier processing information authorization options initiator based on the context it is used
func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateMerchantInitiatedTransaction(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator) contextValidateMerchantInitiatedTransaction(ctx context.Context, formats strfmt.Registry) error {

	if o.MerchantInitiatedTransaction != nil {
		if err := o.MerchantInitiatedTransaction.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator" + "." + "merchantInitiatedTransaction")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator" + "." + "merchantInitiatedTransaction")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction patch customers payment instrument o k body embedded instrument identifier processing information authorization options initiator merchant initiated transaction
swagger:model PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction
*/
type PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction struct {

	// Network transaction identifier that was returned in the payment response field _processorInformation.transactionID_
	// in the reply message for either the original merchant-initiated payment in the series or the previous
	// merchant-initiated payment in the series.
	//
	// Max Length: 15
	PreviousTransactionID string `json:"previousTransactionId,omitempty"`
}

// Validate validates this patch customers payment instrument o k body embedded instrument identifier processing information authorization options initiator merchant initiated transaction
func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validatePreviousTransactionID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction) validatePreviousTransactionID(formats strfmt.Registry) error {
	if swag.IsZero(o.PreviousTransactionID) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomersPaymentInstrumentOK"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"processingInformation"+"."+"authorizationOptions"+"."+"initiator"+"."+"merchantInitiatedTransaction"+"."+"previousTransactionId", "body", o.PreviousTransactionID, 15); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this patch customers payment instrument o k body embedded instrument identifier processing information authorization options initiator merchant initiated transaction based on context it is used
func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierTokenizedCard patch customers payment instrument o k body embedded instrument identifier tokenized card
swagger:model PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierTokenizedCard
*/
type PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierTokenizedCard struct {

	// card
	Card *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierTokenizedCardCard `json:"card,omitempty"`

	// Generated value used in conjunction with the network token for making a payment.
	//
	// Example: CgAFRFYFPTFOfg5rj2ais9wQAAAAAM=
	// Read Only: true
	Cryptogram string `json:"cryptogram,omitempty"`

	// Two-digit month in which the network token expires.
	//
	// Format: `MM`.
	//
	// Valid values: `01` through `12`.
	//
	// Read Only: true
	// Max Length: 2
	ExpirationMonth string `json:"expirationMonth,omitempty"`

	// Four-digit year in which the network token expires.
	//
	// Format: `YYYY`.
	//
	// Read Only: true
	// Max Length: 4
	ExpirationYear string `json:"expirationYear,omitempty"`

	// The token requestors customers payment network token
	//
	// Read Only: true
	Number string `json:"number,omitempty"`

	// Issuers state for the network token
	// Valid values:
	// - ACTIVE
	// - SUSPENDED : This state can change to ACTIVE or DELETED.
	// - DELETED : This is a final state for the network token.
	//
	// Example: ACTIVE
	// Read Only: true
	State string `json:"state,omitempty"`

	// The network token card association brand
	// Valid values:
	// - visa
	// - mastercard
	//
	// Example: visa
	// Read Only: true
	Type string `json:"type,omitempty"`
}

// Validate validates this patch customers payment instrument o k body embedded instrument identifier tokenized card
func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierTokenizedCard) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCard(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpirationMonth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpirationYear(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierTokenizedCard) validateCard(formats strfmt.Registry) error {
	if swag.IsZero(o.Card) { // not required
		return nil
	}

	if o.Card != nil {
		if err := o.Card.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "tokenizedCard" + "." + "card")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "tokenizedCard" + "." + "card")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierTokenizedCard) validateExpirationMonth(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationMonth) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomersPaymentInstrumentOK"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"expirationMonth", "body", o.ExpirationMonth, 2); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierTokenizedCard) validateExpirationYear(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationYear) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomersPaymentInstrumentOK"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"expirationYear", "body", o.ExpirationYear, 4); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this patch customers payment instrument o k body embedded instrument identifier tokenized card based on the context it is used
func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierTokenizedCard) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateCard(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateCryptogram(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateExpirationMonth(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateExpirationYear(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateNumber(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierTokenizedCard) contextValidateCard(ctx context.Context, formats strfmt.Registry) error {

	if o.Card != nil {
		if err := o.Card.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "tokenizedCard" + "." + "card")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "tokenizedCard" + "." + "card")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierTokenizedCard) contextValidateCryptogram(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomersPaymentInstrumentOK"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"cryptogram", "body", string(o.Cryptogram)); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierTokenizedCard) contextValidateExpirationMonth(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomersPaymentInstrumentOK"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"expirationMonth", "body", string(o.ExpirationMonth)); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierTokenizedCard) contextValidateExpirationYear(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomersPaymentInstrumentOK"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"expirationYear", "body", string(o.ExpirationYear)); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierTokenizedCard) contextValidateNumber(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomersPaymentInstrumentOK"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"number", "body", string(o.Number)); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierTokenizedCard) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomersPaymentInstrumentOK"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"state", "body", string(o.State)); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierTokenizedCard) contextValidateType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomersPaymentInstrumentOK"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"type", "body", string(o.Type)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierTokenizedCard) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierTokenizedCard) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierTokenizedCard
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierTokenizedCardCard The latest card details associated with the network token
swagger:model PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierTokenizedCardCard
*/
type PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierTokenizedCardCard struct {

	//
	// Two-digit month in which the customers latest payment card expires.
	//
	// Format: `MM`.
	//
	// Valid values: `01` through `12`.
	//
	// Read Only: true
	// Max Length: 2
	ExpirationMonth string `json:"expirationMonth,omitempty"`

	// Four-digit year in which the customers latest payment card expires.
	//
	// Format: `YYYY`.
	//
	// Read Only: true
	// Max Length: 4
	ExpirationYear string `json:"expirationYear,omitempty"`

	// The customers latest payment card number suffix
	//
	// Example: 1111
	// Read Only: true
	Suffix string `json:"suffix,omitempty"`
}

// Validate validates this patch customers payment instrument o k body embedded instrument identifier tokenized card card
func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierTokenizedCardCard) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateExpirationMonth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpirationYear(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierTokenizedCardCard) validateExpirationMonth(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationMonth) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomersPaymentInstrumentOK"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"card"+"."+"expirationMonth", "body", o.ExpirationMonth, 2); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierTokenizedCardCard) validateExpirationYear(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationYear) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomersPaymentInstrumentOK"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"card"+"."+"expirationYear", "body", o.ExpirationYear, 4); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this patch customers payment instrument o k body embedded instrument identifier tokenized card card based on the context it is used
func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierTokenizedCardCard) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateExpirationMonth(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateExpirationYear(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateSuffix(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierTokenizedCardCard) contextValidateExpirationMonth(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomersPaymentInstrumentOK"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"card"+"."+"expirationMonth", "body", string(o.ExpirationMonth)); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierTokenizedCardCard) contextValidateExpirationYear(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomersPaymentInstrumentOK"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"card"+"."+"expirationYear", "body", string(o.ExpirationYear)); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierTokenizedCardCard) contextValidateSuffix(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomersPaymentInstrumentOK"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"card"+"."+"suffix", "body", string(o.Suffix)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierTokenizedCardCard) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierTokenizedCardCard) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentOKBodyEmbeddedInstrumentIdentifierTokenizedCardCard
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentOKBodyInstrumentIdentifier patch customers payment instrument o k body instrument identifier
swagger:model PatchCustomersPaymentInstrumentOKBodyInstrumentIdentifier
*/
type PatchCustomersPaymentInstrumentOKBodyInstrumentIdentifier struct {

	// The id of the Instrument Identifier token linked to the Payment Instrument.
	//
	// Max Length: 32
	// Min Length: 12
	ID string `json:"id,omitempty"`
}

// Validate validates this patch customers payment instrument o k body instrument identifier
func (o *PatchCustomersPaymentInstrumentOKBodyInstrumentIdentifier) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyInstrumentIdentifier) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MinLength("patchCustomersPaymentInstrumentOK"+"."+"instrumentIdentifier"+"."+"id", "body", o.ID, 12); err != nil {
		return err
	}

	if err := validate.MaxLength("patchCustomersPaymentInstrumentOK"+"."+"instrumentIdentifier"+"."+"id", "body", o.ID, 32); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this patch customers payment instrument o k body instrument identifier based on context it is used
func (o *PatchCustomersPaymentInstrumentOKBodyInstrumentIdentifier) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentOKBodyInstrumentIdentifier) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentOKBodyInstrumentIdentifier) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentOKBodyInstrumentIdentifier
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentOKBodyLinks patch customers payment instrument o k body links
swagger:model PatchCustomersPaymentInstrumentOKBodyLinks
*/
type PatchCustomersPaymentInstrumentOKBodyLinks struct {

	// customer
	Customer *PatchCustomersPaymentInstrumentOKBodyLinksCustomer `json:"customer,omitempty"`

	// self
	Self *PatchCustomersPaymentInstrumentOKBodyLinksSelf `json:"self,omitempty"`
}

// Validate validates this patch customers payment instrument o k body links
func (o *PatchCustomersPaymentInstrumentOKBodyLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCustomer(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyLinks) validateCustomer(formats strfmt.Registry) error {
	if swag.IsZero(o.Customer) { // not required
		return nil
	}

	if o.Customer != nil {
		if err := o.Customer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_links" + "." + "customer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_links" + "." + "customer")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(o.Self) { // not required
		return nil
	}

	if o.Self != nil {
		if err := o.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_links" + "." + "self")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch customers payment instrument o k body links based on the context it is used
func (o *PatchCustomersPaymentInstrumentOKBodyLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateCustomer(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyLinks) contextValidateCustomer(ctx context.Context, formats strfmt.Registry) error {

	if o.Customer != nil {
		if err := o.Customer.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_links" + "." + "customer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_links" + "." + "customer")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if o.Self != nil {
		if err := o.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_links" + "." + "self")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentOKBodyLinks) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentOKBodyLinks) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentOKBodyLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentOKBodyLinksCustomer patch customers payment instrument o k body links customer
swagger:model PatchCustomersPaymentInstrumentOKBodyLinksCustomer
*/
type PatchCustomersPaymentInstrumentOKBodyLinksCustomer struct {

	// Link to the Customer.
	//
	// Example: /tms/v2/customers/1234567890123456789
	// Read Only: true
	Href string `json:"href,omitempty"`
}

// Validate validates this patch customers payment instrument o k body links customer
func (o *PatchCustomersPaymentInstrumentOKBodyLinksCustomer) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this patch customers payment instrument o k body links customer based on the context it is used
func (o *PatchCustomersPaymentInstrumentOKBodyLinksCustomer) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateHref(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyLinksCustomer) contextValidateHref(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomersPaymentInstrumentOK"+"."+"_links"+"."+"customer"+"."+"href", "body", string(o.Href)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentOKBodyLinksCustomer) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentOKBodyLinksCustomer) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentOKBodyLinksCustomer
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentOKBodyLinksSelf patch customers payment instrument o k body links self
swagger:model PatchCustomersPaymentInstrumentOKBodyLinksSelf
*/
type PatchCustomersPaymentInstrumentOKBodyLinksSelf struct {

	// Link to the Payment Instrument.
	//
	// Example: /tms/v2/customers/1234567890123456789/payment-instruments
	// Read Only: true
	Href string `json:"href,omitempty"`
}

// Validate validates this patch customers payment instrument o k body links self
func (o *PatchCustomersPaymentInstrumentOKBodyLinksSelf) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this patch customers payment instrument o k body links self based on the context it is used
func (o *PatchCustomersPaymentInstrumentOKBodyLinksSelf) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateHref(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyLinksSelf) contextValidateHref(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomersPaymentInstrumentOK"+"."+"_links"+"."+"self"+"."+"href", "body", string(o.Href)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentOKBodyLinksSelf) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentOKBodyLinksSelf) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentOKBodyLinksSelf
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentOKBodyMerchantInformation patch customers payment instrument o k body merchant information
swagger:model PatchCustomersPaymentInstrumentOKBodyMerchantInformation
*/
type PatchCustomersPaymentInstrumentOKBodyMerchantInformation struct {

	// merchant descriptor
	MerchantDescriptor *PatchCustomersPaymentInstrumentOKBodyMerchantInformationMerchantDescriptor `json:"merchantDescriptor,omitempty"`
}

// Validate validates this patch customers payment instrument o k body merchant information
func (o *PatchCustomersPaymentInstrumentOKBodyMerchantInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateMerchantDescriptor(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyMerchantInformation) validateMerchantDescriptor(formats strfmt.Registry) error {
	if swag.IsZero(o.MerchantDescriptor) { // not required
		return nil
	}

	if o.MerchantDescriptor != nil {
		if err := o.MerchantDescriptor.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "merchantInformation" + "." + "merchantDescriptor")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "merchantInformation" + "." + "merchantDescriptor")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch customers payment instrument o k body merchant information based on the context it is used
func (o *PatchCustomersPaymentInstrumentOKBodyMerchantInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateMerchantDescriptor(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyMerchantInformation) contextValidateMerchantDescriptor(ctx context.Context, formats strfmt.Registry) error {

	if o.MerchantDescriptor != nil {
		if err := o.MerchantDescriptor.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "merchantInformation" + "." + "merchantDescriptor")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "merchantInformation" + "." + "merchantDescriptor")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentOKBodyMerchantInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentOKBodyMerchantInformation) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentOKBodyMerchantInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentOKBodyMerchantInformationMerchantDescriptor patch customers payment instrument o k body merchant information merchant descriptor
swagger:model PatchCustomersPaymentInstrumentOKBodyMerchantInformationMerchantDescriptor
*/
type PatchCustomersPaymentInstrumentOKBodyMerchantInformationMerchantDescriptor struct {

	// Alternate contact information for your business,such as an email address or URL.
	// This value might be displayed on the cardholders statement.
	// When you do not include this value in your capture or credit request, CyberSource uses the merchant URL from your CyberSource account.
	// Important This value must consist of English characters
	//
	// Max Length: 13
	AlternateName string `json:"alternateName,omitempty"`
}

// Validate validates this patch customers payment instrument o k body merchant information merchant descriptor
func (o *PatchCustomersPaymentInstrumentOKBodyMerchantInformationMerchantDescriptor) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAlternateName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyMerchantInformationMerchantDescriptor) validateAlternateName(formats strfmt.Registry) error {
	if swag.IsZero(o.AlternateName) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomersPaymentInstrumentOK"+"."+"merchantInformation"+"."+"merchantDescriptor"+"."+"alternateName", "body", o.AlternateName, 13); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this patch customers payment instrument o k body merchant information merchant descriptor based on context it is used
func (o *PatchCustomersPaymentInstrumentOKBodyMerchantInformationMerchantDescriptor) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentOKBodyMerchantInformationMerchantDescriptor) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentOKBodyMerchantInformationMerchantDescriptor) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentOKBodyMerchantInformationMerchantDescriptor
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentOKBodyMetadata patch customers payment instrument o k body metadata
swagger:model PatchCustomersPaymentInstrumentOKBodyMetadata
*/
type PatchCustomersPaymentInstrumentOKBodyMetadata struct {

	// The creator of the Payment Instrument token.
	//
	// Read Only: true
	Creator string `json:"creator,omitempty"`
}

// Validate validates this patch customers payment instrument o k body metadata
func (o *PatchCustomersPaymentInstrumentOKBodyMetadata) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this patch customers payment instrument o k body metadata based on the context it is used
func (o *PatchCustomersPaymentInstrumentOKBodyMetadata) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateCreator(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyMetadata) contextValidateCreator(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomersPaymentInstrumentOK"+"."+"metadata"+"."+"creator", "body", string(o.Creator)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentOKBodyMetadata) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentOKBodyMetadata) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentOKBodyMetadata
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentOKBodyProcessingInformation patch customers payment instrument o k body processing information
swagger:model PatchCustomersPaymentInstrumentOKBodyProcessingInformation
*/
type PatchCustomersPaymentInstrumentOKBodyProcessingInformation struct {

	// bank transfer options
	BankTransferOptions *PatchCustomersPaymentInstrumentOKBodyProcessingInformationBankTransferOptions `json:"bankTransferOptions,omitempty"`

	// Flag that indicates that this is a payment for a bill or for an existing contractual loan.
	// For processor-specific details, see the `bill_payment` field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// Valid values:
	// - `true`: Bill payment or loan payment.
	// - `false` (default): Not a bill payment or loan payment.
	//
	BillPaymentProgramEnabled bool `json:"billPaymentProgramEnabled,omitempty"`
}

// Validate validates this patch customers payment instrument o k body processing information
func (o *PatchCustomersPaymentInstrumentOKBodyProcessingInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateBankTransferOptions(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyProcessingInformation) validateBankTransferOptions(formats strfmt.Registry) error {
	if swag.IsZero(o.BankTransferOptions) { // not required
		return nil
	}

	if o.BankTransferOptions != nil {
		if err := o.BankTransferOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "processingInformation" + "." + "bankTransferOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "processingInformation" + "." + "bankTransferOptions")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch customers payment instrument o k body processing information based on the context it is used
func (o *PatchCustomersPaymentInstrumentOKBodyProcessingInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateBankTransferOptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyProcessingInformation) contextValidateBankTransferOptions(ctx context.Context, formats strfmt.Registry) error {

	if o.BankTransferOptions != nil {
		if err := o.BankTransferOptions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "processingInformation" + "." + "bankTransferOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomersPaymentInstrumentOK" + "." + "processingInformation" + "." + "bankTransferOptions")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentOKBodyProcessingInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentOKBodyProcessingInformation) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentOKBodyProcessingInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentOKBodyProcessingInformationBankTransferOptions patch customers payment instrument o k body processing information bank transfer options
swagger:model PatchCustomersPaymentInstrumentOKBodyProcessingInformationBankTransferOptions
*/
type PatchCustomersPaymentInstrumentOKBodyProcessingInformationBankTransferOptions struct {

	// Specifies the authorization method for the transaction.
	//
	// #### TeleCheck
	// Valid values:
	// - `ARC`: account receivable conversion
	// - `CCD`: corporate cash disbursement
	// - `POP`: point of purchase conversion
	// - `PPD`: prearranged payment and deposit entry
	// - `TEL`: telephone-initiated entry
	// - `WEB`: internet-initiated entry
	//
	// For details, see `ecp_sec_code` field description in the [Electronic Check Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/EChecks_SCMP_API/html/)
	//
	// Max Length: 3
	SECCode string `json:"SECCode,omitempty"`
}

// Validate validates this patch customers payment instrument o k body processing information bank transfer options
func (o *PatchCustomersPaymentInstrumentOKBodyProcessingInformationBankTransferOptions) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateSECCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentOKBodyProcessingInformationBankTransferOptions) validateSECCode(formats strfmt.Registry) error {
	if swag.IsZero(o.SECCode) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomersPaymentInstrumentOK"+"."+"processingInformation"+"."+"bankTransferOptions"+"."+"SECCode", "body", o.SECCode, 3); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this patch customers payment instrument o k body processing information bank transfer options based on context it is used
func (o *PatchCustomersPaymentInstrumentOKBodyProcessingInformationBankTransferOptions) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentOKBodyProcessingInformationBankTransferOptions) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentOKBodyProcessingInformationBankTransferOptions) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentOKBodyProcessingInformationBankTransferOptions
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentParamsBodyBankAccount patch customers payment instrument params body bank account
swagger:model PatchCustomersPaymentInstrumentParamsBodyBankAccount
*/
type PatchCustomersPaymentInstrumentParamsBodyBankAccount struct {

	// Account type.
	//
	// Valid values:
	//  - checking : C
	//  - general ledger : G This value is supported only on Wells Fargo ACH
	//  - savings : S (U.S. dollars only)
	//  - corporate checking : X (U.S. dollars only)
	//
	// Max Length: 18
	Type string `json:"type,omitempty"`
}

// Validate validates this patch customers payment instrument params body bank account
func (o *PatchCustomersPaymentInstrumentParamsBodyBankAccount) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyBankAccount) validateType(formats strfmt.Registry) error {
	if swag.IsZero(o.Type) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerPaymentInstrumentRequest"+"."+"bankAccount"+"."+"type", "body", o.Type, 18); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this patch customers payment instrument params body bank account based on context it is used
func (o *PatchCustomersPaymentInstrumentParamsBodyBankAccount) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentParamsBodyBankAccount) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentParamsBodyBankAccount) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentParamsBodyBankAccount
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentParamsBodyBillTo patch customers payment instrument params body bill to
swagger:model PatchCustomersPaymentInstrumentParamsBodyBillTo
*/
type PatchCustomersPaymentInstrumentParamsBodyBillTo struct {

	// Payment card billing street address as it appears on the credit card issuers records.
	//
	// Max Length: 60
	Address1 string `json:"address1,omitempty"`

	// Additional address information.
	//
	// Max Length: 60
	Address2 string `json:"address2,omitempty"`

	// State or province of the billing address. Use the State, Province, and Territory Codes for the United States
	// and Canada.
	//
	// Max Length: 20
	AdministrativeArea string `json:"administrativeArea,omitempty"`

	// Name of the customers company.
	//
	// Max Length: 60
	Company string `json:"company,omitempty"`

	// Payment card billing country. Use the two-character ISO Standard Country Codes.
	//
	// Max Length: 2
	Country string `json:"country,omitempty"`

	// Customer's email address, including the full domain name.
	//
	// Max Length: 255
	Email string `json:"email,omitempty"`

	// Customers first name. This name must be the same as the name on the card.
	//
	// Max Length: 60
	FirstName string `json:"firstName,omitempty"`

	// Customers last name. This name must be the same as the name on the card.
	//
	// Max Length: 60
	LastName string `json:"lastName,omitempty"`

	// Payment card billing city.
	//
	// Max Length: 50
	Locality string `json:"locality,omitempty"`

	// Customers phone number.
	//
	// Max Length: 15
	PhoneNumber string `json:"phoneNumber,omitempty"`

	// Postal code for the billing address. The postal code must consist of 5 to 9 digits.
	//
	// When the billing country is the U.S., the 9-digit postal code must follow this format:
	// [5 digits][dash][4 digits]
	//
	// **Example** `12345-6789`
	//
	// When the billing country is Canada, the 6-digit postal code must follow this format:
	// [alpha][numeric][alpha][space][numeric][alpha][numeric]
	//
	// **Example** `A1B 2C3`
	//
	// Max Length: 10
	PostalCode string `json:"postalCode,omitempty"`
}

// Validate validates this patch customers payment instrument params body bill to
func (o *PatchCustomersPaymentInstrumentParamsBodyBillTo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAddress1(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAddress2(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAdministrativeArea(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCompany(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEmail(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFirstName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLastName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocality(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePhoneNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyBillTo) validateAddress1(formats strfmt.Registry) error {
	if swag.IsZero(o.Address1) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerPaymentInstrumentRequest"+"."+"billTo"+"."+"address1", "body", o.Address1, 60); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyBillTo) validateAddress2(formats strfmt.Registry) error {
	if swag.IsZero(o.Address2) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerPaymentInstrumentRequest"+"."+"billTo"+"."+"address2", "body", o.Address2, 60); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyBillTo) validateAdministrativeArea(formats strfmt.Registry) error {
	if swag.IsZero(o.AdministrativeArea) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerPaymentInstrumentRequest"+"."+"billTo"+"."+"administrativeArea", "body", o.AdministrativeArea, 20); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyBillTo) validateCompany(formats strfmt.Registry) error {
	if swag.IsZero(o.Company) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerPaymentInstrumentRequest"+"."+"billTo"+"."+"company", "body", o.Company, 60); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyBillTo) validateCountry(formats strfmt.Registry) error {
	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerPaymentInstrumentRequest"+"."+"billTo"+"."+"country", "body", o.Country, 2); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyBillTo) validateEmail(formats strfmt.Registry) error {
	if swag.IsZero(o.Email) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerPaymentInstrumentRequest"+"."+"billTo"+"."+"email", "body", o.Email, 255); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyBillTo) validateFirstName(formats strfmt.Registry) error {
	if swag.IsZero(o.FirstName) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerPaymentInstrumentRequest"+"."+"billTo"+"."+"firstName", "body", o.FirstName, 60); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyBillTo) validateLastName(formats strfmt.Registry) error {
	if swag.IsZero(o.LastName) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerPaymentInstrumentRequest"+"."+"billTo"+"."+"lastName", "body", o.LastName, 60); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyBillTo) validateLocality(formats strfmt.Registry) error {
	if swag.IsZero(o.Locality) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerPaymentInstrumentRequest"+"."+"billTo"+"."+"locality", "body", o.Locality, 50); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyBillTo) validatePhoneNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.PhoneNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerPaymentInstrumentRequest"+"."+"billTo"+"."+"phoneNumber", "body", o.PhoneNumber, 15); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyBillTo) validatePostalCode(formats strfmt.Registry) error {
	if swag.IsZero(o.PostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerPaymentInstrumentRequest"+"."+"billTo"+"."+"postalCode", "body", o.PostalCode, 10); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this patch customers payment instrument params body bill to based on context it is used
func (o *PatchCustomersPaymentInstrumentParamsBodyBillTo) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentParamsBodyBillTo) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentParamsBodyBillTo) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentParamsBodyBillTo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentParamsBodyBuyerInformation patch customers payment instrument params body buyer information
swagger:model PatchCustomersPaymentInstrumentParamsBodyBuyerInformation
*/
type PatchCustomersPaymentInstrumentParamsBodyBuyerInformation struct {

	// Companys tax identifier. This is only used for eCheck service.
	//
	// Max Length: 9
	CompanyTaxID string `json:"companyTaxID,omitempty"`

	// Currency used for the order. Use the three-character I[ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)
	//
	// For details about currency as used in partial authorizations, see "Features for Debit Cards and Prepaid Cards" in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// For an authorization reversal (`reversalInformation`) or a capture (`processingOptions.capture` is set to `true`), you must use the same currency that you used in your payment authorization request.
	//
	// #### DCC for First Data
	// Your local currency. For details, see the `currency` field description in [Dynamic Currency Conversion For First Data Using the SCMP API](http://apps.cybersource.com/library/documentation/dev_guides/DCC_FirstData_SCMP/DCC_FirstData_SCMP_API.pdf).
	//
	// Max Length: 3
	Currency string `json:"currency,omitempty"`

	// Date of birth of the customer. Format: YYYY-MM-DD
	//
	// Example: 1960-12-30
	// Format: date
	DateOfBirth strfmt.Date `json:"dateOfBirth,omitempty"`

	// personal identification
	PersonalIdentification []*PatchCustomersPaymentInstrumentParamsBodyBuyerInformationPersonalIdentificationItems0 `json:"personalIdentification"`
}

// Validate validates this patch customers payment instrument params body buyer information
func (o *PatchCustomersPaymentInstrumentParamsBodyBuyerInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCompanyTaxID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCurrency(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDateOfBirth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePersonalIdentification(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyBuyerInformation) validateCompanyTaxID(formats strfmt.Registry) error {
	if swag.IsZero(o.CompanyTaxID) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerPaymentInstrumentRequest"+"."+"buyerInformation"+"."+"companyTaxID", "body", o.CompanyTaxID, 9); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyBuyerInformation) validateCurrency(formats strfmt.Registry) error {
	if swag.IsZero(o.Currency) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerPaymentInstrumentRequest"+"."+"buyerInformation"+"."+"currency", "body", o.Currency, 3); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyBuyerInformation) validateDateOfBirth(formats strfmt.Registry) error {
	if swag.IsZero(o.DateOfBirth) { // not required
		return nil
	}

	if err := validate.FormatOf("patchCustomerPaymentInstrumentRequest"+"."+"buyerInformation"+"."+"dateOfBirth", "body", "date", o.DateOfBirth.String(), formats); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyBuyerInformation) validatePersonalIdentification(formats strfmt.Registry) error {
	if swag.IsZero(o.PersonalIdentification) { // not required
		return nil
	}

	for i := 0; i < len(o.PersonalIdentification); i++ {
		if swag.IsZero(o.PersonalIdentification[i]) { // not required
			continue
		}

		if o.PersonalIdentification[i] != nil {
			if err := o.PersonalIdentification[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "buyerInformation" + "." + "personalIdentification" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "buyerInformation" + "." + "personalIdentification" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this patch customers payment instrument params body buyer information based on the context it is used
func (o *PatchCustomersPaymentInstrumentParamsBodyBuyerInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidatePersonalIdentification(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyBuyerInformation) contextValidatePersonalIdentification(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.PersonalIdentification); i++ {

		if o.PersonalIdentification[i] != nil {
			if err := o.PersonalIdentification[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "buyerInformation" + "." + "personalIdentification" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "buyerInformation" + "." + "personalIdentification" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentParamsBodyBuyerInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentParamsBodyBuyerInformation) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentParamsBodyBuyerInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentParamsBodyBuyerInformationPersonalIdentificationItems0 patch customers payment instrument params body buyer information personal identification items0
swagger:model PatchCustomersPaymentInstrumentParamsBodyBuyerInformationPersonalIdentificationItems0
*/
type PatchCustomersPaymentInstrumentParamsBodyBuyerInformationPersonalIdentificationItems0 struct {

	// The value of the identification type.
	//
	// Max Length: 26
	ID string `json:"id,omitempty"`

	// issued by
	IssuedBy *PatchCustomersPaymentInstrumentParamsBodyBuyerInformationPersonalIdentificationItems0IssuedBy `json:"issuedBy,omitempty"`

	// The type of the identification.
	//
	// Valid values:
	//   - driver license
	//
	Type string `json:"type,omitempty"`
}

// Validate validates this patch customers payment instrument params body buyer information personal identification items0
func (o *PatchCustomersPaymentInstrumentParamsBodyBuyerInformationPersonalIdentificationItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateIssuedBy(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyBuyerInformationPersonalIdentificationItems0) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MaxLength("id", "body", o.ID, 26); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyBuyerInformationPersonalIdentificationItems0) validateIssuedBy(formats strfmt.Registry) error {
	if swag.IsZero(o.IssuedBy) { // not required
		return nil
	}

	if o.IssuedBy != nil {
		if err := o.IssuedBy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("issuedBy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("issuedBy")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch customers payment instrument params body buyer information personal identification items0 based on the context it is used
func (o *PatchCustomersPaymentInstrumentParamsBodyBuyerInformationPersonalIdentificationItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateIssuedBy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyBuyerInformationPersonalIdentificationItems0) contextValidateIssuedBy(ctx context.Context, formats strfmt.Registry) error {

	if o.IssuedBy != nil {
		if err := o.IssuedBy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("issuedBy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("issuedBy")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentParamsBodyBuyerInformationPersonalIdentificationItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentParamsBodyBuyerInformationPersonalIdentificationItems0) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentParamsBodyBuyerInformationPersonalIdentificationItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentParamsBodyBuyerInformationPersonalIdentificationItems0IssuedBy patch customers payment instrument params body buyer information personal identification items0 issued by
swagger:model PatchCustomersPaymentInstrumentParamsBodyBuyerInformationPersonalIdentificationItems0IssuedBy
*/
type PatchCustomersPaymentInstrumentParamsBodyBuyerInformationPersonalIdentificationItems0IssuedBy struct {

	// The State or province where the customers drivers license was issued.
	//
	// Use the two-character State, Province, and Territory Codes for the United States and Canada.
	//
	// Max Length: 20
	AdministrativeArea string `json:"administrativeArea,omitempty"`
}

// Validate validates this patch customers payment instrument params body buyer information personal identification items0 issued by
func (o *PatchCustomersPaymentInstrumentParamsBodyBuyerInformationPersonalIdentificationItems0IssuedBy) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAdministrativeArea(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyBuyerInformationPersonalIdentificationItems0IssuedBy) validateAdministrativeArea(formats strfmt.Registry) error {
	if swag.IsZero(o.AdministrativeArea) { // not required
		return nil
	}

	if err := validate.MaxLength("issuedBy"+"."+"administrativeArea", "body", o.AdministrativeArea, 20); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this patch customers payment instrument params body buyer information personal identification items0 issued by based on context it is used
func (o *PatchCustomersPaymentInstrumentParamsBodyBuyerInformationPersonalIdentificationItems0IssuedBy) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentParamsBodyBuyerInformationPersonalIdentificationItems0IssuedBy) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentParamsBodyBuyerInformationPersonalIdentificationItems0IssuedBy) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentParamsBodyBuyerInformationPersonalIdentificationItems0IssuedBy
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentParamsBodyCard patch customers payment instrument params body card
swagger:model PatchCustomersPaymentInstrumentParamsBodyCard
*/
type PatchCustomersPaymentInstrumentParamsBodyCard struct {

	// Two-digit month in which the payment card expires.
	//
	// Format: `MM`.
	//
	// Valid values: `01` through `12`.
	//
	// Max Length: 2
	ExpirationMonth string `json:"expirationMonth,omitempty"`

	// Four-digit year in which the credit card expires.
	//
	// Format: `YYYY`.
	//
	// Max Length: 4
	ExpirationYear string `json:"expirationYear,omitempty"`

	// Number of times a Maestro (UK Domestic) card has been issued to the account holder. The card might or might not have an issue number. The number can consist of one or two digits, and the first digit might be a zero. When you include this value in your request, include exactly what is printed on the card. A value of 2 is different than a value of 02. Do not include the field, even with a blank value, if the card is not a Maestro (UK Domestic) card.
	//
	// **Note** The issue number is not required for Maestro (UK Domestic) transactions.
	//
	// Max Length: 2
	IssueNumber string `json:"issueNumber,omitempty"`

	// Month of the start of the Maestro (UK Domestic) card validity period. Do not include the field, even with a blank value, if the card is not a Maestro (UK Domestic) card. `Format: MM`.
	// Valid values: 01 through 12.
	//
	// **Note** The start date is not required for Maestro (UK Domestic) transactions.
	//
	// Max Length: 2
	StartMonth string `json:"startMonth,omitempty"`

	// Year of the start of the Maestro (UK Domestic) card validity period. Do not include the field, even with a blank value, if the card is not a Maestro (UK Domestic) card. `Format: YYYY`.
	//
	// **Note** The start date is not required for Maestro (UK Domestic) transactions.
	//
	// Max Length: 4
	StartYear string `json:"startYear,omitempty"`

	// tokenized information
	TokenizedInformation *PatchCustomersPaymentInstrumentParamsBodyCardTokenizedInformation `json:"tokenizedInformation,omitempty"`

	// Value that indicates the card type. Valid v2 : v1 - description values:
	//   * 001 : visa
	//   * 002 : mastercard - EurocardEuropean regional brand of Mastercard
	//   * 003 : american express
	//   * 004 : discover
	//   * 005 : diners club
	//   * 006 : carte blanche
	//   * 007 : jcb
	//   * 008 : optima
	//   * 011 : twinpay credit
	//   * 012 : twinpay debit
	//   * 013 : walmart
	//   * 014 : enRoute
	//   * 015 : lowes consumer
	//   * 016 : home depot consumer
	//   * 017 : mbna
	//   * 018 : dicks sportswear
	//   * 019 : casual corner
	//   * 020 : sears
	//   * 021 : jal
	//   * 023 : disney
	//   * 024 : maestro uk domestic
	//   * 025 : sams club consumer
	//   * 026 : sams club business
	//   * 028 : bill me later
	//   * 029 : bebe
	//   * 030 : restoration hardware
	//   * 031 : delta online  use this value only for Ingenico ePayments. For other processors, use 001 for all Visa card types.
	//   * 032 : solo
	//   * 033 : visa electron
	//   * 034 : dankort
	//   * 035 : laser
	//   * 036 : carte bleue  formerly Cartes Bancaires
	//   * 037 : carta si
	//   * 038 : pinless debit
	//   * 039 : encoded account
	//   * 040 : uatp
	//   * 041 : household
	//   * 042 : maestro international
	//   * 043 : ge money uk
	//   * 044 : korean cards
	//   * 045 : style
	//   * 046 : jcrew
	//   * 047 : payease china processing ewallet
	//   * 048 : payease china processing bank transfer
	//   * 049 : meijer private label
	//   * 050 : hipercard  supported only by the Comercio Latino processor.
	//   * 051 : aura  supported only by the Comercio Latino processor.
	//   * 052 : redecard
	//   * 054 : elo  supported only by the Comercio Latino processor.
	//   * 055 : capital one private label
	//   * 056 : synchrony private label
	//   * 057 : costco private label
	//   * 060 : mada
	//   * 062 : china union pay
	//   * 063 : falabella private label
	//
	Type string `json:"type,omitempty"`

	// 'Payment Instrument was created / updated as part of a pinless debit transaction.'
	//
	// Example: pinless debit
	UseAs string `json:"useAs,omitempty"`
}

// Validate validates this patch customers payment instrument params body card
func (o *PatchCustomersPaymentInstrumentParamsBodyCard) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateExpirationMonth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpirationYear(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateIssueNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateStartMonth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateStartYear(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTokenizedInformation(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyCard) validateExpirationMonth(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationMonth) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerPaymentInstrumentRequest"+"."+"card"+"."+"expirationMonth", "body", o.ExpirationMonth, 2); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyCard) validateExpirationYear(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationYear) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerPaymentInstrumentRequest"+"."+"card"+"."+"expirationYear", "body", o.ExpirationYear, 4); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyCard) validateIssueNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.IssueNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerPaymentInstrumentRequest"+"."+"card"+"."+"issueNumber", "body", o.IssueNumber, 2); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyCard) validateStartMonth(formats strfmt.Registry) error {
	if swag.IsZero(o.StartMonth) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerPaymentInstrumentRequest"+"."+"card"+"."+"startMonth", "body", o.StartMonth, 2); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyCard) validateStartYear(formats strfmt.Registry) error {
	if swag.IsZero(o.StartYear) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerPaymentInstrumentRequest"+"."+"card"+"."+"startYear", "body", o.StartYear, 4); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyCard) validateTokenizedInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.TokenizedInformation) { // not required
		return nil
	}

	if o.TokenizedInformation != nil {
		if err := o.TokenizedInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "card" + "." + "tokenizedInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "card" + "." + "tokenizedInformation")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch customers payment instrument params body card based on the context it is used
func (o *PatchCustomersPaymentInstrumentParamsBodyCard) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateTokenizedInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyCard) contextValidateTokenizedInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.TokenizedInformation != nil {
		if err := o.TokenizedInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "card" + "." + "tokenizedInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "card" + "." + "tokenizedInformation")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentParamsBodyCard) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentParamsBodyCard) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentParamsBodyCard
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentParamsBodyCardTokenizedInformation patch customers payment instrument params body card tokenized information
swagger:model PatchCustomersPaymentInstrumentParamsBodyCardTokenizedInformation
*/
type PatchCustomersPaymentInstrumentParamsBodyCardTokenizedInformation struct {

	// Value that identifies your business and indicates that the cardholders account number is tokenized. This value
	// is assigned by the token service provider and is unique within the token service providers database.
	//
	// **Note** This field is supported only for **CyberSource through VisaNet** and **FDC Nashville Global**.
	//
	// Max Length: 11
	RequestorID string `json:"requestorID,omitempty"`

	// Type of transaction that provided the token data. This value does not specify the token service provider; it
	// specifies the entity that provided you with information about the token.
	//
	// Set the value for this field to 1. An application on the customers mobile device provided the token data.
	//
	// Max Length: 1
	TransactionType string `json:"transactionType,omitempty"`
}

// Validate validates this patch customers payment instrument params body card tokenized information
func (o *PatchCustomersPaymentInstrumentParamsBodyCardTokenizedInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateRequestorID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTransactionType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyCardTokenizedInformation) validateRequestorID(formats strfmt.Registry) error {
	if swag.IsZero(o.RequestorID) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerPaymentInstrumentRequest"+"."+"card"+"."+"tokenizedInformation"+"."+"requestorID", "body", o.RequestorID, 11); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyCardTokenizedInformation) validateTransactionType(formats strfmt.Registry) error {
	if swag.IsZero(o.TransactionType) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerPaymentInstrumentRequest"+"."+"card"+"."+"tokenizedInformation"+"."+"transactionType", "body", o.TransactionType, 1); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this patch customers payment instrument params body card tokenized information based on context it is used
func (o *PatchCustomersPaymentInstrumentParamsBodyCardTokenizedInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentParamsBodyCardTokenizedInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentParamsBodyCardTokenizedInformation) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentParamsBodyCardTokenizedInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentParamsBodyEmbedded Additional resources for the Payment Instrument token.
//
swagger:model PatchCustomersPaymentInstrumentParamsBodyEmbedded
*/
type PatchCustomersPaymentInstrumentParamsBodyEmbedded struct {

	// instrument identifier
	InstrumentIdentifier *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifier `json:"instrumentIdentifier,omitempty"`
}

// Validate validates this patch customers payment instrument params body embedded
func (o *PatchCustomersPaymentInstrumentParamsBodyEmbedded) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateInstrumentIdentifier(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyEmbedded) validateInstrumentIdentifier(formats strfmt.Registry) error {
	if swag.IsZero(o.InstrumentIdentifier) { // not required
		return nil
	}

	if o.InstrumentIdentifier != nil {
		if err := o.InstrumentIdentifier.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch customers payment instrument params body embedded based on the context it is used
func (o *PatchCustomersPaymentInstrumentParamsBodyEmbedded) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateInstrumentIdentifier(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyEmbedded) contextValidateInstrumentIdentifier(ctx context.Context, formats strfmt.Registry) error {

	if o.InstrumentIdentifier != nil {
		if err := o.InstrumentIdentifier.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentParamsBodyEmbedded) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentParamsBodyEmbedded) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentParamsBodyEmbedded
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifier patch customers payment instrument params body embedded instrument identifier
swagger:model PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifier
*/
type PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifier struct {

	// links
	Links *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierLinks `json:"_links,omitempty"`

	// bank account
	BankAccount *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierBankAccount `json:"bankAccount,omitempty"`

	// bill to
	BillTo *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierBillTo `json:"billTo,omitempty"`

	// card
	Card *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierCard `json:"card,omitempty"`

	// The id of the Instrument Identifier Token.
	//
	ID string `json:"id,omitempty"`

	// issuer
	Issuer *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierIssuer `json:"issuer,omitempty"`

	// metadata
	Metadata *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierMetadata `json:"metadata,omitempty"`

	// The type of token.
	//
	// Valid values:
	// - instrumentIdentifier
	//
	// Example: instrumentIdentifier
	// Read Only: true
	Object string `json:"object,omitempty"`

	// processing information
	ProcessingInformation *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformation `json:"processingInformation,omitempty"`

	// Issuers state for the card number.
	// Valid values:
	// - ACTIVE
	// - CLOSED : The account has been closed.
	//
	// Example: ACTIVE
	// Read Only: true
	State string `json:"state,omitempty"`

	// tokenized card
	TokenizedCard *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenizedCard `json:"tokenizedCard,omitempty"`

	// The type of Instrument Identifier.
	// Valid values:
	// - enrollable card
	//
	Type string `json:"type,omitempty"`
}

// Validate validates this patch customers payment instrument params body embedded instrument identifier
func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifier) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBankAccount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBillTo(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCard(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateIssuer(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMetadata(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProcessingInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTokenizedCard(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifier) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(o.Links) { // not required
		return nil
	}

	if o.Links != nil {
		if err := o.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifier) validateBankAccount(formats strfmt.Registry) error {
	if swag.IsZero(o.BankAccount) { // not required
		return nil
	}

	if o.BankAccount != nil {
		if err := o.BankAccount.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "bankAccount")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "bankAccount")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifier) validateBillTo(formats strfmt.Registry) error {
	if swag.IsZero(o.BillTo) { // not required
		return nil
	}

	if o.BillTo != nil {
		if err := o.BillTo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "billTo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "billTo")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifier) validateCard(formats strfmt.Registry) error {
	if swag.IsZero(o.Card) { // not required
		return nil
	}

	if o.Card != nil {
		if err := o.Card.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "card")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "card")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifier) validateIssuer(formats strfmt.Registry) error {
	if swag.IsZero(o.Issuer) { // not required
		return nil
	}

	if o.Issuer != nil {
		if err := o.Issuer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "issuer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "issuer")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifier) validateMetadata(formats strfmt.Registry) error {
	if swag.IsZero(o.Metadata) { // not required
		return nil
	}

	if o.Metadata != nil {
		if err := o.Metadata.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "metadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "metadata")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifier) validateProcessingInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ProcessingInformation) { // not required
		return nil
	}

	if o.ProcessingInformation != nil {
		if err := o.ProcessingInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifier) validateTokenizedCard(formats strfmt.Registry) error {
	if swag.IsZero(o.TokenizedCard) { // not required
		return nil
	}

	if o.TokenizedCard != nil {
		if err := o.TokenizedCard.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "tokenizedCard")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "tokenizedCard")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch customers payment instrument params body embedded instrument identifier based on the context it is used
func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifier) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateBankAccount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateBillTo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateCard(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateIssuer(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateMetadata(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateObject(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateProcessingInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateTokenizedCard(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifier) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if o.Links != nil {
		if err := o.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifier) contextValidateBankAccount(ctx context.Context, formats strfmt.Registry) error {

	if o.BankAccount != nil {
		if err := o.BankAccount.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "bankAccount")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "bankAccount")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifier) contextValidateBillTo(ctx context.Context, formats strfmt.Registry) error {

	if o.BillTo != nil {
		if err := o.BillTo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "billTo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "billTo")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifier) contextValidateCard(ctx context.Context, formats strfmt.Registry) error {

	if o.Card != nil {
		if err := o.Card.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "card")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "card")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifier) contextValidateIssuer(ctx context.Context, formats strfmt.Registry) error {

	if o.Issuer != nil {
		if err := o.Issuer.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "issuer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "issuer")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifier) contextValidateMetadata(ctx context.Context, formats strfmt.Registry) error {

	if o.Metadata != nil {
		if err := o.Metadata.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "metadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "metadata")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifier) contextValidateObject(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerPaymentInstrumentRequest"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"object", "body", string(o.Object)); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifier) contextValidateProcessingInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ProcessingInformation != nil {
		if err := o.ProcessingInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifier) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerPaymentInstrumentRequest"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"state", "body", string(o.State)); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifier) contextValidateTokenizedCard(ctx context.Context, formats strfmt.Registry) error {

	if o.TokenizedCard != nil {
		if err := o.TokenizedCard.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "tokenizedCard")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "tokenizedCard")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifier) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifier) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifier
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierBankAccount patch customers payment instrument params body embedded instrument identifier bank account
swagger:model PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierBankAccount
*/
type PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierBankAccount struct {

	// Account number.
	//
	// When processing encoded account numbers, use this field for the encoded account number.
	//
	// Max Length: 17
	Number string `json:"number,omitempty"`

	// Bank routing number. This is also called the transit number.
	//
	// For details, see `ecp_rdfi` field description in the [Electronic Check Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/EChecks_SCMP_API/html/)
	//
	RoutingNumber string `json:"routingNumber,omitempty"`
}

// Validate validates this patch customers payment instrument params body embedded instrument identifier bank account
func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierBankAccount) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateNumber(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierBankAccount) validateNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.Number) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerPaymentInstrumentRequest"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"bankAccount"+"."+"number", "body", o.Number, 17); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this patch customers payment instrument params body embedded instrument identifier bank account based on context it is used
func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierBankAccount) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierBankAccount) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierBankAccount) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierBankAccount
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierBillTo This information is sent to the issuer as part of network token enrollment and is not stored under the Instrument Identifier token.
//
swagger:model PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierBillTo
*/
type PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierBillTo struct {

	// Payment card billing street address as it appears on the credit card issuers records.
	//
	// Max Length: 60
	Address1 string `json:"address1,omitempty"`

	// Additional address information.
	//
	// Max Length: 60
	Address2 string `json:"address2,omitempty"`

	// State or province of the billing address. Use the State, Province, and Territory Codes for the United States
	// and Canada.
	//
	// Max Length: 20
	AdministrativeArea string `json:"administrativeArea,omitempty"`

	// Payment card billing country. Use the two-character ISO Standard Country Codes.
	//
	// Max Length: 2
	Country string `json:"country,omitempty"`

	// Payment card billing city.
	//
	// Max Length: 50
	Locality string `json:"locality,omitempty"`

	// Postal code for the billing address. The postal code must consist of 5 to 9 digits.
	//
	// When the billing country is the U.S., the 9-digit postal code must follow this format:
	// [5 digits][dash][4 digits]
	//
	// **Example** `12345-6789`
	//
	// When the billing country is Canada, the 6-digit postal code must follow this format:
	// [alpha][numeric][alpha][space][numeric][alpha][numeric]
	//
	// **Example** `A1B 2C3`
	//
	// Max Length: 10
	PostalCode string `json:"postalCode,omitempty"`
}

// Validate validates this patch customers payment instrument params body embedded instrument identifier bill to
func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierBillTo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAddress1(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAddress2(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAdministrativeArea(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocality(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierBillTo) validateAddress1(formats strfmt.Registry) error {
	if swag.IsZero(o.Address1) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerPaymentInstrumentRequest"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"billTo"+"."+"address1", "body", o.Address1, 60); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierBillTo) validateAddress2(formats strfmt.Registry) error {
	if swag.IsZero(o.Address2) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerPaymentInstrumentRequest"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"billTo"+"."+"address2", "body", o.Address2, 60); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierBillTo) validateAdministrativeArea(formats strfmt.Registry) error {
	if swag.IsZero(o.AdministrativeArea) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerPaymentInstrumentRequest"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"billTo"+"."+"administrativeArea", "body", o.AdministrativeArea, 20); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierBillTo) validateCountry(formats strfmt.Registry) error {
	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerPaymentInstrumentRequest"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"billTo"+"."+"country", "body", o.Country, 2); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierBillTo) validateLocality(formats strfmt.Registry) error {
	if swag.IsZero(o.Locality) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerPaymentInstrumentRequest"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"billTo"+"."+"locality", "body", o.Locality, 50); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierBillTo) validatePostalCode(formats strfmt.Registry) error {
	if swag.IsZero(o.PostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerPaymentInstrumentRequest"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"billTo"+"."+"postalCode", "body", o.PostalCode, 10); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this patch customers payment instrument params body embedded instrument identifier bill to based on context it is used
func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierBillTo) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierBillTo) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierBillTo) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierBillTo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierCard The expirationMonth, expirationYear and securityCode is sent to the issuer as part of network token enrollment and is not stored under the Instrument Identifier token.
//
swagger:model PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierCard
*/
type PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierCard struct {

	// Two-digit month in which the payment card expires.
	//
	// Format: `MM`.
	//
	// Valid values: `01` through `12`.
	//
	// Max Length: 2
	ExpirationMonth string `json:"expirationMonth,omitempty"`

	// Four-digit year in which the credit card expires.
	//
	// Format: `YYYY`.
	//
	// Max Length: 4
	ExpirationYear string `json:"expirationYear,omitempty"`

	// The customers payment card number, also known as the Primary Account Number (PAN). You can also use this field
	// for encoded account numbers.
	//
	// Max Length: 19
	// Min Length: 12
	Number string `json:"number,omitempty"`

	// Card Verification Number.
	//
	// Max Length: 4
	SecurityCode string `json:"securityCode,omitempty"`
}

// Validate validates this patch customers payment instrument params body embedded instrument identifier card
func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierCard) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateExpirationMonth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpirationYear(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSecurityCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierCard) validateExpirationMonth(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationMonth) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerPaymentInstrumentRequest"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"card"+"."+"expirationMonth", "body", o.ExpirationMonth, 2); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierCard) validateExpirationYear(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationYear) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerPaymentInstrumentRequest"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"card"+"."+"expirationYear", "body", o.ExpirationYear, 4); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierCard) validateNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.Number) { // not required
		return nil
	}

	if err := validate.MinLength("patchCustomerPaymentInstrumentRequest"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"card"+"."+"number", "body", o.Number, 12); err != nil {
		return err
	}

	if err := validate.MaxLength("patchCustomerPaymentInstrumentRequest"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"card"+"."+"number", "body", o.Number, 19); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierCard) validateSecurityCode(formats strfmt.Registry) error {
	if swag.IsZero(o.SecurityCode) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerPaymentInstrumentRequest"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"card"+"."+"securityCode", "body", o.SecurityCode, 4); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this patch customers payment instrument params body embedded instrument identifier card based on context it is used
func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierCard) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierCard) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierCard) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierCard
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierIssuer patch customers payment instrument params body embedded instrument identifier issuer
swagger:model PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierIssuer
*/
type PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierIssuer struct {

	// This reference number serves as a link to the cardholder account and to all transactions for that account.
	//
	// Read Only: true
	// Max Length: 32
	PaymentAccountReference string `json:"paymentAccountReference,omitempty"`
}

// Validate validates this patch customers payment instrument params body embedded instrument identifier issuer
func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierIssuer) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validatePaymentAccountReference(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierIssuer) validatePaymentAccountReference(formats strfmt.Registry) error {
	if swag.IsZero(o.PaymentAccountReference) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerPaymentInstrumentRequest"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"issuer"+"."+"paymentAccountReference", "body", o.PaymentAccountReference, 32); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this patch customers payment instrument params body embedded instrument identifier issuer based on the context it is used
func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierIssuer) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidatePaymentAccountReference(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierIssuer) contextValidatePaymentAccountReference(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerPaymentInstrumentRequest"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"issuer"+"."+"paymentAccountReference", "body", string(o.PaymentAccountReference)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierIssuer) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierIssuer) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierIssuer
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierLinks patch customers payment instrument params body embedded instrument identifier links
swagger:model PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierLinks
*/
type PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierLinks struct {

	// payment instruments
	PaymentInstruments *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierLinksPaymentInstruments `json:"paymentInstruments,omitempty"`

	// self
	Self *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierLinksSelf `json:"self,omitempty"`
}

// Validate validates this patch customers payment instrument params body embedded instrument identifier links
func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validatePaymentInstruments(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierLinks) validatePaymentInstruments(formats strfmt.Registry) error {
	if swag.IsZero(o.PaymentInstruments) { // not required
		return nil
	}

	if o.PaymentInstruments != nil {
		if err := o.PaymentInstruments.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "_links" + "." + "paymentInstruments")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "_links" + "." + "paymentInstruments")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(o.Self) { // not required
		return nil
	}

	if o.Self != nil {
		if err := o.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "_links" + "." + "self")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch customers payment instrument params body embedded instrument identifier links based on the context it is used
func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidatePaymentInstruments(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierLinks) contextValidatePaymentInstruments(ctx context.Context, formats strfmt.Registry) error {

	if o.PaymentInstruments != nil {
		if err := o.PaymentInstruments.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "_links" + "." + "paymentInstruments")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "_links" + "." + "paymentInstruments")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if o.Self != nil {
		if err := o.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "_links" + "." + "self")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierLinks) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierLinks) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierLinksPaymentInstruments patch customers payment instrument params body embedded instrument identifier links payment instruments
swagger:model PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierLinksPaymentInstruments
*/
type PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierLinksPaymentInstruments struct {

	// Link to the Instrument Identifiers Payment Instruments.
	//
	// Example: tms/v1/instrumentidentifiers/9B8D20D13FF328CCE0539399D30A70N4/paymentinstruments
	// Read Only: true
	Href string `json:"href,omitempty"`
}

// Validate validates this patch customers payment instrument params body embedded instrument identifier links payment instruments
func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierLinksPaymentInstruments) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this patch customers payment instrument params body embedded instrument identifier links payment instruments based on the context it is used
func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierLinksPaymentInstruments) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateHref(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierLinksPaymentInstruments) contextValidateHref(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerPaymentInstrumentRequest"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"_links"+"."+"paymentInstruments"+"."+"href", "body", string(o.Href)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierLinksPaymentInstruments) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierLinksPaymentInstruments) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierLinksPaymentInstruments
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierLinksSelf patch customers payment instrument params body embedded instrument identifier links self
swagger:model PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierLinksSelf
*/
type PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierLinksSelf struct {

	// Link to the Instrument Identifier.
	//
	// Example: tms/v1/instrumentidentifiers/9B8D20D13FF328CCE0539399D30A70N4
	// Read Only: true
	Href string `json:"href,omitempty"`
}

// Validate validates this patch customers payment instrument params body embedded instrument identifier links self
func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierLinksSelf) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this patch customers payment instrument params body embedded instrument identifier links self based on the context it is used
func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierLinksSelf) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateHref(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierLinksSelf) contextValidateHref(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerPaymentInstrumentRequest"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"_links"+"."+"self"+"."+"href", "body", string(o.Href)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierLinksSelf) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierLinksSelf) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierLinksSelf
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierMetadata patch customers payment instrument params body embedded instrument identifier metadata
swagger:model PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierMetadata
*/
type PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierMetadata struct {

	// The creator of the Instrument Identifier token.
	// Read Only: true
	Creator string `json:"creator,omitempty"`
}

// Validate validates this patch customers payment instrument params body embedded instrument identifier metadata
func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierMetadata) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this patch customers payment instrument params body embedded instrument identifier metadata based on the context it is used
func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierMetadata) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateCreator(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierMetadata) contextValidateCreator(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerPaymentInstrumentRequest"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"metadata"+"."+"creator", "body", string(o.Creator)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierMetadata) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierMetadata) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierMetadata
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformation patch customers payment instrument params body embedded instrument identifier processing information
swagger:model PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformation
*/
type PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformation struct {

	// authorization options
	AuthorizationOptions *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions `json:"authorizationOptions,omitempty"`
}

// Validate validates this patch customers payment instrument params body embedded instrument identifier processing information
func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAuthorizationOptions(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformation) validateAuthorizationOptions(formats strfmt.Registry) error {
	if swag.IsZero(o.AuthorizationOptions) { // not required
		return nil
	}

	if o.AuthorizationOptions != nil {
		if err := o.AuthorizationOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch customers payment instrument params body embedded instrument identifier processing information based on the context it is used
func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateAuthorizationOptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformation) contextValidateAuthorizationOptions(ctx context.Context, formats strfmt.Registry) error {

	if o.AuthorizationOptions != nil {
		if err := o.AuthorizationOptions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformation) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions patch customers payment instrument params body embedded instrument identifier processing information authorization options
swagger:model PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions
*/
type PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions struct {

	// initiator
	Initiator *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator `json:"initiator,omitempty"`
}

// Validate validates this patch customers payment instrument params body embedded instrument identifier processing information authorization options
func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateInitiator(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions) validateInitiator(formats strfmt.Registry) error {
	if swag.IsZero(o.Initiator) { // not required
		return nil
	}

	if o.Initiator != nil {
		if err := o.Initiator.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch customers payment instrument params body embedded instrument identifier processing information authorization options based on the context it is used
func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateInitiator(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions) contextValidateInitiator(ctx context.Context, formats strfmt.Registry) error {

	if o.Initiator != nil {
		if err := o.Initiator.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator patch customers payment instrument params body embedded instrument identifier processing information authorization options initiator
swagger:model PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator
*/
type PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator struct {

	// merchant initiated transaction
	MerchantInitiatedTransaction *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction `json:"merchantInitiatedTransaction,omitempty"`
}

// Validate validates this patch customers payment instrument params body embedded instrument identifier processing information authorization options initiator
func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateMerchantInitiatedTransaction(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator) validateMerchantInitiatedTransaction(formats strfmt.Registry) error {
	if swag.IsZero(o.MerchantInitiatedTransaction) { // not required
		return nil
	}

	if o.MerchantInitiatedTransaction != nil {
		if err := o.MerchantInitiatedTransaction.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator" + "." + "merchantInitiatedTransaction")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator" + "." + "merchantInitiatedTransaction")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch customers payment instrument params body embedded instrument identifier processing information authorization options initiator based on the context it is used
func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateMerchantInitiatedTransaction(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator) contextValidateMerchantInitiatedTransaction(ctx context.Context, formats strfmt.Registry) error {

	if o.MerchantInitiatedTransaction != nil {
		if err := o.MerchantInitiatedTransaction.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator" + "." + "merchantInitiatedTransaction")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator" + "." + "merchantInitiatedTransaction")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction patch customers payment instrument params body embedded instrument identifier processing information authorization options initiator merchant initiated transaction
swagger:model PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction
*/
type PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction struct {

	// Network transaction identifier that was returned in the payment response field _processorInformation.transactionID_
	// in the reply message for either the original merchant-initiated payment in the series or the previous
	// merchant-initiated payment in the series.
	//
	// Max Length: 15
	PreviousTransactionID string `json:"previousTransactionId,omitempty"`
}

// Validate validates this patch customers payment instrument params body embedded instrument identifier processing information authorization options initiator merchant initiated transaction
func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validatePreviousTransactionID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction) validatePreviousTransactionID(formats strfmt.Registry) error {
	if swag.IsZero(o.PreviousTransactionID) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerPaymentInstrumentRequest"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"processingInformation"+"."+"authorizationOptions"+"."+"initiator"+"."+"merchantInitiatedTransaction"+"."+"previousTransactionId", "body", o.PreviousTransactionID, 15); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this patch customers payment instrument params body embedded instrument identifier processing information authorization options initiator merchant initiated transaction based on context it is used
func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenizedCard patch customers payment instrument params body embedded instrument identifier tokenized card
swagger:model PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenizedCard
*/
type PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenizedCard struct {

	// card
	Card *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenizedCardCard `json:"card,omitempty"`

	// Generated value used in conjunction with the network token for making a payment.
	//
	// Example: CgAFRFYFPTFOfg5rj2ais9wQAAAAAM=
	// Read Only: true
	Cryptogram string `json:"cryptogram,omitempty"`

	// Two-digit month in which the network token expires.
	//
	// Format: `MM`.
	//
	// Valid values: `01` through `12`.
	//
	// Read Only: true
	// Max Length: 2
	ExpirationMonth string `json:"expirationMonth,omitempty"`

	// Four-digit year in which the network token expires.
	//
	// Format: `YYYY`.
	//
	// Read Only: true
	// Max Length: 4
	ExpirationYear string `json:"expirationYear,omitempty"`

	// The token requestors customers payment network token
	//
	// Read Only: true
	Number string `json:"number,omitempty"`

	// Issuers state for the network token
	// Valid values:
	// - ACTIVE
	// - SUSPENDED : This state can change to ACTIVE or DELETED.
	// - DELETED : This is a final state for the network token.
	//
	// Example: ACTIVE
	// Read Only: true
	State string `json:"state,omitempty"`

	// The network token card association brand
	// Valid values:
	// - visa
	// - mastercard
	//
	// Example: visa
	// Read Only: true
	Type string `json:"type,omitempty"`
}

// Validate validates this patch customers payment instrument params body embedded instrument identifier tokenized card
func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenizedCard) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCard(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpirationMonth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpirationYear(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenizedCard) validateCard(formats strfmt.Registry) error {
	if swag.IsZero(o.Card) { // not required
		return nil
	}

	if o.Card != nil {
		if err := o.Card.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "tokenizedCard" + "." + "card")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "tokenizedCard" + "." + "card")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenizedCard) validateExpirationMonth(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationMonth) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerPaymentInstrumentRequest"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"expirationMonth", "body", o.ExpirationMonth, 2); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenizedCard) validateExpirationYear(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationYear) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerPaymentInstrumentRequest"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"expirationYear", "body", o.ExpirationYear, 4); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this patch customers payment instrument params body embedded instrument identifier tokenized card based on the context it is used
func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenizedCard) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateCard(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateCryptogram(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateExpirationMonth(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateExpirationYear(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateNumber(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenizedCard) contextValidateCard(ctx context.Context, formats strfmt.Registry) error {

	if o.Card != nil {
		if err := o.Card.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "tokenizedCard" + "." + "card")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "tokenizedCard" + "." + "card")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenizedCard) contextValidateCryptogram(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerPaymentInstrumentRequest"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"cryptogram", "body", string(o.Cryptogram)); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenizedCard) contextValidateExpirationMonth(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerPaymentInstrumentRequest"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"expirationMonth", "body", string(o.ExpirationMonth)); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenizedCard) contextValidateExpirationYear(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerPaymentInstrumentRequest"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"expirationYear", "body", string(o.ExpirationYear)); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenizedCard) contextValidateNumber(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerPaymentInstrumentRequest"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"number", "body", string(o.Number)); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenizedCard) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerPaymentInstrumentRequest"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"state", "body", string(o.State)); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenizedCard) contextValidateType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerPaymentInstrumentRequest"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"type", "body", string(o.Type)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenizedCard) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenizedCard) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenizedCard
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenizedCardCard The latest card details associated with the network token
swagger:model PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenizedCardCard
*/
type PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenizedCardCard struct {

	//
	// Two-digit month in which the customers latest payment card expires.
	//
	// Format: `MM`.
	//
	// Valid values: `01` through `12`.
	//
	// Read Only: true
	// Max Length: 2
	ExpirationMonth string `json:"expirationMonth,omitempty"`

	// Four-digit year in which the customers latest payment card expires.
	//
	// Format: `YYYY`.
	//
	// Read Only: true
	// Max Length: 4
	ExpirationYear string `json:"expirationYear,omitempty"`

	// The customers latest payment card number suffix
	//
	// Example: 1111
	// Read Only: true
	Suffix string `json:"suffix,omitempty"`
}

// Validate validates this patch customers payment instrument params body embedded instrument identifier tokenized card card
func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenizedCardCard) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateExpirationMonth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpirationYear(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenizedCardCard) validateExpirationMonth(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationMonth) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerPaymentInstrumentRequest"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"card"+"."+"expirationMonth", "body", o.ExpirationMonth, 2); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenizedCardCard) validateExpirationYear(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationYear) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerPaymentInstrumentRequest"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"card"+"."+"expirationYear", "body", o.ExpirationYear, 4); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this patch customers payment instrument params body embedded instrument identifier tokenized card card based on the context it is used
func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenizedCardCard) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateExpirationMonth(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateExpirationYear(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateSuffix(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenizedCardCard) contextValidateExpirationMonth(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerPaymentInstrumentRequest"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"card"+"."+"expirationMonth", "body", string(o.ExpirationMonth)); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenizedCardCard) contextValidateExpirationYear(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerPaymentInstrumentRequest"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"card"+"."+"expirationYear", "body", string(o.ExpirationYear)); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenizedCardCard) contextValidateSuffix(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerPaymentInstrumentRequest"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"card"+"."+"suffix", "body", string(o.Suffix)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenizedCardCard) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenizedCardCard) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentParamsBodyEmbeddedInstrumentIdentifierTokenizedCardCard
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentParamsBodyInstrumentIdentifier patch customers payment instrument params body instrument identifier
swagger:model PatchCustomersPaymentInstrumentParamsBodyInstrumentIdentifier
*/
type PatchCustomersPaymentInstrumentParamsBodyInstrumentIdentifier struct {

	// The id of the Instrument Identifier token linked to the Payment Instrument.
	//
	// Max Length: 32
	// Min Length: 12
	ID string `json:"id,omitempty"`
}

// Validate validates this patch customers payment instrument params body instrument identifier
func (o *PatchCustomersPaymentInstrumentParamsBodyInstrumentIdentifier) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyInstrumentIdentifier) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MinLength("patchCustomerPaymentInstrumentRequest"+"."+"instrumentIdentifier"+"."+"id", "body", o.ID, 12); err != nil {
		return err
	}

	if err := validate.MaxLength("patchCustomerPaymentInstrumentRequest"+"."+"instrumentIdentifier"+"."+"id", "body", o.ID, 32); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this patch customers payment instrument params body instrument identifier based on context it is used
func (o *PatchCustomersPaymentInstrumentParamsBodyInstrumentIdentifier) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentParamsBodyInstrumentIdentifier) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentParamsBodyInstrumentIdentifier) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentParamsBodyInstrumentIdentifier
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentParamsBodyLinks patch customers payment instrument params body links
swagger:model PatchCustomersPaymentInstrumentParamsBodyLinks
*/
type PatchCustomersPaymentInstrumentParamsBodyLinks struct {

	// customer
	Customer *PatchCustomersPaymentInstrumentParamsBodyLinksCustomer `json:"customer,omitempty"`

	// self
	Self *PatchCustomersPaymentInstrumentParamsBodyLinksSelf `json:"self,omitempty"`
}

// Validate validates this patch customers payment instrument params body links
func (o *PatchCustomersPaymentInstrumentParamsBodyLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCustomer(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyLinks) validateCustomer(formats strfmt.Registry) error {
	if swag.IsZero(o.Customer) { // not required
		return nil
	}

	if o.Customer != nil {
		if err := o.Customer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_links" + "." + "customer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_links" + "." + "customer")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(o.Self) { // not required
		return nil
	}

	if o.Self != nil {
		if err := o.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_links" + "." + "self")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch customers payment instrument params body links based on the context it is used
func (o *PatchCustomersPaymentInstrumentParamsBodyLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateCustomer(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyLinks) contextValidateCustomer(ctx context.Context, formats strfmt.Registry) error {

	if o.Customer != nil {
		if err := o.Customer.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_links" + "." + "customer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_links" + "." + "customer")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if o.Self != nil {
		if err := o.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_links" + "." + "self")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentParamsBodyLinks) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentParamsBodyLinks) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentParamsBodyLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentParamsBodyLinksCustomer patch customers payment instrument params body links customer
swagger:model PatchCustomersPaymentInstrumentParamsBodyLinksCustomer
*/
type PatchCustomersPaymentInstrumentParamsBodyLinksCustomer struct {

	// Link to the Customer.
	//
	// Example: /tms/v2/customers/1234567890123456789
	// Read Only: true
	Href string `json:"href,omitempty"`
}

// Validate validates this patch customers payment instrument params body links customer
func (o *PatchCustomersPaymentInstrumentParamsBodyLinksCustomer) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this patch customers payment instrument params body links customer based on the context it is used
func (o *PatchCustomersPaymentInstrumentParamsBodyLinksCustomer) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateHref(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyLinksCustomer) contextValidateHref(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerPaymentInstrumentRequest"+"."+"_links"+"."+"customer"+"."+"href", "body", string(o.Href)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentParamsBodyLinksCustomer) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentParamsBodyLinksCustomer) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentParamsBodyLinksCustomer
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentParamsBodyLinksSelf patch customers payment instrument params body links self
swagger:model PatchCustomersPaymentInstrumentParamsBodyLinksSelf
*/
type PatchCustomersPaymentInstrumentParamsBodyLinksSelf struct {

	// Link to the Payment Instrument.
	//
	// Example: /tms/v2/customers/1234567890123456789/payment-instruments
	// Read Only: true
	Href string `json:"href,omitempty"`
}

// Validate validates this patch customers payment instrument params body links self
func (o *PatchCustomersPaymentInstrumentParamsBodyLinksSelf) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this patch customers payment instrument params body links self based on the context it is used
func (o *PatchCustomersPaymentInstrumentParamsBodyLinksSelf) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateHref(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyLinksSelf) contextValidateHref(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerPaymentInstrumentRequest"+"."+"_links"+"."+"self"+"."+"href", "body", string(o.Href)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentParamsBodyLinksSelf) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentParamsBodyLinksSelf) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentParamsBodyLinksSelf
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentParamsBodyMerchantInformation patch customers payment instrument params body merchant information
swagger:model PatchCustomersPaymentInstrumentParamsBodyMerchantInformation
*/
type PatchCustomersPaymentInstrumentParamsBodyMerchantInformation struct {

	// merchant descriptor
	MerchantDescriptor *PatchCustomersPaymentInstrumentParamsBodyMerchantInformationMerchantDescriptor `json:"merchantDescriptor,omitempty"`
}

// Validate validates this patch customers payment instrument params body merchant information
func (o *PatchCustomersPaymentInstrumentParamsBodyMerchantInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateMerchantDescriptor(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyMerchantInformation) validateMerchantDescriptor(formats strfmt.Registry) error {
	if swag.IsZero(o.MerchantDescriptor) { // not required
		return nil
	}

	if o.MerchantDescriptor != nil {
		if err := o.MerchantDescriptor.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "merchantInformation" + "." + "merchantDescriptor")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "merchantInformation" + "." + "merchantDescriptor")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch customers payment instrument params body merchant information based on the context it is used
func (o *PatchCustomersPaymentInstrumentParamsBodyMerchantInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateMerchantDescriptor(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyMerchantInformation) contextValidateMerchantDescriptor(ctx context.Context, formats strfmt.Registry) error {

	if o.MerchantDescriptor != nil {
		if err := o.MerchantDescriptor.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "merchantInformation" + "." + "merchantDescriptor")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "merchantInformation" + "." + "merchantDescriptor")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentParamsBodyMerchantInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentParamsBodyMerchantInformation) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentParamsBodyMerchantInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentParamsBodyMerchantInformationMerchantDescriptor patch customers payment instrument params body merchant information merchant descriptor
swagger:model PatchCustomersPaymentInstrumentParamsBodyMerchantInformationMerchantDescriptor
*/
type PatchCustomersPaymentInstrumentParamsBodyMerchantInformationMerchantDescriptor struct {

	// Alternate contact information for your business,such as an email address or URL.
	// This value might be displayed on the cardholders statement.
	// When you do not include this value in your capture or credit request, CyberSource uses the merchant URL from your CyberSource account.
	// Important This value must consist of English characters
	//
	// Max Length: 13
	AlternateName string `json:"alternateName,omitempty"`
}

// Validate validates this patch customers payment instrument params body merchant information merchant descriptor
func (o *PatchCustomersPaymentInstrumentParamsBodyMerchantInformationMerchantDescriptor) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAlternateName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyMerchantInformationMerchantDescriptor) validateAlternateName(formats strfmt.Registry) error {
	if swag.IsZero(o.AlternateName) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerPaymentInstrumentRequest"+"."+"merchantInformation"+"."+"merchantDescriptor"+"."+"alternateName", "body", o.AlternateName, 13); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this patch customers payment instrument params body merchant information merchant descriptor based on context it is used
func (o *PatchCustomersPaymentInstrumentParamsBodyMerchantInformationMerchantDescriptor) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentParamsBodyMerchantInformationMerchantDescriptor) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentParamsBodyMerchantInformationMerchantDescriptor) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentParamsBodyMerchantInformationMerchantDescriptor
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentParamsBodyMetadata patch customers payment instrument params body metadata
swagger:model PatchCustomersPaymentInstrumentParamsBodyMetadata
*/
type PatchCustomersPaymentInstrumentParamsBodyMetadata struct {

	// The creator of the Payment Instrument token.
	//
	// Read Only: true
	Creator string `json:"creator,omitempty"`
}

// Validate validates this patch customers payment instrument params body metadata
func (o *PatchCustomersPaymentInstrumentParamsBodyMetadata) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this patch customers payment instrument params body metadata based on the context it is used
func (o *PatchCustomersPaymentInstrumentParamsBodyMetadata) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateCreator(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyMetadata) contextValidateCreator(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerPaymentInstrumentRequest"+"."+"metadata"+"."+"creator", "body", string(o.Creator)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentParamsBodyMetadata) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentParamsBodyMetadata) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentParamsBodyMetadata
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentParamsBodyProcessingInformation patch customers payment instrument params body processing information
swagger:model PatchCustomersPaymentInstrumentParamsBodyProcessingInformation
*/
type PatchCustomersPaymentInstrumentParamsBodyProcessingInformation struct {

	// bank transfer options
	BankTransferOptions *PatchCustomersPaymentInstrumentParamsBodyProcessingInformationBankTransferOptions `json:"bankTransferOptions,omitempty"`

	// Flag that indicates that this is a payment for a bill or for an existing contractual loan.
	// For processor-specific details, see the `bill_payment` field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// Valid values:
	// - `true`: Bill payment or loan payment.
	// - `false` (default): Not a bill payment or loan payment.
	//
	BillPaymentProgramEnabled bool `json:"billPaymentProgramEnabled,omitempty"`
}

// Validate validates this patch customers payment instrument params body processing information
func (o *PatchCustomersPaymentInstrumentParamsBodyProcessingInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateBankTransferOptions(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyProcessingInformation) validateBankTransferOptions(formats strfmt.Registry) error {
	if swag.IsZero(o.BankTransferOptions) { // not required
		return nil
	}

	if o.BankTransferOptions != nil {
		if err := o.BankTransferOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "processingInformation" + "." + "bankTransferOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "processingInformation" + "." + "bankTransferOptions")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch customers payment instrument params body processing information based on the context it is used
func (o *PatchCustomersPaymentInstrumentParamsBodyProcessingInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateBankTransferOptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyProcessingInformation) contextValidateBankTransferOptions(ctx context.Context, formats strfmt.Registry) error {

	if o.BankTransferOptions != nil {
		if err := o.BankTransferOptions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "processingInformation" + "." + "bankTransferOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerPaymentInstrumentRequest" + "." + "processingInformation" + "." + "bankTransferOptions")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentParamsBodyProcessingInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentParamsBodyProcessingInformation) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentParamsBodyProcessingInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentParamsBodyProcessingInformationBankTransferOptions patch customers payment instrument params body processing information bank transfer options
swagger:model PatchCustomersPaymentInstrumentParamsBodyProcessingInformationBankTransferOptions
*/
type PatchCustomersPaymentInstrumentParamsBodyProcessingInformationBankTransferOptions struct {

	// Specifies the authorization method for the transaction.
	//
	// #### TeleCheck
	// Valid values:
	// - `ARC`: account receivable conversion
	// - `CCD`: corporate cash disbursement
	// - `POP`: point of purchase conversion
	// - `PPD`: prearranged payment and deposit entry
	// - `TEL`: telephone-initiated entry
	// - `WEB`: internet-initiated entry
	//
	// For details, see `ecp_sec_code` field description in the [Electronic Check Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/EChecks_SCMP_API/html/)
	//
	// Max Length: 3
	SECCode string `json:"SECCode,omitempty"`
}

// Validate validates this patch customers payment instrument params body processing information bank transfer options
func (o *PatchCustomersPaymentInstrumentParamsBodyProcessingInformationBankTransferOptions) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateSECCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentParamsBodyProcessingInformationBankTransferOptions) validateSECCode(formats strfmt.Registry) error {
	if swag.IsZero(o.SECCode) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerPaymentInstrumentRequest"+"."+"processingInformation"+"."+"bankTransferOptions"+"."+"SECCode", "body", o.SECCode, 3); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this patch customers payment instrument params body processing information bank transfer options based on context it is used
func (o *PatchCustomersPaymentInstrumentParamsBodyProcessingInformationBankTransferOptions) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentParamsBodyProcessingInformationBankTransferOptions) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentParamsBodyProcessingInformationBankTransferOptions) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentParamsBodyProcessingInformationBankTransferOptions
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentPreconditionFailedBody patch customers payment instrument precondition failed body
swagger:model PatchCustomersPaymentInstrumentPreconditionFailedBody
*/
type PatchCustomersPaymentInstrumentPreconditionFailedBody struct {

	// errors
	// Read Only: true
	Errors []*PatchCustomersPaymentInstrumentPreconditionFailedBodyErrorsItems0 `json:"errors"`
}

// Validate validates this patch customers payment instrument precondition failed body
func (o *PatchCustomersPaymentInstrumentPreconditionFailedBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateErrors(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentPreconditionFailedBody) validateErrors(formats strfmt.Registry) error {
	if swag.IsZero(o.Errors) { // not required
		return nil
	}

	for i := 0; i < len(o.Errors); i++ {
		if swag.IsZero(o.Errors[i]) { // not required
			continue
		}

		if o.Errors[i] != nil {
			if err := o.Errors[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("patchCustomersPaymentInstrumentPreconditionFailed" + "." + "errors" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("patchCustomersPaymentInstrumentPreconditionFailed" + "." + "errors" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this patch customers payment instrument precondition failed body based on the context it is used
func (o *PatchCustomersPaymentInstrumentPreconditionFailedBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateErrors(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentPreconditionFailedBody) contextValidateErrors(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomersPaymentInstrumentPreconditionFailed"+"."+"errors", "body", []*PatchCustomersPaymentInstrumentPreconditionFailedBodyErrorsItems0(o.Errors)); err != nil {
		return err
	}

	for i := 0; i < len(o.Errors); i++ {

		if o.Errors[i] != nil {
			if err := o.Errors[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("patchCustomersPaymentInstrumentPreconditionFailed" + "." + "errors" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("patchCustomersPaymentInstrumentPreconditionFailed" + "." + "errors" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentPreconditionFailedBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentPreconditionFailedBody) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentPreconditionFailedBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentPreconditionFailedBodyErrorsItems0 patch customers payment instrument precondition failed body errors items0
swagger:model PatchCustomersPaymentInstrumentPreconditionFailedBodyErrorsItems0
*/
type PatchCustomersPaymentInstrumentPreconditionFailedBodyErrorsItems0 struct {

	// details
	// Read Only: true
	Details []*PatchCustomersPaymentInstrumentPreconditionFailedBodyErrorsItems0DetailsItems0 `json:"details"`

	// The detailed message related to the type stated above.
	// Read Only: true
	Message string `json:"message,omitempty"`

	// The type of error.
	// Read Only: true
	Type string `json:"type,omitempty"`
}

// Validate validates this patch customers payment instrument precondition failed body errors items0
func (o *PatchCustomersPaymentInstrumentPreconditionFailedBodyErrorsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentPreconditionFailedBodyErrorsItems0) validateDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.Details) { // not required
		return nil
	}

	for i := 0; i < len(o.Details); i++ {
		if swag.IsZero(o.Details[i]) { // not required
			continue
		}

		if o.Details[i] != nil {
			if err := o.Details[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this patch customers payment instrument precondition failed body errors items0 based on the context it is used
func (o *PatchCustomersPaymentInstrumentPreconditionFailedBodyErrorsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateMessage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentPreconditionFailedBodyErrorsItems0) contextValidateDetails(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "details", "body", []*PatchCustomersPaymentInstrumentPreconditionFailedBodyErrorsItems0DetailsItems0(o.Details)); err != nil {
		return err
	}

	for i := 0; i < len(o.Details); i++ {

		if o.Details[i] != nil {
			if err := o.Details[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentPreconditionFailedBodyErrorsItems0) contextValidateMessage(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "message", "body", string(o.Message)); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentPreconditionFailedBodyErrorsItems0) contextValidateType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "type", "body", string(o.Type)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentPreconditionFailedBodyErrorsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentPreconditionFailedBodyErrorsItems0) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentPreconditionFailedBodyErrorsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomersPaymentInstrumentPreconditionFailedBodyErrorsItems0DetailsItems0 patch customers payment instrument precondition failed body errors items0 details items0
swagger:model PatchCustomersPaymentInstrumentPreconditionFailedBodyErrorsItems0DetailsItems0
*/
type PatchCustomersPaymentInstrumentPreconditionFailedBodyErrorsItems0DetailsItems0 struct {

	// The location of the field that caused the error.
	// Read Only: true
	Location string `json:"location,omitempty"`

	// The name of the field that caused the error.
	// Read Only: true
	Name string `json:"name,omitempty"`
}

// Validate validates this patch customers payment instrument precondition failed body errors items0 details items0
func (o *PatchCustomersPaymentInstrumentPreconditionFailedBodyErrorsItems0DetailsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this patch customers payment instrument precondition failed body errors items0 details items0 based on the context it is used
func (o *PatchCustomersPaymentInstrumentPreconditionFailedBodyErrorsItems0DetailsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateLocation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomersPaymentInstrumentPreconditionFailedBodyErrorsItems0DetailsItems0) contextValidateLocation(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "location", "body", string(o.Location)); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomersPaymentInstrumentPreconditionFailedBodyErrorsItems0DetailsItems0) contextValidateName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "name", "body", string(o.Name)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentPreconditionFailedBodyErrorsItems0DetailsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomersPaymentInstrumentPreconditionFailedBodyErrorsItems0DetailsItems0) UnmarshalBinary(b []byte) error {
	var res PatchCustomersPaymentInstrumentPreconditionFailedBodyErrorsItems0DetailsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}
