// Code generated by go-swagger; DO NOT EDIT.

package payer_authentication

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"fmt"
	"io"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// PayerAuthSetupReader is a Reader for the PayerAuthSetup structure.
type PayerAuthSetupReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *PayerAuthSetupReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 201:
		result := NewPayerAuthSetupCreated()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	case 400:
		result := NewPayerAuthSetupBadRequest()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 502:
		result := NewPayerAuthSetupBadGateway()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	default:
		return nil, runtime.NewAPIError("response status code does not match any response statuses defined for this endpoint in the swagger spec", response, response.Code())
	}
}

// NewPayerAuthSetupCreated creates a PayerAuthSetupCreated with default headers values
func NewPayerAuthSetupCreated() *PayerAuthSetupCreated {
	return &PayerAuthSetupCreated{}
}

/* PayerAuthSetupCreated describes a response with status code 201, with default header values.

Setup completed
*/
type PayerAuthSetupCreated struct {
	Payload *PayerAuthSetupCreatedBody
}

func (o *PayerAuthSetupCreated) Error() string {
	return fmt.Sprintf("[POST /risk/v1/authentication-setups][%d] payerAuthSetupCreated  %+v", 201, o.Payload)
}
func (o *PayerAuthSetupCreated) GetPayload() *PayerAuthSetupCreatedBody {
	return o.Payload
}

func (o *PayerAuthSetupCreated) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(PayerAuthSetupCreatedBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPayerAuthSetupBadRequest creates a PayerAuthSetupBadRequest with default headers values
func NewPayerAuthSetupBadRequest() *PayerAuthSetupBadRequest {
	return &PayerAuthSetupBadRequest{}
}

/* PayerAuthSetupBadRequest describes a response with status code 400, with default header values.

Invalid request
*/
type PayerAuthSetupBadRequest struct {
	Payload *PayerAuthSetupBadRequestBody
}

func (o *PayerAuthSetupBadRequest) Error() string {
	return fmt.Sprintf("[POST /risk/v1/authentication-setups][%d] payerAuthSetupBadRequest  %+v", 400, o.Payload)
}
func (o *PayerAuthSetupBadRequest) GetPayload() *PayerAuthSetupBadRequestBody {
	return o.Payload
}

func (o *PayerAuthSetupBadRequest) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(PayerAuthSetupBadRequestBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPayerAuthSetupBadGateway creates a PayerAuthSetupBadGateway with default headers values
func NewPayerAuthSetupBadGateway() *PayerAuthSetupBadGateway {
	return &PayerAuthSetupBadGateway{}
}

/* PayerAuthSetupBadGateway describes a response with status code 502, with default header values.

Unexpected system error or system timeout.
*/
type PayerAuthSetupBadGateway struct {
	Payload *PayerAuthSetupBadGatewayBody
}

func (o *PayerAuthSetupBadGateway) Error() string {
	return fmt.Sprintf("[POST /risk/v1/authentication-setups][%d] payerAuthSetupBadGateway  %+v", 502, o.Payload)
}
func (o *PayerAuthSetupBadGateway) GetPayload() *PayerAuthSetupBadGatewayBody {
	return o.Payload
}

func (o *PayerAuthSetupBadGateway) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(PayerAuthSetupBadGatewayBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

/*PayerAuthSetupBadGatewayBody riskV1AuthenticationsPost502Response
swagger:model PayerAuthSetupBadGatewayBody
*/
type PayerAuthSetupBadGatewayBody struct {

	// The detail message related to the status and reason listed above.
	Message string `json:"message,omitempty"`

	// The reason of the status.
	//
	// Possible values:
	//  - SYSTEM_ERROR
	//  - SERVER_TIMEOUT
	//  - SERVICE_TIMEOUT
	//
	Reason string `json:"reason,omitempty"`

	// The status of the submitted transaction.
	//
	// Possible values:
	//  - SERVER_ERROR
	//
	Status string `json:"status,omitempty"`

	// Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ`
	// **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.).
	// The `T` separates the date and the time. The `Z` indicates UTC.
	//
	// Returned by Cybersource for all services.
	//
	SubmitTimeUtc string `json:"submitTimeUtc,omitempty"`
}

// Validate validates this payer auth setup bad gateway body
func (o *PayerAuthSetupBadGatewayBody) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this payer auth setup bad gateway body based on context it is used
func (o *PayerAuthSetupBadGatewayBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PayerAuthSetupBadGatewayBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PayerAuthSetupBadGatewayBody) UnmarshalBinary(b []byte) error {
	var res PayerAuthSetupBadGatewayBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PayerAuthSetupBadRequestBody riskV1AuthenticationsPost400Response
swagger:model PayerAuthSetupBadRequestBody
*/
type PayerAuthSetupBadRequestBody struct {

	// details
	Details []*PayerAuthSetupBadRequestBodyDetailsItems0 `json:"details"`

	// The message describing the reason of the status. Value is:
	// - Encountered a Payer Authentication problem. Payer could not be setup.
	//
	Message string `json:"message,omitempty"`

	// The reason of the status.
	//
	Reason string `json:"reason,omitempty"`

	// The status for payerAuthentication 400 setup calls. Possible values are:
	// - INVALID_REQUEST
	//
	Status string `json:"status,omitempty"`

	// Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ`
	// **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.).
	// The `T` separates the date and the time. The `Z` indicates UTC.
	//
	// Returned by Cybersource for all services.
	//
	SubmitTimeUtc string `json:"submitTimeUtc,omitempty"`
}

// Validate validates this payer auth setup bad request body
func (o *PayerAuthSetupBadRequestBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PayerAuthSetupBadRequestBody) validateDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.Details) { // not required
		return nil
	}

	for i := 0; i < len(o.Details); i++ {
		if swag.IsZero(o.Details[i]) { // not required
			continue
		}

		if o.Details[i] != nil {
			if err := o.Details[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("payerAuthSetupBadRequest" + "." + "details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("payerAuthSetupBadRequest" + "." + "details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this payer auth setup bad request body based on the context it is used
func (o *PayerAuthSetupBadRequestBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PayerAuthSetupBadRequestBody) contextValidateDetails(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.Details); i++ {

		if o.Details[i] != nil {
			if err := o.Details[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("payerAuthSetupBadRequest" + "." + "details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("payerAuthSetupBadRequest" + "." + "details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *PayerAuthSetupBadRequestBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PayerAuthSetupBadRequestBody) UnmarshalBinary(b []byte) error {
	var res PayerAuthSetupBadRequestBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PayerAuthSetupBadRequestBodyDetailsItems0 payer auth setup bad request body details items0
swagger:model PayerAuthSetupBadRequestBodyDetailsItems0
*/
type PayerAuthSetupBadRequestBodyDetailsItems0 struct {

	// This is the flattened JSON object field name/path that is either missing or invalid.
	Field string `json:"field,omitempty"`

	// Possible reasons for the error.
	//
	// Possible values:
	//  - MISSING_FIELD
	//  - INVALID_DATA
	//
	Reason string `json:"reason,omitempty"`
}

// Validate validates this payer auth setup bad request body details items0
func (o *PayerAuthSetupBadRequestBodyDetailsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this payer auth setup bad request body details items0 based on context it is used
func (o *PayerAuthSetupBadRequestBodyDetailsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PayerAuthSetupBadRequestBodyDetailsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PayerAuthSetupBadRequestBodyDetailsItems0) UnmarshalBinary(b []byte) error {
	var res PayerAuthSetupBadRequestBodyDetailsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PayerAuthSetupBody payer auth setup body
swagger:model PayerAuthSetupBody
*/
type PayerAuthSetupBody struct {

	// client reference information
	ClientReferenceInformation *PayerAuthSetupParamsBodyClientReferenceInformation `json:"clientReferenceInformation,omitempty"`

	// payment information
	PaymentInformation *PayerAuthSetupParamsBodyPaymentInformation `json:"paymentInformation,omitempty"`

	// processing information
	ProcessingInformation *PayerAuthSetupParamsBodyProcessingInformation `json:"processingInformation,omitempty"`

	// token information
	TokenInformation *PayerAuthSetupParamsBodyTokenInformation `json:"tokenInformation,omitempty"`
}

// Validate validates this payer auth setup body
func (o *PayerAuthSetupBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateClientReferenceInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePaymentInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProcessingInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTokenInformation(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PayerAuthSetupBody) validateClientReferenceInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ClientReferenceInformation) { // not required
		return nil
	}

	if o.ClientReferenceInformation != nil {
		if err := o.ClientReferenceInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("payerAuthSetupRequest" + "." + "clientReferenceInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("payerAuthSetupRequest" + "." + "clientReferenceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *PayerAuthSetupBody) validatePaymentInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.PaymentInformation) { // not required
		return nil
	}

	if o.PaymentInformation != nil {
		if err := o.PaymentInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("payerAuthSetupRequest" + "." + "paymentInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("payerAuthSetupRequest" + "." + "paymentInformation")
			}
			return err
		}
	}

	return nil
}

func (o *PayerAuthSetupBody) validateProcessingInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ProcessingInformation) { // not required
		return nil
	}

	if o.ProcessingInformation != nil {
		if err := o.ProcessingInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("payerAuthSetupRequest" + "." + "processingInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("payerAuthSetupRequest" + "." + "processingInformation")
			}
			return err
		}
	}

	return nil
}

func (o *PayerAuthSetupBody) validateTokenInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.TokenInformation) { // not required
		return nil
	}

	if o.TokenInformation != nil {
		if err := o.TokenInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("payerAuthSetupRequest" + "." + "tokenInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("payerAuthSetupRequest" + "." + "tokenInformation")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this payer auth setup body based on the context it is used
func (o *PayerAuthSetupBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateClientReferenceInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidatePaymentInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateProcessingInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateTokenInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PayerAuthSetupBody) contextValidateClientReferenceInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ClientReferenceInformation != nil {
		if err := o.ClientReferenceInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("payerAuthSetupRequest" + "." + "clientReferenceInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("payerAuthSetupRequest" + "." + "clientReferenceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *PayerAuthSetupBody) contextValidatePaymentInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.PaymentInformation != nil {
		if err := o.PaymentInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("payerAuthSetupRequest" + "." + "paymentInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("payerAuthSetupRequest" + "." + "paymentInformation")
			}
			return err
		}
	}

	return nil
}

func (o *PayerAuthSetupBody) contextValidateProcessingInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ProcessingInformation != nil {
		if err := o.ProcessingInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("payerAuthSetupRequest" + "." + "processingInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("payerAuthSetupRequest" + "." + "processingInformation")
			}
			return err
		}
	}

	return nil
}

func (o *PayerAuthSetupBody) contextValidateTokenInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.TokenInformation != nil {
		if err := o.TokenInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("payerAuthSetupRequest" + "." + "tokenInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("payerAuthSetupRequest" + "." + "tokenInformation")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PayerAuthSetupBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PayerAuthSetupBody) UnmarshalBinary(b []byte) error {
	var res PayerAuthSetupBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PayerAuthSetupCreatedBody riskV1AuthenticationSetupsPost201Response
swagger:model PayerAuthSetupCreatedBody
*/
type PayerAuthSetupCreatedBody struct {

	// links
	Links *PayerAuthSetupCreatedBodyLinks `json:"_links,omitempty"`

	// client reference information
	ClientReferenceInformation *PayerAuthSetupCreatedBodyClientReferenceInformation `json:"clientReferenceInformation,omitempty"`

	// consumer authentication information
	ConsumerAuthenticationInformation *PayerAuthSetupCreatedBodyConsumerAuthenticationInformation `json:"consumerAuthenticationInformation,omitempty"`

	// error information
	ErrorInformation *PayerAuthSetupCreatedBodyErrorInformation `json:"errorInformation,omitempty"`

	// An unique identification number generated by Cybersource to identify the submitted request. Returned by all services.
	// It is also appended to the endpoint of the resource.
	// On incremental authorizations, this value with be the same as the identification number returned in the original authorization response.
	//
	// Max Length: 26
	ID string `json:"id,omitempty"`

	// The status for payerAuthentication 201 setup calls. Possible value is:
	// - COMPLETED
	// - FAILED
	//
	Status string `json:"status,omitempty"`

	// Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ`
	// **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.).
	// The `T` separates the date and the time. The `Z` indicates UTC.
	//
	// Returned by Cybersource for all services.
	//
	SubmitTimeUtc string `json:"submitTimeUtc,omitempty"`
}

// Validate validates this payer auth setup created body
func (o *PayerAuthSetupCreatedBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateClientReferenceInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateConsumerAuthenticationInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateErrorInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PayerAuthSetupCreatedBody) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(o.Links) { // not required
		return nil
	}

	if o.Links != nil {
		if err := o.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("payerAuthSetupCreated" + "." + "_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("payerAuthSetupCreated" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (o *PayerAuthSetupCreatedBody) validateClientReferenceInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ClientReferenceInformation) { // not required
		return nil
	}

	if o.ClientReferenceInformation != nil {
		if err := o.ClientReferenceInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("payerAuthSetupCreated" + "." + "clientReferenceInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("payerAuthSetupCreated" + "." + "clientReferenceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *PayerAuthSetupCreatedBody) validateConsumerAuthenticationInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ConsumerAuthenticationInformation) { // not required
		return nil
	}

	if o.ConsumerAuthenticationInformation != nil {
		if err := o.ConsumerAuthenticationInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("payerAuthSetupCreated" + "." + "consumerAuthenticationInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("payerAuthSetupCreated" + "." + "consumerAuthenticationInformation")
			}
			return err
		}
	}

	return nil
}

func (o *PayerAuthSetupCreatedBody) validateErrorInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ErrorInformation) { // not required
		return nil
	}

	if o.ErrorInformation != nil {
		if err := o.ErrorInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("payerAuthSetupCreated" + "." + "errorInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("payerAuthSetupCreated" + "." + "errorInformation")
			}
			return err
		}
	}

	return nil
}

func (o *PayerAuthSetupCreatedBody) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MaxLength("payerAuthSetupCreated"+"."+"id", "body", o.ID, 26); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this payer auth setup created body based on the context it is used
func (o *PayerAuthSetupCreatedBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateClientReferenceInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateConsumerAuthenticationInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateErrorInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PayerAuthSetupCreatedBody) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if o.Links != nil {
		if err := o.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("payerAuthSetupCreated" + "." + "_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("payerAuthSetupCreated" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (o *PayerAuthSetupCreatedBody) contextValidateClientReferenceInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ClientReferenceInformation != nil {
		if err := o.ClientReferenceInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("payerAuthSetupCreated" + "." + "clientReferenceInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("payerAuthSetupCreated" + "." + "clientReferenceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *PayerAuthSetupCreatedBody) contextValidateConsumerAuthenticationInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ConsumerAuthenticationInformation != nil {
		if err := o.ConsumerAuthenticationInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("payerAuthSetupCreated" + "." + "consumerAuthenticationInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("payerAuthSetupCreated" + "." + "consumerAuthenticationInformation")
			}
			return err
		}
	}

	return nil
}

func (o *PayerAuthSetupCreatedBody) contextValidateErrorInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ErrorInformation != nil {
		if err := o.ErrorInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("payerAuthSetupCreated" + "." + "errorInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("payerAuthSetupCreated" + "." + "errorInformation")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PayerAuthSetupCreatedBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PayerAuthSetupCreatedBody) UnmarshalBinary(b []byte) error {
	var res PayerAuthSetupCreatedBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PayerAuthSetupCreatedBodyClientReferenceInformation payer auth setup created body client reference information
swagger:model PayerAuthSetupCreatedBodyClientReferenceInformation
*/
type PayerAuthSetupCreatedBodyClientReferenceInformation struct {

	// Merchant-generated order reference or tracking number. It is recommended that you send a unique value for each
	// transaction so that you can perform meaningful searches for the transaction.
	//
	// #### Used by
	// **Authorization**
	// Required field.
	//
	// #### PIN Debit
	// Requests for PIN debit reversals need to use the same merchant reference number that was used in the transaction that is being
	// reversed.
	//
	// Required field for all PIN Debit requests (purchase, credit, and reversal).
	//
	// #### FDC Nashville Global
	// Certain circumstances can cause the processor to truncate this value to 15 or 17 characters for Level II and Level III processing, which can cause a discrepancy between the value you submit and the value included in some processor reports.
	//
	// Max Length: 50
	Code string `json:"code,omitempty"`

	// Brief description of the order or any comment you wish to add to the order.
	//
	// Max Length: 255
	Comments string `json:"comments,omitempty"`

	// partner
	Partner *PayerAuthSetupCreatedBodyClientReferenceInformationPartner `json:"partner,omitempty"`
}

// Validate validates this payer auth setup created body client reference information
func (o *PayerAuthSetupCreatedBodyClientReferenceInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateComments(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePartner(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PayerAuthSetupCreatedBodyClientReferenceInformation) validateCode(formats strfmt.Registry) error {
	if swag.IsZero(o.Code) { // not required
		return nil
	}

	if err := validate.MaxLength("payerAuthSetupCreated"+"."+"clientReferenceInformation"+"."+"code", "body", o.Code, 50); err != nil {
		return err
	}

	return nil
}

func (o *PayerAuthSetupCreatedBodyClientReferenceInformation) validateComments(formats strfmt.Registry) error {
	if swag.IsZero(o.Comments) { // not required
		return nil
	}

	if err := validate.MaxLength("payerAuthSetupCreated"+"."+"clientReferenceInformation"+"."+"comments", "body", o.Comments, 255); err != nil {
		return err
	}

	return nil
}

func (o *PayerAuthSetupCreatedBodyClientReferenceInformation) validatePartner(formats strfmt.Registry) error {
	if swag.IsZero(o.Partner) { // not required
		return nil
	}

	if o.Partner != nil {
		if err := o.Partner.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("payerAuthSetupCreated" + "." + "clientReferenceInformation" + "." + "partner")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("payerAuthSetupCreated" + "." + "clientReferenceInformation" + "." + "partner")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this payer auth setup created body client reference information based on the context it is used
func (o *PayerAuthSetupCreatedBodyClientReferenceInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidatePartner(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PayerAuthSetupCreatedBodyClientReferenceInformation) contextValidatePartner(ctx context.Context, formats strfmt.Registry) error {

	if o.Partner != nil {
		if err := o.Partner.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("payerAuthSetupCreated" + "." + "clientReferenceInformation" + "." + "partner")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("payerAuthSetupCreated" + "." + "clientReferenceInformation" + "." + "partner")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PayerAuthSetupCreatedBodyClientReferenceInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PayerAuthSetupCreatedBodyClientReferenceInformation) UnmarshalBinary(b []byte) error {
	var res PayerAuthSetupCreatedBodyClientReferenceInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PayerAuthSetupCreatedBodyClientReferenceInformationPartner payer auth setup created body client reference information partner
swagger:model PayerAuthSetupCreatedBodyClientReferenceInformationPartner
*/
type PayerAuthSetupCreatedBodyClientReferenceInformationPartner struct {

	// Identifier for the developer that helped integrate a partner solution to CyberSource.
	//
	// Send this value in all requests that are sent through the partner solutions built by that developer.
	// CyberSource assigns the ID to the developer.
	//
	// **Note** When you see a developer ID of 999 in reports, the developer ID that was submitted is incorrect.
	//
	// Max Length: 8
	DeveloperID string `json:"developerId,omitempty"`

	// Identifier for the partner that is integrated to CyberSource.
	//
	// Send this value in all requests that are sent through the partner solution. CyberSource assigns the ID to the partner.
	//
	// **Note** When you see a solutionId of 999 in reports, the solutionId that was submitted is incorrect.
	//
	// Max Length: 8
	SolutionID string `json:"solutionId,omitempty"`
}

// Validate validates this payer auth setup created body client reference information partner
func (o *PayerAuthSetupCreatedBodyClientReferenceInformationPartner) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDeveloperID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSolutionID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PayerAuthSetupCreatedBodyClientReferenceInformationPartner) validateDeveloperID(formats strfmt.Registry) error {
	if swag.IsZero(o.DeveloperID) { // not required
		return nil
	}

	if err := validate.MaxLength("payerAuthSetupCreated"+"."+"clientReferenceInformation"+"."+"partner"+"."+"developerId", "body", o.DeveloperID, 8); err != nil {
		return err
	}

	return nil
}

func (o *PayerAuthSetupCreatedBodyClientReferenceInformationPartner) validateSolutionID(formats strfmt.Registry) error {
	if swag.IsZero(o.SolutionID) { // not required
		return nil
	}

	if err := validate.MaxLength("payerAuthSetupCreated"+"."+"clientReferenceInformation"+"."+"partner"+"."+"solutionId", "body", o.SolutionID, 8); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this payer auth setup created body client reference information partner based on context it is used
func (o *PayerAuthSetupCreatedBodyClientReferenceInformationPartner) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PayerAuthSetupCreatedBodyClientReferenceInformationPartner) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PayerAuthSetupCreatedBodyClientReferenceInformationPartner) UnmarshalBinary(b []byte) error {
	var res PayerAuthSetupCreatedBodyClientReferenceInformationPartner
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PayerAuthSetupCreatedBodyConsumerAuthenticationInformation payer auth setup created body consumer authentication information
swagger:model PayerAuthSetupCreatedBodyConsumerAuthenticationInformation
*/
type PayerAuthSetupCreatedBodyConsumerAuthenticationInformation struct {

	// JSON Web Token (JWT) used to authenticate the consumer with the authentication provider, such as, CardinalCommerce or Rupay.
	// Note - Max Length of this field is 2048 characters.
	//
	AccessToken string `json:"accessToken,omitempty"`

	// The deviceDataCollectionUrl is the location to send the Authentication JWT when invoking the Device Data collection process.
	//
	// Max Length: 100
	DeviceDataCollectionURL string `json:"deviceDataCollectionUrl,omitempty"`

	// This identifier represents cardinal has started device data collection session and this must be passed in
	// Authentication JWT to Cardinal when invoking the deviceDataCollectionUrl.
	//
	// Max Length: 50
	ReferenceID string `json:"referenceId,omitempty"`
}

// Validate validates this payer auth setup created body consumer authentication information
func (o *PayerAuthSetupCreatedBodyConsumerAuthenticationInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDeviceDataCollectionURL(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateReferenceID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PayerAuthSetupCreatedBodyConsumerAuthenticationInformation) validateDeviceDataCollectionURL(formats strfmt.Registry) error {
	if swag.IsZero(o.DeviceDataCollectionURL) { // not required
		return nil
	}

	if err := validate.MaxLength("payerAuthSetupCreated"+"."+"consumerAuthenticationInformation"+"."+"deviceDataCollectionUrl", "body", o.DeviceDataCollectionURL, 100); err != nil {
		return err
	}

	return nil
}

func (o *PayerAuthSetupCreatedBodyConsumerAuthenticationInformation) validateReferenceID(formats strfmt.Registry) error {
	if swag.IsZero(o.ReferenceID) { // not required
		return nil
	}

	if err := validate.MaxLength("payerAuthSetupCreated"+"."+"consumerAuthenticationInformation"+"."+"referenceId", "body", o.ReferenceID, 50); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this payer auth setup created body consumer authentication information based on context it is used
func (o *PayerAuthSetupCreatedBodyConsumerAuthenticationInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PayerAuthSetupCreatedBodyConsumerAuthenticationInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PayerAuthSetupCreatedBodyConsumerAuthenticationInformation) UnmarshalBinary(b []byte) error {
	var res PayerAuthSetupCreatedBodyConsumerAuthenticationInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PayerAuthSetupCreatedBodyErrorInformation payer auth setup created body error information
swagger:model PayerAuthSetupCreatedBodyErrorInformation
*/
type PayerAuthSetupCreatedBodyErrorInformation struct {

	// details
	Details []*PayerAuthSetupCreatedBodyErrorInformationDetailsItems0 `json:"details"`

	// The detail message related to the status and reason listed above.
	Message string `json:"message,omitempty"`

	// The reason of the status.
	//
	// Possible values:
	//  - EXPIRED_CARD
	//  - GENERAL_DECLINE
	//
	Reason string `json:"reason,omitempty"`
}

// Validate validates this payer auth setup created body error information
func (o *PayerAuthSetupCreatedBodyErrorInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PayerAuthSetupCreatedBodyErrorInformation) validateDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.Details) { // not required
		return nil
	}

	for i := 0; i < len(o.Details); i++ {
		if swag.IsZero(o.Details[i]) { // not required
			continue
		}

		if o.Details[i] != nil {
			if err := o.Details[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("payerAuthSetupCreated" + "." + "errorInformation" + "." + "details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("payerAuthSetupCreated" + "." + "errorInformation" + "." + "details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this payer auth setup created body error information based on the context it is used
func (o *PayerAuthSetupCreatedBodyErrorInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PayerAuthSetupCreatedBodyErrorInformation) contextValidateDetails(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.Details); i++ {

		if o.Details[i] != nil {
			if err := o.Details[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("payerAuthSetupCreated" + "." + "errorInformation" + "." + "details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("payerAuthSetupCreated" + "." + "errorInformation" + "." + "details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *PayerAuthSetupCreatedBodyErrorInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PayerAuthSetupCreatedBodyErrorInformation) UnmarshalBinary(b []byte) error {
	var res PayerAuthSetupCreatedBodyErrorInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PayerAuthSetupCreatedBodyErrorInformationDetailsItems0 payer auth setup created body error information details items0
swagger:model PayerAuthSetupCreatedBodyErrorInformationDetailsItems0
*/
type PayerAuthSetupCreatedBodyErrorInformationDetailsItems0 struct {

	// This is the flattened JSON object field name/path that is either missing or invalid.
	Field string `json:"field,omitempty"`

	// Possible reasons for the error.
	//
	// Possible values:
	//  - MISSING_FIELD
	//  - INVALID_DATA
	//
	Reason string `json:"reason,omitempty"`
}

// Validate validates this payer auth setup created body error information details items0
func (o *PayerAuthSetupCreatedBodyErrorInformationDetailsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this payer auth setup created body error information details items0 based on context it is used
func (o *PayerAuthSetupCreatedBodyErrorInformationDetailsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PayerAuthSetupCreatedBodyErrorInformationDetailsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PayerAuthSetupCreatedBodyErrorInformationDetailsItems0) UnmarshalBinary(b []byte) error {
	var res PayerAuthSetupCreatedBodyErrorInformationDetailsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PayerAuthSetupCreatedBodyLinks payer auth setup created body links
swagger:model PayerAuthSetupCreatedBodyLinks
*/
type PayerAuthSetupCreatedBodyLinks struct {

	// self
	Self *PayerAuthSetupCreatedBodyLinksSelf `json:"self,omitempty"`
}

// Validate validates this payer auth setup created body links
func (o *PayerAuthSetupCreatedBodyLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PayerAuthSetupCreatedBodyLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(o.Self) { // not required
		return nil
	}

	if o.Self != nil {
		if err := o.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("payerAuthSetupCreated" + "." + "_links" + "." + "self")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("payerAuthSetupCreated" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this payer auth setup created body links based on the context it is used
func (o *PayerAuthSetupCreatedBodyLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PayerAuthSetupCreatedBodyLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if o.Self != nil {
		if err := o.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("payerAuthSetupCreated" + "." + "_links" + "." + "self")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("payerAuthSetupCreated" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PayerAuthSetupCreatedBodyLinks) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PayerAuthSetupCreatedBodyLinks) UnmarshalBinary(b []byte) error {
	var res PayerAuthSetupCreatedBodyLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PayerAuthSetupCreatedBodyLinksSelf payer auth setup created body links self
swagger:model PayerAuthSetupCreatedBodyLinksSelf
*/
type PayerAuthSetupCreatedBodyLinksSelf struct {

	// This is the endpoint of the resource that was created by the successful request.
	Href string `json:"href,omitempty"`

	// `method` refers to the HTTP method that you can send to the `self` endpoint to retrieve details of the resource.
	Method string `json:"method,omitempty"`
}

// Validate validates this payer auth setup created body links self
func (o *PayerAuthSetupCreatedBodyLinksSelf) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this payer auth setup created body links self based on context it is used
func (o *PayerAuthSetupCreatedBodyLinksSelf) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PayerAuthSetupCreatedBodyLinksSelf) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PayerAuthSetupCreatedBodyLinksSelf) UnmarshalBinary(b []byte) error {
	var res PayerAuthSetupCreatedBodyLinksSelf
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PayerAuthSetupParamsBodyClientReferenceInformation payer auth setup params body client reference information
swagger:model PayerAuthSetupParamsBodyClientReferenceInformation
*/
type PayerAuthSetupParamsBodyClientReferenceInformation struct {

	// Merchant-generated order reference or tracking number. It is recommended that you send a unique value for each
	// transaction so that you can perform meaningful searches for the transaction.
	//
	// #### Used by
	// **Authorization**
	// Required field.
	//
	// #### PIN Debit
	// Requests for PIN debit reversals need to use the same merchant reference number that was used in the transaction that is being
	// reversed.
	//
	// Required field for all PIN Debit requests (purchase, credit, and reversal).
	//
	// #### FDC Nashville Global
	// Certain circumstances can cause the processor to truncate this value to 15 or 17 characters for Level II and Level III processing, which can cause a discrepancy between the value you submit and the value included in some processor reports.
	//
	// Required: true
	// Max Length: 50
	Code *string `json:"code"`

	// Brief description of the order or any comment you wish to add to the order.
	//
	// Max Length: 255
	Comments string `json:"comments,omitempty"`

	// partner
	Partner *PayerAuthSetupParamsBodyClientReferenceInformationPartner `json:"partner,omitempty"`

	// Used to resume a transaction that was paused for an order modification rule to allow for payer authentication to complete. To resume and continue with the authorization/decision service flow, call the services and include the request id from the prior decision call.
	//
	// Max Length: 26
	PausedRequestID string `json:"pausedRequestId,omitempty"`
}

// Validate validates this payer auth setup params body client reference information
func (o *PayerAuthSetupParamsBodyClientReferenceInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateComments(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePartner(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePausedRequestID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PayerAuthSetupParamsBodyClientReferenceInformation) validateCode(formats strfmt.Registry) error {

	if err := validate.Required("payerAuthSetupRequest"+"."+"clientReferenceInformation"+"."+"code", "body", o.Code); err != nil {
		return err
	}

	if err := validate.MaxLength("payerAuthSetupRequest"+"."+"clientReferenceInformation"+"."+"code", "body", *o.Code, 50); err != nil {
		return err
	}

	return nil
}

func (o *PayerAuthSetupParamsBodyClientReferenceInformation) validateComments(formats strfmt.Registry) error {
	if swag.IsZero(o.Comments) { // not required
		return nil
	}

	if err := validate.MaxLength("payerAuthSetupRequest"+"."+"clientReferenceInformation"+"."+"comments", "body", o.Comments, 255); err != nil {
		return err
	}

	return nil
}

func (o *PayerAuthSetupParamsBodyClientReferenceInformation) validatePartner(formats strfmt.Registry) error {
	if swag.IsZero(o.Partner) { // not required
		return nil
	}

	if o.Partner != nil {
		if err := o.Partner.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("payerAuthSetupRequest" + "." + "clientReferenceInformation" + "." + "partner")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("payerAuthSetupRequest" + "." + "clientReferenceInformation" + "." + "partner")
			}
			return err
		}
	}

	return nil
}

func (o *PayerAuthSetupParamsBodyClientReferenceInformation) validatePausedRequestID(formats strfmt.Registry) error {
	if swag.IsZero(o.PausedRequestID) { // not required
		return nil
	}

	if err := validate.MaxLength("payerAuthSetupRequest"+"."+"clientReferenceInformation"+"."+"pausedRequestId", "body", o.PausedRequestID, 26); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this payer auth setup params body client reference information based on the context it is used
func (o *PayerAuthSetupParamsBodyClientReferenceInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidatePartner(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PayerAuthSetupParamsBodyClientReferenceInformation) contextValidatePartner(ctx context.Context, formats strfmt.Registry) error {

	if o.Partner != nil {
		if err := o.Partner.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("payerAuthSetupRequest" + "." + "clientReferenceInformation" + "." + "partner")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("payerAuthSetupRequest" + "." + "clientReferenceInformation" + "." + "partner")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PayerAuthSetupParamsBodyClientReferenceInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PayerAuthSetupParamsBodyClientReferenceInformation) UnmarshalBinary(b []byte) error {
	var res PayerAuthSetupParamsBodyClientReferenceInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PayerAuthSetupParamsBodyClientReferenceInformationPartner payer auth setup params body client reference information partner
swagger:model PayerAuthSetupParamsBodyClientReferenceInformationPartner
*/
type PayerAuthSetupParamsBodyClientReferenceInformationPartner struct {

	// Identifier for the developer that helped integrate a partner solution to CyberSource.
	//
	// Send this value in all requests that are sent through the partner solutions built by that developer.
	// CyberSource assigns the ID to the developer.
	//
	// **Note** When you see a developer ID of 999 in reports, the developer ID that was submitted is incorrect.
	//
	// Max Length: 8
	DeveloperID string `json:"developerId,omitempty"`

	// Identifier for the partner that is integrated to CyberSource.
	//
	// Send this value in all requests that are sent through the partner solution. CyberSource assigns the ID to the partner.
	//
	// **Note** When you see a solutionId of 999 in reports, the solutionId that was submitted is incorrect.
	//
	// Max Length: 8
	SolutionID string `json:"solutionId,omitempty"`
}

// Validate validates this payer auth setup params body client reference information partner
func (o *PayerAuthSetupParamsBodyClientReferenceInformationPartner) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDeveloperID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSolutionID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PayerAuthSetupParamsBodyClientReferenceInformationPartner) validateDeveloperID(formats strfmt.Registry) error {
	if swag.IsZero(o.DeveloperID) { // not required
		return nil
	}

	if err := validate.MaxLength("payerAuthSetupRequest"+"."+"clientReferenceInformation"+"."+"partner"+"."+"developerId", "body", o.DeveloperID, 8); err != nil {
		return err
	}

	return nil
}

func (o *PayerAuthSetupParamsBodyClientReferenceInformationPartner) validateSolutionID(formats strfmt.Registry) error {
	if swag.IsZero(o.SolutionID) { // not required
		return nil
	}

	if err := validate.MaxLength("payerAuthSetupRequest"+"."+"clientReferenceInformation"+"."+"partner"+"."+"solutionId", "body", o.SolutionID, 8); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this payer auth setup params body client reference information partner based on context it is used
func (o *PayerAuthSetupParamsBodyClientReferenceInformationPartner) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PayerAuthSetupParamsBodyClientReferenceInformationPartner) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PayerAuthSetupParamsBodyClientReferenceInformationPartner) UnmarshalBinary(b []byte) error {
	var res PayerAuthSetupParamsBodyClientReferenceInformationPartner
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PayerAuthSetupParamsBodyPaymentInformation payer auth setup params body payment information
swagger:model PayerAuthSetupParamsBodyPaymentInformation
*/
type PayerAuthSetupParamsBodyPaymentInformation struct {

	// card
	Card *PayerAuthSetupParamsBodyPaymentInformationCard `json:"card,omitempty"`

	// customer
	Customer *PayerAuthSetupParamsBodyPaymentInformationCustomer `json:"customer,omitempty"`

	// fluid data
	FluidData *PayerAuthSetupParamsBodyPaymentInformationFluidData `json:"fluidData,omitempty"`

	// tokenized card
	TokenizedCard *PayerAuthSetupParamsBodyPaymentInformationTokenizedCard `json:"tokenizedCard,omitempty"`
}

// Validate validates this payer auth setup params body payment information
func (o *PayerAuthSetupParamsBodyPaymentInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCard(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCustomer(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFluidData(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTokenizedCard(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PayerAuthSetupParamsBodyPaymentInformation) validateCard(formats strfmt.Registry) error {
	if swag.IsZero(o.Card) { // not required
		return nil
	}

	if o.Card != nil {
		if err := o.Card.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("payerAuthSetupRequest" + "." + "paymentInformation" + "." + "card")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("payerAuthSetupRequest" + "." + "paymentInformation" + "." + "card")
			}
			return err
		}
	}

	return nil
}

func (o *PayerAuthSetupParamsBodyPaymentInformation) validateCustomer(formats strfmt.Registry) error {
	if swag.IsZero(o.Customer) { // not required
		return nil
	}

	if o.Customer != nil {
		if err := o.Customer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("payerAuthSetupRequest" + "." + "paymentInformation" + "." + "customer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("payerAuthSetupRequest" + "." + "paymentInformation" + "." + "customer")
			}
			return err
		}
	}

	return nil
}

func (o *PayerAuthSetupParamsBodyPaymentInformation) validateFluidData(formats strfmt.Registry) error {
	if swag.IsZero(o.FluidData) { // not required
		return nil
	}

	if o.FluidData != nil {
		if err := o.FluidData.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("payerAuthSetupRequest" + "." + "paymentInformation" + "." + "fluidData")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("payerAuthSetupRequest" + "." + "paymentInformation" + "." + "fluidData")
			}
			return err
		}
	}

	return nil
}

func (o *PayerAuthSetupParamsBodyPaymentInformation) validateTokenizedCard(formats strfmt.Registry) error {
	if swag.IsZero(o.TokenizedCard) { // not required
		return nil
	}

	if o.TokenizedCard != nil {
		if err := o.TokenizedCard.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("payerAuthSetupRequest" + "." + "paymentInformation" + "." + "tokenizedCard")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("payerAuthSetupRequest" + "." + "paymentInformation" + "." + "tokenizedCard")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this payer auth setup params body payment information based on the context it is used
func (o *PayerAuthSetupParamsBodyPaymentInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateCard(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateCustomer(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateFluidData(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateTokenizedCard(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PayerAuthSetupParamsBodyPaymentInformation) contextValidateCard(ctx context.Context, formats strfmt.Registry) error {

	if o.Card != nil {
		if err := o.Card.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("payerAuthSetupRequest" + "." + "paymentInformation" + "." + "card")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("payerAuthSetupRequest" + "." + "paymentInformation" + "." + "card")
			}
			return err
		}
	}

	return nil
}

func (o *PayerAuthSetupParamsBodyPaymentInformation) contextValidateCustomer(ctx context.Context, formats strfmt.Registry) error {

	if o.Customer != nil {
		if err := o.Customer.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("payerAuthSetupRequest" + "." + "paymentInformation" + "." + "customer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("payerAuthSetupRequest" + "." + "paymentInformation" + "." + "customer")
			}
			return err
		}
	}

	return nil
}

func (o *PayerAuthSetupParamsBodyPaymentInformation) contextValidateFluidData(ctx context.Context, formats strfmt.Registry) error {

	if o.FluidData != nil {
		if err := o.FluidData.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("payerAuthSetupRequest" + "." + "paymentInformation" + "." + "fluidData")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("payerAuthSetupRequest" + "." + "paymentInformation" + "." + "fluidData")
			}
			return err
		}
	}

	return nil
}

func (o *PayerAuthSetupParamsBodyPaymentInformation) contextValidateTokenizedCard(ctx context.Context, formats strfmt.Registry) error {

	if o.TokenizedCard != nil {
		if err := o.TokenizedCard.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("payerAuthSetupRequest" + "." + "paymentInformation" + "." + "tokenizedCard")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("payerAuthSetupRequest" + "." + "paymentInformation" + "." + "tokenizedCard")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PayerAuthSetupParamsBodyPaymentInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PayerAuthSetupParamsBodyPaymentInformation) UnmarshalBinary(b []byte) error {
	var res PayerAuthSetupParamsBodyPaymentInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PayerAuthSetupParamsBodyPaymentInformationCard payer auth setup params body payment information card
swagger:model PayerAuthSetupParamsBodyPaymentInformationCard
*/
type PayerAuthSetupParamsBodyPaymentInformationCard struct {

	// Two-digit month in which the payment card expires.
	//
	// Format: `MM`.
	//
	// Valid values: `01` through `12`. Leading 0 is required.
	//
	// #### Barclays and Streamline
	// For Maestro (UK Domestic) and Maestro (International) cards on Barclays and Streamline, this must be a valid value
	// (`01` through `12`) but is not required to be a valid expiration date. In other words, an expiration date that is
	// in the past does not cause CyberSource to reject your request. However, an invalid expiration date might cause
	// the issuer to reject your request.
	//
	// #### Encoded Account Numbers
	// For encoded account numbers (_type_=039), if there is no expiration date on the card, use `12`.
	//
	// #### FDMS Nashville
	// Required field.
	//
	// #### All other processors
	// Required if `pointOfSaleInformation.entryMode=keyed`. However, this field is optional if your account is configured
	// for relaxed requirements for address data and expiration date. **Important** It is your responsibility to determine
	// whether a field is required for the transaction you are requesting.
	//
	// #### Google Pay transactions
	// For PAN-based Google Pay transactions, this field is returned in the API response.
	//
	// Required: true
	// Max Length: 2
	ExpirationMonth *string `json:"expirationMonth"`

	// Four-digit year in which the payment card expires.
	//
	// Format: `YYYY`.
	//
	// #### Barclays and Streamline
	// For Maestro (UK Domestic) and Maestro (International) cards on Barclays and Streamline, this must be a valid value (`1900` through `3000`) but is not required to be a valid expiration date. In other words, an expiration date that is in the past does not cause CyberSource to reject your request. However, an invalid expiration date might cause the issuer to reject your request.
	//
	// #### Encoded Account Numbers
	// For encoded account numbers (**_type_**`=039`), if there is no expiration date on the card, use `2021`.
	//
	// #### FDMS Nashville
	// Required field.
	//
	// #### FDC Nashville Global and FDMS South
	// You can send in 2 digits or 4 digits. If you send in 2 digits, they must be the last 2 digits of the year.
	//
	// #### All other processors
	// Required if `pointOfSaleInformation.entryMode=keyed`. However, this field is optional if your account is configured
	// for relaxed requirements for address data and expiration date. **Important** It is your responsibility to determine
	// whether a field is required for the transaction you are requesting.
	//
	// #### Google Pay transactions
	// For PAN-based Google Pay transactions, this field is returned in the API response.
	//
	// Required: true
	// Max Length: 4
	ExpirationYear *string `json:"expirationYear"`

	// The customers payment card number, also known as the Primary Account Number (PAN). You can also use this field
	// for encoded account numbers.
	//
	// #### FDMS Nashville
	// Required. String (19)
	//
	// #### GPX
	// Required if `pointOfSaleInformation.entryMode=keyed`. However, this field is optional if your account is configured
	// for relaxed requirements for address data and expiration date. **Important** It is your responsibility to determine
	// whether a field is required for the transaction you are requesting.
	//
	// #### All other processors
	// Required if `pointOfSaleInformation.entryMode=keyed`. However, this field is optional if your account is configured
	// for relaxed requirements for address data and expiration date. **Important** It is your responsibility to determine
	// whether a field is required for the transaction you are requesting.
	//
	// Required: true
	// Max Length: 20
	Number *string `json:"number"`

	// Three-digit value that indicates the card type.
	//
	// **IMPORTANT** It is strongly recommended that you include the card type field in request messages even if it is
	// optional for your processor and card type. Omitting the card type can cause the transaction to be processed with the wrong card type.
	//
	// Possible values:
	// - `001`: Visa. For card-present transactions on all processors except SIX, the Visa Electron card type is processed the same way that the Visa debit card is processed. Use card type value `001` for Visa Electron.
	// - `002`: Mastercard, Eurocard[^1], which is a European regional brand of Mastercard.
	// - `003`: American Express
	// - `004`: Discover
	// - `005`: Diners Club
	// - `006`: Carte Blanche[^1]
	// - `007`: JCB[^1]
	// - `014`: Enroute[^1]
	// - `021`: JAL[^1]
	// - `024`: Maestro (UK Domestic)[^1]
	// - `031`: Delta[^1]: Use this value only for Ingenico ePayments. For other processors, use `001` for all Visa card types.
	// - `033`: Visa Electron[^1]. Use this value only for Ingenico ePayments and SIX. For other processors, use `001` for all Visa card types.
	// - `034`: Dankort[^1]
	// - `036`: Cartes Bancaires[^1,4]
	// - `037`: Carta Si[^1]
	// - `039`: Encoded account number[^1]
	// - `040`: UATP[^1]
	// - `042`: Maestro (International)[^1]
	// - `050`: Hipercard[^2,3]
	// - `051`: Aura
	// - `054`: Elo[^3]
	// - `062`: China UnionPay
	//
	// [^1]: For this card type, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in your request for an authorization or a stand-alone credit.
	// [^2]: For this card type on Cielo 3.0, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in a request for an authorization or a stand-alone credit. This card type is not supported on Cielo 1.5.
	// [^3]: For this card type on Getnet and Rede, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in a request for an authorization or a stand-alone credit.
	// [^4]: For this card type, you must include the `paymentInformation.card.type` in your request for any payer authentication services.
	//
	// #### Used by
	// **Authorization**
	// Required for Carte Blanche and JCB.
	// Optional for all other card types.
	//
	// #### Card Present reply
	// This field is included in the reply message when the client software that is installed on the POS terminal uses
	// the token management service (TMS) to retrieve tokenized payment details. You must contact customer support to
	// have your account enabled to receive these fields in the credit reply message.
	//
	// Returned by the Credit service.
	//
	// This reply field is only supported by the following processors:
	// - American Express Direct
	// - Credit Mutuel-CIC
	// - FDC Nashville Global
	// - OmniPay Direct
	// - SIX
	//
	// #### Google Pay transactions
	// For PAN-based Google Pay transactions, this field is returned in the API response.
	//
	// #### GPX
	// This field only supports transactions from the following card types:
	// - Visa
	// - Mastercard
	// - AMEX
	// - Discover
	// - Diners
	// - JCB
	// - Union Pay International
	//
	Type string `json:"type,omitempty"`
}

// Validate validates this payer auth setup params body payment information card
func (o *PayerAuthSetupParamsBodyPaymentInformationCard) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateExpirationMonth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpirationYear(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNumber(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PayerAuthSetupParamsBodyPaymentInformationCard) validateExpirationMonth(formats strfmt.Registry) error {

	if err := validate.Required("payerAuthSetupRequest"+"."+"paymentInformation"+"."+"card"+"."+"expirationMonth", "body", o.ExpirationMonth); err != nil {
		return err
	}

	if err := validate.MaxLength("payerAuthSetupRequest"+"."+"paymentInformation"+"."+"card"+"."+"expirationMonth", "body", *o.ExpirationMonth, 2); err != nil {
		return err
	}

	return nil
}

func (o *PayerAuthSetupParamsBodyPaymentInformationCard) validateExpirationYear(formats strfmt.Registry) error {

	if err := validate.Required("payerAuthSetupRequest"+"."+"paymentInformation"+"."+"card"+"."+"expirationYear", "body", o.ExpirationYear); err != nil {
		return err
	}

	if err := validate.MaxLength("payerAuthSetupRequest"+"."+"paymentInformation"+"."+"card"+"."+"expirationYear", "body", *o.ExpirationYear, 4); err != nil {
		return err
	}

	return nil
}

func (o *PayerAuthSetupParamsBodyPaymentInformationCard) validateNumber(formats strfmt.Registry) error {

	if err := validate.Required("payerAuthSetupRequest"+"."+"paymentInformation"+"."+"card"+"."+"number", "body", o.Number); err != nil {
		return err
	}

	if err := validate.MaxLength("payerAuthSetupRequest"+"."+"paymentInformation"+"."+"card"+"."+"number", "body", *o.Number, 20); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this payer auth setup params body payment information card based on context it is used
func (o *PayerAuthSetupParamsBodyPaymentInformationCard) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PayerAuthSetupParamsBodyPaymentInformationCard) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PayerAuthSetupParamsBodyPaymentInformationCard) UnmarshalBinary(b []byte) error {
	var res PayerAuthSetupParamsBodyPaymentInformationCard
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PayerAuthSetupParamsBodyPaymentInformationCustomer payer auth setup params body payment information customer
swagger:model PayerAuthSetupParamsBodyPaymentInformationCustomer
*/
type PayerAuthSetupParamsBodyPaymentInformationCustomer struct {

	// Unique identifier for the legacy Secure Storage token used in the transaction.
	// When you include this value in your request, many of the fields that are normally required for an authorization or credit
	// become optional.
	//
	// Max Length: 22
	// Min Length: 16
	CustomerID string `json:"customerId,omitempty"`
}

// Validate validates this payer auth setup params body payment information customer
func (o *PayerAuthSetupParamsBodyPaymentInformationCustomer) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCustomerID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PayerAuthSetupParamsBodyPaymentInformationCustomer) validateCustomerID(formats strfmt.Registry) error {
	if swag.IsZero(o.CustomerID) { // not required
		return nil
	}

	if err := validate.MinLength("payerAuthSetupRequest"+"."+"paymentInformation"+"."+"customer"+"."+"customerId", "body", o.CustomerID, 16); err != nil {
		return err
	}

	if err := validate.MaxLength("payerAuthSetupRequest"+"."+"paymentInformation"+"."+"customer"+"."+"customerId", "body", o.CustomerID, 22); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this payer auth setup params body payment information customer based on context it is used
func (o *PayerAuthSetupParamsBodyPaymentInformationCustomer) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PayerAuthSetupParamsBodyPaymentInformationCustomer) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PayerAuthSetupParamsBodyPaymentInformationCustomer) UnmarshalBinary(b []byte) error {
	var res PayerAuthSetupParamsBodyPaymentInformationCustomer
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PayerAuthSetupParamsBodyPaymentInformationFluidData payer auth setup params body payment information fluid data
swagger:model PayerAuthSetupParamsBodyPaymentInformationFluidData
*/
type PayerAuthSetupParamsBodyPaymentInformationFluidData struct {

	// The identifier for a payment solution, which is sending the encrypted payment data for decryption. Valid values:
	// Samsung Pay: RklEPUNPTU1PTi5TQU1TVU5HLklOQVBQLlBBWU1FTlQ=
	// Note: For other payment solutions, the value may be specific to the terminal or device initiatinf the payment. For example, the descriptor for a Bluefin payment encryption would be a device-generated descriptor.
	// Used by Authorization and Standalone Credits. Required for authorizations and standalone credits.
	//
	// Card Present processing:
	// Format of the encrypted payment data.
	// The value for Bluefin PCI P2PE is `Ymx1ZWZpbg==`. paymentInformation.fluidData.encoding must be `Base64`.
	// The value for Cybersource P2PE decryption depends on the encoding method used and identified in encoding field.
	// If paymentInformation.fluidData.encoding is `Base64`, the value is: `RklEPUVNVi5QQVlNRU5ULkFQSQ==`
	// If paymentInformation.fluidData.encoding is `HEX`, the value is: `4649443D454D562E5041594D454E542E41504`
	//
	// Max Length: 128
	Descriptor string `json:"descriptor,omitempty"`

	// Encoding method used to encrypt the payment data.
	// Valid values: `Base64`, `HEX`
	// If no value is provided, `Base64` is taken as the default value. And the `Base64` descriptor is used for paymentInformation.fluidData.encoding
	//
	// Max Length: 6
	Encoding string `json:"encoding,omitempty"`

	// The encoded or encrypted value that a payment solution returns for an authorization request. For details about the valid values for a key, see [Creating an Online Authorization](https://developer.cybersource.com/api/developer-guides/dita-payments/CreatingOnlineAuth.html)
	//
	KeySerialNumber string `json:"keySerialNumber,omitempty"`

	// Represents the encrypted payment data BLOB. The entry for this field is dependent on the payment solution used by the merchant.
	// Used by Authorization and Standalone Credits. Required for authorizations and standalone credits that use a Cybersource suppored Point-to-Point encryption method.
	// Card Present processing
	// This field represents the encrypted payment data generated by the payment terminal/device.
	//
	// Required: true
	// Max Length: 3072
	Value *string `json:"value"`
}

// Validate validates this payer auth setup params body payment information fluid data
func (o *PayerAuthSetupParamsBodyPaymentInformationFluidData) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDescriptor(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEncoding(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateValue(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PayerAuthSetupParamsBodyPaymentInformationFluidData) validateDescriptor(formats strfmt.Registry) error {
	if swag.IsZero(o.Descriptor) { // not required
		return nil
	}

	if err := validate.MaxLength("payerAuthSetupRequest"+"."+"paymentInformation"+"."+"fluidData"+"."+"descriptor", "body", o.Descriptor, 128); err != nil {
		return err
	}

	return nil
}

func (o *PayerAuthSetupParamsBodyPaymentInformationFluidData) validateEncoding(formats strfmt.Registry) error {
	if swag.IsZero(o.Encoding) { // not required
		return nil
	}

	if err := validate.MaxLength("payerAuthSetupRequest"+"."+"paymentInformation"+"."+"fluidData"+"."+"encoding", "body", o.Encoding, 6); err != nil {
		return err
	}

	return nil
}

func (o *PayerAuthSetupParamsBodyPaymentInformationFluidData) validateValue(formats strfmt.Registry) error {

	if err := validate.Required("payerAuthSetupRequest"+"."+"paymentInformation"+"."+"fluidData"+"."+"value", "body", o.Value); err != nil {
		return err
	}

	if err := validate.MaxLength("payerAuthSetupRequest"+"."+"paymentInformation"+"."+"fluidData"+"."+"value", "body", *o.Value, 3072); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this payer auth setup params body payment information fluid data based on context it is used
func (o *PayerAuthSetupParamsBodyPaymentInformationFluidData) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PayerAuthSetupParamsBodyPaymentInformationFluidData) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PayerAuthSetupParamsBodyPaymentInformationFluidData) UnmarshalBinary(b []byte) error {
	var res PayerAuthSetupParamsBodyPaymentInformationFluidData
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PayerAuthSetupParamsBodyPaymentInformationTokenizedCard payer auth setup params body payment information tokenized card
swagger:model PayerAuthSetupParamsBodyPaymentInformationTokenizedCard
*/
type PayerAuthSetupParamsBodyPaymentInformationTokenizedCard struct {

	// One of two possible meanings:
	// - The two-digit month in which a token expires.
	// - The two-digit month in which a card expires.
	// Format: `MM`
	// Possible values: `01` through `12`
	//
	// **NOTE** The meaning of this field is dependent on the payment processor that is returning the value in an authorization reply. Please see the processor-specific details below.
	//
	// #### Barclays and Streamline
	// For Maestro (UK Domestic) and Maestro (International) cards on Barclays and Streamline, this must be a valid value (`01` through `12`) but is not required to be a valid expiration date. In other words, an expiration date that is in the past does not cause CyberSource to reject your request. However, an invalid expiration date might cause the issuer to reject your request.
	//
	// #### Encoded Account Numbers
	// For encoded account numbers (`card_type=039`), if there is no expiration date on the card, use `12`.\
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// #### Samsung Pay and Apple Pay
	// Month in which the token expires. CyberSource includes this field in the reply message when it decrypts the payment blob for the tokenized transaction.
	//
	// For processor-specific information, see the `customer_cc_expmo` field in [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Required: true
	// Max Length: 2
	ExpirationMonth *string `json:"expirationMonth"`

	// One of two possible meanings:
	// - The four-digit year in which a token expires.
	// - The four-digit year in which a card expires.
	// Format: `YYYY`
	// Possible values: `1900` through `3000`
	// Data type: Non-negative integer
	//
	// **NOTE** The meaning of this field is dependent on the payment processor that is returning the value in an authorization reply. Please see the processor-specific details below.
	//
	// #### Barclays and Streamline
	// For Maestro (UK Domestic) and Maestro (International) cards on Barclays and Streamline, this must be a valid value (1900 through
	// 3000) but is not required to be a valid expiration date. In other words, an expiration date that is in the past does not cause CyberSource to reject your request. However, an invalid expiration date might cause the issuer to reject your request.
	//
	// #### Encoded Account Numbers
	// For encoded account numbers (`card_ type=039`), if there is no expiration date on the card, use `2021`.
	//
	// #### FDC Nashville Global and FDMS South
	// You can send in 2 digits or 4 digits. When you send in 2 digits, they must be the last 2 digits of
	// the year.
	//
	// #### Samsung Pay and Apple Pay
	// Year in which the token expires. CyberSource includes this field in the reply message when it decrypts the payment blob for the tokenized transaction.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction
	// you are requesting.
	//
	// For processor-specific information, see the `customer_cc_expyr` or `token_expiration_year` field in [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Required: true
	// Max Length: 4
	ExpirationYear *string `json:"expirationYear"`

	// Customers payment network token value.
	//
	// Required: true
	// Max Length: 20
	Number *string `json:"number"`

	// Type of transaction that provided the token data. This value does not specify the token service provider; it specifies the entity that
	// provided you with information about the token.
	//
	// Possible value:
	// - `2`: Near-field communication (NFC) transaction. The customers mobile device provided the token data for a contactless EMV transaction. For recurring
	// transactions, use this value if the original transaction was a contactless EMV transaction.
	//
	// **NOTE** No CyberSource through VisaNet acquirers support EMV at this time.
	//
	// Required field for PIN debit credit or PIN debit purchase transactions that use payment network tokens; otherwise, not used.
	//
	// Required: true
	// Max Length: 1
	TransactionType *string `json:"transactionType"`

	// Three-digit value that indicates the card type.
	//
	// **IMPORTANT** It is strongly recommended that you include the card type field in request messages even if it is
	// optional for your processor and card type. Omitting the card type can cause the transaction to be processed with the wrong card type.
	//
	// Possible values:
	// - `001`: Visa. For card-present transactions on all processors except SIX, the Visa Electron card type is processed the same way that the Visa debit card is processed. Use card type value `001` for Visa Electron.
	// - `002`: Mastercard, Eurocard[^1], which is a European regional brand of Mastercard.
	// - `003`: American Express
	// - `004`: Discover
	// - `005`: Diners Club
	// - `006`: Carte Blanche[^1]
	// - `007`: JCB[^1]
	// - `014`: Enroute[^1]
	// - `021`: JAL[^1]
	// - `024`: Maestro (UK Domestic)[^1]
	// - `031`: Delta[^1]: Use this value only for Ingenico ePayments. For other processors, use `001` for all Visa card types.
	// - `033`: Visa Electron[^1]. Use this value only for Ingenico ePayments and SIX. For other processors, use `001` for all Visa card types.
	// - `034`: Dankort[^1]
	// - `036`: Cartes Bancaires[^1,4]
	// - `037`: Carta Si[^1]
	// - `039`: Encoded account number[^1]
	// - `040`: UATP[^1]
	// - `042`: Maestro (International)[^1]
	// - `050`: Hipercard[^2,3]
	// - `051`: Aura
	// - `054`: Elo[^3]
	// - `062`: China UnionPay
	//
	// [^1]: For this card type, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in your request for an authorization or a stand-alone credit.
	// [^2]: For this card type on Cielo 3.0, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in a request for an authorization or a stand-alone credit. This card type is not supported on Cielo 1.5.
	// [^3]: For this card type on Getnet and Rede, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in a request for an authorization or a stand-alone credit.
	// [^4]: For this card type, you must include the `paymentInformation.card.type` in your request for any payer authentication services.
	//
	// #### Used by
	// **Authorization**
	// Required for Carte Blanche and JCB.
	// Optional for all other card types.
	//
	// #### Card Present reply
	// This field is included in the reply message when the client software that is installed on the POS terminal uses
	// the token management service (TMS) to retrieve tokenized payment details. You must contact customer support to
	// have your account enabled to receive these fields in the credit reply message.
	//
	// Returned by the Credit service.
	//
	// This reply field is only supported by the following processors:
	// - American Express Direct
	// - Credit Mutuel-CIC
	// - FDC Nashville Global
	// - OmniPay Direct
	// - SIX
	//
	// #### Google Pay transactions
	// For PAN-based Google Pay transactions, this field is returned in the API response.
	//
	// #### GPX
	// This field only supports transactions from the following card types:
	// - Visa
	// - Mastercard
	// - AMEX
	// - Discover
	// - Diners
	// - JCB
	// - Union Pay International
	//
	// Required: true
	Type *string `json:"type"`
}

// Validate validates this payer auth setup params body payment information tokenized card
func (o *PayerAuthSetupParamsBodyPaymentInformationTokenizedCard) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateExpirationMonth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpirationYear(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTransactionType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PayerAuthSetupParamsBodyPaymentInformationTokenizedCard) validateExpirationMonth(formats strfmt.Registry) error {

	if err := validate.Required("payerAuthSetupRequest"+"."+"paymentInformation"+"."+"tokenizedCard"+"."+"expirationMonth", "body", o.ExpirationMonth); err != nil {
		return err
	}

	if err := validate.MaxLength("payerAuthSetupRequest"+"."+"paymentInformation"+"."+"tokenizedCard"+"."+"expirationMonth", "body", *o.ExpirationMonth, 2); err != nil {
		return err
	}

	return nil
}

func (o *PayerAuthSetupParamsBodyPaymentInformationTokenizedCard) validateExpirationYear(formats strfmt.Registry) error {

	if err := validate.Required("payerAuthSetupRequest"+"."+"paymentInformation"+"."+"tokenizedCard"+"."+"expirationYear", "body", o.ExpirationYear); err != nil {
		return err
	}

	if err := validate.MaxLength("payerAuthSetupRequest"+"."+"paymentInformation"+"."+"tokenizedCard"+"."+"expirationYear", "body", *o.ExpirationYear, 4); err != nil {
		return err
	}

	return nil
}

func (o *PayerAuthSetupParamsBodyPaymentInformationTokenizedCard) validateNumber(formats strfmt.Registry) error {

	if err := validate.Required("payerAuthSetupRequest"+"."+"paymentInformation"+"."+"tokenizedCard"+"."+"number", "body", o.Number); err != nil {
		return err
	}

	if err := validate.MaxLength("payerAuthSetupRequest"+"."+"paymentInformation"+"."+"tokenizedCard"+"."+"number", "body", *o.Number, 20); err != nil {
		return err
	}

	return nil
}

func (o *PayerAuthSetupParamsBodyPaymentInformationTokenizedCard) validateTransactionType(formats strfmt.Registry) error {

	if err := validate.Required("payerAuthSetupRequest"+"."+"paymentInformation"+"."+"tokenizedCard"+"."+"transactionType", "body", o.TransactionType); err != nil {
		return err
	}

	if err := validate.MaxLength("payerAuthSetupRequest"+"."+"paymentInformation"+"."+"tokenizedCard"+"."+"transactionType", "body", *o.TransactionType, 1); err != nil {
		return err
	}

	return nil
}

func (o *PayerAuthSetupParamsBodyPaymentInformationTokenizedCard) validateType(formats strfmt.Registry) error {

	if err := validate.Required("payerAuthSetupRequest"+"."+"paymentInformation"+"."+"tokenizedCard"+"."+"type", "body", o.Type); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this payer auth setup params body payment information tokenized card based on context it is used
func (o *PayerAuthSetupParamsBodyPaymentInformationTokenizedCard) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PayerAuthSetupParamsBodyPaymentInformationTokenizedCard) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PayerAuthSetupParamsBodyPaymentInformationTokenizedCard) UnmarshalBinary(b []byte) error {
	var res PayerAuthSetupParamsBodyPaymentInformationTokenizedCard
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PayerAuthSetupParamsBodyProcessingInformation payer auth setup params body processing information
swagger:model PayerAuthSetupParamsBodyProcessingInformation
*/
type PayerAuthSetupParamsBodyProcessingInformation struct {

	// Type of digital payment solution for the transaction. Possible Values:
	//
	//  - `visacheckout`: Visa Checkout. This value is required for Visa Checkout transactions. For details, see `payment_solution` field description in [Visa Checkout Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/VCO_SCMP_API/html/)
	//  - `001`: Apple Pay.
	//  - `004`: Cybersource In-App Solution.
	//  - `005`: Masterpass. This value is required for Masterpass transactions on OmniPay Direct. For details, see "Masterpass" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//  - `006`: Android Pay.
	//  - `007`: Chase Pay.
	//  - `008`: Samsung Pay.
	//  - `012`: Google Pay.
	//  - `013`: Cybersource P2PE Decryption
	//  - `014`: Mastercard credential on file (COF) payment network token. Returned in authorizations that use a payment network token associated with a TMS token.
	//  - `015`: Visa credential on file (COF) payment network token. Returned in authorizations that use a payment network token associated with a TMS token.
	//  - `027`: Click to Pay.
	//
	// Max Length: 12
	PaymentSolution string `json:"paymentSolution,omitempty"`

	// Identifier for the **Visa Checkout** order. Visa Checkout provides a unique order ID for every transaction in
	// the Visa Checkout **callID** field.
	//
	// Max Length: 48
	VisaCheckoutID string `json:"visaCheckoutId,omitempty"`
}

// Validate validates this payer auth setup params body processing information
func (o *PayerAuthSetupParamsBodyProcessingInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validatePaymentSolution(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateVisaCheckoutID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PayerAuthSetupParamsBodyProcessingInformation) validatePaymentSolution(formats strfmt.Registry) error {
	if swag.IsZero(o.PaymentSolution) { // not required
		return nil
	}

	if err := validate.MaxLength("payerAuthSetupRequest"+"."+"processingInformation"+"."+"paymentSolution", "body", o.PaymentSolution, 12); err != nil {
		return err
	}

	return nil
}

func (o *PayerAuthSetupParamsBodyProcessingInformation) validateVisaCheckoutID(formats strfmt.Registry) error {
	if swag.IsZero(o.VisaCheckoutID) { // not required
		return nil
	}

	if err := validate.MaxLength("payerAuthSetupRequest"+"."+"processingInformation"+"."+"visaCheckoutId", "body", o.VisaCheckoutID, 48); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this payer auth setup params body processing information based on context it is used
func (o *PayerAuthSetupParamsBodyProcessingInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PayerAuthSetupParamsBodyProcessingInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PayerAuthSetupParamsBodyProcessingInformation) UnmarshalBinary(b []byte) error {
	var res PayerAuthSetupParamsBodyProcessingInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PayerAuthSetupParamsBodyTokenInformation payer auth setup params body token information
swagger:model PayerAuthSetupParamsBodyTokenInformation
*/
type PayerAuthSetupParamsBodyTokenInformation struct {

	// A temporary ID that represents the customer's payment data (which is securely stored in Visa Data Centers). Flex
	// Microform generates this ID and sets it to expire within 15 minutes from when the ID is generated or until the
	// first payment authorization is carried out (whichever occurs first).
	//
	// Valid value for the ID is a 64-character, alphanumeric string.
	//
	// Example: 1D08M4YB968R1F7YVL4TBBKYVNRIR02VZFH9CBYSQIJJXORPI1NK5C98D7F6EB53
	//
	TransientToken string `json:"transientToken,omitempty"`
}

// Validate validates this payer auth setup params body token information
func (o *PayerAuthSetupParamsBodyTokenInformation) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this payer auth setup params body token information based on context it is used
func (o *PayerAuthSetupParamsBodyTokenInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PayerAuthSetupParamsBodyTokenInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PayerAuthSetupParamsBodyTokenInformation) UnmarshalBinary(b []byte) error {
	var res PayerAuthSetupParamsBodyTokenInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}
