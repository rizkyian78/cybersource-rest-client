// Code generated by go-swagger; DO NOT EDIT.

package customer

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"fmt"
	"io"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// PatchCustomerReader is a Reader for the PatchCustomer structure.
type PatchCustomerReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *PatchCustomerReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 200:
		result := NewPatchCustomerOK()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	case 400:
		result := NewPatchCustomerBadRequest()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 403:
		result := NewPatchCustomerForbidden()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 404:
		result := NewPatchCustomerNotFound()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 410:
		result := NewPatchCustomerGone()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 412:
		result := NewPatchCustomerPreconditionFailed()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 424:
		result := NewPatchCustomerFailedDependency()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 500:
		result := NewPatchCustomerInternalServerError()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	default:
		return nil, runtime.NewAPIError("response status code does not match any response statuses defined for this endpoint in the swagger spec", response, response.Code())
	}
}

// NewPatchCustomerOK creates a PatchCustomerOK with default headers values
func NewPatchCustomerOK() *PatchCustomerOK {
	return &PatchCustomerOK{}
}

/* PatchCustomerOK describes a response with status code 200, with default header values.

Returns an existing Customer associated with the supplied token id.
*/
type PatchCustomerOK struct {

	/* An ETag is an identifier assigned to a specific version of a resource.
	 */
	ETag string

	/* A globally-unique ID associated with your request.
	 */
	UniqueTransactionID string

	/* The mandatory correlation id passed by upstream (calling) system.
	 */
	VcCorrelationID string

	Payload *PatchCustomerOKBody
}

func (o *PatchCustomerOK) Error() string {
	return fmt.Sprintf("[PATCH /tms/v2/customers/{customerTokenId}][%d] patchCustomerOK  %+v", 200, o.Payload)
}
func (o *PatchCustomerOK) GetPayload() *PatchCustomerOKBody {
	return o.Payload
}

func (o *PatchCustomerOK) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	// hydrates response header ETag
	hdrETag := response.GetHeader("ETag")

	if hdrETag != "" {
		o.ETag = hdrETag
	}

	// hydrates response header uniqueTransactionID
	hdrUniqueTransactionID := response.GetHeader("uniqueTransactionID")

	if hdrUniqueTransactionID != "" {
		o.UniqueTransactionID = hdrUniqueTransactionID
	}

	// hydrates response header v-c-correlation-id
	hdrVcCorrelationID := response.GetHeader("v-c-correlation-id")

	if hdrVcCorrelationID != "" {
		o.VcCorrelationID = hdrVcCorrelationID
	}

	o.Payload = new(PatchCustomerOKBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPatchCustomerBadRequest creates a PatchCustomerBadRequest with default headers values
func NewPatchCustomerBadRequest() *PatchCustomerBadRequest {
	return &PatchCustomerBadRequest{}
}

/* PatchCustomerBadRequest describes a response with status code 400, with default header values.

Bad Request: e.g. A required header value could be missing.
*/
type PatchCustomerBadRequest struct {

	/* A globally unique id associated with your request.
	 */
	UniqueTransactionID string

	/* The mandatory correlation id passed by upstream (calling) system.
	 */
	VcCorrelationID string

	Payload *PatchCustomerBadRequestBody
}

func (o *PatchCustomerBadRequest) Error() string {
	return fmt.Sprintf("[PATCH /tms/v2/customers/{customerTokenId}][%d] patchCustomerBadRequest  %+v", 400, o.Payload)
}
func (o *PatchCustomerBadRequest) GetPayload() *PatchCustomerBadRequestBody {
	return o.Payload
}

func (o *PatchCustomerBadRequest) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	// hydrates response header uniqueTransactionID
	hdrUniqueTransactionID := response.GetHeader("uniqueTransactionID")

	if hdrUniqueTransactionID != "" {
		o.UniqueTransactionID = hdrUniqueTransactionID
	}

	// hydrates response header v-c-correlation-id
	hdrVcCorrelationID := response.GetHeader("v-c-correlation-id")

	if hdrVcCorrelationID != "" {
		o.VcCorrelationID = hdrVcCorrelationID
	}

	o.Payload = new(PatchCustomerBadRequestBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPatchCustomerForbidden creates a PatchCustomerForbidden with default headers values
func NewPatchCustomerForbidden() *PatchCustomerForbidden {
	return &PatchCustomerForbidden{}
}

/* PatchCustomerForbidden describes a response with status code 403, with default header values.

403ForbiddenResponse: e.g. The profile might not have permission to perform the operation.
*/
type PatchCustomerForbidden struct {

	/* A globally unique id associated with your request.
	 */
	UniqueTransactionID string

	/* The mandatory correlation id passed by upstream (calling) system.
	 */
	VcCorrelationID string

	Payload *PatchCustomerForbiddenBody
}

func (o *PatchCustomerForbidden) Error() string {
	return fmt.Sprintf("[PATCH /tms/v2/customers/{customerTokenId}][%d] patchCustomerForbidden  %+v", 403, o.Payload)
}
func (o *PatchCustomerForbidden) GetPayload() *PatchCustomerForbiddenBody {
	return o.Payload
}

func (o *PatchCustomerForbidden) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	// hydrates response header uniqueTransactionID
	hdrUniqueTransactionID := response.GetHeader("uniqueTransactionID")

	if hdrUniqueTransactionID != "" {
		o.UniqueTransactionID = hdrUniqueTransactionID
	}

	// hydrates response header v-c-correlation-id
	hdrVcCorrelationID := response.GetHeader("v-c-correlation-id")

	if hdrVcCorrelationID != "" {
		o.VcCorrelationID = hdrVcCorrelationID
	}

	o.Payload = new(PatchCustomerForbiddenBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPatchCustomerNotFound creates a PatchCustomerNotFound with default headers values
func NewPatchCustomerNotFound() *PatchCustomerNotFound {
	return &PatchCustomerNotFound{}
}

/* PatchCustomerNotFound describes a response with status code 404, with default header values.

Token Not Found. The `tokenid` may not exist or was entered incorrectly.
*/
type PatchCustomerNotFound struct {

	/* A globally unique ID associated with your request.
	 */
	UniqueTransactionID string

	/* The mandatory correlation id passed by upstream (calling) system.
	 */
	VcCorrelationID string

	Payload *PatchCustomerNotFoundBody
}

func (o *PatchCustomerNotFound) Error() string {
	return fmt.Sprintf("[PATCH /tms/v2/customers/{customerTokenId}][%d] patchCustomerNotFound  %+v", 404, o.Payload)
}
func (o *PatchCustomerNotFound) GetPayload() *PatchCustomerNotFoundBody {
	return o.Payload
}

func (o *PatchCustomerNotFound) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	// hydrates response header uniqueTransactionID
	hdrUniqueTransactionID := response.GetHeader("uniqueTransactionID")

	if hdrUniqueTransactionID != "" {
		o.UniqueTransactionID = hdrUniqueTransactionID
	}

	// hydrates response header v-c-correlation-id
	hdrVcCorrelationID := response.GetHeader("v-c-correlation-id")

	if hdrVcCorrelationID != "" {
		o.VcCorrelationID = hdrVcCorrelationID
	}

	o.Payload = new(PatchCustomerNotFoundBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPatchCustomerGone creates a PatchCustomerGone with default headers values
func NewPatchCustomerGone() *PatchCustomerGone {
	return &PatchCustomerGone{}
}

/* PatchCustomerGone describes a response with status code 410, with default header values.

Token Not Available. The token has been deleted.
*/
type PatchCustomerGone struct {

	/* A globally unique ID associated with your request.
	 */
	UniqueTransactionID string

	/* The mandatory correlation id passed by upstream (calling) system.
	 */
	VcCorrelationID string

	Payload *PatchCustomerGoneBody
}

func (o *PatchCustomerGone) Error() string {
	return fmt.Sprintf("[PATCH /tms/v2/customers/{customerTokenId}][%d] patchCustomerGone  %+v", 410, o.Payload)
}
func (o *PatchCustomerGone) GetPayload() *PatchCustomerGoneBody {
	return o.Payload
}

func (o *PatchCustomerGone) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	// hydrates response header uniqueTransactionID
	hdrUniqueTransactionID := response.GetHeader("uniqueTransactionID")

	if hdrUniqueTransactionID != "" {
		o.UniqueTransactionID = hdrUniqueTransactionID
	}

	// hydrates response header v-c-correlation-id
	hdrVcCorrelationID := response.GetHeader("v-c-correlation-id")

	if hdrVcCorrelationID != "" {
		o.VcCorrelationID = hdrVcCorrelationID
	}

	o.Payload = new(PatchCustomerGoneBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPatchCustomerPreconditionFailed creates a PatchCustomerPreconditionFailed with default headers values
func NewPatchCustomerPreconditionFailed() *PatchCustomerPreconditionFailed {
	return &PatchCustomerPreconditionFailed{}
}

/* PatchCustomerPreconditionFailed describes a response with status code 412, with default header values.

Precondition Failed: The If-Match request header value does not match the current resources ETag
*/
type PatchCustomerPreconditionFailed struct {

	/* A globally unique id associated with your request.
	 */
	UniqueTransactionID string

	/* The mandatory correlation id passed by upstream (calling) system.
	 */
	VcCorrelationID string

	Payload *PatchCustomerPreconditionFailedBody
}

func (o *PatchCustomerPreconditionFailed) Error() string {
	return fmt.Sprintf("[PATCH /tms/v2/customers/{customerTokenId}][%d] patchCustomerPreconditionFailed  %+v", 412, o.Payload)
}
func (o *PatchCustomerPreconditionFailed) GetPayload() *PatchCustomerPreconditionFailedBody {
	return o.Payload
}

func (o *PatchCustomerPreconditionFailed) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	// hydrates response header uniqueTransactionID
	hdrUniqueTransactionID := response.GetHeader("uniqueTransactionID")

	if hdrUniqueTransactionID != "" {
		o.UniqueTransactionID = hdrUniqueTransactionID
	}

	// hydrates response header v-c-correlation-id
	hdrVcCorrelationID := response.GetHeader("v-c-correlation-id")

	if hdrVcCorrelationID != "" {
		o.VcCorrelationID = hdrVcCorrelationID
	}

	o.Payload = new(PatchCustomerPreconditionFailedBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPatchCustomerFailedDependency creates a PatchCustomerFailedDependency with default headers values
func NewPatchCustomerFailedDependency() *PatchCustomerFailedDependency {
	return &PatchCustomerFailedDependency{}
}

/* PatchCustomerFailedDependency describes a response with status code 424, with default header values.

Failed Dependency: e.g. The profile represented by the profile-id may not exist or the profile-id was entered incorrectly.
*/
type PatchCustomerFailedDependency struct {

	/* A globally unique id associated with your request.
	 */
	UniqueTransactionID string

	/* The mandatory correlation id passed by upstream (calling) system.
	 */
	VcCorrelationID string

	Payload *PatchCustomerFailedDependencyBody
}

func (o *PatchCustomerFailedDependency) Error() string {
	return fmt.Sprintf("[PATCH /tms/v2/customers/{customerTokenId}][%d] patchCustomerFailedDependency  %+v", 424, o.Payload)
}
func (o *PatchCustomerFailedDependency) GetPayload() *PatchCustomerFailedDependencyBody {
	return o.Payload
}

func (o *PatchCustomerFailedDependency) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	// hydrates response header uniqueTransactionID
	hdrUniqueTransactionID := response.GetHeader("uniqueTransactionID")

	if hdrUniqueTransactionID != "" {
		o.UniqueTransactionID = hdrUniqueTransactionID
	}

	// hydrates response header v-c-correlation-id
	hdrVcCorrelationID := response.GetHeader("v-c-correlation-id")

	if hdrVcCorrelationID != "" {
		o.VcCorrelationID = hdrVcCorrelationID
	}

	o.Payload = new(PatchCustomerFailedDependencyBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewPatchCustomerInternalServerError creates a PatchCustomerInternalServerError with default headers values
func NewPatchCustomerInternalServerError() *PatchCustomerInternalServerError {
	return &PatchCustomerInternalServerError{}
}

/* PatchCustomerInternalServerError describes a response with status code 500, with default header values.

Unexpected error.
*/
type PatchCustomerInternalServerError struct {

	/* A globally unique id associated with your request.
	 */
	UniqueTransactionID string

	/* The mandatory correlation id passed by upstream (calling) system.
	 */
	VcCorrelationID string

	Payload *PatchCustomerInternalServerErrorBody
}

func (o *PatchCustomerInternalServerError) Error() string {
	return fmt.Sprintf("[PATCH /tms/v2/customers/{customerTokenId}][%d] patchCustomerInternalServerError  %+v", 500, o.Payload)
}
func (o *PatchCustomerInternalServerError) GetPayload() *PatchCustomerInternalServerErrorBody {
	return o.Payload
}

func (o *PatchCustomerInternalServerError) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	// hydrates response header uniqueTransactionID
	hdrUniqueTransactionID := response.GetHeader("uniqueTransactionID")

	if hdrUniqueTransactionID != "" {
		o.UniqueTransactionID = hdrUniqueTransactionID
	}

	// hydrates response header v-c-correlation-id
	hdrVcCorrelationID := response.GetHeader("v-c-correlation-id")

	if hdrVcCorrelationID != "" {
		o.VcCorrelationID = hdrVcCorrelationID
	}

	o.Payload = new(PatchCustomerInternalServerErrorBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

/*PatchCustomerBadRequestBody patch customer bad request body
swagger:model PatchCustomerBadRequestBody
*/
type PatchCustomerBadRequestBody struct {

	// errors
	// Read Only: true
	Errors []*PatchCustomerBadRequestBodyErrorsItems0 `json:"errors"`
}

// Validate validates this patch customer bad request body
func (o *PatchCustomerBadRequestBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateErrors(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerBadRequestBody) validateErrors(formats strfmt.Registry) error {
	if swag.IsZero(o.Errors) { // not required
		return nil
	}

	for i := 0; i < len(o.Errors); i++ {
		if swag.IsZero(o.Errors[i]) { // not required
			continue
		}

		if o.Errors[i] != nil {
			if err := o.Errors[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("patchCustomerBadRequest" + "." + "errors" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("patchCustomerBadRequest" + "." + "errors" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this patch customer bad request body based on the context it is used
func (o *PatchCustomerBadRequestBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateErrors(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerBadRequestBody) contextValidateErrors(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerBadRequest"+"."+"errors", "body", []*PatchCustomerBadRequestBodyErrorsItems0(o.Errors)); err != nil {
		return err
	}

	for i := 0; i < len(o.Errors); i++ {

		if o.Errors[i] != nil {
			if err := o.Errors[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("patchCustomerBadRequest" + "." + "errors" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("patchCustomerBadRequest" + "." + "errors" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerBadRequestBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerBadRequestBody) UnmarshalBinary(b []byte) error {
	var res PatchCustomerBadRequestBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerBadRequestBodyErrorsItems0 patch customer bad request body errors items0
swagger:model PatchCustomerBadRequestBodyErrorsItems0
*/
type PatchCustomerBadRequestBodyErrorsItems0 struct {

	// details
	// Read Only: true
	Details []*PatchCustomerBadRequestBodyErrorsItems0DetailsItems0 `json:"details"`

	// The detailed message related to the type stated above.
	// Read Only: true
	Message string `json:"message,omitempty"`

	// The type of error.
	// Read Only: true
	Type string `json:"type,omitempty"`
}

// Validate validates this patch customer bad request body errors items0
func (o *PatchCustomerBadRequestBodyErrorsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerBadRequestBodyErrorsItems0) validateDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.Details) { // not required
		return nil
	}

	for i := 0; i < len(o.Details); i++ {
		if swag.IsZero(o.Details[i]) { // not required
			continue
		}

		if o.Details[i] != nil {
			if err := o.Details[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this patch customer bad request body errors items0 based on the context it is used
func (o *PatchCustomerBadRequestBodyErrorsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateMessage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerBadRequestBodyErrorsItems0) contextValidateDetails(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "details", "body", []*PatchCustomerBadRequestBodyErrorsItems0DetailsItems0(o.Details)); err != nil {
		return err
	}

	for i := 0; i < len(o.Details); i++ {

		if o.Details[i] != nil {
			if err := o.Details[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *PatchCustomerBadRequestBodyErrorsItems0) contextValidateMessage(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "message", "body", string(o.Message)); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerBadRequestBodyErrorsItems0) contextValidateType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "type", "body", string(o.Type)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerBadRequestBodyErrorsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerBadRequestBodyErrorsItems0) UnmarshalBinary(b []byte) error {
	var res PatchCustomerBadRequestBodyErrorsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerBadRequestBodyErrorsItems0DetailsItems0 patch customer bad request body errors items0 details items0
swagger:model PatchCustomerBadRequestBodyErrorsItems0DetailsItems0
*/
type PatchCustomerBadRequestBodyErrorsItems0DetailsItems0 struct {

	// The location of the field that caused the error.
	// Read Only: true
	Location string `json:"location,omitempty"`

	// The name of the field that caused the error.
	// Read Only: true
	Name string `json:"name,omitempty"`
}

// Validate validates this patch customer bad request body errors items0 details items0
func (o *PatchCustomerBadRequestBodyErrorsItems0DetailsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this patch customer bad request body errors items0 details items0 based on the context it is used
func (o *PatchCustomerBadRequestBodyErrorsItems0DetailsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateLocation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerBadRequestBodyErrorsItems0DetailsItems0) contextValidateLocation(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "location", "body", string(o.Location)); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerBadRequestBodyErrorsItems0DetailsItems0) contextValidateName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "name", "body", string(o.Name)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerBadRequestBodyErrorsItems0DetailsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerBadRequestBodyErrorsItems0DetailsItems0) UnmarshalBinary(b []byte) error {
	var res PatchCustomerBadRequestBodyErrorsItems0DetailsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerBody patch customer body
swagger:model PatchCustomerBody
*/
type PatchCustomerBody struct {

	// embedded
	Embedded *PatchCustomerParamsBodyEmbedded `json:"_embedded,omitempty"`

	// links
	Links *PatchCustomerParamsBodyLinks `json:"_links,omitempty"`

	// buyer information
	BuyerInformation *PatchCustomerParamsBodyBuyerInformation `json:"buyerInformation,omitempty"`

	// client reference information
	ClientReferenceInformation *PatchCustomerParamsBodyClientReferenceInformation `json:"clientReferenceInformation,omitempty"`

	// default payment instrument
	DefaultPaymentInstrument *PatchCustomerParamsBodyDefaultPaymentInstrument `json:"defaultPaymentInstrument,omitempty"`

	// default shipping address
	DefaultShippingAddress *PatchCustomerParamsBodyDefaultShippingAddress `json:"defaultShippingAddress,omitempty"`

	// The id of the Customer Token.
	// Max Length: 32
	// Min Length: 1
	ID string `json:"id,omitempty"`

	// Object containing the custom data that the merchant defines.
	//
	MerchantDefinedInformation []*PatchCustomerParamsBodyMerchantDefinedInformationItems0 `json:"merchantDefinedInformation"`

	// metadata
	Metadata *PatchCustomerParamsBodyMetadata `json:"metadata,omitempty"`

	// object information
	ObjectInformation *PatchCustomerParamsBodyObjectInformation `json:"objectInformation,omitempty"`
}

// Validate validates this patch customer body
func (o *PatchCustomerBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateEmbedded(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBuyerInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateClientReferenceInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDefaultPaymentInstrument(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDefaultShippingAddress(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMerchantDefinedInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMetadata(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateObjectInformation(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerBody) validateEmbedded(formats strfmt.Registry) error {
	if swag.IsZero(o.Embedded) { // not required
		return nil
	}

	if o.Embedded != nil {
		if err := o.Embedded.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerBody) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(o.Links) { // not required
		return nil
	}

	if o.Links != nil {
		if err := o.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerBody) validateBuyerInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.BuyerInformation) { // not required
		return nil
	}

	if o.BuyerInformation != nil {
		if err := o.BuyerInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "buyerInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "buyerInformation")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerBody) validateClientReferenceInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ClientReferenceInformation) { // not required
		return nil
	}

	if o.ClientReferenceInformation != nil {
		if err := o.ClientReferenceInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "clientReferenceInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "clientReferenceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerBody) validateDefaultPaymentInstrument(formats strfmt.Registry) error {
	if swag.IsZero(o.DefaultPaymentInstrument) { // not required
		return nil
	}

	if o.DefaultPaymentInstrument != nil {
		if err := o.DefaultPaymentInstrument.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "defaultPaymentInstrument")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "defaultPaymentInstrument")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerBody) validateDefaultShippingAddress(formats strfmt.Registry) error {
	if swag.IsZero(o.DefaultShippingAddress) { // not required
		return nil
	}

	if o.DefaultShippingAddress != nil {
		if err := o.DefaultShippingAddress.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "defaultShippingAddress")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "defaultShippingAddress")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerBody) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MinLength("patchCustomerRequest"+"."+"id", "body", o.ID, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("patchCustomerRequest"+"."+"id", "body", o.ID, 32); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerBody) validateMerchantDefinedInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.MerchantDefinedInformation) { // not required
		return nil
	}

	for i := 0; i < len(o.MerchantDefinedInformation); i++ {
		if swag.IsZero(o.MerchantDefinedInformation[i]) { // not required
			continue
		}

		if o.MerchantDefinedInformation[i] != nil {
			if err := o.MerchantDefinedInformation[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("patchCustomerRequest" + "." + "merchantDefinedInformation" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("patchCustomerRequest" + "." + "merchantDefinedInformation" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *PatchCustomerBody) validateMetadata(formats strfmt.Registry) error {
	if swag.IsZero(o.Metadata) { // not required
		return nil
	}

	if o.Metadata != nil {
		if err := o.Metadata.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "metadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "metadata")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerBody) validateObjectInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ObjectInformation) { // not required
		return nil
	}

	if o.ObjectInformation != nil {
		if err := o.ObjectInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "objectInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "objectInformation")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch customer body based on the context it is used
func (o *PatchCustomerBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateEmbedded(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateBuyerInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateClientReferenceInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateDefaultPaymentInstrument(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateDefaultShippingAddress(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateMerchantDefinedInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateMetadata(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateObjectInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerBody) contextValidateEmbedded(ctx context.Context, formats strfmt.Registry) error {

	if o.Embedded != nil {
		if err := o.Embedded.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerBody) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if o.Links != nil {
		if err := o.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerBody) contextValidateBuyerInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.BuyerInformation != nil {
		if err := o.BuyerInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "buyerInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "buyerInformation")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerBody) contextValidateClientReferenceInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ClientReferenceInformation != nil {
		if err := o.ClientReferenceInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "clientReferenceInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "clientReferenceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerBody) contextValidateDefaultPaymentInstrument(ctx context.Context, formats strfmt.Registry) error {

	if o.DefaultPaymentInstrument != nil {
		if err := o.DefaultPaymentInstrument.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "defaultPaymentInstrument")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "defaultPaymentInstrument")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerBody) contextValidateDefaultShippingAddress(ctx context.Context, formats strfmt.Registry) error {

	if o.DefaultShippingAddress != nil {
		if err := o.DefaultShippingAddress.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "defaultShippingAddress")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "defaultShippingAddress")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerBody) contextValidateMerchantDefinedInformation(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.MerchantDefinedInformation); i++ {

		if o.MerchantDefinedInformation[i] != nil {
			if err := o.MerchantDefinedInformation[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("patchCustomerRequest" + "." + "merchantDefinedInformation" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("patchCustomerRequest" + "." + "merchantDefinedInformation" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *PatchCustomerBody) contextValidateMetadata(ctx context.Context, formats strfmt.Registry) error {

	if o.Metadata != nil {
		if err := o.Metadata.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "metadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "metadata")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerBody) contextValidateObjectInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ObjectInformation != nil {
		if err := o.ObjectInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "objectInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "objectInformation")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerBody) UnmarshalBinary(b []byte) error {
	var res PatchCustomerBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerFailedDependencyBody patch customer failed dependency body
swagger:model PatchCustomerFailedDependencyBody
*/
type PatchCustomerFailedDependencyBody struct {

	// errors
	// Read Only: true
	Errors []*PatchCustomerFailedDependencyBodyErrorsItems0 `json:"errors"`
}

// Validate validates this patch customer failed dependency body
func (o *PatchCustomerFailedDependencyBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateErrors(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerFailedDependencyBody) validateErrors(formats strfmt.Registry) error {
	if swag.IsZero(o.Errors) { // not required
		return nil
	}

	for i := 0; i < len(o.Errors); i++ {
		if swag.IsZero(o.Errors[i]) { // not required
			continue
		}

		if o.Errors[i] != nil {
			if err := o.Errors[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("patchCustomerFailedDependency" + "." + "errors" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("patchCustomerFailedDependency" + "." + "errors" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this patch customer failed dependency body based on the context it is used
func (o *PatchCustomerFailedDependencyBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateErrors(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerFailedDependencyBody) contextValidateErrors(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerFailedDependency"+"."+"errors", "body", []*PatchCustomerFailedDependencyBodyErrorsItems0(o.Errors)); err != nil {
		return err
	}

	for i := 0; i < len(o.Errors); i++ {

		if o.Errors[i] != nil {
			if err := o.Errors[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("patchCustomerFailedDependency" + "." + "errors" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("patchCustomerFailedDependency" + "." + "errors" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerFailedDependencyBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerFailedDependencyBody) UnmarshalBinary(b []byte) error {
	var res PatchCustomerFailedDependencyBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerFailedDependencyBodyErrorsItems0 patch customer failed dependency body errors items0
swagger:model PatchCustomerFailedDependencyBodyErrorsItems0
*/
type PatchCustomerFailedDependencyBodyErrorsItems0 struct {

	// details
	// Read Only: true
	Details []*PatchCustomerFailedDependencyBodyErrorsItems0DetailsItems0 `json:"details"`

	// The detailed message related to the type stated above.
	// Read Only: true
	Message string `json:"message,omitempty"`

	// The type of error.
	// Read Only: true
	Type string `json:"type,omitempty"`
}

// Validate validates this patch customer failed dependency body errors items0
func (o *PatchCustomerFailedDependencyBodyErrorsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerFailedDependencyBodyErrorsItems0) validateDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.Details) { // not required
		return nil
	}

	for i := 0; i < len(o.Details); i++ {
		if swag.IsZero(o.Details[i]) { // not required
			continue
		}

		if o.Details[i] != nil {
			if err := o.Details[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this patch customer failed dependency body errors items0 based on the context it is used
func (o *PatchCustomerFailedDependencyBodyErrorsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateMessage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerFailedDependencyBodyErrorsItems0) contextValidateDetails(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "details", "body", []*PatchCustomerFailedDependencyBodyErrorsItems0DetailsItems0(o.Details)); err != nil {
		return err
	}

	for i := 0; i < len(o.Details); i++ {

		if o.Details[i] != nil {
			if err := o.Details[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *PatchCustomerFailedDependencyBodyErrorsItems0) contextValidateMessage(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "message", "body", string(o.Message)); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerFailedDependencyBodyErrorsItems0) contextValidateType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "type", "body", string(o.Type)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerFailedDependencyBodyErrorsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerFailedDependencyBodyErrorsItems0) UnmarshalBinary(b []byte) error {
	var res PatchCustomerFailedDependencyBodyErrorsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerFailedDependencyBodyErrorsItems0DetailsItems0 patch customer failed dependency body errors items0 details items0
swagger:model PatchCustomerFailedDependencyBodyErrorsItems0DetailsItems0
*/
type PatchCustomerFailedDependencyBodyErrorsItems0DetailsItems0 struct {

	// The location of the field that caused the error.
	// Read Only: true
	Location string `json:"location,omitempty"`

	// The name of the field that caused the error.
	// Read Only: true
	Name string `json:"name,omitempty"`
}

// Validate validates this patch customer failed dependency body errors items0 details items0
func (o *PatchCustomerFailedDependencyBodyErrorsItems0DetailsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this patch customer failed dependency body errors items0 details items0 based on the context it is used
func (o *PatchCustomerFailedDependencyBodyErrorsItems0DetailsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateLocation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerFailedDependencyBodyErrorsItems0DetailsItems0) contextValidateLocation(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "location", "body", string(o.Location)); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerFailedDependencyBodyErrorsItems0DetailsItems0) contextValidateName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "name", "body", string(o.Name)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerFailedDependencyBodyErrorsItems0DetailsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerFailedDependencyBodyErrorsItems0DetailsItems0) UnmarshalBinary(b []byte) error {
	var res PatchCustomerFailedDependencyBodyErrorsItems0DetailsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerForbiddenBody patch customer forbidden body
swagger:model PatchCustomerForbiddenBody
*/
type PatchCustomerForbiddenBody struct {

	// errors
	// Read Only: true
	Errors []*PatchCustomerForbiddenBodyErrorsItems0 `json:"errors"`
}

// Validate validates this patch customer forbidden body
func (o *PatchCustomerForbiddenBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateErrors(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerForbiddenBody) validateErrors(formats strfmt.Registry) error {
	if swag.IsZero(o.Errors) { // not required
		return nil
	}

	for i := 0; i < len(o.Errors); i++ {
		if swag.IsZero(o.Errors[i]) { // not required
			continue
		}

		if o.Errors[i] != nil {
			if err := o.Errors[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("patchCustomerForbidden" + "." + "errors" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("patchCustomerForbidden" + "." + "errors" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this patch customer forbidden body based on the context it is used
func (o *PatchCustomerForbiddenBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateErrors(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerForbiddenBody) contextValidateErrors(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerForbidden"+"."+"errors", "body", []*PatchCustomerForbiddenBodyErrorsItems0(o.Errors)); err != nil {
		return err
	}

	for i := 0; i < len(o.Errors); i++ {

		if o.Errors[i] != nil {
			if err := o.Errors[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("patchCustomerForbidden" + "." + "errors" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("patchCustomerForbidden" + "." + "errors" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerForbiddenBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerForbiddenBody) UnmarshalBinary(b []byte) error {
	var res PatchCustomerForbiddenBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerForbiddenBodyErrorsItems0 patch customer forbidden body errors items0
swagger:model PatchCustomerForbiddenBodyErrorsItems0
*/
type PatchCustomerForbiddenBodyErrorsItems0 struct {

	// details
	// Read Only: true
	Details []*PatchCustomerForbiddenBodyErrorsItems0DetailsItems0 `json:"details"`

	// The detailed message related to the type stated above.
	// Read Only: true
	Message string `json:"message,omitempty"`

	// The type of error.
	// Read Only: true
	Type string `json:"type,omitempty"`
}

// Validate validates this patch customer forbidden body errors items0
func (o *PatchCustomerForbiddenBodyErrorsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerForbiddenBodyErrorsItems0) validateDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.Details) { // not required
		return nil
	}

	for i := 0; i < len(o.Details); i++ {
		if swag.IsZero(o.Details[i]) { // not required
			continue
		}

		if o.Details[i] != nil {
			if err := o.Details[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this patch customer forbidden body errors items0 based on the context it is used
func (o *PatchCustomerForbiddenBodyErrorsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateMessage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerForbiddenBodyErrorsItems0) contextValidateDetails(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "details", "body", []*PatchCustomerForbiddenBodyErrorsItems0DetailsItems0(o.Details)); err != nil {
		return err
	}

	for i := 0; i < len(o.Details); i++ {

		if o.Details[i] != nil {
			if err := o.Details[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *PatchCustomerForbiddenBodyErrorsItems0) contextValidateMessage(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "message", "body", string(o.Message)); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerForbiddenBodyErrorsItems0) contextValidateType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "type", "body", string(o.Type)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerForbiddenBodyErrorsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerForbiddenBodyErrorsItems0) UnmarshalBinary(b []byte) error {
	var res PatchCustomerForbiddenBodyErrorsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerForbiddenBodyErrorsItems0DetailsItems0 patch customer forbidden body errors items0 details items0
swagger:model PatchCustomerForbiddenBodyErrorsItems0DetailsItems0
*/
type PatchCustomerForbiddenBodyErrorsItems0DetailsItems0 struct {

	// The location of the field that caused the error.
	// Read Only: true
	Location string `json:"location,omitempty"`

	// The name of the field that caused the error.
	// Read Only: true
	Name string `json:"name,omitempty"`
}

// Validate validates this patch customer forbidden body errors items0 details items0
func (o *PatchCustomerForbiddenBodyErrorsItems0DetailsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this patch customer forbidden body errors items0 details items0 based on the context it is used
func (o *PatchCustomerForbiddenBodyErrorsItems0DetailsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateLocation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerForbiddenBodyErrorsItems0DetailsItems0) contextValidateLocation(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "location", "body", string(o.Location)); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerForbiddenBodyErrorsItems0DetailsItems0) contextValidateName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "name", "body", string(o.Name)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerForbiddenBodyErrorsItems0DetailsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerForbiddenBodyErrorsItems0DetailsItems0) UnmarshalBinary(b []byte) error {
	var res PatchCustomerForbiddenBodyErrorsItems0DetailsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerGoneBody patch customer gone body
swagger:model PatchCustomerGoneBody
*/
type PatchCustomerGoneBody struct {

	// errors
	// Read Only: true
	Errors []*PatchCustomerGoneBodyErrorsItems0 `json:"errors"`
}

// Validate validates this patch customer gone body
func (o *PatchCustomerGoneBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateErrors(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerGoneBody) validateErrors(formats strfmt.Registry) error {
	if swag.IsZero(o.Errors) { // not required
		return nil
	}

	for i := 0; i < len(o.Errors); i++ {
		if swag.IsZero(o.Errors[i]) { // not required
			continue
		}

		if o.Errors[i] != nil {
			if err := o.Errors[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("patchCustomerGone" + "." + "errors" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("patchCustomerGone" + "." + "errors" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this patch customer gone body based on the context it is used
func (o *PatchCustomerGoneBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateErrors(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerGoneBody) contextValidateErrors(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerGone"+"."+"errors", "body", []*PatchCustomerGoneBodyErrorsItems0(o.Errors)); err != nil {
		return err
	}

	for i := 0; i < len(o.Errors); i++ {

		if o.Errors[i] != nil {
			if err := o.Errors[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("patchCustomerGone" + "." + "errors" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("patchCustomerGone" + "." + "errors" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerGoneBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerGoneBody) UnmarshalBinary(b []byte) error {
	var res PatchCustomerGoneBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerGoneBodyErrorsItems0 patch customer gone body errors items0
swagger:model PatchCustomerGoneBodyErrorsItems0
*/
type PatchCustomerGoneBodyErrorsItems0 struct {

	// details
	// Read Only: true
	Details []*PatchCustomerGoneBodyErrorsItems0DetailsItems0 `json:"details"`

	// The detailed message related to the type stated above.
	// Read Only: true
	Message string `json:"message,omitempty"`

	// The type of error.
	// Read Only: true
	Type string `json:"type,omitempty"`
}

// Validate validates this patch customer gone body errors items0
func (o *PatchCustomerGoneBodyErrorsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerGoneBodyErrorsItems0) validateDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.Details) { // not required
		return nil
	}

	for i := 0; i < len(o.Details); i++ {
		if swag.IsZero(o.Details[i]) { // not required
			continue
		}

		if o.Details[i] != nil {
			if err := o.Details[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this patch customer gone body errors items0 based on the context it is used
func (o *PatchCustomerGoneBodyErrorsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateMessage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerGoneBodyErrorsItems0) contextValidateDetails(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "details", "body", []*PatchCustomerGoneBodyErrorsItems0DetailsItems0(o.Details)); err != nil {
		return err
	}

	for i := 0; i < len(o.Details); i++ {

		if o.Details[i] != nil {
			if err := o.Details[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *PatchCustomerGoneBodyErrorsItems0) contextValidateMessage(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "message", "body", string(o.Message)); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerGoneBodyErrorsItems0) contextValidateType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "type", "body", string(o.Type)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerGoneBodyErrorsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerGoneBodyErrorsItems0) UnmarshalBinary(b []byte) error {
	var res PatchCustomerGoneBodyErrorsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerGoneBodyErrorsItems0DetailsItems0 patch customer gone body errors items0 details items0
swagger:model PatchCustomerGoneBodyErrorsItems0DetailsItems0
*/
type PatchCustomerGoneBodyErrorsItems0DetailsItems0 struct {

	// The location of the field that caused the error.
	// Read Only: true
	Location string `json:"location,omitempty"`

	// The name of the field that caused the error.
	// Read Only: true
	Name string `json:"name,omitempty"`
}

// Validate validates this patch customer gone body errors items0 details items0
func (o *PatchCustomerGoneBodyErrorsItems0DetailsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this patch customer gone body errors items0 details items0 based on the context it is used
func (o *PatchCustomerGoneBodyErrorsItems0DetailsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateLocation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerGoneBodyErrorsItems0DetailsItems0) contextValidateLocation(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "location", "body", string(o.Location)); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerGoneBodyErrorsItems0DetailsItems0) contextValidateName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "name", "body", string(o.Name)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerGoneBodyErrorsItems0DetailsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerGoneBodyErrorsItems0DetailsItems0) UnmarshalBinary(b []byte) error {
	var res PatchCustomerGoneBodyErrorsItems0DetailsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerInternalServerErrorBody patch customer internal server error body
swagger:model PatchCustomerInternalServerErrorBody
*/
type PatchCustomerInternalServerErrorBody struct {

	// errors
	// Read Only: true
	Errors []*PatchCustomerInternalServerErrorBodyErrorsItems0 `json:"errors"`
}

// Validate validates this patch customer internal server error body
func (o *PatchCustomerInternalServerErrorBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateErrors(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerInternalServerErrorBody) validateErrors(formats strfmt.Registry) error {
	if swag.IsZero(o.Errors) { // not required
		return nil
	}

	for i := 0; i < len(o.Errors); i++ {
		if swag.IsZero(o.Errors[i]) { // not required
			continue
		}

		if o.Errors[i] != nil {
			if err := o.Errors[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("patchCustomerInternalServerError" + "." + "errors" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("patchCustomerInternalServerError" + "." + "errors" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this patch customer internal server error body based on the context it is used
func (o *PatchCustomerInternalServerErrorBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateErrors(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerInternalServerErrorBody) contextValidateErrors(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerInternalServerError"+"."+"errors", "body", []*PatchCustomerInternalServerErrorBodyErrorsItems0(o.Errors)); err != nil {
		return err
	}

	for i := 0; i < len(o.Errors); i++ {

		if o.Errors[i] != nil {
			if err := o.Errors[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("patchCustomerInternalServerError" + "." + "errors" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("patchCustomerInternalServerError" + "." + "errors" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerInternalServerErrorBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerInternalServerErrorBody) UnmarshalBinary(b []byte) error {
	var res PatchCustomerInternalServerErrorBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerInternalServerErrorBodyErrorsItems0 patch customer internal server error body errors items0
swagger:model PatchCustomerInternalServerErrorBodyErrorsItems0
*/
type PatchCustomerInternalServerErrorBodyErrorsItems0 struct {

	// details
	// Read Only: true
	Details []*PatchCustomerInternalServerErrorBodyErrorsItems0DetailsItems0 `json:"details"`

	// The detailed message related to the type stated above.
	// Read Only: true
	Message string `json:"message,omitempty"`

	// The type of error.
	// Read Only: true
	Type string `json:"type,omitempty"`
}

// Validate validates this patch customer internal server error body errors items0
func (o *PatchCustomerInternalServerErrorBodyErrorsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerInternalServerErrorBodyErrorsItems0) validateDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.Details) { // not required
		return nil
	}

	for i := 0; i < len(o.Details); i++ {
		if swag.IsZero(o.Details[i]) { // not required
			continue
		}

		if o.Details[i] != nil {
			if err := o.Details[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this patch customer internal server error body errors items0 based on the context it is used
func (o *PatchCustomerInternalServerErrorBodyErrorsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateMessage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerInternalServerErrorBodyErrorsItems0) contextValidateDetails(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "details", "body", []*PatchCustomerInternalServerErrorBodyErrorsItems0DetailsItems0(o.Details)); err != nil {
		return err
	}

	for i := 0; i < len(o.Details); i++ {

		if o.Details[i] != nil {
			if err := o.Details[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *PatchCustomerInternalServerErrorBodyErrorsItems0) contextValidateMessage(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "message", "body", string(o.Message)); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerInternalServerErrorBodyErrorsItems0) contextValidateType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "type", "body", string(o.Type)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerInternalServerErrorBodyErrorsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerInternalServerErrorBodyErrorsItems0) UnmarshalBinary(b []byte) error {
	var res PatchCustomerInternalServerErrorBodyErrorsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerInternalServerErrorBodyErrorsItems0DetailsItems0 patch customer internal server error body errors items0 details items0
swagger:model PatchCustomerInternalServerErrorBodyErrorsItems0DetailsItems0
*/
type PatchCustomerInternalServerErrorBodyErrorsItems0DetailsItems0 struct {

	// The location of the field that caused the error.
	// Read Only: true
	Location string `json:"location,omitempty"`

	// The name of the field that caused the error.
	// Read Only: true
	Name string `json:"name,omitempty"`
}

// Validate validates this patch customer internal server error body errors items0 details items0
func (o *PatchCustomerInternalServerErrorBodyErrorsItems0DetailsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this patch customer internal server error body errors items0 details items0 based on the context it is used
func (o *PatchCustomerInternalServerErrorBodyErrorsItems0DetailsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateLocation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerInternalServerErrorBodyErrorsItems0DetailsItems0) contextValidateLocation(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "location", "body", string(o.Location)); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerInternalServerErrorBodyErrorsItems0DetailsItems0) contextValidateName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "name", "body", string(o.Name)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerInternalServerErrorBodyErrorsItems0DetailsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerInternalServerErrorBodyErrorsItems0DetailsItems0) UnmarshalBinary(b []byte) error {
	var res PatchCustomerInternalServerErrorBodyErrorsItems0DetailsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerNotFoundBody patch customer not found body
swagger:model PatchCustomerNotFoundBody
*/
type PatchCustomerNotFoundBody struct {

	// errors
	// Read Only: true
	Errors []*PatchCustomerNotFoundBodyErrorsItems0 `json:"errors"`
}

// Validate validates this patch customer not found body
func (o *PatchCustomerNotFoundBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateErrors(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerNotFoundBody) validateErrors(formats strfmt.Registry) error {
	if swag.IsZero(o.Errors) { // not required
		return nil
	}

	for i := 0; i < len(o.Errors); i++ {
		if swag.IsZero(o.Errors[i]) { // not required
			continue
		}

		if o.Errors[i] != nil {
			if err := o.Errors[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("patchCustomerNotFound" + "." + "errors" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("patchCustomerNotFound" + "." + "errors" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this patch customer not found body based on the context it is used
func (o *PatchCustomerNotFoundBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateErrors(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerNotFoundBody) contextValidateErrors(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerNotFound"+"."+"errors", "body", []*PatchCustomerNotFoundBodyErrorsItems0(o.Errors)); err != nil {
		return err
	}

	for i := 0; i < len(o.Errors); i++ {

		if o.Errors[i] != nil {
			if err := o.Errors[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("patchCustomerNotFound" + "." + "errors" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("patchCustomerNotFound" + "." + "errors" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerNotFoundBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerNotFoundBody) UnmarshalBinary(b []byte) error {
	var res PatchCustomerNotFoundBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerNotFoundBodyErrorsItems0 patch customer not found body errors items0
swagger:model PatchCustomerNotFoundBodyErrorsItems0
*/
type PatchCustomerNotFoundBodyErrorsItems0 struct {

	// details
	// Read Only: true
	Details []*PatchCustomerNotFoundBodyErrorsItems0DetailsItems0 `json:"details"`

	// The detailed message related to the type stated above.
	// Read Only: true
	Message string `json:"message,omitempty"`

	// The type of error.
	// Read Only: true
	Type string `json:"type,omitempty"`
}

// Validate validates this patch customer not found body errors items0
func (o *PatchCustomerNotFoundBodyErrorsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerNotFoundBodyErrorsItems0) validateDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.Details) { // not required
		return nil
	}

	for i := 0; i < len(o.Details); i++ {
		if swag.IsZero(o.Details[i]) { // not required
			continue
		}

		if o.Details[i] != nil {
			if err := o.Details[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this patch customer not found body errors items0 based on the context it is used
func (o *PatchCustomerNotFoundBodyErrorsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateMessage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerNotFoundBodyErrorsItems0) contextValidateDetails(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "details", "body", []*PatchCustomerNotFoundBodyErrorsItems0DetailsItems0(o.Details)); err != nil {
		return err
	}

	for i := 0; i < len(o.Details); i++ {

		if o.Details[i] != nil {
			if err := o.Details[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *PatchCustomerNotFoundBodyErrorsItems0) contextValidateMessage(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "message", "body", string(o.Message)); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerNotFoundBodyErrorsItems0) contextValidateType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "type", "body", string(o.Type)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerNotFoundBodyErrorsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerNotFoundBodyErrorsItems0) UnmarshalBinary(b []byte) error {
	var res PatchCustomerNotFoundBodyErrorsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerNotFoundBodyErrorsItems0DetailsItems0 patch customer not found body errors items0 details items0
swagger:model PatchCustomerNotFoundBodyErrorsItems0DetailsItems0
*/
type PatchCustomerNotFoundBodyErrorsItems0DetailsItems0 struct {

	// The location of the field that caused the error.
	// Read Only: true
	Location string `json:"location,omitempty"`

	// The name of the field that caused the error.
	// Read Only: true
	Name string `json:"name,omitempty"`
}

// Validate validates this patch customer not found body errors items0 details items0
func (o *PatchCustomerNotFoundBodyErrorsItems0DetailsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this patch customer not found body errors items0 details items0 based on the context it is used
func (o *PatchCustomerNotFoundBodyErrorsItems0DetailsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateLocation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerNotFoundBodyErrorsItems0DetailsItems0) contextValidateLocation(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "location", "body", string(o.Location)); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerNotFoundBodyErrorsItems0DetailsItems0) contextValidateName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "name", "body", string(o.Name)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerNotFoundBodyErrorsItems0DetailsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerNotFoundBodyErrorsItems0DetailsItems0) UnmarshalBinary(b []byte) error {
	var res PatchCustomerNotFoundBodyErrorsItems0DetailsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerOKBody patch customer o k body
swagger:model PatchCustomerOKBody
*/
type PatchCustomerOKBody struct {

	// embedded
	Embedded *PatchCustomerOKBodyEmbedded `json:"_embedded,omitempty"`

	// links
	Links *PatchCustomerOKBodyLinks `json:"_links,omitempty"`

	// buyer information
	BuyerInformation *PatchCustomerOKBodyBuyerInformation `json:"buyerInformation,omitempty"`

	// client reference information
	ClientReferenceInformation *PatchCustomerOKBodyClientReferenceInformation `json:"clientReferenceInformation,omitempty"`

	// default payment instrument
	DefaultPaymentInstrument *PatchCustomerOKBodyDefaultPaymentInstrument `json:"defaultPaymentInstrument,omitempty"`

	// default shipping address
	DefaultShippingAddress *PatchCustomerOKBodyDefaultShippingAddress `json:"defaultShippingAddress,omitempty"`

	// The id of the Customer Token.
	// Max Length: 32
	// Min Length: 1
	ID string `json:"id,omitempty"`

	// Object containing the custom data that the merchant defines.
	//
	MerchantDefinedInformation []*PatchCustomerOKBodyMerchantDefinedInformationItems0 `json:"merchantDefinedInformation"`

	// metadata
	Metadata *PatchCustomerOKBodyMetadata `json:"metadata,omitempty"`

	// object information
	ObjectInformation *PatchCustomerOKBodyObjectInformation `json:"objectInformation,omitempty"`
}

// Validate validates this patch customer o k body
func (o *PatchCustomerOKBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateEmbedded(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBuyerInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateClientReferenceInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDefaultPaymentInstrument(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDefaultShippingAddress(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMerchantDefinedInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMetadata(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateObjectInformation(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerOKBody) validateEmbedded(formats strfmt.Registry) error {
	if swag.IsZero(o.Embedded) { // not required
		return nil
	}

	if o.Embedded != nil {
		if err := o.Embedded.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerOKBody) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(o.Links) { // not required
		return nil
	}

	if o.Links != nil {
		if err := o.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerOKBody) validateBuyerInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.BuyerInformation) { // not required
		return nil
	}

	if o.BuyerInformation != nil {
		if err := o.BuyerInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "buyerInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "buyerInformation")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerOKBody) validateClientReferenceInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ClientReferenceInformation) { // not required
		return nil
	}

	if o.ClientReferenceInformation != nil {
		if err := o.ClientReferenceInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "clientReferenceInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "clientReferenceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerOKBody) validateDefaultPaymentInstrument(formats strfmt.Registry) error {
	if swag.IsZero(o.DefaultPaymentInstrument) { // not required
		return nil
	}

	if o.DefaultPaymentInstrument != nil {
		if err := o.DefaultPaymentInstrument.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "defaultPaymentInstrument")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "defaultPaymentInstrument")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerOKBody) validateDefaultShippingAddress(formats strfmt.Registry) error {
	if swag.IsZero(o.DefaultShippingAddress) { // not required
		return nil
	}

	if o.DefaultShippingAddress != nil {
		if err := o.DefaultShippingAddress.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "defaultShippingAddress")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "defaultShippingAddress")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerOKBody) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MinLength("patchCustomerOK"+"."+"id", "body", o.ID, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("patchCustomerOK"+"."+"id", "body", o.ID, 32); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerOKBody) validateMerchantDefinedInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.MerchantDefinedInformation) { // not required
		return nil
	}

	for i := 0; i < len(o.MerchantDefinedInformation); i++ {
		if swag.IsZero(o.MerchantDefinedInformation[i]) { // not required
			continue
		}

		if o.MerchantDefinedInformation[i] != nil {
			if err := o.MerchantDefinedInformation[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("patchCustomerOK" + "." + "merchantDefinedInformation" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("patchCustomerOK" + "." + "merchantDefinedInformation" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *PatchCustomerOKBody) validateMetadata(formats strfmt.Registry) error {
	if swag.IsZero(o.Metadata) { // not required
		return nil
	}

	if o.Metadata != nil {
		if err := o.Metadata.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "metadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "metadata")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerOKBody) validateObjectInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ObjectInformation) { // not required
		return nil
	}

	if o.ObjectInformation != nil {
		if err := o.ObjectInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "objectInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "objectInformation")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch customer o k body based on the context it is used
func (o *PatchCustomerOKBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateEmbedded(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateBuyerInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateClientReferenceInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateDefaultPaymentInstrument(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateDefaultShippingAddress(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateMerchantDefinedInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateMetadata(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateObjectInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerOKBody) contextValidateEmbedded(ctx context.Context, formats strfmt.Registry) error {

	if o.Embedded != nil {
		if err := o.Embedded.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerOKBody) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if o.Links != nil {
		if err := o.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerOKBody) contextValidateBuyerInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.BuyerInformation != nil {
		if err := o.BuyerInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "buyerInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "buyerInformation")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerOKBody) contextValidateClientReferenceInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ClientReferenceInformation != nil {
		if err := o.ClientReferenceInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "clientReferenceInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "clientReferenceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerOKBody) contextValidateDefaultPaymentInstrument(ctx context.Context, formats strfmt.Registry) error {

	if o.DefaultPaymentInstrument != nil {
		if err := o.DefaultPaymentInstrument.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "defaultPaymentInstrument")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "defaultPaymentInstrument")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerOKBody) contextValidateDefaultShippingAddress(ctx context.Context, formats strfmt.Registry) error {

	if o.DefaultShippingAddress != nil {
		if err := o.DefaultShippingAddress.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "defaultShippingAddress")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "defaultShippingAddress")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerOKBody) contextValidateMerchantDefinedInformation(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.MerchantDefinedInformation); i++ {

		if o.MerchantDefinedInformation[i] != nil {
			if err := o.MerchantDefinedInformation[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("patchCustomerOK" + "." + "merchantDefinedInformation" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("patchCustomerOK" + "." + "merchantDefinedInformation" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *PatchCustomerOKBody) contextValidateMetadata(ctx context.Context, formats strfmt.Registry) error {

	if o.Metadata != nil {
		if err := o.Metadata.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "metadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "metadata")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerOKBody) contextValidateObjectInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ObjectInformation != nil {
		if err := o.ObjectInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "objectInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "objectInformation")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerOKBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerOKBody) UnmarshalBinary(b []byte) error {
	var res PatchCustomerOKBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerOKBodyBuyerInformation patch customer o k body buyer information
swagger:model PatchCustomerOKBodyBuyerInformation
*/
type PatchCustomerOKBodyBuyerInformation struct {

	// Customer's primary email address, including the full domain name.
	//
	// Max Length: 255
	Email string `json:"email,omitempty"`

	// Your identifier for the customer.
	//
	// Max Length: 100
	MerchantCustomerID string `json:"merchantCustomerID,omitempty"`
}

// Validate validates this patch customer o k body buyer information
func (o *PatchCustomerOKBodyBuyerInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateEmail(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMerchantCustomerID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerOKBodyBuyerInformation) validateEmail(formats strfmt.Registry) error {
	if swag.IsZero(o.Email) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerOK"+"."+"buyerInformation"+"."+"email", "body", o.Email, 255); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerOKBodyBuyerInformation) validateMerchantCustomerID(formats strfmt.Registry) error {
	if swag.IsZero(o.MerchantCustomerID) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerOK"+"."+"buyerInformation"+"."+"merchantCustomerID", "body", o.MerchantCustomerID, 100); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this patch customer o k body buyer information based on context it is used
func (o *PatchCustomerOKBodyBuyerInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerOKBodyBuyerInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerOKBodyBuyerInformation) UnmarshalBinary(b []byte) error {
	var res PatchCustomerOKBodyBuyerInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerOKBodyClientReferenceInformation patch customer o k body client reference information
swagger:model PatchCustomerOKBodyClientReferenceInformation
*/
type PatchCustomerOKBodyClientReferenceInformation struct {

	// Client-generated order reference or tracking number.
	//
	// Max Length: 50
	Code string `json:"code,omitempty"`
}

// Validate validates this patch customer o k body client reference information
func (o *PatchCustomerOKBodyClientReferenceInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerOKBodyClientReferenceInformation) validateCode(formats strfmt.Registry) error {
	if swag.IsZero(o.Code) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerOK"+"."+"clientReferenceInformation"+"."+"code", "body", o.Code, 50); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this patch customer o k body client reference information based on context it is used
func (o *PatchCustomerOKBodyClientReferenceInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerOKBodyClientReferenceInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerOKBodyClientReferenceInformation) UnmarshalBinary(b []byte) error {
	var res PatchCustomerOKBodyClientReferenceInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerOKBodyDefaultPaymentInstrument patch customer o k body default payment instrument
swagger:model PatchCustomerOKBodyDefaultPaymentInstrument
*/
type PatchCustomerOKBodyDefaultPaymentInstrument struct {

	// The id of the Customers default Payment Instrument
	//
	ID string `json:"id,omitempty"`
}

// Validate validates this patch customer o k body default payment instrument
func (o *PatchCustomerOKBodyDefaultPaymentInstrument) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this patch customer o k body default payment instrument based on context it is used
func (o *PatchCustomerOKBodyDefaultPaymentInstrument) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerOKBodyDefaultPaymentInstrument) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerOKBodyDefaultPaymentInstrument) UnmarshalBinary(b []byte) error {
	var res PatchCustomerOKBodyDefaultPaymentInstrument
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerOKBodyDefaultShippingAddress patch customer o k body default shipping address
swagger:model PatchCustomerOKBodyDefaultShippingAddress
*/
type PatchCustomerOKBodyDefaultShippingAddress struct {

	// The id of the Customers default Shipping Address
	//
	ID string `json:"id,omitempty"`
}

// Validate validates this patch customer o k body default shipping address
func (o *PatchCustomerOKBodyDefaultShippingAddress) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this patch customer o k body default shipping address based on context it is used
func (o *PatchCustomerOKBodyDefaultShippingAddress) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerOKBodyDefaultShippingAddress) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerOKBodyDefaultShippingAddress) UnmarshalBinary(b []byte) error {
	var res PatchCustomerOKBodyDefaultShippingAddress
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerOKBodyEmbedded Additional resources for the Customer token.
//
swagger:model PatchCustomerOKBodyEmbedded
*/
type PatchCustomerOKBodyEmbedded struct {

	// default payment instrument
	DefaultPaymentInstrument *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrument `json:"defaultPaymentInstrument,omitempty"`

	// default shipping address
	DefaultShippingAddress *PatchCustomerOKBodyEmbeddedDefaultShippingAddress `json:"defaultShippingAddress,omitempty"`
}

// Validate validates this patch customer o k body embedded
func (o *PatchCustomerOKBodyEmbedded) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDefaultPaymentInstrument(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDefaultShippingAddress(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerOKBodyEmbedded) validateDefaultPaymentInstrument(formats strfmt.Registry) error {
	if swag.IsZero(o.DefaultPaymentInstrument) { // not required
		return nil
	}

	if o.DefaultPaymentInstrument != nil {
		if err := o.DefaultPaymentInstrument.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbedded) validateDefaultShippingAddress(formats strfmt.Registry) error {
	if swag.IsZero(o.DefaultShippingAddress) { // not required
		return nil
	}

	if o.DefaultShippingAddress != nil {
		if err := o.DefaultShippingAddress.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultShippingAddress")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultShippingAddress")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch customer o k body embedded based on the context it is used
func (o *PatchCustomerOKBodyEmbedded) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateDefaultPaymentInstrument(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateDefaultShippingAddress(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerOKBodyEmbedded) contextValidateDefaultPaymentInstrument(ctx context.Context, formats strfmt.Registry) error {

	if o.DefaultPaymentInstrument != nil {
		if err := o.DefaultPaymentInstrument.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbedded) contextValidateDefaultShippingAddress(ctx context.Context, formats strfmt.Registry) error {

	if o.DefaultShippingAddress != nil {
		if err := o.DefaultShippingAddress.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultShippingAddress")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultShippingAddress")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbedded) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbedded) UnmarshalBinary(b []byte) error {
	var res PatchCustomerOKBodyEmbedded
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerOKBodyEmbeddedDefaultPaymentInstrument patch customer o k body embedded default payment instrument
swagger:model PatchCustomerOKBodyEmbeddedDefaultPaymentInstrument
*/
type PatchCustomerOKBodyEmbeddedDefaultPaymentInstrument struct {

	// embedded
	Embedded *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbedded `json:"_embedded,omitempty"`

	// links
	Links *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentLinks `json:"_links,omitempty"`

	// bank account
	BankAccount *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentBankAccount `json:"bankAccount,omitempty"`

	// bill to
	BillTo *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentBillTo `json:"billTo,omitempty"`

	// buyer information
	BuyerInformation *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentBuyerInformation `json:"buyerInformation,omitempty"`

	// card
	Card *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentCard `json:"card,omitempty"`

	// Flag that indicates whether customer payment instrument is the dafault.
	// Valid values:
	//  - `true`: Payment instrument is customer's default.
	//  - `false`: Payment instrument is not customer's default.
	//
	Default bool `json:"default,omitempty"`

	// The id of the Payment Instrument Token.
	// Max Length: 32
	// Min Length: 1
	ID string `json:"id,omitempty"`

	// instrument identifier
	InstrumentIdentifier *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentInstrumentIdentifier `json:"instrumentIdentifier,omitempty"`

	// merchant information
	MerchantInformation *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentMerchantInformation `json:"merchantInformation,omitempty"`

	// metadata
	Metadata *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentMetadata `json:"metadata,omitempty"`

	// The type of token.
	//
	// Valid values:
	// - paymentInstrument
	//
	// Example: paymentInstrument
	// Read Only: true
	Object string `json:"object,omitempty"`

	// processing information
	ProcessingInformation *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentProcessingInformation `json:"processingInformation,omitempty"`

	// Issuers state for the card number.
	// Valid values:
	// - ACTIVE
	// - CLOSED : The account has been closed.
	//
	// Example: ACTIVE
	// Read Only: true
	State string `json:"state,omitempty"`
}

// Validate validates this patch customer o k body embedded default payment instrument
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrument) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateEmbedded(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBankAccount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBillTo(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBuyerInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCard(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateInstrumentIdentifier(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMerchantInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMetadata(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProcessingInformation(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrument) validateEmbedded(formats strfmt.Registry) error {
	if swag.IsZero(o.Embedded) { // not required
		return nil
	}

	if o.Embedded != nil {
		if err := o.Embedded.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrument) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(o.Links) { // not required
		return nil
	}

	if o.Links != nil {
		if err := o.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrument) validateBankAccount(formats strfmt.Registry) error {
	if swag.IsZero(o.BankAccount) { // not required
		return nil
	}

	if o.BankAccount != nil {
		if err := o.BankAccount.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "bankAccount")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "bankAccount")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrument) validateBillTo(formats strfmt.Registry) error {
	if swag.IsZero(o.BillTo) { // not required
		return nil
	}

	if o.BillTo != nil {
		if err := o.BillTo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "billTo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "billTo")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrument) validateBuyerInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.BuyerInformation) { // not required
		return nil
	}

	if o.BuyerInformation != nil {
		if err := o.BuyerInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "buyerInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "buyerInformation")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrument) validateCard(formats strfmt.Registry) error {
	if swag.IsZero(o.Card) { // not required
		return nil
	}

	if o.Card != nil {
		if err := o.Card.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "card")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "card")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrument) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MinLength("patchCustomerOK"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"id", "body", o.ID, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("patchCustomerOK"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"id", "body", o.ID, 32); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrument) validateInstrumentIdentifier(formats strfmt.Registry) error {
	if swag.IsZero(o.InstrumentIdentifier) { // not required
		return nil
	}

	if o.InstrumentIdentifier != nil {
		if err := o.InstrumentIdentifier.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "instrumentIdentifier")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "instrumentIdentifier")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrument) validateMerchantInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.MerchantInformation) { // not required
		return nil
	}

	if o.MerchantInformation != nil {
		if err := o.MerchantInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "merchantInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "merchantInformation")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrument) validateMetadata(formats strfmt.Registry) error {
	if swag.IsZero(o.Metadata) { // not required
		return nil
	}

	if o.Metadata != nil {
		if err := o.Metadata.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "metadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "metadata")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrument) validateProcessingInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ProcessingInformation) { // not required
		return nil
	}

	if o.ProcessingInformation != nil {
		if err := o.ProcessingInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "processingInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "processingInformation")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch customer o k body embedded default payment instrument based on the context it is used
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrument) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateEmbedded(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateBankAccount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateBillTo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateBuyerInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateCard(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateInstrumentIdentifier(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateMerchantInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateMetadata(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateObject(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateProcessingInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrument) contextValidateEmbedded(ctx context.Context, formats strfmt.Registry) error {

	if o.Embedded != nil {
		if err := o.Embedded.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrument) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if o.Links != nil {
		if err := o.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrument) contextValidateBankAccount(ctx context.Context, formats strfmt.Registry) error {

	if o.BankAccount != nil {
		if err := o.BankAccount.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "bankAccount")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "bankAccount")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrument) contextValidateBillTo(ctx context.Context, formats strfmt.Registry) error {

	if o.BillTo != nil {
		if err := o.BillTo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "billTo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "billTo")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrument) contextValidateBuyerInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.BuyerInformation != nil {
		if err := o.BuyerInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "buyerInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "buyerInformation")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrument) contextValidateCard(ctx context.Context, formats strfmt.Registry) error {

	if o.Card != nil {
		if err := o.Card.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "card")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "card")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrument) contextValidateInstrumentIdentifier(ctx context.Context, formats strfmt.Registry) error {

	if o.InstrumentIdentifier != nil {
		if err := o.InstrumentIdentifier.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "instrumentIdentifier")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "instrumentIdentifier")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrument) contextValidateMerchantInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.MerchantInformation != nil {
		if err := o.MerchantInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "merchantInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "merchantInformation")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrument) contextValidateMetadata(ctx context.Context, formats strfmt.Registry) error {

	if o.Metadata != nil {
		if err := o.Metadata.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "metadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "metadata")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrument) contextValidateObject(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerOK"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"object", "body", string(o.Object)); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrument) contextValidateProcessingInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ProcessingInformation != nil {
		if err := o.ProcessingInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "processingInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "processingInformation")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrument) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerOK"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"state", "body", string(o.State)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrument) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrument) UnmarshalBinary(b []byte) error {
	var res PatchCustomerOKBodyEmbeddedDefaultPaymentInstrument
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentBankAccount patch customer o k body embedded default payment instrument bank account
swagger:model PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentBankAccount
*/
type PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentBankAccount struct {

	// Account type.
	//
	// Valid values:
	//  - checking : C
	//  - general ledger : G This value is supported only on Wells Fargo ACH
	//  - savings : S (U.S. dollars only)
	//  - corporate checking : X (U.S. dollars only)
	//
	// Max Length: 18
	Type string `json:"type,omitempty"`
}

// Validate validates this patch customer o k body embedded default payment instrument bank account
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentBankAccount) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentBankAccount) validateType(formats strfmt.Registry) error {
	if swag.IsZero(o.Type) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerOK"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"bankAccount"+"."+"type", "body", o.Type, 18); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this patch customer o k body embedded default payment instrument bank account based on context it is used
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentBankAccount) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentBankAccount) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentBankAccount) UnmarshalBinary(b []byte) error {
	var res PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentBankAccount
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentBillTo patch customer o k body embedded default payment instrument bill to
swagger:model PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentBillTo
*/
type PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentBillTo struct {

	// Payment card billing street address as it appears on the credit card issuers records.
	//
	// Max Length: 60
	Address1 string `json:"address1,omitempty"`

	// Additional address information.
	//
	// Max Length: 60
	Address2 string `json:"address2,omitempty"`

	// State or province of the billing address. Use the State, Province, and Territory Codes for the United States
	// and Canada.
	//
	// Max Length: 20
	AdministrativeArea string `json:"administrativeArea,omitempty"`

	// Name of the customers company.
	//
	// Max Length: 60
	Company string `json:"company,omitempty"`

	// Payment card billing country. Use the two-character ISO Standard Country Codes.
	//
	// Max Length: 2
	Country string `json:"country,omitempty"`

	// Customer's email address, including the full domain name.
	//
	// Max Length: 255
	Email string `json:"email,omitempty"`

	// Customers first name. This name must be the same as the name on the card.
	//
	// Max Length: 60
	FirstName string `json:"firstName,omitempty"`

	// Customers last name. This name must be the same as the name on the card.
	//
	// Max Length: 60
	LastName string `json:"lastName,omitempty"`

	// Payment card billing city.
	//
	// Max Length: 50
	Locality string `json:"locality,omitempty"`

	// Customers phone number.
	//
	// Max Length: 15
	PhoneNumber string `json:"phoneNumber,omitempty"`

	// Postal code for the billing address. The postal code must consist of 5 to 9 digits.
	//
	// When the billing country is the U.S., the 9-digit postal code must follow this format:
	// [5 digits][dash][4 digits]
	//
	// **Example** `12345-6789`
	//
	// When the billing country is Canada, the 6-digit postal code must follow this format:
	// [alpha][numeric][alpha][space][numeric][alpha][numeric]
	//
	// **Example** `A1B 2C3`
	//
	// Max Length: 10
	PostalCode string `json:"postalCode,omitempty"`
}

// Validate validates this patch customer o k body embedded default payment instrument bill to
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentBillTo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAddress1(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAddress2(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAdministrativeArea(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCompany(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEmail(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFirstName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLastName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocality(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePhoneNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentBillTo) validateAddress1(formats strfmt.Registry) error {
	if swag.IsZero(o.Address1) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerOK"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"billTo"+"."+"address1", "body", o.Address1, 60); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentBillTo) validateAddress2(formats strfmt.Registry) error {
	if swag.IsZero(o.Address2) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerOK"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"billTo"+"."+"address2", "body", o.Address2, 60); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentBillTo) validateAdministrativeArea(formats strfmt.Registry) error {
	if swag.IsZero(o.AdministrativeArea) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerOK"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"billTo"+"."+"administrativeArea", "body", o.AdministrativeArea, 20); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentBillTo) validateCompany(formats strfmt.Registry) error {
	if swag.IsZero(o.Company) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerOK"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"billTo"+"."+"company", "body", o.Company, 60); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentBillTo) validateCountry(formats strfmt.Registry) error {
	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerOK"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"billTo"+"."+"country", "body", o.Country, 2); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentBillTo) validateEmail(formats strfmt.Registry) error {
	if swag.IsZero(o.Email) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerOK"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"billTo"+"."+"email", "body", o.Email, 255); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentBillTo) validateFirstName(formats strfmt.Registry) error {
	if swag.IsZero(o.FirstName) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerOK"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"billTo"+"."+"firstName", "body", o.FirstName, 60); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentBillTo) validateLastName(formats strfmt.Registry) error {
	if swag.IsZero(o.LastName) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerOK"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"billTo"+"."+"lastName", "body", o.LastName, 60); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentBillTo) validateLocality(formats strfmt.Registry) error {
	if swag.IsZero(o.Locality) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerOK"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"billTo"+"."+"locality", "body", o.Locality, 50); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentBillTo) validatePhoneNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.PhoneNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerOK"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"billTo"+"."+"phoneNumber", "body", o.PhoneNumber, 15); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentBillTo) validatePostalCode(formats strfmt.Registry) error {
	if swag.IsZero(o.PostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerOK"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"billTo"+"."+"postalCode", "body", o.PostalCode, 10); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this patch customer o k body embedded default payment instrument bill to based on context it is used
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentBillTo) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentBillTo) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentBillTo) UnmarshalBinary(b []byte) error {
	var res PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentBillTo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentBuyerInformation patch customer o k body embedded default payment instrument buyer information
swagger:model PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentBuyerInformation
*/
type PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentBuyerInformation struct {

	// Companys tax identifier. This is only used for eCheck service.
	//
	// Max Length: 9
	CompanyTaxID string `json:"companyTaxID,omitempty"`

	// Currency used for the order. Use the three-character I[ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)
	//
	// For details about currency as used in partial authorizations, see "Features for Debit Cards and Prepaid Cards" in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// For an authorization reversal (`reversalInformation`) or a capture (`processingOptions.capture` is set to `true`), you must use the same currency that you used in your payment authorization request.
	//
	// #### DCC for First Data
	// Your local currency. For details, see the `currency` field description in [Dynamic Currency Conversion For First Data Using the SCMP API](http://apps.cybersource.com/library/documentation/dev_guides/DCC_FirstData_SCMP/DCC_FirstData_SCMP_API.pdf).
	//
	// Max Length: 3
	Currency string `json:"currency,omitempty"`

	// Date of birth of the customer. Format: YYYY-MM-DD
	//
	// Example: 1960-12-30
	// Format: date
	DateOfBirth strfmt.Date `json:"dateOfBirth,omitempty"`

	// personal identification
	PersonalIdentification []*PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentBuyerInformationPersonalIdentificationItems0 `json:"personalIdentification"`
}

// Validate validates this patch customer o k body embedded default payment instrument buyer information
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentBuyerInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCompanyTaxID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCurrency(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDateOfBirth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePersonalIdentification(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentBuyerInformation) validateCompanyTaxID(formats strfmt.Registry) error {
	if swag.IsZero(o.CompanyTaxID) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerOK"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"buyerInformation"+"."+"companyTaxID", "body", o.CompanyTaxID, 9); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentBuyerInformation) validateCurrency(formats strfmt.Registry) error {
	if swag.IsZero(o.Currency) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerOK"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"buyerInformation"+"."+"currency", "body", o.Currency, 3); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentBuyerInformation) validateDateOfBirth(formats strfmt.Registry) error {
	if swag.IsZero(o.DateOfBirth) { // not required
		return nil
	}

	if err := validate.FormatOf("patchCustomerOK"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"buyerInformation"+"."+"dateOfBirth", "body", "date", o.DateOfBirth.String(), formats); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentBuyerInformation) validatePersonalIdentification(formats strfmt.Registry) error {
	if swag.IsZero(o.PersonalIdentification) { // not required
		return nil
	}

	for i := 0; i < len(o.PersonalIdentification); i++ {
		if swag.IsZero(o.PersonalIdentification[i]) { // not required
			continue
		}

		if o.PersonalIdentification[i] != nil {
			if err := o.PersonalIdentification[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "buyerInformation" + "." + "personalIdentification" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "buyerInformation" + "." + "personalIdentification" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this patch customer o k body embedded default payment instrument buyer information based on the context it is used
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentBuyerInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidatePersonalIdentification(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentBuyerInformation) contextValidatePersonalIdentification(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.PersonalIdentification); i++ {

		if o.PersonalIdentification[i] != nil {
			if err := o.PersonalIdentification[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "buyerInformation" + "." + "personalIdentification" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "buyerInformation" + "." + "personalIdentification" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentBuyerInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentBuyerInformation) UnmarshalBinary(b []byte) error {
	var res PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentBuyerInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentBuyerInformationPersonalIdentificationItems0 patch customer o k body embedded default payment instrument buyer information personal identification items0
swagger:model PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentBuyerInformationPersonalIdentificationItems0
*/
type PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentBuyerInformationPersonalIdentificationItems0 struct {

	// The value of the identification type.
	//
	// Max Length: 26
	ID string `json:"id,omitempty"`

	// issued by
	IssuedBy *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentBuyerInformationPersonalIdentificationItems0IssuedBy `json:"issuedBy,omitempty"`

	// The type of the identification.
	//
	// Valid values:
	//   - driver license
	//
	Type string `json:"type,omitempty"`
}

// Validate validates this patch customer o k body embedded default payment instrument buyer information personal identification items0
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentBuyerInformationPersonalIdentificationItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateIssuedBy(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentBuyerInformationPersonalIdentificationItems0) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MaxLength("id", "body", o.ID, 26); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentBuyerInformationPersonalIdentificationItems0) validateIssuedBy(formats strfmt.Registry) error {
	if swag.IsZero(o.IssuedBy) { // not required
		return nil
	}

	if o.IssuedBy != nil {
		if err := o.IssuedBy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("issuedBy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("issuedBy")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch customer o k body embedded default payment instrument buyer information personal identification items0 based on the context it is used
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentBuyerInformationPersonalIdentificationItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateIssuedBy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentBuyerInformationPersonalIdentificationItems0) contextValidateIssuedBy(ctx context.Context, formats strfmt.Registry) error {

	if o.IssuedBy != nil {
		if err := o.IssuedBy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("issuedBy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("issuedBy")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentBuyerInformationPersonalIdentificationItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentBuyerInformationPersonalIdentificationItems0) UnmarshalBinary(b []byte) error {
	var res PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentBuyerInformationPersonalIdentificationItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentBuyerInformationPersonalIdentificationItems0IssuedBy patch customer o k body embedded default payment instrument buyer information personal identification items0 issued by
swagger:model PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentBuyerInformationPersonalIdentificationItems0IssuedBy
*/
type PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentBuyerInformationPersonalIdentificationItems0IssuedBy struct {

	// The State or province where the customers drivers license was issued.
	//
	// Use the two-character State, Province, and Territory Codes for the United States and Canada.
	//
	// Max Length: 20
	AdministrativeArea string `json:"administrativeArea,omitempty"`
}

// Validate validates this patch customer o k body embedded default payment instrument buyer information personal identification items0 issued by
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentBuyerInformationPersonalIdentificationItems0IssuedBy) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAdministrativeArea(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentBuyerInformationPersonalIdentificationItems0IssuedBy) validateAdministrativeArea(formats strfmt.Registry) error {
	if swag.IsZero(o.AdministrativeArea) { // not required
		return nil
	}

	if err := validate.MaxLength("issuedBy"+"."+"administrativeArea", "body", o.AdministrativeArea, 20); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this patch customer o k body embedded default payment instrument buyer information personal identification items0 issued by based on context it is used
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentBuyerInformationPersonalIdentificationItems0IssuedBy) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentBuyerInformationPersonalIdentificationItems0IssuedBy) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentBuyerInformationPersonalIdentificationItems0IssuedBy) UnmarshalBinary(b []byte) error {
	var res PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentBuyerInformationPersonalIdentificationItems0IssuedBy
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentCard patch customer o k body embedded default payment instrument card
swagger:model PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentCard
*/
type PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentCard struct {

	// Two-digit month in which the payment card expires.
	//
	// Format: `MM`.
	//
	// Valid values: `01` through `12`.
	//
	// Max Length: 2
	ExpirationMonth string `json:"expirationMonth,omitempty"`

	// Four-digit year in which the credit card expires.
	//
	// Format: `YYYY`.
	//
	// Max Length: 4
	ExpirationYear string `json:"expirationYear,omitempty"`

	// Number of times a Maestro (UK Domestic) card has been issued to the account holder. The card might or might not have an issue number. The number can consist of one or two digits, and the first digit might be a zero. When you include this value in your request, include exactly what is printed on the card. A value of 2 is different than a value of 02. Do not include the field, even with a blank value, if the card is not a Maestro (UK Domestic) card.
	//
	// **Note** The issue number is not required for Maestro (UK Domestic) transactions.
	//
	// Max Length: 2
	IssueNumber string `json:"issueNumber,omitempty"`

	// Month of the start of the Maestro (UK Domestic) card validity period. Do not include the field, even with a blank value, if the card is not a Maestro (UK Domestic) card. `Format: MM`.
	// Valid values: 01 through 12.
	//
	// **Note** The start date is not required for Maestro (UK Domestic) transactions.
	//
	// Max Length: 2
	StartMonth string `json:"startMonth,omitempty"`

	// Year of the start of the Maestro (UK Domestic) card validity period. Do not include the field, even with a blank value, if the card is not a Maestro (UK Domestic) card. `Format: YYYY`.
	//
	// **Note** The start date is not required for Maestro (UK Domestic) transactions.
	//
	// Max Length: 4
	StartYear string `json:"startYear,omitempty"`

	// tokenized information
	TokenizedInformation *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentCardTokenizedInformation `json:"tokenizedInformation,omitempty"`

	// Value that indicates the card type. Valid v2 : v1 - description values:
	//   * 001 : visa
	//   * 002 : mastercard - EurocardEuropean regional brand of Mastercard
	//   * 003 : american express
	//   * 004 : discover
	//   * 005 : diners club
	//   * 006 : carte blanche
	//   * 007 : jcb
	//   * 008 : optima
	//   * 011 : twinpay credit
	//   * 012 : twinpay debit
	//   * 013 : walmart
	//   * 014 : enRoute
	//   * 015 : lowes consumer
	//   * 016 : home depot consumer
	//   * 017 : mbna
	//   * 018 : dicks sportswear
	//   * 019 : casual corner
	//   * 020 : sears
	//   * 021 : jal
	//   * 023 : disney
	//   * 024 : maestro uk domestic
	//   * 025 : sams club consumer
	//   * 026 : sams club business
	//   * 028 : bill me later
	//   * 029 : bebe
	//   * 030 : restoration hardware
	//   * 031 : delta online  use this value only for Ingenico ePayments. For other processors, use 001 for all Visa card types.
	//   * 032 : solo
	//   * 033 : visa electron
	//   * 034 : dankort
	//   * 035 : laser
	//   * 036 : carte bleue  formerly Cartes Bancaires
	//   * 037 : carta si
	//   * 038 : pinless debit
	//   * 039 : encoded account
	//   * 040 : uatp
	//   * 041 : household
	//   * 042 : maestro international
	//   * 043 : ge money uk
	//   * 044 : korean cards
	//   * 045 : style
	//   * 046 : jcrew
	//   * 047 : payease china processing ewallet
	//   * 048 : payease china processing bank transfer
	//   * 049 : meijer private label
	//   * 050 : hipercard  supported only by the Comercio Latino processor.
	//   * 051 : aura  supported only by the Comercio Latino processor.
	//   * 052 : redecard
	//   * 054 : elo  supported only by the Comercio Latino processor.
	//   * 055 : capital one private label
	//   * 056 : synchrony private label
	//   * 057 : costco private label
	//   * 060 : mada
	//   * 062 : china union pay
	//   * 063 : falabella private label
	//
	Type string `json:"type,omitempty"`

	// 'Payment Instrument was created / updated as part of a pinless debit transaction.'
	//
	// Example: pinless debit
	UseAs string `json:"useAs,omitempty"`
}

// Validate validates this patch customer o k body embedded default payment instrument card
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentCard) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateExpirationMonth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpirationYear(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateIssueNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateStartMonth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateStartYear(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTokenizedInformation(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentCard) validateExpirationMonth(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationMonth) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerOK"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"card"+"."+"expirationMonth", "body", o.ExpirationMonth, 2); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentCard) validateExpirationYear(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationYear) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerOK"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"card"+"."+"expirationYear", "body", o.ExpirationYear, 4); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentCard) validateIssueNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.IssueNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerOK"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"card"+"."+"issueNumber", "body", o.IssueNumber, 2); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentCard) validateStartMonth(formats strfmt.Registry) error {
	if swag.IsZero(o.StartMonth) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerOK"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"card"+"."+"startMonth", "body", o.StartMonth, 2); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentCard) validateStartYear(formats strfmt.Registry) error {
	if swag.IsZero(o.StartYear) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerOK"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"card"+"."+"startYear", "body", o.StartYear, 4); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentCard) validateTokenizedInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.TokenizedInformation) { // not required
		return nil
	}

	if o.TokenizedInformation != nil {
		if err := o.TokenizedInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "card" + "." + "tokenizedInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "card" + "." + "tokenizedInformation")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch customer o k body embedded default payment instrument card based on the context it is used
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentCard) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateTokenizedInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentCard) contextValidateTokenizedInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.TokenizedInformation != nil {
		if err := o.TokenizedInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "card" + "." + "tokenizedInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "card" + "." + "tokenizedInformation")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentCard) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentCard) UnmarshalBinary(b []byte) error {
	var res PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentCard
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentCardTokenizedInformation patch customer o k body embedded default payment instrument card tokenized information
swagger:model PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentCardTokenizedInformation
*/
type PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentCardTokenizedInformation struct {

	// Value that identifies your business and indicates that the cardholders account number is tokenized. This value
	// is assigned by the token service provider and is unique within the token service providers database.
	//
	// **Note** This field is supported only for **CyberSource through VisaNet** and **FDC Nashville Global**.
	//
	// Max Length: 11
	RequestorID string `json:"requestorID,omitempty"`

	// Type of transaction that provided the token data. This value does not specify the token service provider; it
	// specifies the entity that provided you with information about the token.
	//
	// Set the value for this field to 1. An application on the customers mobile device provided the token data.
	//
	// Max Length: 1
	TransactionType string `json:"transactionType,omitempty"`
}

// Validate validates this patch customer o k body embedded default payment instrument card tokenized information
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentCardTokenizedInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateRequestorID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTransactionType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentCardTokenizedInformation) validateRequestorID(formats strfmt.Registry) error {
	if swag.IsZero(o.RequestorID) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerOK"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"card"+"."+"tokenizedInformation"+"."+"requestorID", "body", o.RequestorID, 11); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentCardTokenizedInformation) validateTransactionType(formats strfmt.Registry) error {
	if swag.IsZero(o.TransactionType) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerOK"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"card"+"."+"tokenizedInformation"+"."+"transactionType", "body", o.TransactionType, 1); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this patch customer o k body embedded default payment instrument card tokenized information based on context it is used
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentCardTokenizedInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentCardTokenizedInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentCardTokenizedInformation) UnmarshalBinary(b []byte) error {
	var res PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentCardTokenizedInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbedded Additional resources for the Payment Instrument token.
//
swagger:model PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbedded
*/
type PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbedded struct {

	// instrument identifier
	InstrumentIdentifier *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifier `json:"instrumentIdentifier,omitempty"`
}

// Validate validates this patch customer o k body embedded default payment instrument embedded
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbedded) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateInstrumentIdentifier(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbedded) validateInstrumentIdentifier(formats strfmt.Registry) error {
	if swag.IsZero(o.InstrumentIdentifier) { // not required
		return nil
	}

	if o.InstrumentIdentifier != nil {
		if err := o.InstrumentIdentifier.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch customer o k body embedded default payment instrument embedded based on the context it is used
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbedded) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateInstrumentIdentifier(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbedded) contextValidateInstrumentIdentifier(ctx context.Context, formats strfmt.Registry) error {

	if o.InstrumentIdentifier != nil {
		if err := o.InstrumentIdentifier.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbedded) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbedded) UnmarshalBinary(b []byte) error {
	var res PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbedded
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifier patch customer o k body embedded default payment instrument embedded instrument identifier
swagger:model PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifier
*/
type PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifier struct {

	// links
	Links *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierLinks `json:"_links,omitempty"`

	// bank account
	BankAccount *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierBankAccount `json:"bankAccount,omitempty"`

	// bill to
	BillTo *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierBillTo `json:"billTo,omitempty"`

	// card
	Card *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierCard `json:"card,omitempty"`

	// The id of the Instrument Identifier Token.
	//
	ID string `json:"id,omitempty"`

	// issuer
	Issuer *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierIssuer `json:"issuer,omitempty"`

	// metadata
	Metadata *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierMetadata `json:"metadata,omitempty"`

	// The type of token.
	//
	// Valid values:
	// - instrumentIdentifier
	//
	// Example: instrumentIdentifier
	// Read Only: true
	Object string `json:"object,omitempty"`

	// processing information
	ProcessingInformation *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformation `json:"processingInformation,omitempty"`

	// Issuers state for the card number.
	// Valid values:
	// - ACTIVE
	// - CLOSED : The account has been closed.
	//
	// Example: ACTIVE
	// Read Only: true
	State string `json:"state,omitempty"`

	// tokenized card
	TokenizedCard *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCard `json:"tokenizedCard,omitempty"`

	// The type of Instrument Identifier.
	// Valid values:
	// - enrollable card
	//
	Type string `json:"type,omitempty"`
}

// Validate validates this patch customer o k body embedded default payment instrument embedded instrument identifier
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifier) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBankAccount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBillTo(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCard(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateIssuer(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMetadata(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProcessingInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTokenizedCard(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifier) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(o.Links) { // not required
		return nil
	}

	if o.Links != nil {
		if err := o.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifier) validateBankAccount(formats strfmt.Registry) error {
	if swag.IsZero(o.BankAccount) { // not required
		return nil
	}

	if o.BankAccount != nil {
		if err := o.BankAccount.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "bankAccount")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "bankAccount")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifier) validateBillTo(formats strfmt.Registry) error {
	if swag.IsZero(o.BillTo) { // not required
		return nil
	}

	if o.BillTo != nil {
		if err := o.BillTo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "billTo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "billTo")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifier) validateCard(formats strfmt.Registry) error {
	if swag.IsZero(o.Card) { // not required
		return nil
	}

	if o.Card != nil {
		if err := o.Card.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "card")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "card")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifier) validateIssuer(formats strfmt.Registry) error {
	if swag.IsZero(o.Issuer) { // not required
		return nil
	}

	if o.Issuer != nil {
		if err := o.Issuer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "issuer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "issuer")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifier) validateMetadata(formats strfmt.Registry) error {
	if swag.IsZero(o.Metadata) { // not required
		return nil
	}

	if o.Metadata != nil {
		if err := o.Metadata.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "metadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "metadata")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifier) validateProcessingInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ProcessingInformation) { // not required
		return nil
	}

	if o.ProcessingInformation != nil {
		if err := o.ProcessingInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifier) validateTokenizedCard(formats strfmt.Registry) error {
	if swag.IsZero(o.TokenizedCard) { // not required
		return nil
	}

	if o.TokenizedCard != nil {
		if err := o.TokenizedCard.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "tokenizedCard")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "tokenizedCard")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch customer o k body embedded default payment instrument embedded instrument identifier based on the context it is used
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifier) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateBankAccount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateBillTo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateCard(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateIssuer(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateMetadata(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateObject(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateProcessingInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateTokenizedCard(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifier) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if o.Links != nil {
		if err := o.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifier) contextValidateBankAccount(ctx context.Context, formats strfmt.Registry) error {

	if o.BankAccount != nil {
		if err := o.BankAccount.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "bankAccount")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "bankAccount")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifier) contextValidateBillTo(ctx context.Context, formats strfmt.Registry) error {

	if o.BillTo != nil {
		if err := o.BillTo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "billTo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "billTo")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifier) contextValidateCard(ctx context.Context, formats strfmt.Registry) error {

	if o.Card != nil {
		if err := o.Card.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "card")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "card")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifier) contextValidateIssuer(ctx context.Context, formats strfmt.Registry) error {

	if o.Issuer != nil {
		if err := o.Issuer.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "issuer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "issuer")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifier) contextValidateMetadata(ctx context.Context, formats strfmt.Registry) error {

	if o.Metadata != nil {
		if err := o.Metadata.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "metadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "metadata")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifier) contextValidateObject(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerOK"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"object", "body", string(o.Object)); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifier) contextValidateProcessingInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ProcessingInformation != nil {
		if err := o.ProcessingInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifier) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerOK"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"state", "body", string(o.State)); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifier) contextValidateTokenizedCard(ctx context.Context, formats strfmt.Registry) error {

	if o.TokenizedCard != nil {
		if err := o.TokenizedCard.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "tokenizedCard")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "tokenizedCard")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifier) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifier) UnmarshalBinary(b []byte) error {
	var res PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifier
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierBankAccount patch customer o k body embedded default payment instrument embedded instrument identifier bank account
swagger:model PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierBankAccount
*/
type PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierBankAccount struct {

	// Account number.
	//
	// When processing encoded account numbers, use this field for the encoded account number.
	//
	// Max Length: 17
	Number string `json:"number,omitempty"`

	// Bank routing number. This is also called the transit number.
	//
	// For details, see `ecp_rdfi` field description in the [Electronic Check Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/EChecks_SCMP_API/html/)
	//
	RoutingNumber string `json:"routingNumber,omitempty"`
}

// Validate validates this patch customer o k body embedded default payment instrument embedded instrument identifier bank account
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierBankAccount) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateNumber(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierBankAccount) validateNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.Number) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerOK"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"bankAccount"+"."+"number", "body", o.Number, 17); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this patch customer o k body embedded default payment instrument embedded instrument identifier bank account based on context it is used
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierBankAccount) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierBankAccount) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierBankAccount) UnmarshalBinary(b []byte) error {
	var res PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierBankAccount
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierBillTo This information is sent to the issuer as part of network token enrollment and is not stored under the Instrument Identifier token.
//
swagger:model PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierBillTo
*/
type PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierBillTo struct {

	// Payment card billing street address as it appears on the credit card issuers records.
	//
	// Max Length: 60
	Address1 string `json:"address1,omitempty"`

	// Additional address information.
	//
	// Max Length: 60
	Address2 string `json:"address2,omitempty"`

	// State or province of the billing address. Use the State, Province, and Territory Codes for the United States
	// and Canada.
	//
	// Max Length: 20
	AdministrativeArea string `json:"administrativeArea,omitempty"`

	// Payment card billing country. Use the two-character ISO Standard Country Codes.
	//
	// Max Length: 2
	Country string `json:"country,omitempty"`

	// Payment card billing city.
	//
	// Max Length: 50
	Locality string `json:"locality,omitempty"`

	// Postal code for the billing address. The postal code must consist of 5 to 9 digits.
	//
	// When the billing country is the U.S., the 9-digit postal code must follow this format:
	// [5 digits][dash][4 digits]
	//
	// **Example** `12345-6789`
	//
	// When the billing country is Canada, the 6-digit postal code must follow this format:
	// [alpha][numeric][alpha][space][numeric][alpha][numeric]
	//
	// **Example** `A1B 2C3`
	//
	// Max Length: 10
	PostalCode string `json:"postalCode,omitempty"`
}

// Validate validates this patch customer o k body embedded default payment instrument embedded instrument identifier bill to
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierBillTo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAddress1(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAddress2(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAdministrativeArea(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocality(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierBillTo) validateAddress1(formats strfmt.Registry) error {
	if swag.IsZero(o.Address1) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerOK"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"billTo"+"."+"address1", "body", o.Address1, 60); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierBillTo) validateAddress2(formats strfmt.Registry) error {
	if swag.IsZero(o.Address2) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerOK"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"billTo"+"."+"address2", "body", o.Address2, 60); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierBillTo) validateAdministrativeArea(formats strfmt.Registry) error {
	if swag.IsZero(o.AdministrativeArea) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerOK"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"billTo"+"."+"administrativeArea", "body", o.AdministrativeArea, 20); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierBillTo) validateCountry(formats strfmt.Registry) error {
	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerOK"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"billTo"+"."+"country", "body", o.Country, 2); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierBillTo) validateLocality(formats strfmt.Registry) error {
	if swag.IsZero(o.Locality) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerOK"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"billTo"+"."+"locality", "body", o.Locality, 50); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierBillTo) validatePostalCode(formats strfmt.Registry) error {
	if swag.IsZero(o.PostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerOK"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"billTo"+"."+"postalCode", "body", o.PostalCode, 10); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this patch customer o k body embedded default payment instrument embedded instrument identifier bill to based on context it is used
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierBillTo) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierBillTo) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierBillTo) UnmarshalBinary(b []byte) error {
	var res PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierBillTo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierCard The expirationMonth, expirationYear and securityCode is sent to the issuer as part of network token enrollment and is not stored under the Instrument Identifier token.
//
swagger:model PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierCard
*/
type PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierCard struct {

	// Two-digit month in which the payment card expires.
	//
	// Format: `MM`.
	//
	// Valid values: `01` through `12`.
	//
	// Max Length: 2
	ExpirationMonth string `json:"expirationMonth,omitempty"`

	// Four-digit year in which the credit card expires.
	//
	// Format: `YYYY`.
	//
	// Max Length: 4
	ExpirationYear string `json:"expirationYear,omitempty"`

	// The customers payment card number, also known as the Primary Account Number (PAN). You can also use this field
	// for encoded account numbers.
	//
	// Max Length: 19
	// Min Length: 12
	Number string `json:"number,omitempty"`

	// Card Verification Number.
	//
	// Max Length: 4
	SecurityCode string `json:"securityCode,omitempty"`
}

// Validate validates this patch customer o k body embedded default payment instrument embedded instrument identifier card
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierCard) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateExpirationMonth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpirationYear(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSecurityCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierCard) validateExpirationMonth(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationMonth) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerOK"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"card"+"."+"expirationMonth", "body", o.ExpirationMonth, 2); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierCard) validateExpirationYear(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationYear) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerOK"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"card"+"."+"expirationYear", "body", o.ExpirationYear, 4); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierCard) validateNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.Number) { // not required
		return nil
	}

	if err := validate.MinLength("patchCustomerOK"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"card"+"."+"number", "body", o.Number, 12); err != nil {
		return err
	}

	if err := validate.MaxLength("patchCustomerOK"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"card"+"."+"number", "body", o.Number, 19); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierCard) validateSecurityCode(formats strfmt.Registry) error {
	if swag.IsZero(o.SecurityCode) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerOK"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"card"+"."+"securityCode", "body", o.SecurityCode, 4); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this patch customer o k body embedded default payment instrument embedded instrument identifier card based on context it is used
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierCard) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierCard) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierCard) UnmarshalBinary(b []byte) error {
	var res PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierCard
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierIssuer patch customer o k body embedded default payment instrument embedded instrument identifier issuer
swagger:model PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierIssuer
*/
type PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierIssuer struct {

	// This reference number serves as a link to the cardholder account and to all transactions for that account.
	//
	// Read Only: true
	// Max Length: 32
	PaymentAccountReference string `json:"paymentAccountReference,omitempty"`
}

// Validate validates this patch customer o k body embedded default payment instrument embedded instrument identifier issuer
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierIssuer) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validatePaymentAccountReference(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierIssuer) validatePaymentAccountReference(formats strfmt.Registry) error {
	if swag.IsZero(o.PaymentAccountReference) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerOK"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"issuer"+"."+"paymentAccountReference", "body", o.PaymentAccountReference, 32); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this patch customer o k body embedded default payment instrument embedded instrument identifier issuer based on the context it is used
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierIssuer) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidatePaymentAccountReference(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierIssuer) contextValidatePaymentAccountReference(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerOK"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"issuer"+"."+"paymentAccountReference", "body", string(o.PaymentAccountReference)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierIssuer) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierIssuer) UnmarshalBinary(b []byte) error {
	var res PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierIssuer
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierLinks patch customer o k body embedded default payment instrument embedded instrument identifier links
swagger:model PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierLinks
*/
type PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierLinks struct {

	// payment instruments
	PaymentInstruments *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierLinksPaymentInstruments `json:"paymentInstruments,omitempty"`

	// self
	Self *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierLinksSelf `json:"self,omitempty"`
}

// Validate validates this patch customer o k body embedded default payment instrument embedded instrument identifier links
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validatePaymentInstruments(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierLinks) validatePaymentInstruments(formats strfmt.Registry) error {
	if swag.IsZero(o.PaymentInstruments) { // not required
		return nil
	}

	if o.PaymentInstruments != nil {
		if err := o.PaymentInstruments.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "_links" + "." + "paymentInstruments")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "_links" + "." + "paymentInstruments")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(o.Self) { // not required
		return nil
	}

	if o.Self != nil {
		if err := o.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "_links" + "." + "self")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch customer o k body embedded default payment instrument embedded instrument identifier links based on the context it is used
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidatePaymentInstruments(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierLinks) contextValidatePaymentInstruments(ctx context.Context, formats strfmt.Registry) error {

	if o.PaymentInstruments != nil {
		if err := o.PaymentInstruments.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "_links" + "." + "paymentInstruments")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "_links" + "." + "paymentInstruments")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if o.Self != nil {
		if err := o.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "_links" + "." + "self")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierLinks) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierLinks) UnmarshalBinary(b []byte) error {
	var res PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierLinksPaymentInstruments patch customer o k body embedded default payment instrument embedded instrument identifier links payment instruments
swagger:model PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierLinksPaymentInstruments
*/
type PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierLinksPaymentInstruments struct {

	// Link to the Instrument Identifiers Payment Instruments.
	//
	// Example: tms/v1/instrumentidentifiers/9B8D20D13FF328CCE0539399D30A70N4/paymentinstruments
	// Read Only: true
	Href string `json:"href,omitempty"`
}

// Validate validates this patch customer o k body embedded default payment instrument embedded instrument identifier links payment instruments
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierLinksPaymentInstruments) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this patch customer o k body embedded default payment instrument embedded instrument identifier links payment instruments based on the context it is used
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierLinksPaymentInstruments) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateHref(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierLinksPaymentInstruments) contextValidateHref(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerOK"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"_links"+"."+"paymentInstruments"+"."+"href", "body", string(o.Href)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierLinksPaymentInstruments) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierLinksPaymentInstruments) UnmarshalBinary(b []byte) error {
	var res PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierLinksPaymentInstruments
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierLinksSelf patch customer o k body embedded default payment instrument embedded instrument identifier links self
swagger:model PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierLinksSelf
*/
type PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierLinksSelf struct {

	// Link to the Instrument Identifier.
	//
	// Example: tms/v1/instrumentidentifiers/9B8D20D13FF328CCE0539399D30A70N4
	// Read Only: true
	Href string `json:"href,omitempty"`
}

// Validate validates this patch customer o k body embedded default payment instrument embedded instrument identifier links self
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierLinksSelf) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this patch customer o k body embedded default payment instrument embedded instrument identifier links self based on the context it is used
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierLinksSelf) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateHref(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierLinksSelf) contextValidateHref(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerOK"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"_links"+"."+"self"+"."+"href", "body", string(o.Href)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierLinksSelf) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierLinksSelf) UnmarshalBinary(b []byte) error {
	var res PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierLinksSelf
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierMetadata patch customer o k body embedded default payment instrument embedded instrument identifier metadata
swagger:model PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierMetadata
*/
type PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierMetadata struct {

	// The creator of the Instrument Identifier token.
	// Read Only: true
	Creator string `json:"creator,omitempty"`
}

// Validate validates this patch customer o k body embedded default payment instrument embedded instrument identifier metadata
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierMetadata) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this patch customer o k body embedded default payment instrument embedded instrument identifier metadata based on the context it is used
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierMetadata) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateCreator(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierMetadata) contextValidateCreator(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerOK"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"metadata"+"."+"creator", "body", string(o.Creator)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierMetadata) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierMetadata) UnmarshalBinary(b []byte) error {
	var res PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierMetadata
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformation patch customer o k body embedded default payment instrument embedded instrument identifier processing information
swagger:model PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformation
*/
type PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformation struct {

	// authorization options
	AuthorizationOptions *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions `json:"authorizationOptions,omitempty"`
}

// Validate validates this patch customer o k body embedded default payment instrument embedded instrument identifier processing information
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAuthorizationOptions(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformation) validateAuthorizationOptions(formats strfmt.Registry) error {
	if swag.IsZero(o.AuthorizationOptions) { // not required
		return nil
	}

	if o.AuthorizationOptions != nil {
		if err := o.AuthorizationOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch customer o k body embedded default payment instrument embedded instrument identifier processing information based on the context it is used
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateAuthorizationOptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformation) contextValidateAuthorizationOptions(ctx context.Context, formats strfmt.Registry) error {

	if o.AuthorizationOptions != nil {
		if err := o.AuthorizationOptions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformation) UnmarshalBinary(b []byte) error {
	var res PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions patch customer o k body embedded default payment instrument embedded instrument identifier processing information authorization options
swagger:model PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions
*/
type PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions struct {

	// initiator
	Initiator *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator `json:"initiator,omitempty"`
}

// Validate validates this patch customer o k body embedded default payment instrument embedded instrument identifier processing information authorization options
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateInitiator(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions) validateInitiator(formats strfmt.Registry) error {
	if swag.IsZero(o.Initiator) { // not required
		return nil
	}

	if o.Initiator != nil {
		if err := o.Initiator.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch customer o k body embedded default payment instrument embedded instrument identifier processing information authorization options based on the context it is used
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateInitiator(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions) contextValidateInitiator(ctx context.Context, formats strfmt.Registry) error {

	if o.Initiator != nil {
		if err := o.Initiator.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions) UnmarshalBinary(b []byte) error {
	var res PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator patch customer o k body embedded default payment instrument embedded instrument identifier processing information authorization options initiator
swagger:model PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator
*/
type PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator struct {

	// merchant initiated transaction
	MerchantInitiatedTransaction *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction `json:"merchantInitiatedTransaction,omitempty"`
}

// Validate validates this patch customer o k body embedded default payment instrument embedded instrument identifier processing information authorization options initiator
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateMerchantInitiatedTransaction(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator) validateMerchantInitiatedTransaction(formats strfmt.Registry) error {
	if swag.IsZero(o.MerchantInitiatedTransaction) { // not required
		return nil
	}

	if o.MerchantInitiatedTransaction != nil {
		if err := o.MerchantInitiatedTransaction.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator" + "." + "merchantInitiatedTransaction")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator" + "." + "merchantInitiatedTransaction")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch customer o k body embedded default payment instrument embedded instrument identifier processing information authorization options initiator based on the context it is used
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateMerchantInitiatedTransaction(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator) contextValidateMerchantInitiatedTransaction(ctx context.Context, formats strfmt.Registry) error {

	if o.MerchantInitiatedTransaction != nil {
		if err := o.MerchantInitiatedTransaction.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator" + "." + "merchantInitiatedTransaction")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator" + "." + "merchantInitiatedTransaction")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator) UnmarshalBinary(b []byte) error {
	var res PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction patch customer o k body embedded default payment instrument embedded instrument identifier processing information authorization options initiator merchant initiated transaction
swagger:model PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction
*/
type PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction struct {

	// Network transaction identifier that was returned in the payment response field _processorInformation.transactionID_
	// in the reply message for either the original merchant-initiated payment in the series or the previous
	// merchant-initiated payment in the series.
	//
	// Max Length: 15
	PreviousTransactionID string `json:"previousTransactionId,omitempty"`
}

// Validate validates this patch customer o k body embedded default payment instrument embedded instrument identifier processing information authorization options initiator merchant initiated transaction
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validatePreviousTransactionID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction) validatePreviousTransactionID(formats strfmt.Registry) error {
	if swag.IsZero(o.PreviousTransactionID) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerOK"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"processingInformation"+"."+"authorizationOptions"+"."+"initiator"+"."+"merchantInitiatedTransaction"+"."+"previousTransactionId", "body", o.PreviousTransactionID, 15); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this patch customer o k body embedded default payment instrument embedded instrument identifier processing information authorization options initiator merchant initiated transaction based on context it is used
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction) UnmarshalBinary(b []byte) error {
	var res PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCard patch customer o k body embedded default payment instrument embedded instrument identifier tokenized card
swagger:model PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCard
*/
type PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCard struct {

	// card
	Card *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCardCard `json:"card,omitempty"`

	// Generated value used in conjunction with the network token for making a payment.
	//
	// Example: CgAFRFYFPTFOfg5rj2ais9wQAAAAAM=
	// Read Only: true
	Cryptogram string `json:"cryptogram,omitempty"`

	// Two-digit month in which the network token expires.
	//
	// Format: `MM`.
	//
	// Valid values: `01` through `12`.
	//
	// Read Only: true
	// Max Length: 2
	ExpirationMonth string `json:"expirationMonth,omitempty"`

	// Four-digit year in which the network token expires.
	//
	// Format: `YYYY`.
	//
	// Read Only: true
	// Max Length: 4
	ExpirationYear string `json:"expirationYear,omitempty"`

	// The token requestors customers payment network token
	//
	// Read Only: true
	Number string `json:"number,omitempty"`

	// Issuers state for the network token
	// Valid values:
	// - ACTIVE
	// - SUSPENDED : This state can change to ACTIVE or DELETED.
	// - DELETED : This is a final state for the network token.
	//
	// Example: ACTIVE
	// Read Only: true
	State string `json:"state,omitempty"`

	// The network token card association brand
	// Valid values:
	// - visa
	// - mastercard
	//
	// Example: visa
	// Read Only: true
	Type string `json:"type,omitempty"`
}

// Validate validates this patch customer o k body embedded default payment instrument embedded instrument identifier tokenized card
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCard) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCard(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpirationMonth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpirationYear(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCard) validateCard(formats strfmt.Registry) error {
	if swag.IsZero(o.Card) { // not required
		return nil
	}

	if o.Card != nil {
		if err := o.Card.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "tokenizedCard" + "." + "card")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "tokenizedCard" + "." + "card")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCard) validateExpirationMonth(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationMonth) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerOK"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"expirationMonth", "body", o.ExpirationMonth, 2); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCard) validateExpirationYear(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationYear) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerOK"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"expirationYear", "body", o.ExpirationYear, 4); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this patch customer o k body embedded default payment instrument embedded instrument identifier tokenized card based on the context it is used
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCard) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateCard(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateCryptogram(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateExpirationMonth(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateExpirationYear(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateNumber(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCard) contextValidateCard(ctx context.Context, formats strfmt.Registry) error {

	if o.Card != nil {
		if err := o.Card.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "tokenizedCard" + "." + "card")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "tokenizedCard" + "." + "card")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCard) contextValidateCryptogram(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerOK"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"cryptogram", "body", string(o.Cryptogram)); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCard) contextValidateExpirationMonth(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerOK"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"expirationMonth", "body", string(o.ExpirationMonth)); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCard) contextValidateExpirationYear(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerOK"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"expirationYear", "body", string(o.ExpirationYear)); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCard) contextValidateNumber(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerOK"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"number", "body", string(o.Number)); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCard) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerOK"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"state", "body", string(o.State)); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCard) contextValidateType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerOK"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"type", "body", string(o.Type)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCard) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCard) UnmarshalBinary(b []byte) error {
	var res PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCard
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCardCard The latest card details associated with the network token
swagger:model PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCardCard
*/
type PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCardCard struct {

	//
	// Two-digit month in which the customers latest payment card expires.
	//
	// Format: `MM`.
	//
	// Valid values: `01` through `12`.
	//
	// Read Only: true
	// Max Length: 2
	ExpirationMonth string `json:"expirationMonth,omitempty"`

	// Four-digit year in which the customers latest payment card expires.
	//
	// Format: `YYYY`.
	//
	// Read Only: true
	// Max Length: 4
	ExpirationYear string `json:"expirationYear,omitempty"`

	// The customers latest payment card number suffix
	//
	// Example: 1111
	// Read Only: true
	Suffix string `json:"suffix,omitempty"`
}

// Validate validates this patch customer o k body embedded default payment instrument embedded instrument identifier tokenized card card
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCardCard) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateExpirationMonth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpirationYear(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCardCard) validateExpirationMonth(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationMonth) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerOK"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"card"+"."+"expirationMonth", "body", o.ExpirationMonth, 2); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCardCard) validateExpirationYear(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationYear) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerOK"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"card"+"."+"expirationYear", "body", o.ExpirationYear, 4); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this patch customer o k body embedded default payment instrument embedded instrument identifier tokenized card card based on the context it is used
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCardCard) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateExpirationMonth(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateExpirationYear(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateSuffix(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCardCard) contextValidateExpirationMonth(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerOK"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"card"+"."+"expirationMonth", "body", string(o.ExpirationMonth)); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCardCard) contextValidateExpirationYear(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerOK"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"card"+"."+"expirationYear", "body", string(o.ExpirationYear)); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCardCard) contextValidateSuffix(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerOK"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"card"+"."+"suffix", "body", string(o.Suffix)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCardCard) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCardCard) UnmarshalBinary(b []byte) error {
	var res PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCardCard
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentInstrumentIdentifier patch customer o k body embedded default payment instrument instrument identifier
swagger:model PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentInstrumentIdentifier
*/
type PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentInstrumentIdentifier struct {

	// The id of the Instrument Identifier token linked to the Payment Instrument.
	//
	// Max Length: 32
	// Min Length: 12
	ID string `json:"id,omitempty"`
}

// Validate validates this patch customer o k body embedded default payment instrument instrument identifier
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentInstrumentIdentifier) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentInstrumentIdentifier) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MinLength("patchCustomerOK"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"instrumentIdentifier"+"."+"id", "body", o.ID, 12); err != nil {
		return err
	}

	if err := validate.MaxLength("patchCustomerOK"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"instrumentIdentifier"+"."+"id", "body", o.ID, 32); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this patch customer o k body embedded default payment instrument instrument identifier based on context it is used
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentInstrumentIdentifier) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentInstrumentIdentifier) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentInstrumentIdentifier) UnmarshalBinary(b []byte) error {
	var res PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentInstrumentIdentifier
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentLinks patch customer o k body embedded default payment instrument links
swagger:model PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentLinks
*/
type PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentLinks struct {

	// customer
	Customer *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentLinksCustomer `json:"customer,omitempty"`

	// self
	Self *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentLinksSelf `json:"self,omitempty"`
}

// Validate validates this patch customer o k body embedded default payment instrument links
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCustomer(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentLinks) validateCustomer(formats strfmt.Registry) error {
	if swag.IsZero(o.Customer) { // not required
		return nil
	}

	if o.Customer != nil {
		if err := o.Customer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_links" + "." + "customer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_links" + "." + "customer")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(o.Self) { // not required
		return nil
	}

	if o.Self != nil {
		if err := o.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_links" + "." + "self")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch customer o k body embedded default payment instrument links based on the context it is used
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateCustomer(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentLinks) contextValidateCustomer(ctx context.Context, formats strfmt.Registry) error {

	if o.Customer != nil {
		if err := o.Customer.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_links" + "." + "customer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_links" + "." + "customer")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if o.Self != nil {
		if err := o.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_links" + "." + "self")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentLinks) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentLinks) UnmarshalBinary(b []byte) error {
	var res PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentLinksCustomer patch customer o k body embedded default payment instrument links customer
swagger:model PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentLinksCustomer
*/
type PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentLinksCustomer struct {

	// Link to the Customer.
	//
	// Example: /tms/v2/customers/1234567890123456789
	// Read Only: true
	Href string `json:"href,omitempty"`
}

// Validate validates this patch customer o k body embedded default payment instrument links customer
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentLinksCustomer) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this patch customer o k body embedded default payment instrument links customer based on the context it is used
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentLinksCustomer) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateHref(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentLinksCustomer) contextValidateHref(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerOK"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"_links"+"."+"customer"+"."+"href", "body", string(o.Href)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentLinksCustomer) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentLinksCustomer) UnmarshalBinary(b []byte) error {
	var res PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentLinksCustomer
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentLinksSelf patch customer o k body embedded default payment instrument links self
swagger:model PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentLinksSelf
*/
type PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentLinksSelf struct {

	// Link to the Payment Instrument.
	//
	// Example: /tms/v2/customers/1234567890123456789/payment-instruments
	// Read Only: true
	Href string `json:"href,omitempty"`
}

// Validate validates this patch customer o k body embedded default payment instrument links self
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentLinksSelf) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this patch customer o k body embedded default payment instrument links self based on the context it is used
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentLinksSelf) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateHref(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentLinksSelf) contextValidateHref(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerOK"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"_links"+"."+"self"+"."+"href", "body", string(o.Href)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentLinksSelf) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentLinksSelf) UnmarshalBinary(b []byte) error {
	var res PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentLinksSelf
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentMerchantInformation patch customer o k body embedded default payment instrument merchant information
swagger:model PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentMerchantInformation
*/
type PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentMerchantInformation struct {

	// merchant descriptor
	MerchantDescriptor *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentMerchantInformationMerchantDescriptor `json:"merchantDescriptor,omitempty"`
}

// Validate validates this patch customer o k body embedded default payment instrument merchant information
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentMerchantInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateMerchantDescriptor(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentMerchantInformation) validateMerchantDescriptor(formats strfmt.Registry) error {
	if swag.IsZero(o.MerchantDescriptor) { // not required
		return nil
	}

	if o.MerchantDescriptor != nil {
		if err := o.MerchantDescriptor.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "merchantInformation" + "." + "merchantDescriptor")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "merchantInformation" + "." + "merchantDescriptor")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch customer o k body embedded default payment instrument merchant information based on the context it is used
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentMerchantInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateMerchantDescriptor(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentMerchantInformation) contextValidateMerchantDescriptor(ctx context.Context, formats strfmt.Registry) error {

	if o.MerchantDescriptor != nil {
		if err := o.MerchantDescriptor.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "merchantInformation" + "." + "merchantDescriptor")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "merchantInformation" + "." + "merchantDescriptor")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentMerchantInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentMerchantInformation) UnmarshalBinary(b []byte) error {
	var res PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentMerchantInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentMerchantInformationMerchantDescriptor patch customer o k body embedded default payment instrument merchant information merchant descriptor
swagger:model PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentMerchantInformationMerchantDescriptor
*/
type PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentMerchantInformationMerchantDescriptor struct {

	// Alternate contact information for your business,such as an email address or URL.
	// This value might be displayed on the cardholders statement.
	// When you do not include this value in your capture or credit request, CyberSource uses the merchant URL from your CyberSource account.
	// Important This value must consist of English characters
	//
	// Max Length: 13
	AlternateName string `json:"alternateName,omitempty"`
}

// Validate validates this patch customer o k body embedded default payment instrument merchant information merchant descriptor
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentMerchantInformationMerchantDescriptor) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAlternateName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentMerchantInformationMerchantDescriptor) validateAlternateName(formats strfmt.Registry) error {
	if swag.IsZero(o.AlternateName) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerOK"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"merchantInformation"+"."+"merchantDescriptor"+"."+"alternateName", "body", o.AlternateName, 13); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this patch customer o k body embedded default payment instrument merchant information merchant descriptor based on context it is used
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentMerchantInformationMerchantDescriptor) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentMerchantInformationMerchantDescriptor) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentMerchantInformationMerchantDescriptor) UnmarshalBinary(b []byte) error {
	var res PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentMerchantInformationMerchantDescriptor
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentMetadata patch customer o k body embedded default payment instrument metadata
swagger:model PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentMetadata
*/
type PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentMetadata struct {

	// The creator of the Payment Instrument token.
	//
	// Read Only: true
	Creator string `json:"creator,omitempty"`
}

// Validate validates this patch customer o k body embedded default payment instrument metadata
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentMetadata) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this patch customer o k body embedded default payment instrument metadata based on the context it is used
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentMetadata) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateCreator(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentMetadata) contextValidateCreator(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerOK"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"metadata"+"."+"creator", "body", string(o.Creator)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentMetadata) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentMetadata) UnmarshalBinary(b []byte) error {
	var res PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentMetadata
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentProcessingInformation patch customer o k body embedded default payment instrument processing information
swagger:model PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentProcessingInformation
*/
type PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentProcessingInformation struct {

	// bank transfer options
	BankTransferOptions *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentProcessingInformationBankTransferOptions `json:"bankTransferOptions,omitempty"`

	// Flag that indicates that this is a payment for a bill or for an existing contractual loan.
	// For processor-specific details, see the `bill_payment` field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// Valid values:
	// - `true`: Bill payment or loan payment.
	// - `false` (default): Not a bill payment or loan payment.
	//
	BillPaymentProgramEnabled bool `json:"billPaymentProgramEnabled,omitempty"`
}

// Validate validates this patch customer o k body embedded default payment instrument processing information
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentProcessingInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateBankTransferOptions(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentProcessingInformation) validateBankTransferOptions(formats strfmt.Registry) error {
	if swag.IsZero(o.BankTransferOptions) { // not required
		return nil
	}

	if o.BankTransferOptions != nil {
		if err := o.BankTransferOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "processingInformation" + "." + "bankTransferOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "processingInformation" + "." + "bankTransferOptions")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch customer o k body embedded default payment instrument processing information based on the context it is used
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentProcessingInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateBankTransferOptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentProcessingInformation) contextValidateBankTransferOptions(ctx context.Context, formats strfmt.Registry) error {

	if o.BankTransferOptions != nil {
		if err := o.BankTransferOptions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "processingInformation" + "." + "bankTransferOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "processingInformation" + "." + "bankTransferOptions")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentProcessingInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentProcessingInformation) UnmarshalBinary(b []byte) error {
	var res PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentProcessingInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentProcessingInformationBankTransferOptions patch customer o k body embedded default payment instrument processing information bank transfer options
swagger:model PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentProcessingInformationBankTransferOptions
*/
type PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentProcessingInformationBankTransferOptions struct {

	// Specifies the authorization method for the transaction.
	//
	// #### TeleCheck
	// Valid values:
	// - `ARC`: account receivable conversion
	// - `CCD`: corporate cash disbursement
	// - `POP`: point of purchase conversion
	// - `PPD`: prearranged payment and deposit entry
	// - `TEL`: telephone-initiated entry
	// - `WEB`: internet-initiated entry
	//
	// For details, see `ecp_sec_code` field description in the [Electronic Check Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/EChecks_SCMP_API/html/)
	//
	// Max Length: 3
	SECCode string `json:"SECCode,omitempty"`
}

// Validate validates this patch customer o k body embedded default payment instrument processing information bank transfer options
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentProcessingInformationBankTransferOptions) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateSECCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentProcessingInformationBankTransferOptions) validateSECCode(formats strfmt.Registry) error {
	if swag.IsZero(o.SECCode) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerOK"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"processingInformation"+"."+"bankTransferOptions"+"."+"SECCode", "body", o.SECCode, 3); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this patch customer o k body embedded default payment instrument processing information bank transfer options based on context it is used
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentProcessingInformationBankTransferOptions) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentProcessingInformationBankTransferOptions) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentProcessingInformationBankTransferOptions) UnmarshalBinary(b []byte) error {
	var res PatchCustomerOKBodyEmbeddedDefaultPaymentInstrumentProcessingInformationBankTransferOptions
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerOKBodyEmbeddedDefaultShippingAddress patch customer o k body embedded default shipping address
swagger:model PatchCustomerOKBodyEmbeddedDefaultShippingAddress
*/
type PatchCustomerOKBodyEmbeddedDefaultShippingAddress struct {

	// links
	Links *PatchCustomerOKBodyEmbeddedDefaultShippingAddressLinks `json:"_links,omitempty"`

	// Flag that indicates whether customer shipping address is the dafault.
	// Valid values:
	//  - `true`: Shipping Address is customer's default.
	//  - `false`: Shipping Address is not customer's default.
	//
	Default bool `json:"default,omitempty"`

	// The id of the Shipping Address Token.
	// Max Length: 32
	// Min Length: 1
	ID string `json:"id,omitempty"`

	// metadata
	Metadata *PatchCustomerOKBodyEmbeddedDefaultShippingAddressMetadata `json:"metadata,omitempty"`

	// ship to
	ShipTo *PatchCustomerOKBodyEmbeddedDefaultShippingAddressShipTo `json:"shipTo,omitempty"`
}

// Validate validates this patch customer o k body embedded default shipping address
func (o *PatchCustomerOKBodyEmbeddedDefaultShippingAddress) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMetadata(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateShipTo(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultShippingAddress) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(o.Links) { // not required
		return nil
	}

	if o.Links != nil {
		if err := o.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultShippingAddress" + "." + "_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultShippingAddress" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultShippingAddress) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MinLength("patchCustomerOK"+"."+"_embedded"+"."+"defaultShippingAddress"+"."+"id", "body", o.ID, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("patchCustomerOK"+"."+"_embedded"+"."+"defaultShippingAddress"+"."+"id", "body", o.ID, 32); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultShippingAddress) validateMetadata(formats strfmt.Registry) error {
	if swag.IsZero(o.Metadata) { // not required
		return nil
	}

	if o.Metadata != nil {
		if err := o.Metadata.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultShippingAddress" + "." + "metadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultShippingAddress" + "." + "metadata")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultShippingAddress) validateShipTo(formats strfmt.Registry) error {
	if swag.IsZero(o.ShipTo) { // not required
		return nil
	}

	if o.ShipTo != nil {
		if err := o.ShipTo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultShippingAddress" + "." + "shipTo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultShippingAddress" + "." + "shipTo")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch customer o k body embedded default shipping address based on the context it is used
func (o *PatchCustomerOKBodyEmbeddedDefaultShippingAddress) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateMetadata(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateShipTo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultShippingAddress) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if o.Links != nil {
		if err := o.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultShippingAddress" + "." + "_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultShippingAddress" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultShippingAddress) contextValidateMetadata(ctx context.Context, formats strfmt.Registry) error {

	if o.Metadata != nil {
		if err := o.Metadata.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultShippingAddress" + "." + "metadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultShippingAddress" + "." + "metadata")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultShippingAddress) contextValidateShipTo(ctx context.Context, formats strfmt.Registry) error {

	if o.ShipTo != nil {
		if err := o.ShipTo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultShippingAddress" + "." + "shipTo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultShippingAddress" + "." + "shipTo")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultShippingAddress) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultShippingAddress) UnmarshalBinary(b []byte) error {
	var res PatchCustomerOKBodyEmbeddedDefaultShippingAddress
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerOKBodyEmbeddedDefaultShippingAddressLinks patch customer o k body embedded default shipping address links
swagger:model PatchCustomerOKBodyEmbeddedDefaultShippingAddressLinks
*/
type PatchCustomerOKBodyEmbeddedDefaultShippingAddressLinks struct {

	// customer
	Customer *PatchCustomerOKBodyEmbeddedDefaultShippingAddressLinksCustomer `json:"customer,omitempty"`

	// self
	Self *PatchCustomerOKBodyEmbeddedDefaultShippingAddressLinksSelf `json:"self,omitempty"`
}

// Validate validates this patch customer o k body embedded default shipping address links
func (o *PatchCustomerOKBodyEmbeddedDefaultShippingAddressLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCustomer(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultShippingAddressLinks) validateCustomer(formats strfmt.Registry) error {
	if swag.IsZero(o.Customer) { // not required
		return nil
	}

	if o.Customer != nil {
		if err := o.Customer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultShippingAddress" + "." + "_links" + "." + "customer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultShippingAddress" + "." + "_links" + "." + "customer")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultShippingAddressLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(o.Self) { // not required
		return nil
	}

	if o.Self != nil {
		if err := o.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultShippingAddress" + "." + "_links" + "." + "self")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultShippingAddress" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch customer o k body embedded default shipping address links based on the context it is used
func (o *PatchCustomerOKBodyEmbeddedDefaultShippingAddressLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateCustomer(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultShippingAddressLinks) contextValidateCustomer(ctx context.Context, formats strfmt.Registry) error {

	if o.Customer != nil {
		if err := o.Customer.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultShippingAddress" + "." + "_links" + "." + "customer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultShippingAddress" + "." + "_links" + "." + "customer")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultShippingAddressLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if o.Self != nil {
		if err := o.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultShippingAddress" + "." + "_links" + "." + "self")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_embedded" + "." + "defaultShippingAddress" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultShippingAddressLinks) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultShippingAddressLinks) UnmarshalBinary(b []byte) error {
	var res PatchCustomerOKBodyEmbeddedDefaultShippingAddressLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerOKBodyEmbeddedDefaultShippingAddressLinksCustomer patch customer o k body embedded default shipping address links customer
swagger:model PatchCustomerOKBodyEmbeddedDefaultShippingAddressLinksCustomer
*/
type PatchCustomerOKBodyEmbeddedDefaultShippingAddressLinksCustomer struct {

	// Link to the Customer
	//
	// Example: /tms/v2/customers/1234567890123456789
	// Read Only: true
	Href string `json:"href,omitempty"`
}

// Validate validates this patch customer o k body embedded default shipping address links customer
func (o *PatchCustomerOKBodyEmbeddedDefaultShippingAddressLinksCustomer) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this patch customer o k body embedded default shipping address links customer based on the context it is used
func (o *PatchCustomerOKBodyEmbeddedDefaultShippingAddressLinksCustomer) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateHref(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultShippingAddressLinksCustomer) contextValidateHref(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerOK"+"."+"_embedded"+"."+"defaultShippingAddress"+"."+"_links"+"."+"customer"+"."+"href", "body", string(o.Href)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultShippingAddressLinksCustomer) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultShippingAddressLinksCustomer) UnmarshalBinary(b []byte) error {
	var res PatchCustomerOKBodyEmbeddedDefaultShippingAddressLinksCustomer
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerOKBodyEmbeddedDefaultShippingAddressLinksSelf patch customer o k body embedded default shipping address links self
swagger:model PatchCustomerOKBodyEmbeddedDefaultShippingAddressLinksSelf
*/
type PatchCustomerOKBodyEmbeddedDefaultShippingAddressLinksSelf struct {

	// Link to the Customers Shipping Address
	//
	// Example: /tms/v2/customers/1234567890123456789/shipping-addresses/9B8D20D13FF328CCE0539399D30A70N4
	// Read Only: true
	Href string `json:"href,omitempty"`
}

// Validate validates this patch customer o k body embedded default shipping address links self
func (o *PatchCustomerOKBodyEmbeddedDefaultShippingAddressLinksSelf) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this patch customer o k body embedded default shipping address links self based on the context it is used
func (o *PatchCustomerOKBodyEmbeddedDefaultShippingAddressLinksSelf) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateHref(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultShippingAddressLinksSelf) contextValidateHref(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerOK"+"."+"_embedded"+"."+"defaultShippingAddress"+"."+"_links"+"."+"self"+"."+"href", "body", string(o.Href)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultShippingAddressLinksSelf) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultShippingAddressLinksSelf) UnmarshalBinary(b []byte) error {
	var res PatchCustomerOKBodyEmbeddedDefaultShippingAddressLinksSelf
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerOKBodyEmbeddedDefaultShippingAddressMetadata patch customer o k body embedded default shipping address metadata
swagger:model PatchCustomerOKBodyEmbeddedDefaultShippingAddressMetadata
*/
type PatchCustomerOKBodyEmbeddedDefaultShippingAddressMetadata struct {

	// The creator of the Shipping Address token.
	// Read Only: true
	Creator string `json:"creator,omitempty"`
}

// Validate validates this patch customer o k body embedded default shipping address metadata
func (o *PatchCustomerOKBodyEmbeddedDefaultShippingAddressMetadata) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this patch customer o k body embedded default shipping address metadata based on the context it is used
func (o *PatchCustomerOKBodyEmbeddedDefaultShippingAddressMetadata) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateCreator(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultShippingAddressMetadata) contextValidateCreator(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerOK"+"."+"_embedded"+"."+"defaultShippingAddress"+"."+"metadata"+"."+"creator", "body", string(o.Creator)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultShippingAddressMetadata) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultShippingAddressMetadata) UnmarshalBinary(b []byte) error {
	var res PatchCustomerOKBodyEmbeddedDefaultShippingAddressMetadata
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerOKBodyEmbeddedDefaultShippingAddressShipTo patch customer o k body embedded default shipping address ship to
swagger:model PatchCustomerOKBodyEmbeddedDefaultShippingAddressShipTo
*/
type PatchCustomerOKBodyEmbeddedDefaultShippingAddressShipTo struct {

	// First line of the shipping address.
	//
	// Max Length: 60
	Address1 string `json:"address1,omitempty"`

	// Second line of the shipping address.
	//
	// Max Length: 60
	Address2 string `json:"address2,omitempty"`

	// State or province of the shipping address. Use 2 character the State,
	// Province, and Territory Codes for the United States and Canada.
	//
	// Max Length: 20
	AdministrativeArea string `json:"administrativeArea,omitempty"`

	// Company associated with the shipping address.
	//
	// Max Length: 60
	Company string `json:"company,omitempty"`

	// Country of the shipping address. Use the two-character ISO Standard Country Codes.
	//
	// Max Length: 2
	Country string `json:"country,omitempty"`

	// Email associated with the shipping address.
	//
	// Max Length: 320
	Email string `json:"email,omitempty"`

	// First name of the recipient.
	//
	// Max Length: 60
	FirstName string `json:"firstName,omitempty"`

	// Last name of the recipient.
	//
	// Max Length: 60
	LastName string `json:"lastName,omitempty"`

	// City of the shipping address.
	//
	// Max Length: 50
	Locality string `json:"locality,omitempty"`

	// Phone number associated with the shipping address.
	//
	// Max Length: 15
	PhoneNumber string `json:"phoneNumber,omitempty"`

	// Postal code for the shipping address. The postal code must consist of 5 to 9 digits.
	//
	// When the billing country is the U.S., the 9-digit postal code must follow this format:
	// [5 digits][dash][4 digits]
	//
	// Example 12345-6789
	//
	// When the billing country is Canada, the 6-digit postal code must follow this format:
	// [alpha][numeric][alpha][space][numeric][alpha][numeric]
	//
	// Example A1B 2C3
	//
	// **American Express Direct**\
	// Before sending the postal code to the processor, CyberSource removes all nonalphanumeric characters and, if the
	// remaining value is longer than nine characters, truncates the value starting from the right side.
	//
	// Max Length: 10
	PostalCode string `json:"postalCode,omitempty"`
}

// Validate validates this patch customer o k body embedded default shipping address ship to
func (o *PatchCustomerOKBodyEmbeddedDefaultShippingAddressShipTo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAddress1(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAddress2(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAdministrativeArea(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCompany(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEmail(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFirstName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLastName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocality(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePhoneNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultShippingAddressShipTo) validateAddress1(formats strfmt.Registry) error {
	if swag.IsZero(o.Address1) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerOK"+"."+"_embedded"+"."+"defaultShippingAddress"+"."+"shipTo"+"."+"address1", "body", o.Address1, 60); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultShippingAddressShipTo) validateAddress2(formats strfmt.Registry) error {
	if swag.IsZero(o.Address2) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerOK"+"."+"_embedded"+"."+"defaultShippingAddress"+"."+"shipTo"+"."+"address2", "body", o.Address2, 60); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultShippingAddressShipTo) validateAdministrativeArea(formats strfmt.Registry) error {
	if swag.IsZero(o.AdministrativeArea) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerOK"+"."+"_embedded"+"."+"defaultShippingAddress"+"."+"shipTo"+"."+"administrativeArea", "body", o.AdministrativeArea, 20); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultShippingAddressShipTo) validateCompany(formats strfmt.Registry) error {
	if swag.IsZero(o.Company) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerOK"+"."+"_embedded"+"."+"defaultShippingAddress"+"."+"shipTo"+"."+"company", "body", o.Company, 60); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultShippingAddressShipTo) validateCountry(formats strfmt.Registry) error {
	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerOK"+"."+"_embedded"+"."+"defaultShippingAddress"+"."+"shipTo"+"."+"country", "body", o.Country, 2); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultShippingAddressShipTo) validateEmail(formats strfmt.Registry) error {
	if swag.IsZero(o.Email) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerOK"+"."+"_embedded"+"."+"defaultShippingAddress"+"."+"shipTo"+"."+"email", "body", o.Email, 320); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultShippingAddressShipTo) validateFirstName(formats strfmt.Registry) error {
	if swag.IsZero(o.FirstName) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerOK"+"."+"_embedded"+"."+"defaultShippingAddress"+"."+"shipTo"+"."+"firstName", "body", o.FirstName, 60); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultShippingAddressShipTo) validateLastName(formats strfmt.Registry) error {
	if swag.IsZero(o.LastName) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerOK"+"."+"_embedded"+"."+"defaultShippingAddress"+"."+"shipTo"+"."+"lastName", "body", o.LastName, 60); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultShippingAddressShipTo) validateLocality(formats strfmt.Registry) error {
	if swag.IsZero(o.Locality) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerOK"+"."+"_embedded"+"."+"defaultShippingAddress"+"."+"shipTo"+"."+"locality", "body", o.Locality, 50); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultShippingAddressShipTo) validatePhoneNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.PhoneNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerOK"+"."+"_embedded"+"."+"defaultShippingAddress"+"."+"shipTo"+"."+"phoneNumber", "body", o.PhoneNumber, 15); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerOKBodyEmbeddedDefaultShippingAddressShipTo) validatePostalCode(formats strfmt.Registry) error {
	if swag.IsZero(o.PostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerOK"+"."+"_embedded"+"."+"defaultShippingAddress"+"."+"shipTo"+"."+"postalCode", "body", o.PostalCode, 10); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this patch customer o k body embedded default shipping address ship to based on context it is used
func (o *PatchCustomerOKBodyEmbeddedDefaultShippingAddressShipTo) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultShippingAddressShipTo) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerOKBodyEmbeddedDefaultShippingAddressShipTo) UnmarshalBinary(b []byte) error {
	var res PatchCustomerOKBodyEmbeddedDefaultShippingAddressShipTo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerOKBodyLinks patch customer o k body links
swagger:model PatchCustomerOKBodyLinks
*/
type PatchCustomerOKBodyLinks struct {

	// payment instruments
	PaymentInstruments *PatchCustomerOKBodyLinksPaymentInstruments `json:"paymentInstruments,omitempty"`

	// self
	Self *PatchCustomerOKBodyLinksSelf `json:"self,omitempty"`

	// shipping address
	ShippingAddress *PatchCustomerOKBodyLinksShippingAddress `json:"shippingAddress,omitempty"`
}

// Validate validates this patch customer o k body links
func (o *PatchCustomerOKBodyLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validatePaymentInstruments(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateShippingAddress(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerOKBodyLinks) validatePaymentInstruments(formats strfmt.Registry) error {
	if swag.IsZero(o.PaymentInstruments) { // not required
		return nil
	}

	if o.PaymentInstruments != nil {
		if err := o.PaymentInstruments.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_links" + "." + "paymentInstruments")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_links" + "." + "paymentInstruments")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerOKBodyLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(o.Self) { // not required
		return nil
	}

	if o.Self != nil {
		if err := o.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_links" + "." + "self")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerOKBodyLinks) validateShippingAddress(formats strfmt.Registry) error {
	if swag.IsZero(o.ShippingAddress) { // not required
		return nil
	}

	if o.ShippingAddress != nil {
		if err := o.ShippingAddress.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_links" + "." + "shippingAddress")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_links" + "." + "shippingAddress")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch customer o k body links based on the context it is used
func (o *PatchCustomerOKBodyLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidatePaymentInstruments(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateShippingAddress(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerOKBodyLinks) contextValidatePaymentInstruments(ctx context.Context, formats strfmt.Registry) error {

	if o.PaymentInstruments != nil {
		if err := o.PaymentInstruments.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_links" + "." + "paymentInstruments")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_links" + "." + "paymentInstruments")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerOKBodyLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if o.Self != nil {
		if err := o.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_links" + "." + "self")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerOKBodyLinks) contextValidateShippingAddress(ctx context.Context, formats strfmt.Registry) error {

	if o.ShippingAddress != nil {
		if err := o.ShippingAddress.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerOK" + "." + "_links" + "." + "shippingAddress")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerOK" + "." + "_links" + "." + "shippingAddress")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerOKBodyLinks) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerOKBodyLinks) UnmarshalBinary(b []byte) error {
	var res PatchCustomerOKBodyLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerOKBodyLinksPaymentInstruments patch customer o k body links payment instruments
swagger:model PatchCustomerOKBodyLinksPaymentInstruments
*/
type PatchCustomerOKBodyLinksPaymentInstruments struct {

	// Link to the Customers Payment Instruments.
	//
	// Example: /tms/v2/customers/1234567890123456789/payment-instruments
	// Read Only: true
	Href string `json:"href,omitempty"`
}

// Validate validates this patch customer o k body links payment instruments
func (o *PatchCustomerOKBodyLinksPaymentInstruments) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this patch customer o k body links payment instruments based on the context it is used
func (o *PatchCustomerOKBodyLinksPaymentInstruments) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateHref(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerOKBodyLinksPaymentInstruments) contextValidateHref(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerOK"+"."+"_links"+"."+"paymentInstruments"+"."+"href", "body", string(o.Href)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerOKBodyLinksPaymentInstruments) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerOKBodyLinksPaymentInstruments) UnmarshalBinary(b []byte) error {
	var res PatchCustomerOKBodyLinksPaymentInstruments
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerOKBodyLinksSelf patch customer o k body links self
swagger:model PatchCustomerOKBodyLinksSelf
*/
type PatchCustomerOKBodyLinksSelf struct {

	// Link to the Customer.
	//
	// Example: /tms/v2/customers/1234567890123456789
	// Read Only: true
	Href string `json:"href,omitempty"`
}

// Validate validates this patch customer o k body links self
func (o *PatchCustomerOKBodyLinksSelf) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this patch customer o k body links self based on the context it is used
func (o *PatchCustomerOKBodyLinksSelf) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateHref(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerOKBodyLinksSelf) contextValidateHref(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerOK"+"."+"_links"+"."+"self"+"."+"href", "body", string(o.Href)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerOKBodyLinksSelf) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerOKBodyLinksSelf) UnmarshalBinary(b []byte) error {
	var res PatchCustomerOKBodyLinksSelf
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerOKBodyLinksShippingAddress patch customer o k body links shipping address
swagger:model PatchCustomerOKBodyLinksShippingAddress
*/
type PatchCustomerOKBodyLinksShippingAddress struct {

	// Link to the Customers Shipping Addresses.
	//
	// Example: /tms/v2/customers/1234567890123456789/shipping-addresses
	// Read Only: true
	Href string `json:"href,omitempty"`
}

// Validate validates this patch customer o k body links shipping address
func (o *PatchCustomerOKBodyLinksShippingAddress) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this patch customer o k body links shipping address based on the context it is used
func (o *PatchCustomerOKBodyLinksShippingAddress) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateHref(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerOKBodyLinksShippingAddress) contextValidateHref(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerOK"+"."+"_links"+"."+"shippingAddress"+"."+"href", "body", string(o.Href)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerOKBodyLinksShippingAddress) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerOKBodyLinksShippingAddress) UnmarshalBinary(b []byte) error {
	var res PatchCustomerOKBodyLinksShippingAddress
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerOKBodyMerchantDefinedInformationItems0 patch customer o k body merchant defined information items0
swagger:model PatchCustomerOKBodyMerchantDefinedInformationItems0
*/
type PatchCustomerOKBodyMerchantDefinedInformationItems0 struct {

	// The number you assign as the name for your merchant-defined data or secure field. Valid values are data1 to data4 and sensitive1 to sensitive4
	//
	// For example, to set the name for merchant-defined data 2 field, you would reference merchantDefinedInformation[x].name as data2
	// Valid values:
	// - data1
	// - data2
	// - data3
	// - data4
	// - sensitive1
	// - sensitive2
	// - sensitive3
	// - sensitive4
	//
	Name string `json:"name,omitempty"`

	// The value you assign for your merchant-defined data field.
	//
	// **Warning** Merchant-defined data fields are not intended to and must not be used to capture personally identifying information. Accordingly, merchants are prohibited from capturing, obtaining, and/or transmitting any personally identifying information in or via the merchant-defined data fields. Personally identifying information includes, but is not
	// limited to, address, credit card number, social security number, driver's license number, state-issued identification number, passport number, and card verification numbers (CVV,
	// CVC2, CVV2, CID, CVN). In the event CyberSource discovers that a merchant is capturing and/or transmitting personally identifying information via the merchant-defined data fields, whether or not intentionally, CyberSource will immediately suspend the merchant's account, which will result in a rejection of any and all transaction requests submitted by the merchant after the point of suspension.
	//
	// Max Length: 100
	Value string `json:"value,omitempty"`
}

// Validate validates this patch customer o k body merchant defined information items0
func (o *PatchCustomerOKBodyMerchantDefinedInformationItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateValue(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerOKBodyMerchantDefinedInformationItems0) validateValue(formats strfmt.Registry) error {
	if swag.IsZero(o.Value) { // not required
		return nil
	}

	if err := validate.MaxLength("value", "body", o.Value, 100); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this patch customer o k body merchant defined information items0 based on context it is used
func (o *PatchCustomerOKBodyMerchantDefinedInformationItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerOKBodyMerchantDefinedInformationItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerOKBodyMerchantDefinedInformationItems0) UnmarshalBinary(b []byte) error {
	var res PatchCustomerOKBodyMerchantDefinedInformationItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerOKBodyMetadata patch customer o k body metadata
swagger:model PatchCustomerOKBodyMetadata
*/
type PatchCustomerOKBodyMetadata struct {

	// The creator of the Customer token.
	//
	// Read Only: true
	Creator string `json:"creator,omitempty"`
}

// Validate validates this patch customer o k body metadata
func (o *PatchCustomerOKBodyMetadata) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this patch customer o k body metadata based on the context it is used
func (o *PatchCustomerOKBodyMetadata) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateCreator(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerOKBodyMetadata) contextValidateCreator(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerOK"+"."+"metadata"+"."+"creator", "body", string(o.Creator)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerOKBodyMetadata) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerOKBodyMetadata) UnmarshalBinary(b []byte) error {
	var res PatchCustomerOKBodyMetadata
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerOKBodyObjectInformation patch customer o k body object information
swagger:model PatchCustomerOKBodyObjectInformation
*/
type PatchCustomerOKBodyObjectInformation struct {

	// Comments that you can make about the customer.
	//
	// Max Length: 150
	Comment string `json:"comment,omitempty"`

	// Name or title of the customer.
	//
	// Max Length: 60
	Title string `json:"title,omitempty"`
}

// Validate validates this patch customer o k body object information
func (o *PatchCustomerOKBodyObjectInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateComment(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTitle(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerOKBodyObjectInformation) validateComment(formats strfmt.Registry) error {
	if swag.IsZero(o.Comment) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerOK"+"."+"objectInformation"+"."+"comment", "body", o.Comment, 150); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerOKBodyObjectInformation) validateTitle(formats strfmt.Registry) error {
	if swag.IsZero(o.Title) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerOK"+"."+"objectInformation"+"."+"title", "body", o.Title, 60); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this patch customer o k body object information based on context it is used
func (o *PatchCustomerOKBodyObjectInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerOKBodyObjectInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerOKBodyObjectInformation) UnmarshalBinary(b []byte) error {
	var res PatchCustomerOKBodyObjectInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerParamsBodyBuyerInformation patch customer params body buyer information
swagger:model PatchCustomerParamsBodyBuyerInformation
*/
type PatchCustomerParamsBodyBuyerInformation struct {

	// Customer's primary email address, including the full domain name.
	//
	// Max Length: 255
	Email string `json:"email,omitempty"`

	// Your identifier for the customer.
	//
	// Max Length: 100
	MerchantCustomerID string `json:"merchantCustomerID,omitempty"`
}

// Validate validates this patch customer params body buyer information
func (o *PatchCustomerParamsBodyBuyerInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateEmail(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMerchantCustomerID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerParamsBodyBuyerInformation) validateEmail(formats strfmt.Registry) error {
	if swag.IsZero(o.Email) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerRequest"+"."+"buyerInformation"+"."+"email", "body", o.Email, 255); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerParamsBodyBuyerInformation) validateMerchantCustomerID(formats strfmt.Registry) error {
	if swag.IsZero(o.MerchantCustomerID) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerRequest"+"."+"buyerInformation"+"."+"merchantCustomerID", "body", o.MerchantCustomerID, 100); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this patch customer params body buyer information based on context it is used
func (o *PatchCustomerParamsBodyBuyerInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerParamsBodyBuyerInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerParamsBodyBuyerInformation) UnmarshalBinary(b []byte) error {
	var res PatchCustomerParamsBodyBuyerInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerParamsBodyClientReferenceInformation patch customer params body client reference information
swagger:model PatchCustomerParamsBodyClientReferenceInformation
*/
type PatchCustomerParamsBodyClientReferenceInformation struct {

	// Client-generated order reference or tracking number.
	//
	// Max Length: 50
	Code string `json:"code,omitempty"`
}

// Validate validates this patch customer params body client reference information
func (o *PatchCustomerParamsBodyClientReferenceInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerParamsBodyClientReferenceInformation) validateCode(formats strfmt.Registry) error {
	if swag.IsZero(o.Code) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerRequest"+"."+"clientReferenceInformation"+"."+"code", "body", o.Code, 50); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this patch customer params body client reference information based on context it is used
func (o *PatchCustomerParamsBodyClientReferenceInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerParamsBodyClientReferenceInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerParamsBodyClientReferenceInformation) UnmarshalBinary(b []byte) error {
	var res PatchCustomerParamsBodyClientReferenceInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerParamsBodyDefaultPaymentInstrument patch customer params body default payment instrument
swagger:model PatchCustomerParamsBodyDefaultPaymentInstrument
*/
type PatchCustomerParamsBodyDefaultPaymentInstrument struct {

	// The id of the Customers default Payment Instrument
	//
	ID string `json:"id,omitempty"`
}

// Validate validates this patch customer params body default payment instrument
func (o *PatchCustomerParamsBodyDefaultPaymentInstrument) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this patch customer params body default payment instrument based on context it is used
func (o *PatchCustomerParamsBodyDefaultPaymentInstrument) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerParamsBodyDefaultPaymentInstrument) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerParamsBodyDefaultPaymentInstrument) UnmarshalBinary(b []byte) error {
	var res PatchCustomerParamsBodyDefaultPaymentInstrument
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerParamsBodyDefaultShippingAddress patch customer params body default shipping address
swagger:model PatchCustomerParamsBodyDefaultShippingAddress
*/
type PatchCustomerParamsBodyDefaultShippingAddress struct {

	// The id of the Customers default Shipping Address
	//
	ID string `json:"id,omitempty"`
}

// Validate validates this patch customer params body default shipping address
func (o *PatchCustomerParamsBodyDefaultShippingAddress) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this patch customer params body default shipping address based on context it is used
func (o *PatchCustomerParamsBodyDefaultShippingAddress) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerParamsBodyDefaultShippingAddress) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerParamsBodyDefaultShippingAddress) UnmarshalBinary(b []byte) error {
	var res PatchCustomerParamsBodyDefaultShippingAddress
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerParamsBodyEmbedded Additional resources for the Customer token.
//
swagger:model PatchCustomerParamsBodyEmbedded
*/
type PatchCustomerParamsBodyEmbedded struct {

	// default payment instrument
	DefaultPaymentInstrument *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrument `json:"defaultPaymentInstrument,omitempty"`

	// default shipping address
	DefaultShippingAddress *PatchCustomerParamsBodyEmbeddedDefaultShippingAddress `json:"defaultShippingAddress,omitempty"`
}

// Validate validates this patch customer params body embedded
func (o *PatchCustomerParamsBodyEmbedded) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDefaultPaymentInstrument(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDefaultShippingAddress(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerParamsBodyEmbedded) validateDefaultPaymentInstrument(formats strfmt.Registry) error {
	if swag.IsZero(o.DefaultPaymentInstrument) { // not required
		return nil
	}

	if o.DefaultPaymentInstrument != nil {
		if err := o.DefaultPaymentInstrument.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbedded) validateDefaultShippingAddress(formats strfmt.Registry) error {
	if swag.IsZero(o.DefaultShippingAddress) { // not required
		return nil
	}

	if o.DefaultShippingAddress != nil {
		if err := o.DefaultShippingAddress.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultShippingAddress")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultShippingAddress")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch customer params body embedded based on the context it is used
func (o *PatchCustomerParamsBodyEmbedded) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateDefaultPaymentInstrument(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateDefaultShippingAddress(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerParamsBodyEmbedded) contextValidateDefaultPaymentInstrument(ctx context.Context, formats strfmt.Registry) error {

	if o.DefaultPaymentInstrument != nil {
		if err := o.DefaultPaymentInstrument.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbedded) contextValidateDefaultShippingAddress(ctx context.Context, formats strfmt.Registry) error {

	if o.DefaultShippingAddress != nil {
		if err := o.DefaultShippingAddress.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultShippingAddress")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultShippingAddress")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbedded) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbedded) UnmarshalBinary(b []byte) error {
	var res PatchCustomerParamsBodyEmbedded
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrument patch customer params body embedded default payment instrument
swagger:model PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrument
*/
type PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrument struct {

	// embedded
	Embedded *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbedded `json:"_embedded,omitempty"`

	// links
	Links *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentLinks `json:"_links,omitempty"`

	// bank account
	BankAccount *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentBankAccount `json:"bankAccount,omitempty"`

	// bill to
	BillTo *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentBillTo `json:"billTo,omitempty"`

	// buyer information
	BuyerInformation *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentBuyerInformation `json:"buyerInformation,omitempty"`

	// card
	Card *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentCard `json:"card,omitempty"`

	// Flag that indicates whether customer payment instrument is the dafault.
	// Valid values:
	//  - `true`: Payment instrument is customer's default.
	//  - `false`: Payment instrument is not customer's default.
	//
	Default bool `json:"default,omitempty"`

	// The id of the Payment Instrument Token.
	// Max Length: 32
	// Min Length: 1
	ID string `json:"id,omitempty"`

	// instrument identifier
	InstrumentIdentifier *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentInstrumentIdentifier `json:"instrumentIdentifier,omitempty"`

	// merchant information
	MerchantInformation *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentMerchantInformation `json:"merchantInformation,omitempty"`

	// metadata
	Metadata *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentMetadata `json:"metadata,omitempty"`

	// The type of token.
	//
	// Valid values:
	// - paymentInstrument
	//
	// Example: paymentInstrument
	// Read Only: true
	Object string `json:"object,omitempty"`

	// processing information
	ProcessingInformation *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentProcessingInformation `json:"processingInformation,omitempty"`

	// Issuers state for the card number.
	// Valid values:
	// - ACTIVE
	// - CLOSED : The account has been closed.
	//
	// Example: ACTIVE
	// Read Only: true
	State string `json:"state,omitempty"`
}

// Validate validates this patch customer params body embedded default payment instrument
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrument) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateEmbedded(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBankAccount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBillTo(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBuyerInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCard(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateInstrumentIdentifier(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMerchantInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMetadata(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProcessingInformation(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrument) validateEmbedded(formats strfmt.Registry) error {
	if swag.IsZero(o.Embedded) { // not required
		return nil
	}

	if o.Embedded != nil {
		if err := o.Embedded.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrument) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(o.Links) { // not required
		return nil
	}

	if o.Links != nil {
		if err := o.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrument) validateBankAccount(formats strfmt.Registry) error {
	if swag.IsZero(o.BankAccount) { // not required
		return nil
	}

	if o.BankAccount != nil {
		if err := o.BankAccount.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "bankAccount")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "bankAccount")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrument) validateBillTo(formats strfmt.Registry) error {
	if swag.IsZero(o.BillTo) { // not required
		return nil
	}

	if o.BillTo != nil {
		if err := o.BillTo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "billTo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "billTo")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrument) validateBuyerInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.BuyerInformation) { // not required
		return nil
	}

	if o.BuyerInformation != nil {
		if err := o.BuyerInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "buyerInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "buyerInformation")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrument) validateCard(formats strfmt.Registry) error {
	if swag.IsZero(o.Card) { // not required
		return nil
	}

	if o.Card != nil {
		if err := o.Card.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "card")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "card")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrument) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MinLength("patchCustomerRequest"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"id", "body", o.ID, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("patchCustomerRequest"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"id", "body", o.ID, 32); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrument) validateInstrumentIdentifier(formats strfmt.Registry) error {
	if swag.IsZero(o.InstrumentIdentifier) { // not required
		return nil
	}

	if o.InstrumentIdentifier != nil {
		if err := o.InstrumentIdentifier.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "instrumentIdentifier")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "instrumentIdentifier")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrument) validateMerchantInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.MerchantInformation) { // not required
		return nil
	}

	if o.MerchantInformation != nil {
		if err := o.MerchantInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "merchantInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "merchantInformation")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrument) validateMetadata(formats strfmt.Registry) error {
	if swag.IsZero(o.Metadata) { // not required
		return nil
	}

	if o.Metadata != nil {
		if err := o.Metadata.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "metadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "metadata")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrument) validateProcessingInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ProcessingInformation) { // not required
		return nil
	}

	if o.ProcessingInformation != nil {
		if err := o.ProcessingInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "processingInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "processingInformation")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch customer params body embedded default payment instrument based on the context it is used
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrument) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateEmbedded(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateBankAccount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateBillTo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateBuyerInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateCard(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateInstrumentIdentifier(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateMerchantInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateMetadata(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateObject(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateProcessingInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrument) contextValidateEmbedded(ctx context.Context, formats strfmt.Registry) error {

	if o.Embedded != nil {
		if err := o.Embedded.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrument) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if o.Links != nil {
		if err := o.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrument) contextValidateBankAccount(ctx context.Context, formats strfmt.Registry) error {

	if o.BankAccount != nil {
		if err := o.BankAccount.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "bankAccount")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "bankAccount")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrument) contextValidateBillTo(ctx context.Context, formats strfmt.Registry) error {

	if o.BillTo != nil {
		if err := o.BillTo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "billTo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "billTo")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrument) contextValidateBuyerInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.BuyerInformation != nil {
		if err := o.BuyerInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "buyerInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "buyerInformation")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrument) contextValidateCard(ctx context.Context, formats strfmt.Registry) error {

	if o.Card != nil {
		if err := o.Card.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "card")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "card")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrument) contextValidateInstrumentIdentifier(ctx context.Context, formats strfmt.Registry) error {

	if o.InstrumentIdentifier != nil {
		if err := o.InstrumentIdentifier.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "instrumentIdentifier")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "instrumentIdentifier")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrument) contextValidateMerchantInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.MerchantInformation != nil {
		if err := o.MerchantInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "merchantInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "merchantInformation")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrument) contextValidateMetadata(ctx context.Context, formats strfmt.Registry) error {

	if o.Metadata != nil {
		if err := o.Metadata.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "metadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "metadata")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrument) contextValidateObject(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerRequest"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"object", "body", string(o.Object)); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrument) contextValidateProcessingInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ProcessingInformation != nil {
		if err := o.ProcessingInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "processingInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "processingInformation")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrument) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerRequest"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"state", "body", string(o.State)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrument) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrument) UnmarshalBinary(b []byte) error {
	var res PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrument
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentBankAccount patch customer params body embedded default payment instrument bank account
swagger:model PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentBankAccount
*/
type PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentBankAccount struct {

	// Account type.
	//
	// Valid values:
	//  - checking : C
	//  - general ledger : G This value is supported only on Wells Fargo ACH
	//  - savings : S (U.S. dollars only)
	//  - corporate checking : X (U.S. dollars only)
	//
	// Max Length: 18
	Type string `json:"type,omitempty"`
}

// Validate validates this patch customer params body embedded default payment instrument bank account
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentBankAccount) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentBankAccount) validateType(formats strfmt.Registry) error {
	if swag.IsZero(o.Type) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerRequest"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"bankAccount"+"."+"type", "body", o.Type, 18); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this patch customer params body embedded default payment instrument bank account based on context it is used
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentBankAccount) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentBankAccount) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentBankAccount) UnmarshalBinary(b []byte) error {
	var res PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentBankAccount
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentBillTo patch customer params body embedded default payment instrument bill to
swagger:model PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentBillTo
*/
type PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentBillTo struct {

	// Payment card billing street address as it appears on the credit card issuers records.
	//
	// Max Length: 60
	Address1 string `json:"address1,omitempty"`

	// Additional address information.
	//
	// Max Length: 60
	Address2 string `json:"address2,omitempty"`

	// State or province of the billing address. Use the State, Province, and Territory Codes for the United States
	// and Canada.
	//
	// Max Length: 20
	AdministrativeArea string `json:"administrativeArea,omitempty"`

	// Name of the customers company.
	//
	// Max Length: 60
	Company string `json:"company,omitempty"`

	// Payment card billing country. Use the two-character ISO Standard Country Codes.
	//
	// Max Length: 2
	Country string `json:"country,omitempty"`

	// Customer's email address, including the full domain name.
	//
	// Max Length: 255
	Email string `json:"email,omitempty"`

	// Customers first name. This name must be the same as the name on the card.
	//
	// Max Length: 60
	FirstName string `json:"firstName,omitempty"`

	// Customers last name. This name must be the same as the name on the card.
	//
	// Max Length: 60
	LastName string `json:"lastName,omitempty"`

	// Payment card billing city.
	//
	// Max Length: 50
	Locality string `json:"locality,omitempty"`

	// Customers phone number.
	//
	// Max Length: 15
	PhoneNumber string `json:"phoneNumber,omitempty"`

	// Postal code for the billing address. The postal code must consist of 5 to 9 digits.
	//
	// When the billing country is the U.S., the 9-digit postal code must follow this format:
	// [5 digits][dash][4 digits]
	//
	// **Example** `12345-6789`
	//
	// When the billing country is Canada, the 6-digit postal code must follow this format:
	// [alpha][numeric][alpha][space][numeric][alpha][numeric]
	//
	// **Example** `A1B 2C3`
	//
	// Max Length: 10
	PostalCode string `json:"postalCode,omitempty"`
}

// Validate validates this patch customer params body embedded default payment instrument bill to
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentBillTo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAddress1(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAddress2(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAdministrativeArea(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCompany(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEmail(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFirstName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLastName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocality(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePhoneNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentBillTo) validateAddress1(formats strfmt.Registry) error {
	if swag.IsZero(o.Address1) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerRequest"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"billTo"+"."+"address1", "body", o.Address1, 60); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentBillTo) validateAddress2(formats strfmt.Registry) error {
	if swag.IsZero(o.Address2) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerRequest"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"billTo"+"."+"address2", "body", o.Address2, 60); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentBillTo) validateAdministrativeArea(formats strfmt.Registry) error {
	if swag.IsZero(o.AdministrativeArea) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerRequest"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"billTo"+"."+"administrativeArea", "body", o.AdministrativeArea, 20); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentBillTo) validateCompany(formats strfmt.Registry) error {
	if swag.IsZero(o.Company) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerRequest"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"billTo"+"."+"company", "body", o.Company, 60); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentBillTo) validateCountry(formats strfmt.Registry) error {
	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerRequest"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"billTo"+"."+"country", "body", o.Country, 2); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentBillTo) validateEmail(formats strfmt.Registry) error {
	if swag.IsZero(o.Email) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerRequest"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"billTo"+"."+"email", "body", o.Email, 255); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentBillTo) validateFirstName(formats strfmt.Registry) error {
	if swag.IsZero(o.FirstName) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerRequest"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"billTo"+"."+"firstName", "body", o.FirstName, 60); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentBillTo) validateLastName(formats strfmt.Registry) error {
	if swag.IsZero(o.LastName) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerRequest"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"billTo"+"."+"lastName", "body", o.LastName, 60); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentBillTo) validateLocality(formats strfmt.Registry) error {
	if swag.IsZero(o.Locality) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerRequest"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"billTo"+"."+"locality", "body", o.Locality, 50); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentBillTo) validatePhoneNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.PhoneNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerRequest"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"billTo"+"."+"phoneNumber", "body", o.PhoneNumber, 15); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentBillTo) validatePostalCode(formats strfmt.Registry) error {
	if swag.IsZero(o.PostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerRequest"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"billTo"+"."+"postalCode", "body", o.PostalCode, 10); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this patch customer params body embedded default payment instrument bill to based on context it is used
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentBillTo) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentBillTo) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentBillTo) UnmarshalBinary(b []byte) error {
	var res PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentBillTo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentBuyerInformation patch customer params body embedded default payment instrument buyer information
swagger:model PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentBuyerInformation
*/
type PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentBuyerInformation struct {

	// Companys tax identifier. This is only used for eCheck service.
	//
	// Max Length: 9
	CompanyTaxID string `json:"companyTaxID,omitempty"`

	// Currency used for the order. Use the three-character I[ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)
	//
	// For details about currency as used in partial authorizations, see "Features for Debit Cards and Prepaid Cards" in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// For an authorization reversal (`reversalInformation`) or a capture (`processingOptions.capture` is set to `true`), you must use the same currency that you used in your payment authorization request.
	//
	// #### DCC for First Data
	// Your local currency. For details, see the `currency` field description in [Dynamic Currency Conversion For First Data Using the SCMP API](http://apps.cybersource.com/library/documentation/dev_guides/DCC_FirstData_SCMP/DCC_FirstData_SCMP_API.pdf).
	//
	// Max Length: 3
	Currency string `json:"currency,omitempty"`

	// Date of birth of the customer. Format: YYYY-MM-DD
	//
	// Example: 1960-12-30
	// Format: date
	DateOfBirth strfmt.Date `json:"dateOfBirth,omitempty"`

	// personal identification
	PersonalIdentification []*PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentBuyerInformationPersonalIdentificationItems0 `json:"personalIdentification"`
}

// Validate validates this patch customer params body embedded default payment instrument buyer information
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentBuyerInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCompanyTaxID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCurrency(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDateOfBirth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePersonalIdentification(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentBuyerInformation) validateCompanyTaxID(formats strfmt.Registry) error {
	if swag.IsZero(o.CompanyTaxID) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerRequest"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"buyerInformation"+"."+"companyTaxID", "body", o.CompanyTaxID, 9); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentBuyerInformation) validateCurrency(formats strfmt.Registry) error {
	if swag.IsZero(o.Currency) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerRequest"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"buyerInformation"+"."+"currency", "body", o.Currency, 3); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentBuyerInformation) validateDateOfBirth(formats strfmt.Registry) error {
	if swag.IsZero(o.DateOfBirth) { // not required
		return nil
	}

	if err := validate.FormatOf("patchCustomerRequest"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"buyerInformation"+"."+"dateOfBirth", "body", "date", o.DateOfBirth.String(), formats); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentBuyerInformation) validatePersonalIdentification(formats strfmt.Registry) error {
	if swag.IsZero(o.PersonalIdentification) { // not required
		return nil
	}

	for i := 0; i < len(o.PersonalIdentification); i++ {
		if swag.IsZero(o.PersonalIdentification[i]) { // not required
			continue
		}

		if o.PersonalIdentification[i] != nil {
			if err := o.PersonalIdentification[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "buyerInformation" + "." + "personalIdentification" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "buyerInformation" + "." + "personalIdentification" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this patch customer params body embedded default payment instrument buyer information based on the context it is used
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentBuyerInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidatePersonalIdentification(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentBuyerInformation) contextValidatePersonalIdentification(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.PersonalIdentification); i++ {

		if o.PersonalIdentification[i] != nil {
			if err := o.PersonalIdentification[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "buyerInformation" + "." + "personalIdentification" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "buyerInformation" + "." + "personalIdentification" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentBuyerInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentBuyerInformation) UnmarshalBinary(b []byte) error {
	var res PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentBuyerInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentBuyerInformationPersonalIdentificationItems0 patch customer params body embedded default payment instrument buyer information personal identification items0
swagger:model PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentBuyerInformationPersonalIdentificationItems0
*/
type PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentBuyerInformationPersonalIdentificationItems0 struct {

	// The value of the identification type.
	//
	// Max Length: 26
	ID string `json:"id,omitempty"`

	// issued by
	IssuedBy *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentBuyerInformationPersonalIdentificationItems0IssuedBy `json:"issuedBy,omitempty"`

	// The type of the identification.
	//
	// Valid values:
	//   - driver license
	//
	Type string `json:"type,omitempty"`
}

// Validate validates this patch customer params body embedded default payment instrument buyer information personal identification items0
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentBuyerInformationPersonalIdentificationItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateIssuedBy(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentBuyerInformationPersonalIdentificationItems0) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MaxLength("id", "body", o.ID, 26); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentBuyerInformationPersonalIdentificationItems0) validateIssuedBy(formats strfmt.Registry) error {
	if swag.IsZero(o.IssuedBy) { // not required
		return nil
	}

	if o.IssuedBy != nil {
		if err := o.IssuedBy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("issuedBy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("issuedBy")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch customer params body embedded default payment instrument buyer information personal identification items0 based on the context it is used
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentBuyerInformationPersonalIdentificationItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateIssuedBy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentBuyerInformationPersonalIdentificationItems0) contextValidateIssuedBy(ctx context.Context, formats strfmt.Registry) error {

	if o.IssuedBy != nil {
		if err := o.IssuedBy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("issuedBy")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("issuedBy")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentBuyerInformationPersonalIdentificationItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentBuyerInformationPersonalIdentificationItems0) UnmarshalBinary(b []byte) error {
	var res PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentBuyerInformationPersonalIdentificationItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentBuyerInformationPersonalIdentificationItems0IssuedBy patch customer params body embedded default payment instrument buyer information personal identification items0 issued by
swagger:model PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentBuyerInformationPersonalIdentificationItems0IssuedBy
*/
type PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentBuyerInformationPersonalIdentificationItems0IssuedBy struct {

	// The State or province where the customers drivers license was issued.
	//
	// Use the two-character State, Province, and Territory Codes for the United States and Canada.
	//
	// Max Length: 20
	AdministrativeArea string `json:"administrativeArea,omitempty"`
}

// Validate validates this patch customer params body embedded default payment instrument buyer information personal identification items0 issued by
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentBuyerInformationPersonalIdentificationItems0IssuedBy) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAdministrativeArea(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentBuyerInformationPersonalIdentificationItems0IssuedBy) validateAdministrativeArea(formats strfmt.Registry) error {
	if swag.IsZero(o.AdministrativeArea) { // not required
		return nil
	}

	if err := validate.MaxLength("issuedBy"+"."+"administrativeArea", "body", o.AdministrativeArea, 20); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this patch customer params body embedded default payment instrument buyer information personal identification items0 issued by based on context it is used
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentBuyerInformationPersonalIdentificationItems0IssuedBy) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentBuyerInformationPersonalIdentificationItems0IssuedBy) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentBuyerInformationPersonalIdentificationItems0IssuedBy) UnmarshalBinary(b []byte) error {
	var res PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentBuyerInformationPersonalIdentificationItems0IssuedBy
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentCard patch customer params body embedded default payment instrument card
swagger:model PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentCard
*/
type PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentCard struct {

	// Two-digit month in which the payment card expires.
	//
	// Format: `MM`.
	//
	// Valid values: `01` through `12`.
	//
	// Max Length: 2
	ExpirationMonth string `json:"expirationMonth,omitempty"`

	// Four-digit year in which the credit card expires.
	//
	// Format: `YYYY`.
	//
	// Max Length: 4
	ExpirationYear string `json:"expirationYear,omitempty"`

	// Number of times a Maestro (UK Domestic) card has been issued to the account holder. The card might or might not have an issue number. The number can consist of one or two digits, and the first digit might be a zero. When you include this value in your request, include exactly what is printed on the card. A value of 2 is different than a value of 02. Do not include the field, even with a blank value, if the card is not a Maestro (UK Domestic) card.
	//
	// **Note** The issue number is not required for Maestro (UK Domestic) transactions.
	//
	// Max Length: 2
	IssueNumber string `json:"issueNumber,omitempty"`

	// Month of the start of the Maestro (UK Domestic) card validity period. Do not include the field, even with a blank value, if the card is not a Maestro (UK Domestic) card. `Format: MM`.
	// Valid values: 01 through 12.
	//
	// **Note** The start date is not required for Maestro (UK Domestic) transactions.
	//
	// Max Length: 2
	StartMonth string `json:"startMonth,omitempty"`

	// Year of the start of the Maestro (UK Domestic) card validity period. Do not include the field, even with a blank value, if the card is not a Maestro (UK Domestic) card. `Format: YYYY`.
	//
	// **Note** The start date is not required for Maestro (UK Domestic) transactions.
	//
	// Max Length: 4
	StartYear string `json:"startYear,omitempty"`

	// tokenized information
	TokenizedInformation *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentCardTokenizedInformation `json:"tokenizedInformation,omitempty"`

	// Value that indicates the card type. Valid v2 : v1 - description values:
	//   * 001 : visa
	//   * 002 : mastercard - EurocardEuropean regional brand of Mastercard
	//   * 003 : american express
	//   * 004 : discover
	//   * 005 : diners club
	//   * 006 : carte blanche
	//   * 007 : jcb
	//   * 008 : optima
	//   * 011 : twinpay credit
	//   * 012 : twinpay debit
	//   * 013 : walmart
	//   * 014 : enRoute
	//   * 015 : lowes consumer
	//   * 016 : home depot consumer
	//   * 017 : mbna
	//   * 018 : dicks sportswear
	//   * 019 : casual corner
	//   * 020 : sears
	//   * 021 : jal
	//   * 023 : disney
	//   * 024 : maestro uk domestic
	//   * 025 : sams club consumer
	//   * 026 : sams club business
	//   * 028 : bill me later
	//   * 029 : bebe
	//   * 030 : restoration hardware
	//   * 031 : delta online  use this value only for Ingenico ePayments. For other processors, use 001 for all Visa card types.
	//   * 032 : solo
	//   * 033 : visa electron
	//   * 034 : dankort
	//   * 035 : laser
	//   * 036 : carte bleue  formerly Cartes Bancaires
	//   * 037 : carta si
	//   * 038 : pinless debit
	//   * 039 : encoded account
	//   * 040 : uatp
	//   * 041 : household
	//   * 042 : maestro international
	//   * 043 : ge money uk
	//   * 044 : korean cards
	//   * 045 : style
	//   * 046 : jcrew
	//   * 047 : payease china processing ewallet
	//   * 048 : payease china processing bank transfer
	//   * 049 : meijer private label
	//   * 050 : hipercard  supported only by the Comercio Latino processor.
	//   * 051 : aura  supported only by the Comercio Latino processor.
	//   * 052 : redecard
	//   * 054 : elo  supported only by the Comercio Latino processor.
	//   * 055 : capital one private label
	//   * 056 : synchrony private label
	//   * 057 : costco private label
	//   * 060 : mada
	//   * 062 : china union pay
	//   * 063 : falabella private label
	//
	Type string `json:"type,omitempty"`

	// 'Payment Instrument was created / updated as part of a pinless debit transaction.'
	//
	// Example: pinless debit
	UseAs string `json:"useAs,omitempty"`
}

// Validate validates this patch customer params body embedded default payment instrument card
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentCard) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateExpirationMonth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpirationYear(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateIssueNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateStartMonth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateStartYear(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTokenizedInformation(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentCard) validateExpirationMonth(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationMonth) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerRequest"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"card"+"."+"expirationMonth", "body", o.ExpirationMonth, 2); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentCard) validateExpirationYear(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationYear) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerRequest"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"card"+"."+"expirationYear", "body", o.ExpirationYear, 4); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentCard) validateIssueNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.IssueNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerRequest"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"card"+"."+"issueNumber", "body", o.IssueNumber, 2); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentCard) validateStartMonth(formats strfmt.Registry) error {
	if swag.IsZero(o.StartMonth) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerRequest"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"card"+"."+"startMonth", "body", o.StartMonth, 2); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentCard) validateStartYear(formats strfmt.Registry) error {
	if swag.IsZero(o.StartYear) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerRequest"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"card"+"."+"startYear", "body", o.StartYear, 4); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentCard) validateTokenizedInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.TokenizedInformation) { // not required
		return nil
	}

	if o.TokenizedInformation != nil {
		if err := o.TokenizedInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "card" + "." + "tokenizedInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "card" + "." + "tokenizedInformation")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch customer params body embedded default payment instrument card based on the context it is used
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentCard) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateTokenizedInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentCard) contextValidateTokenizedInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.TokenizedInformation != nil {
		if err := o.TokenizedInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "card" + "." + "tokenizedInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "card" + "." + "tokenizedInformation")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentCard) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentCard) UnmarshalBinary(b []byte) error {
	var res PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentCard
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentCardTokenizedInformation patch customer params body embedded default payment instrument card tokenized information
swagger:model PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentCardTokenizedInformation
*/
type PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentCardTokenizedInformation struct {

	// Value that identifies your business and indicates that the cardholders account number is tokenized. This value
	// is assigned by the token service provider and is unique within the token service providers database.
	//
	// **Note** This field is supported only for **CyberSource through VisaNet** and **FDC Nashville Global**.
	//
	// Max Length: 11
	RequestorID string `json:"requestorID,omitempty"`

	// Type of transaction that provided the token data. This value does not specify the token service provider; it
	// specifies the entity that provided you with information about the token.
	//
	// Set the value for this field to 1. An application on the customers mobile device provided the token data.
	//
	// Max Length: 1
	TransactionType string `json:"transactionType,omitempty"`
}

// Validate validates this patch customer params body embedded default payment instrument card tokenized information
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentCardTokenizedInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateRequestorID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTransactionType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentCardTokenizedInformation) validateRequestorID(formats strfmt.Registry) error {
	if swag.IsZero(o.RequestorID) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerRequest"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"card"+"."+"tokenizedInformation"+"."+"requestorID", "body", o.RequestorID, 11); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentCardTokenizedInformation) validateTransactionType(formats strfmt.Registry) error {
	if swag.IsZero(o.TransactionType) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerRequest"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"card"+"."+"tokenizedInformation"+"."+"transactionType", "body", o.TransactionType, 1); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this patch customer params body embedded default payment instrument card tokenized information based on context it is used
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentCardTokenizedInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentCardTokenizedInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentCardTokenizedInformation) UnmarshalBinary(b []byte) error {
	var res PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentCardTokenizedInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbedded Additional resources for the Payment Instrument token.
//
swagger:model PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbedded
*/
type PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbedded struct {

	// instrument identifier
	InstrumentIdentifier *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifier `json:"instrumentIdentifier,omitempty"`
}

// Validate validates this patch customer params body embedded default payment instrument embedded
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbedded) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateInstrumentIdentifier(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbedded) validateInstrumentIdentifier(formats strfmt.Registry) error {
	if swag.IsZero(o.InstrumentIdentifier) { // not required
		return nil
	}

	if o.InstrumentIdentifier != nil {
		if err := o.InstrumentIdentifier.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch customer params body embedded default payment instrument embedded based on the context it is used
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbedded) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateInstrumentIdentifier(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbedded) contextValidateInstrumentIdentifier(ctx context.Context, formats strfmt.Registry) error {

	if o.InstrumentIdentifier != nil {
		if err := o.InstrumentIdentifier.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbedded) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbedded) UnmarshalBinary(b []byte) error {
	var res PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbedded
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifier patch customer params body embedded default payment instrument embedded instrument identifier
swagger:model PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifier
*/
type PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifier struct {

	// links
	Links *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierLinks `json:"_links,omitempty"`

	// bank account
	BankAccount *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierBankAccount `json:"bankAccount,omitempty"`

	// bill to
	BillTo *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierBillTo `json:"billTo,omitempty"`

	// card
	Card *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierCard `json:"card,omitempty"`

	// The id of the Instrument Identifier Token.
	//
	ID string `json:"id,omitempty"`

	// issuer
	Issuer *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierIssuer `json:"issuer,omitempty"`

	// metadata
	Metadata *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierMetadata `json:"metadata,omitempty"`

	// The type of token.
	//
	// Valid values:
	// - instrumentIdentifier
	//
	// Example: instrumentIdentifier
	// Read Only: true
	Object string `json:"object,omitempty"`

	// processing information
	ProcessingInformation *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformation `json:"processingInformation,omitempty"`

	// Issuers state for the card number.
	// Valid values:
	// - ACTIVE
	// - CLOSED : The account has been closed.
	//
	// Example: ACTIVE
	// Read Only: true
	State string `json:"state,omitempty"`

	// tokenized card
	TokenizedCard *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCard `json:"tokenizedCard,omitempty"`

	// The type of Instrument Identifier.
	// Valid values:
	// - enrollable card
	//
	Type string `json:"type,omitempty"`
}

// Validate validates this patch customer params body embedded default payment instrument embedded instrument identifier
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifier) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBankAccount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBillTo(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCard(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateIssuer(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMetadata(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProcessingInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTokenizedCard(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifier) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(o.Links) { // not required
		return nil
	}

	if o.Links != nil {
		if err := o.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifier) validateBankAccount(formats strfmt.Registry) error {
	if swag.IsZero(o.BankAccount) { // not required
		return nil
	}

	if o.BankAccount != nil {
		if err := o.BankAccount.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "bankAccount")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "bankAccount")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifier) validateBillTo(formats strfmt.Registry) error {
	if swag.IsZero(o.BillTo) { // not required
		return nil
	}

	if o.BillTo != nil {
		if err := o.BillTo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "billTo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "billTo")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifier) validateCard(formats strfmt.Registry) error {
	if swag.IsZero(o.Card) { // not required
		return nil
	}

	if o.Card != nil {
		if err := o.Card.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "card")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "card")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifier) validateIssuer(formats strfmt.Registry) error {
	if swag.IsZero(o.Issuer) { // not required
		return nil
	}

	if o.Issuer != nil {
		if err := o.Issuer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "issuer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "issuer")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifier) validateMetadata(formats strfmt.Registry) error {
	if swag.IsZero(o.Metadata) { // not required
		return nil
	}

	if o.Metadata != nil {
		if err := o.Metadata.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "metadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "metadata")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifier) validateProcessingInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ProcessingInformation) { // not required
		return nil
	}

	if o.ProcessingInformation != nil {
		if err := o.ProcessingInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifier) validateTokenizedCard(formats strfmt.Registry) error {
	if swag.IsZero(o.TokenizedCard) { // not required
		return nil
	}

	if o.TokenizedCard != nil {
		if err := o.TokenizedCard.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "tokenizedCard")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "tokenizedCard")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch customer params body embedded default payment instrument embedded instrument identifier based on the context it is used
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifier) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateBankAccount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateBillTo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateCard(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateIssuer(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateMetadata(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateObject(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateProcessingInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateTokenizedCard(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifier) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if o.Links != nil {
		if err := o.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifier) contextValidateBankAccount(ctx context.Context, formats strfmt.Registry) error {

	if o.BankAccount != nil {
		if err := o.BankAccount.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "bankAccount")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "bankAccount")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifier) contextValidateBillTo(ctx context.Context, formats strfmt.Registry) error {

	if o.BillTo != nil {
		if err := o.BillTo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "billTo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "billTo")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifier) contextValidateCard(ctx context.Context, formats strfmt.Registry) error {

	if o.Card != nil {
		if err := o.Card.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "card")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "card")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifier) contextValidateIssuer(ctx context.Context, formats strfmt.Registry) error {

	if o.Issuer != nil {
		if err := o.Issuer.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "issuer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "issuer")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifier) contextValidateMetadata(ctx context.Context, formats strfmt.Registry) error {

	if o.Metadata != nil {
		if err := o.Metadata.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "metadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "metadata")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifier) contextValidateObject(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerRequest"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"object", "body", string(o.Object)); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifier) contextValidateProcessingInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ProcessingInformation != nil {
		if err := o.ProcessingInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifier) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerRequest"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"state", "body", string(o.State)); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifier) contextValidateTokenizedCard(ctx context.Context, formats strfmt.Registry) error {

	if o.TokenizedCard != nil {
		if err := o.TokenizedCard.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "tokenizedCard")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "tokenizedCard")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifier) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifier) UnmarshalBinary(b []byte) error {
	var res PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifier
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierBankAccount patch customer params body embedded default payment instrument embedded instrument identifier bank account
swagger:model PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierBankAccount
*/
type PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierBankAccount struct {

	// Account number.
	//
	// When processing encoded account numbers, use this field for the encoded account number.
	//
	// Max Length: 17
	Number string `json:"number,omitempty"`

	// Bank routing number. This is also called the transit number.
	//
	// For details, see `ecp_rdfi` field description in the [Electronic Check Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/EChecks_SCMP_API/html/)
	//
	RoutingNumber string `json:"routingNumber,omitempty"`
}

// Validate validates this patch customer params body embedded default payment instrument embedded instrument identifier bank account
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierBankAccount) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateNumber(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierBankAccount) validateNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.Number) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerRequest"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"bankAccount"+"."+"number", "body", o.Number, 17); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this patch customer params body embedded default payment instrument embedded instrument identifier bank account based on context it is used
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierBankAccount) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierBankAccount) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierBankAccount) UnmarshalBinary(b []byte) error {
	var res PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierBankAccount
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierBillTo This information is sent to the issuer as part of network token enrollment and is not stored under the Instrument Identifier token.
//
swagger:model PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierBillTo
*/
type PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierBillTo struct {

	// Payment card billing street address as it appears on the credit card issuers records.
	//
	// Max Length: 60
	Address1 string `json:"address1,omitempty"`

	// Additional address information.
	//
	// Max Length: 60
	Address2 string `json:"address2,omitempty"`

	// State or province of the billing address. Use the State, Province, and Territory Codes for the United States
	// and Canada.
	//
	// Max Length: 20
	AdministrativeArea string `json:"administrativeArea,omitempty"`

	// Payment card billing country. Use the two-character ISO Standard Country Codes.
	//
	// Max Length: 2
	Country string `json:"country,omitempty"`

	// Payment card billing city.
	//
	// Max Length: 50
	Locality string `json:"locality,omitempty"`

	// Postal code for the billing address. The postal code must consist of 5 to 9 digits.
	//
	// When the billing country is the U.S., the 9-digit postal code must follow this format:
	// [5 digits][dash][4 digits]
	//
	// **Example** `12345-6789`
	//
	// When the billing country is Canada, the 6-digit postal code must follow this format:
	// [alpha][numeric][alpha][space][numeric][alpha][numeric]
	//
	// **Example** `A1B 2C3`
	//
	// Max Length: 10
	PostalCode string `json:"postalCode,omitempty"`
}

// Validate validates this patch customer params body embedded default payment instrument embedded instrument identifier bill to
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierBillTo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAddress1(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAddress2(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAdministrativeArea(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocality(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierBillTo) validateAddress1(formats strfmt.Registry) error {
	if swag.IsZero(o.Address1) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerRequest"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"billTo"+"."+"address1", "body", o.Address1, 60); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierBillTo) validateAddress2(formats strfmt.Registry) error {
	if swag.IsZero(o.Address2) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerRequest"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"billTo"+"."+"address2", "body", o.Address2, 60); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierBillTo) validateAdministrativeArea(formats strfmt.Registry) error {
	if swag.IsZero(o.AdministrativeArea) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerRequest"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"billTo"+"."+"administrativeArea", "body", o.AdministrativeArea, 20); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierBillTo) validateCountry(formats strfmt.Registry) error {
	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerRequest"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"billTo"+"."+"country", "body", o.Country, 2); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierBillTo) validateLocality(formats strfmt.Registry) error {
	if swag.IsZero(o.Locality) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerRequest"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"billTo"+"."+"locality", "body", o.Locality, 50); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierBillTo) validatePostalCode(formats strfmt.Registry) error {
	if swag.IsZero(o.PostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerRequest"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"billTo"+"."+"postalCode", "body", o.PostalCode, 10); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this patch customer params body embedded default payment instrument embedded instrument identifier bill to based on context it is used
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierBillTo) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierBillTo) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierBillTo) UnmarshalBinary(b []byte) error {
	var res PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierBillTo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierCard The expirationMonth, expirationYear and securityCode is sent to the issuer as part of network token enrollment and is not stored under the Instrument Identifier token.
//
swagger:model PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierCard
*/
type PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierCard struct {

	// Two-digit month in which the payment card expires.
	//
	// Format: `MM`.
	//
	// Valid values: `01` through `12`.
	//
	// Max Length: 2
	ExpirationMonth string `json:"expirationMonth,omitempty"`

	// Four-digit year in which the credit card expires.
	//
	// Format: `YYYY`.
	//
	// Max Length: 4
	ExpirationYear string `json:"expirationYear,omitempty"`

	// The customers payment card number, also known as the Primary Account Number (PAN). You can also use this field
	// for encoded account numbers.
	//
	// Max Length: 19
	// Min Length: 12
	Number string `json:"number,omitempty"`

	// Card Verification Number.
	//
	// Max Length: 4
	SecurityCode string `json:"securityCode,omitempty"`
}

// Validate validates this patch customer params body embedded default payment instrument embedded instrument identifier card
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierCard) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateExpirationMonth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpirationYear(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSecurityCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierCard) validateExpirationMonth(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationMonth) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerRequest"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"card"+"."+"expirationMonth", "body", o.ExpirationMonth, 2); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierCard) validateExpirationYear(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationYear) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerRequest"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"card"+"."+"expirationYear", "body", o.ExpirationYear, 4); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierCard) validateNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.Number) { // not required
		return nil
	}

	if err := validate.MinLength("patchCustomerRequest"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"card"+"."+"number", "body", o.Number, 12); err != nil {
		return err
	}

	if err := validate.MaxLength("patchCustomerRequest"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"card"+"."+"number", "body", o.Number, 19); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierCard) validateSecurityCode(formats strfmt.Registry) error {
	if swag.IsZero(o.SecurityCode) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerRequest"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"card"+"."+"securityCode", "body", o.SecurityCode, 4); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this patch customer params body embedded default payment instrument embedded instrument identifier card based on context it is used
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierCard) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierCard) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierCard) UnmarshalBinary(b []byte) error {
	var res PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierCard
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierIssuer patch customer params body embedded default payment instrument embedded instrument identifier issuer
swagger:model PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierIssuer
*/
type PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierIssuer struct {

	// This reference number serves as a link to the cardholder account and to all transactions for that account.
	//
	// Read Only: true
	// Max Length: 32
	PaymentAccountReference string `json:"paymentAccountReference,omitempty"`
}

// Validate validates this patch customer params body embedded default payment instrument embedded instrument identifier issuer
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierIssuer) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validatePaymentAccountReference(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierIssuer) validatePaymentAccountReference(formats strfmt.Registry) error {
	if swag.IsZero(o.PaymentAccountReference) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerRequest"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"issuer"+"."+"paymentAccountReference", "body", o.PaymentAccountReference, 32); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this patch customer params body embedded default payment instrument embedded instrument identifier issuer based on the context it is used
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierIssuer) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidatePaymentAccountReference(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierIssuer) contextValidatePaymentAccountReference(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerRequest"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"issuer"+"."+"paymentAccountReference", "body", string(o.PaymentAccountReference)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierIssuer) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierIssuer) UnmarshalBinary(b []byte) error {
	var res PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierIssuer
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierLinks patch customer params body embedded default payment instrument embedded instrument identifier links
swagger:model PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierLinks
*/
type PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierLinks struct {

	// payment instruments
	PaymentInstruments *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierLinksPaymentInstruments `json:"paymentInstruments,omitempty"`

	// self
	Self *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierLinksSelf `json:"self,omitempty"`
}

// Validate validates this patch customer params body embedded default payment instrument embedded instrument identifier links
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validatePaymentInstruments(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierLinks) validatePaymentInstruments(formats strfmt.Registry) error {
	if swag.IsZero(o.PaymentInstruments) { // not required
		return nil
	}

	if o.PaymentInstruments != nil {
		if err := o.PaymentInstruments.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "_links" + "." + "paymentInstruments")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "_links" + "." + "paymentInstruments")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(o.Self) { // not required
		return nil
	}

	if o.Self != nil {
		if err := o.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "_links" + "." + "self")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch customer params body embedded default payment instrument embedded instrument identifier links based on the context it is used
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidatePaymentInstruments(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierLinks) contextValidatePaymentInstruments(ctx context.Context, formats strfmt.Registry) error {

	if o.PaymentInstruments != nil {
		if err := o.PaymentInstruments.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "_links" + "." + "paymentInstruments")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "_links" + "." + "paymentInstruments")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if o.Self != nil {
		if err := o.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "_links" + "." + "self")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierLinks) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierLinks) UnmarshalBinary(b []byte) error {
	var res PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierLinksPaymentInstruments patch customer params body embedded default payment instrument embedded instrument identifier links payment instruments
swagger:model PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierLinksPaymentInstruments
*/
type PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierLinksPaymentInstruments struct {

	// Link to the Instrument Identifiers Payment Instruments.
	//
	// Example: tms/v1/instrumentidentifiers/9B8D20D13FF328CCE0539399D30A70N4/paymentinstruments
	// Read Only: true
	Href string `json:"href,omitempty"`
}

// Validate validates this patch customer params body embedded default payment instrument embedded instrument identifier links payment instruments
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierLinksPaymentInstruments) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this patch customer params body embedded default payment instrument embedded instrument identifier links payment instruments based on the context it is used
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierLinksPaymentInstruments) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateHref(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierLinksPaymentInstruments) contextValidateHref(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerRequest"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"_links"+"."+"paymentInstruments"+"."+"href", "body", string(o.Href)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierLinksPaymentInstruments) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierLinksPaymentInstruments) UnmarshalBinary(b []byte) error {
	var res PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierLinksPaymentInstruments
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierLinksSelf patch customer params body embedded default payment instrument embedded instrument identifier links self
swagger:model PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierLinksSelf
*/
type PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierLinksSelf struct {

	// Link to the Instrument Identifier.
	//
	// Example: tms/v1/instrumentidentifiers/9B8D20D13FF328CCE0539399D30A70N4
	// Read Only: true
	Href string `json:"href,omitempty"`
}

// Validate validates this patch customer params body embedded default payment instrument embedded instrument identifier links self
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierLinksSelf) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this patch customer params body embedded default payment instrument embedded instrument identifier links self based on the context it is used
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierLinksSelf) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateHref(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierLinksSelf) contextValidateHref(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerRequest"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"_links"+"."+"self"+"."+"href", "body", string(o.Href)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierLinksSelf) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierLinksSelf) UnmarshalBinary(b []byte) error {
	var res PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierLinksSelf
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierMetadata patch customer params body embedded default payment instrument embedded instrument identifier metadata
swagger:model PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierMetadata
*/
type PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierMetadata struct {

	// The creator of the Instrument Identifier token.
	// Read Only: true
	Creator string `json:"creator,omitempty"`
}

// Validate validates this patch customer params body embedded default payment instrument embedded instrument identifier metadata
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierMetadata) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this patch customer params body embedded default payment instrument embedded instrument identifier metadata based on the context it is used
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierMetadata) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateCreator(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierMetadata) contextValidateCreator(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerRequest"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"metadata"+"."+"creator", "body", string(o.Creator)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierMetadata) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierMetadata) UnmarshalBinary(b []byte) error {
	var res PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierMetadata
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformation patch customer params body embedded default payment instrument embedded instrument identifier processing information
swagger:model PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformation
*/
type PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformation struct {

	// authorization options
	AuthorizationOptions *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions `json:"authorizationOptions,omitempty"`
}

// Validate validates this patch customer params body embedded default payment instrument embedded instrument identifier processing information
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAuthorizationOptions(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformation) validateAuthorizationOptions(formats strfmt.Registry) error {
	if swag.IsZero(o.AuthorizationOptions) { // not required
		return nil
	}

	if o.AuthorizationOptions != nil {
		if err := o.AuthorizationOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch customer params body embedded default payment instrument embedded instrument identifier processing information based on the context it is used
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateAuthorizationOptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformation) contextValidateAuthorizationOptions(ctx context.Context, formats strfmt.Registry) error {

	if o.AuthorizationOptions != nil {
		if err := o.AuthorizationOptions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformation) UnmarshalBinary(b []byte) error {
	var res PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions patch customer params body embedded default payment instrument embedded instrument identifier processing information authorization options
swagger:model PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions
*/
type PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions struct {

	// initiator
	Initiator *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator `json:"initiator,omitempty"`
}

// Validate validates this patch customer params body embedded default payment instrument embedded instrument identifier processing information authorization options
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateInitiator(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions) validateInitiator(formats strfmt.Registry) error {
	if swag.IsZero(o.Initiator) { // not required
		return nil
	}

	if o.Initiator != nil {
		if err := o.Initiator.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch customer params body embedded default payment instrument embedded instrument identifier processing information authorization options based on the context it is used
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateInitiator(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions) contextValidateInitiator(ctx context.Context, formats strfmt.Registry) error {

	if o.Initiator != nil {
		if err := o.Initiator.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions) UnmarshalBinary(b []byte) error {
	var res PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptions
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator patch customer params body embedded default payment instrument embedded instrument identifier processing information authorization options initiator
swagger:model PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator
*/
type PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator struct {

	// merchant initiated transaction
	MerchantInitiatedTransaction *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction `json:"merchantInitiatedTransaction,omitempty"`
}

// Validate validates this patch customer params body embedded default payment instrument embedded instrument identifier processing information authorization options initiator
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateMerchantInitiatedTransaction(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator) validateMerchantInitiatedTransaction(formats strfmt.Registry) error {
	if swag.IsZero(o.MerchantInitiatedTransaction) { // not required
		return nil
	}

	if o.MerchantInitiatedTransaction != nil {
		if err := o.MerchantInitiatedTransaction.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator" + "." + "merchantInitiatedTransaction")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator" + "." + "merchantInitiatedTransaction")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch customer params body embedded default payment instrument embedded instrument identifier processing information authorization options initiator based on the context it is used
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateMerchantInitiatedTransaction(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator) contextValidateMerchantInitiatedTransaction(ctx context.Context, formats strfmt.Registry) error {

	if o.MerchantInitiatedTransaction != nil {
		if err := o.MerchantInitiatedTransaction.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator" + "." + "merchantInitiatedTransaction")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator" + "." + "merchantInitiatedTransaction")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator) UnmarshalBinary(b []byte) error {
	var res PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiator
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction patch customer params body embedded default payment instrument embedded instrument identifier processing information authorization options initiator merchant initiated transaction
swagger:model PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction
*/
type PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction struct {

	// Network transaction identifier that was returned in the payment response field _processorInformation.transactionID_
	// in the reply message for either the original merchant-initiated payment in the series or the previous
	// merchant-initiated payment in the series.
	//
	// Max Length: 15
	PreviousTransactionID string `json:"previousTransactionId,omitempty"`
}

// Validate validates this patch customer params body embedded default payment instrument embedded instrument identifier processing information authorization options initiator merchant initiated transaction
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validatePreviousTransactionID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction) validatePreviousTransactionID(formats strfmt.Registry) error {
	if swag.IsZero(o.PreviousTransactionID) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerRequest"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"processingInformation"+"."+"authorizationOptions"+"."+"initiator"+"."+"merchantInitiatedTransaction"+"."+"previousTransactionId", "body", o.PreviousTransactionID, 15); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this patch customer params body embedded default payment instrument embedded instrument identifier processing information authorization options initiator merchant initiated transaction based on context it is used
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction) UnmarshalBinary(b []byte) error {
	var res PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCard patch customer params body embedded default payment instrument embedded instrument identifier tokenized card
swagger:model PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCard
*/
type PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCard struct {

	// card
	Card *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCardCard `json:"card,omitempty"`

	// Generated value used in conjunction with the network token for making a payment.
	//
	// Example: CgAFRFYFPTFOfg5rj2ais9wQAAAAAM=
	// Read Only: true
	Cryptogram string `json:"cryptogram,omitempty"`

	// Two-digit month in which the network token expires.
	//
	// Format: `MM`.
	//
	// Valid values: `01` through `12`.
	//
	// Read Only: true
	// Max Length: 2
	ExpirationMonth string `json:"expirationMonth,omitempty"`

	// Four-digit year in which the network token expires.
	//
	// Format: `YYYY`.
	//
	// Read Only: true
	// Max Length: 4
	ExpirationYear string `json:"expirationYear,omitempty"`

	// The token requestors customers payment network token
	//
	// Read Only: true
	Number string `json:"number,omitempty"`

	// Issuers state for the network token
	// Valid values:
	// - ACTIVE
	// - SUSPENDED : This state can change to ACTIVE or DELETED.
	// - DELETED : This is a final state for the network token.
	//
	// Example: ACTIVE
	// Read Only: true
	State string `json:"state,omitempty"`

	// The network token card association brand
	// Valid values:
	// - visa
	// - mastercard
	//
	// Example: visa
	// Read Only: true
	Type string `json:"type,omitempty"`
}

// Validate validates this patch customer params body embedded default payment instrument embedded instrument identifier tokenized card
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCard) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCard(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpirationMonth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpirationYear(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCard) validateCard(formats strfmt.Registry) error {
	if swag.IsZero(o.Card) { // not required
		return nil
	}

	if o.Card != nil {
		if err := o.Card.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "tokenizedCard" + "." + "card")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "tokenizedCard" + "." + "card")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCard) validateExpirationMonth(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationMonth) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerRequest"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"expirationMonth", "body", o.ExpirationMonth, 2); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCard) validateExpirationYear(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationYear) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerRequest"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"expirationYear", "body", o.ExpirationYear, 4); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this patch customer params body embedded default payment instrument embedded instrument identifier tokenized card based on the context it is used
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCard) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateCard(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateCryptogram(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateExpirationMonth(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateExpirationYear(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateNumber(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCard) contextValidateCard(ctx context.Context, formats strfmt.Registry) error {

	if o.Card != nil {
		if err := o.Card.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "tokenizedCard" + "." + "card")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_embedded" + "." + "instrumentIdentifier" + "." + "tokenizedCard" + "." + "card")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCard) contextValidateCryptogram(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerRequest"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"cryptogram", "body", string(o.Cryptogram)); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCard) contextValidateExpirationMonth(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerRequest"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"expirationMonth", "body", string(o.ExpirationMonth)); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCard) contextValidateExpirationYear(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerRequest"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"expirationYear", "body", string(o.ExpirationYear)); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCard) contextValidateNumber(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerRequest"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"number", "body", string(o.Number)); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCard) contextValidateState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerRequest"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"state", "body", string(o.State)); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCard) contextValidateType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerRequest"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"type", "body", string(o.Type)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCard) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCard) UnmarshalBinary(b []byte) error {
	var res PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCard
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCardCard The latest card details associated with the network token
swagger:model PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCardCard
*/
type PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCardCard struct {

	//
	// Two-digit month in which the customers latest payment card expires.
	//
	// Format: `MM`.
	//
	// Valid values: `01` through `12`.
	//
	// Read Only: true
	// Max Length: 2
	ExpirationMonth string `json:"expirationMonth,omitempty"`

	// Four-digit year in which the customers latest payment card expires.
	//
	// Format: `YYYY`.
	//
	// Read Only: true
	// Max Length: 4
	ExpirationYear string `json:"expirationYear,omitempty"`

	// The customers latest payment card number suffix
	//
	// Example: 1111
	// Read Only: true
	Suffix string `json:"suffix,omitempty"`
}

// Validate validates this patch customer params body embedded default payment instrument embedded instrument identifier tokenized card card
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCardCard) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateExpirationMonth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpirationYear(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCardCard) validateExpirationMonth(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationMonth) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerRequest"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"card"+"."+"expirationMonth", "body", o.ExpirationMonth, 2); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCardCard) validateExpirationYear(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationYear) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerRequest"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"card"+"."+"expirationYear", "body", o.ExpirationYear, 4); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this patch customer params body embedded default payment instrument embedded instrument identifier tokenized card card based on the context it is used
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCardCard) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateExpirationMonth(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateExpirationYear(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateSuffix(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCardCard) contextValidateExpirationMonth(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerRequest"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"card"+"."+"expirationMonth", "body", string(o.ExpirationMonth)); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCardCard) contextValidateExpirationYear(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerRequest"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"card"+"."+"expirationYear", "body", string(o.ExpirationYear)); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCardCard) contextValidateSuffix(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerRequest"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"_embedded"+"."+"instrumentIdentifier"+"."+"tokenizedCard"+"."+"card"+"."+"suffix", "body", string(o.Suffix)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCardCard) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCardCard) UnmarshalBinary(b []byte) error {
	var res PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentEmbeddedInstrumentIdentifierTokenizedCardCard
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentInstrumentIdentifier patch customer params body embedded default payment instrument instrument identifier
swagger:model PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentInstrumentIdentifier
*/
type PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentInstrumentIdentifier struct {

	// The id of the Instrument Identifier token linked to the Payment Instrument.
	//
	// Max Length: 32
	// Min Length: 12
	ID string `json:"id,omitempty"`
}

// Validate validates this patch customer params body embedded default payment instrument instrument identifier
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentInstrumentIdentifier) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentInstrumentIdentifier) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MinLength("patchCustomerRequest"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"instrumentIdentifier"+"."+"id", "body", o.ID, 12); err != nil {
		return err
	}

	if err := validate.MaxLength("patchCustomerRequest"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"instrumentIdentifier"+"."+"id", "body", o.ID, 32); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this patch customer params body embedded default payment instrument instrument identifier based on context it is used
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentInstrumentIdentifier) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentInstrumentIdentifier) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentInstrumentIdentifier) UnmarshalBinary(b []byte) error {
	var res PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentInstrumentIdentifier
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentLinks patch customer params body embedded default payment instrument links
swagger:model PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentLinks
*/
type PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentLinks struct {

	// customer
	Customer *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentLinksCustomer `json:"customer,omitempty"`

	// self
	Self *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentLinksSelf `json:"self,omitempty"`
}

// Validate validates this patch customer params body embedded default payment instrument links
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCustomer(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentLinks) validateCustomer(formats strfmt.Registry) error {
	if swag.IsZero(o.Customer) { // not required
		return nil
	}

	if o.Customer != nil {
		if err := o.Customer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_links" + "." + "customer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_links" + "." + "customer")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(o.Self) { // not required
		return nil
	}

	if o.Self != nil {
		if err := o.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_links" + "." + "self")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch customer params body embedded default payment instrument links based on the context it is used
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateCustomer(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentLinks) contextValidateCustomer(ctx context.Context, formats strfmt.Registry) error {

	if o.Customer != nil {
		if err := o.Customer.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_links" + "." + "customer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_links" + "." + "customer")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if o.Self != nil {
		if err := o.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_links" + "." + "self")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentLinks) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentLinks) UnmarshalBinary(b []byte) error {
	var res PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentLinksCustomer patch customer params body embedded default payment instrument links customer
swagger:model PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentLinksCustomer
*/
type PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentLinksCustomer struct {

	// Link to the Customer.
	//
	// Example: /tms/v2/customers/1234567890123456789
	// Read Only: true
	Href string `json:"href,omitempty"`
}

// Validate validates this patch customer params body embedded default payment instrument links customer
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentLinksCustomer) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this patch customer params body embedded default payment instrument links customer based on the context it is used
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentLinksCustomer) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateHref(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentLinksCustomer) contextValidateHref(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerRequest"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"_links"+"."+"customer"+"."+"href", "body", string(o.Href)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentLinksCustomer) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentLinksCustomer) UnmarshalBinary(b []byte) error {
	var res PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentLinksCustomer
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentLinksSelf patch customer params body embedded default payment instrument links self
swagger:model PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentLinksSelf
*/
type PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentLinksSelf struct {

	// Link to the Payment Instrument.
	//
	// Example: /tms/v2/customers/1234567890123456789/payment-instruments
	// Read Only: true
	Href string `json:"href,omitempty"`
}

// Validate validates this patch customer params body embedded default payment instrument links self
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentLinksSelf) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this patch customer params body embedded default payment instrument links self based on the context it is used
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentLinksSelf) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateHref(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentLinksSelf) contextValidateHref(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerRequest"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"_links"+"."+"self"+"."+"href", "body", string(o.Href)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentLinksSelf) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentLinksSelf) UnmarshalBinary(b []byte) error {
	var res PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentLinksSelf
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentMerchantInformation patch customer params body embedded default payment instrument merchant information
swagger:model PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentMerchantInformation
*/
type PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentMerchantInformation struct {

	// merchant descriptor
	MerchantDescriptor *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentMerchantInformationMerchantDescriptor `json:"merchantDescriptor,omitempty"`
}

// Validate validates this patch customer params body embedded default payment instrument merchant information
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentMerchantInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateMerchantDescriptor(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentMerchantInformation) validateMerchantDescriptor(formats strfmt.Registry) error {
	if swag.IsZero(o.MerchantDescriptor) { // not required
		return nil
	}

	if o.MerchantDescriptor != nil {
		if err := o.MerchantDescriptor.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "merchantInformation" + "." + "merchantDescriptor")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "merchantInformation" + "." + "merchantDescriptor")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch customer params body embedded default payment instrument merchant information based on the context it is used
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentMerchantInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateMerchantDescriptor(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentMerchantInformation) contextValidateMerchantDescriptor(ctx context.Context, formats strfmt.Registry) error {

	if o.MerchantDescriptor != nil {
		if err := o.MerchantDescriptor.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "merchantInformation" + "." + "merchantDescriptor")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "merchantInformation" + "." + "merchantDescriptor")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentMerchantInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentMerchantInformation) UnmarshalBinary(b []byte) error {
	var res PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentMerchantInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentMerchantInformationMerchantDescriptor patch customer params body embedded default payment instrument merchant information merchant descriptor
swagger:model PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentMerchantInformationMerchantDescriptor
*/
type PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentMerchantInformationMerchantDescriptor struct {

	// Alternate contact information for your business,such as an email address or URL.
	// This value might be displayed on the cardholders statement.
	// When you do not include this value in your capture or credit request, CyberSource uses the merchant URL from your CyberSource account.
	// Important This value must consist of English characters
	//
	// Max Length: 13
	AlternateName string `json:"alternateName,omitempty"`
}

// Validate validates this patch customer params body embedded default payment instrument merchant information merchant descriptor
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentMerchantInformationMerchantDescriptor) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAlternateName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentMerchantInformationMerchantDescriptor) validateAlternateName(formats strfmt.Registry) error {
	if swag.IsZero(o.AlternateName) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerRequest"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"merchantInformation"+"."+"merchantDescriptor"+"."+"alternateName", "body", o.AlternateName, 13); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this patch customer params body embedded default payment instrument merchant information merchant descriptor based on context it is used
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentMerchantInformationMerchantDescriptor) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentMerchantInformationMerchantDescriptor) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentMerchantInformationMerchantDescriptor) UnmarshalBinary(b []byte) error {
	var res PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentMerchantInformationMerchantDescriptor
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentMetadata patch customer params body embedded default payment instrument metadata
swagger:model PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentMetadata
*/
type PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentMetadata struct {

	// The creator of the Payment Instrument token.
	//
	// Read Only: true
	Creator string `json:"creator,omitempty"`
}

// Validate validates this patch customer params body embedded default payment instrument metadata
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentMetadata) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this patch customer params body embedded default payment instrument metadata based on the context it is used
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentMetadata) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateCreator(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentMetadata) contextValidateCreator(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerRequest"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"metadata"+"."+"creator", "body", string(o.Creator)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentMetadata) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentMetadata) UnmarshalBinary(b []byte) error {
	var res PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentMetadata
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentProcessingInformation patch customer params body embedded default payment instrument processing information
swagger:model PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentProcessingInformation
*/
type PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentProcessingInformation struct {

	// bank transfer options
	BankTransferOptions *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentProcessingInformationBankTransferOptions `json:"bankTransferOptions,omitempty"`

	// Flag that indicates that this is a payment for a bill or for an existing contractual loan.
	// For processor-specific details, see the `bill_payment` field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// Valid values:
	// - `true`: Bill payment or loan payment.
	// - `false` (default): Not a bill payment or loan payment.
	//
	BillPaymentProgramEnabled bool `json:"billPaymentProgramEnabled,omitempty"`
}

// Validate validates this patch customer params body embedded default payment instrument processing information
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentProcessingInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateBankTransferOptions(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentProcessingInformation) validateBankTransferOptions(formats strfmt.Registry) error {
	if swag.IsZero(o.BankTransferOptions) { // not required
		return nil
	}

	if o.BankTransferOptions != nil {
		if err := o.BankTransferOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "processingInformation" + "." + "bankTransferOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "processingInformation" + "." + "bankTransferOptions")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch customer params body embedded default payment instrument processing information based on the context it is used
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentProcessingInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateBankTransferOptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentProcessingInformation) contextValidateBankTransferOptions(ctx context.Context, formats strfmt.Registry) error {

	if o.BankTransferOptions != nil {
		if err := o.BankTransferOptions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "processingInformation" + "." + "bankTransferOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultPaymentInstrument" + "." + "processingInformation" + "." + "bankTransferOptions")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentProcessingInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentProcessingInformation) UnmarshalBinary(b []byte) error {
	var res PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentProcessingInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentProcessingInformationBankTransferOptions patch customer params body embedded default payment instrument processing information bank transfer options
swagger:model PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentProcessingInformationBankTransferOptions
*/
type PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentProcessingInformationBankTransferOptions struct {

	// Specifies the authorization method for the transaction.
	//
	// #### TeleCheck
	// Valid values:
	// - `ARC`: account receivable conversion
	// - `CCD`: corporate cash disbursement
	// - `POP`: point of purchase conversion
	// - `PPD`: prearranged payment and deposit entry
	// - `TEL`: telephone-initiated entry
	// - `WEB`: internet-initiated entry
	//
	// For details, see `ecp_sec_code` field description in the [Electronic Check Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/EChecks_SCMP_API/html/)
	//
	// Max Length: 3
	SECCode string `json:"SECCode,omitempty"`
}

// Validate validates this patch customer params body embedded default payment instrument processing information bank transfer options
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentProcessingInformationBankTransferOptions) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateSECCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentProcessingInformationBankTransferOptions) validateSECCode(formats strfmt.Registry) error {
	if swag.IsZero(o.SECCode) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerRequest"+"."+"_embedded"+"."+"defaultPaymentInstrument"+"."+"processingInformation"+"."+"bankTransferOptions"+"."+"SECCode", "body", o.SECCode, 3); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this patch customer params body embedded default payment instrument processing information bank transfer options based on context it is used
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentProcessingInformationBankTransferOptions) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentProcessingInformationBankTransferOptions) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentProcessingInformationBankTransferOptions) UnmarshalBinary(b []byte) error {
	var res PatchCustomerParamsBodyEmbeddedDefaultPaymentInstrumentProcessingInformationBankTransferOptions
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerParamsBodyEmbeddedDefaultShippingAddress patch customer params body embedded default shipping address
swagger:model PatchCustomerParamsBodyEmbeddedDefaultShippingAddress
*/
type PatchCustomerParamsBodyEmbeddedDefaultShippingAddress struct {

	// links
	Links *PatchCustomerParamsBodyEmbeddedDefaultShippingAddressLinks `json:"_links,omitempty"`

	// Flag that indicates whether customer shipping address is the dafault.
	// Valid values:
	//  - `true`: Shipping Address is customer's default.
	//  - `false`: Shipping Address is not customer's default.
	//
	Default bool `json:"default,omitempty"`

	// The id of the Shipping Address Token.
	// Max Length: 32
	// Min Length: 1
	ID string `json:"id,omitempty"`

	// metadata
	Metadata *PatchCustomerParamsBodyEmbeddedDefaultShippingAddressMetadata `json:"metadata,omitempty"`

	// ship to
	ShipTo *PatchCustomerParamsBodyEmbeddedDefaultShippingAddressShipTo `json:"shipTo,omitempty"`
}

// Validate validates this patch customer params body embedded default shipping address
func (o *PatchCustomerParamsBodyEmbeddedDefaultShippingAddress) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMetadata(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateShipTo(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultShippingAddress) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(o.Links) { // not required
		return nil
	}

	if o.Links != nil {
		if err := o.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultShippingAddress" + "." + "_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultShippingAddress" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultShippingAddress) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MinLength("patchCustomerRequest"+"."+"_embedded"+"."+"defaultShippingAddress"+"."+"id", "body", o.ID, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("patchCustomerRequest"+"."+"_embedded"+"."+"defaultShippingAddress"+"."+"id", "body", o.ID, 32); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultShippingAddress) validateMetadata(formats strfmt.Registry) error {
	if swag.IsZero(o.Metadata) { // not required
		return nil
	}

	if o.Metadata != nil {
		if err := o.Metadata.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultShippingAddress" + "." + "metadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultShippingAddress" + "." + "metadata")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultShippingAddress) validateShipTo(formats strfmt.Registry) error {
	if swag.IsZero(o.ShipTo) { // not required
		return nil
	}

	if o.ShipTo != nil {
		if err := o.ShipTo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultShippingAddress" + "." + "shipTo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultShippingAddress" + "." + "shipTo")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch customer params body embedded default shipping address based on the context it is used
func (o *PatchCustomerParamsBodyEmbeddedDefaultShippingAddress) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateMetadata(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateShipTo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultShippingAddress) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if o.Links != nil {
		if err := o.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultShippingAddress" + "." + "_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultShippingAddress" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultShippingAddress) contextValidateMetadata(ctx context.Context, formats strfmt.Registry) error {

	if o.Metadata != nil {
		if err := o.Metadata.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultShippingAddress" + "." + "metadata")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultShippingAddress" + "." + "metadata")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultShippingAddress) contextValidateShipTo(ctx context.Context, formats strfmt.Registry) error {

	if o.ShipTo != nil {
		if err := o.ShipTo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultShippingAddress" + "." + "shipTo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultShippingAddress" + "." + "shipTo")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultShippingAddress) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultShippingAddress) UnmarshalBinary(b []byte) error {
	var res PatchCustomerParamsBodyEmbeddedDefaultShippingAddress
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerParamsBodyEmbeddedDefaultShippingAddressLinks patch customer params body embedded default shipping address links
swagger:model PatchCustomerParamsBodyEmbeddedDefaultShippingAddressLinks
*/
type PatchCustomerParamsBodyEmbeddedDefaultShippingAddressLinks struct {

	// customer
	Customer *PatchCustomerParamsBodyEmbeddedDefaultShippingAddressLinksCustomer `json:"customer,omitempty"`

	// self
	Self *PatchCustomerParamsBodyEmbeddedDefaultShippingAddressLinksSelf `json:"self,omitempty"`
}

// Validate validates this patch customer params body embedded default shipping address links
func (o *PatchCustomerParamsBodyEmbeddedDefaultShippingAddressLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCustomer(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultShippingAddressLinks) validateCustomer(formats strfmt.Registry) error {
	if swag.IsZero(o.Customer) { // not required
		return nil
	}

	if o.Customer != nil {
		if err := o.Customer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultShippingAddress" + "." + "_links" + "." + "customer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultShippingAddress" + "." + "_links" + "." + "customer")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultShippingAddressLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(o.Self) { // not required
		return nil
	}

	if o.Self != nil {
		if err := o.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultShippingAddress" + "." + "_links" + "." + "self")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultShippingAddress" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch customer params body embedded default shipping address links based on the context it is used
func (o *PatchCustomerParamsBodyEmbeddedDefaultShippingAddressLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateCustomer(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultShippingAddressLinks) contextValidateCustomer(ctx context.Context, formats strfmt.Registry) error {

	if o.Customer != nil {
		if err := o.Customer.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultShippingAddress" + "." + "_links" + "." + "customer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultShippingAddress" + "." + "_links" + "." + "customer")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultShippingAddressLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if o.Self != nil {
		if err := o.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultShippingAddress" + "." + "_links" + "." + "self")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_embedded" + "." + "defaultShippingAddress" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultShippingAddressLinks) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultShippingAddressLinks) UnmarshalBinary(b []byte) error {
	var res PatchCustomerParamsBodyEmbeddedDefaultShippingAddressLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerParamsBodyEmbeddedDefaultShippingAddressLinksCustomer patch customer params body embedded default shipping address links customer
swagger:model PatchCustomerParamsBodyEmbeddedDefaultShippingAddressLinksCustomer
*/
type PatchCustomerParamsBodyEmbeddedDefaultShippingAddressLinksCustomer struct {

	// Link to the Customer
	//
	// Example: /tms/v2/customers/1234567890123456789
	// Read Only: true
	Href string `json:"href,omitempty"`
}

// Validate validates this patch customer params body embedded default shipping address links customer
func (o *PatchCustomerParamsBodyEmbeddedDefaultShippingAddressLinksCustomer) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this patch customer params body embedded default shipping address links customer based on the context it is used
func (o *PatchCustomerParamsBodyEmbeddedDefaultShippingAddressLinksCustomer) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateHref(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultShippingAddressLinksCustomer) contextValidateHref(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerRequest"+"."+"_embedded"+"."+"defaultShippingAddress"+"."+"_links"+"."+"customer"+"."+"href", "body", string(o.Href)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultShippingAddressLinksCustomer) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultShippingAddressLinksCustomer) UnmarshalBinary(b []byte) error {
	var res PatchCustomerParamsBodyEmbeddedDefaultShippingAddressLinksCustomer
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerParamsBodyEmbeddedDefaultShippingAddressLinksSelf patch customer params body embedded default shipping address links self
swagger:model PatchCustomerParamsBodyEmbeddedDefaultShippingAddressLinksSelf
*/
type PatchCustomerParamsBodyEmbeddedDefaultShippingAddressLinksSelf struct {

	// Link to the Customers Shipping Address
	//
	// Example: /tms/v2/customers/1234567890123456789/shipping-addresses/9B8D20D13FF328CCE0539399D30A70N4
	// Read Only: true
	Href string `json:"href,omitempty"`
}

// Validate validates this patch customer params body embedded default shipping address links self
func (o *PatchCustomerParamsBodyEmbeddedDefaultShippingAddressLinksSelf) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this patch customer params body embedded default shipping address links self based on the context it is used
func (o *PatchCustomerParamsBodyEmbeddedDefaultShippingAddressLinksSelf) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateHref(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultShippingAddressLinksSelf) contextValidateHref(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerRequest"+"."+"_embedded"+"."+"defaultShippingAddress"+"."+"_links"+"."+"self"+"."+"href", "body", string(o.Href)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultShippingAddressLinksSelf) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultShippingAddressLinksSelf) UnmarshalBinary(b []byte) error {
	var res PatchCustomerParamsBodyEmbeddedDefaultShippingAddressLinksSelf
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerParamsBodyEmbeddedDefaultShippingAddressMetadata patch customer params body embedded default shipping address metadata
swagger:model PatchCustomerParamsBodyEmbeddedDefaultShippingAddressMetadata
*/
type PatchCustomerParamsBodyEmbeddedDefaultShippingAddressMetadata struct {

	// The creator of the Shipping Address token.
	// Read Only: true
	Creator string `json:"creator,omitempty"`
}

// Validate validates this patch customer params body embedded default shipping address metadata
func (o *PatchCustomerParamsBodyEmbeddedDefaultShippingAddressMetadata) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this patch customer params body embedded default shipping address metadata based on the context it is used
func (o *PatchCustomerParamsBodyEmbeddedDefaultShippingAddressMetadata) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateCreator(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultShippingAddressMetadata) contextValidateCreator(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerRequest"+"."+"_embedded"+"."+"defaultShippingAddress"+"."+"metadata"+"."+"creator", "body", string(o.Creator)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultShippingAddressMetadata) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultShippingAddressMetadata) UnmarshalBinary(b []byte) error {
	var res PatchCustomerParamsBodyEmbeddedDefaultShippingAddressMetadata
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerParamsBodyEmbeddedDefaultShippingAddressShipTo patch customer params body embedded default shipping address ship to
swagger:model PatchCustomerParamsBodyEmbeddedDefaultShippingAddressShipTo
*/
type PatchCustomerParamsBodyEmbeddedDefaultShippingAddressShipTo struct {

	// First line of the shipping address.
	//
	// Max Length: 60
	Address1 string `json:"address1,omitempty"`

	// Second line of the shipping address.
	//
	// Max Length: 60
	Address2 string `json:"address2,omitempty"`

	// State or province of the shipping address. Use 2 character the State,
	// Province, and Territory Codes for the United States and Canada.
	//
	// Max Length: 20
	AdministrativeArea string `json:"administrativeArea,omitempty"`

	// Company associated with the shipping address.
	//
	// Max Length: 60
	Company string `json:"company,omitempty"`

	// Country of the shipping address. Use the two-character ISO Standard Country Codes.
	//
	// Max Length: 2
	Country string `json:"country,omitempty"`

	// Email associated with the shipping address.
	//
	// Max Length: 320
	Email string `json:"email,omitempty"`

	// First name of the recipient.
	//
	// Max Length: 60
	FirstName string `json:"firstName,omitempty"`

	// Last name of the recipient.
	//
	// Max Length: 60
	LastName string `json:"lastName,omitempty"`

	// City of the shipping address.
	//
	// Max Length: 50
	Locality string `json:"locality,omitempty"`

	// Phone number associated with the shipping address.
	//
	// Max Length: 15
	PhoneNumber string `json:"phoneNumber,omitempty"`

	// Postal code for the shipping address. The postal code must consist of 5 to 9 digits.
	//
	// When the billing country is the U.S., the 9-digit postal code must follow this format:
	// [5 digits][dash][4 digits]
	//
	// Example 12345-6789
	//
	// When the billing country is Canada, the 6-digit postal code must follow this format:
	// [alpha][numeric][alpha][space][numeric][alpha][numeric]
	//
	// Example A1B 2C3
	//
	// **American Express Direct**\
	// Before sending the postal code to the processor, CyberSource removes all nonalphanumeric characters and, if the
	// remaining value is longer than nine characters, truncates the value starting from the right side.
	//
	// Max Length: 10
	PostalCode string `json:"postalCode,omitempty"`
}

// Validate validates this patch customer params body embedded default shipping address ship to
func (o *PatchCustomerParamsBodyEmbeddedDefaultShippingAddressShipTo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAddress1(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAddress2(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAdministrativeArea(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCompany(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEmail(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFirstName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLastName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocality(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePhoneNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultShippingAddressShipTo) validateAddress1(formats strfmt.Registry) error {
	if swag.IsZero(o.Address1) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerRequest"+"."+"_embedded"+"."+"defaultShippingAddress"+"."+"shipTo"+"."+"address1", "body", o.Address1, 60); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultShippingAddressShipTo) validateAddress2(formats strfmt.Registry) error {
	if swag.IsZero(o.Address2) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerRequest"+"."+"_embedded"+"."+"defaultShippingAddress"+"."+"shipTo"+"."+"address2", "body", o.Address2, 60); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultShippingAddressShipTo) validateAdministrativeArea(formats strfmt.Registry) error {
	if swag.IsZero(o.AdministrativeArea) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerRequest"+"."+"_embedded"+"."+"defaultShippingAddress"+"."+"shipTo"+"."+"administrativeArea", "body", o.AdministrativeArea, 20); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultShippingAddressShipTo) validateCompany(formats strfmt.Registry) error {
	if swag.IsZero(o.Company) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerRequest"+"."+"_embedded"+"."+"defaultShippingAddress"+"."+"shipTo"+"."+"company", "body", o.Company, 60); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultShippingAddressShipTo) validateCountry(formats strfmt.Registry) error {
	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerRequest"+"."+"_embedded"+"."+"defaultShippingAddress"+"."+"shipTo"+"."+"country", "body", o.Country, 2); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultShippingAddressShipTo) validateEmail(formats strfmt.Registry) error {
	if swag.IsZero(o.Email) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerRequest"+"."+"_embedded"+"."+"defaultShippingAddress"+"."+"shipTo"+"."+"email", "body", o.Email, 320); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultShippingAddressShipTo) validateFirstName(formats strfmt.Registry) error {
	if swag.IsZero(o.FirstName) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerRequest"+"."+"_embedded"+"."+"defaultShippingAddress"+"."+"shipTo"+"."+"firstName", "body", o.FirstName, 60); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultShippingAddressShipTo) validateLastName(formats strfmt.Registry) error {
	if swag.IsZero(o.LastName) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerRequest"+"."+"_embedded"+"."+"defaultShippingAddress"+"."+"shipTo"+"."+"lastName", "body", o.LastName, 60); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultShippingAddressShipTo) validateLocality(formats strfmt.Registry) error {
	if swag.IsZero(o.Locality) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerRequest"+"."+"_embedded"+"."+"defaultShippingAddress"+"."+"shipTo"+"."+"locality", "body", o.Locality, 50); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultShippingAddressShipTo) validatePhoneNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.PhoneNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerRequest"+"."+"_embedded"+"."+"defaultShippingAddress"+"."+"shipTo"+"."+"phoneNumber", "body", o.PhoneNumber, 15); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerParamsBodyEmbeddedDefaultShippingAddressShipTo) validatePostalCode(formats strfmt.Registry) error {
	if swag.IsZero(o.PostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerRequest"+"."+"_embedded"+"."+"defaultShippingAddress"+"."+"shipTo"+"."+"postalCode", "body", o.PostalCode, 10); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this patch customer params body embedded default shipping address ship to based on context it is used
func (o *PatchCustomerParamsBodyEmbeddedDefaultShippingAddressShipTo) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultShippingAddressShipTo) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerParamsBodyEmbeddedDefaultShippingAddressShipTo) UnmarshalBinary(b []byte) error {
	var res PatchCustomerParamsBodyEmbeddedDefaultShippingAddressShipTo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerParamsBodyLinks patch customer params body links
swagger:model PatchCustomerParamsBodyLinks
*/
type PatchCustomerParamsBodyLinks struct {

	// payment instruments
	PaymentInstruments *PatchCustomerParamsBodyLinksPaymentInstruments `json:"paymentInstruments,omitempty"`

	// self
	Self *PatchCustomerParamsBodyLinksSelf `json:"self,omitempty"`

	// shipping address
	ShippingAddress *PatchCustomerParamsBodyLinksShippingAddress `json:"shippingAddress,omitempty"`
}

// Validate validates this patch customer params body links
func (o *PatchCustomerParamsBodyLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validatePaymentInstruments(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateShippingAddress(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerParamsBodyLinks) validatePaymentInstruments(formats strfmt.Registry) error {
	if swag.IsZero(o.PaymentInstruments) { // not required
		return nil
	}

	if o.PaymentInstruments != nil {
		if err := o.PaymentInstruments.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_links" + "." + "paymentInstruments")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_links" + "." + "paymentInstruments")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerParamsBodyLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(o.Self) { // not required
		return nil
	}

	if o.Self != nil {
		if err := o.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_links" + "." + "self")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerParamsBodyLinks) validateShippingAddress(formats strfmt.Registry) error {
	if swag.IsZero(o.ShippingAddress) { // not required
		return nil
	}

	if o.ShippingAddress != nil {
		if err := o.ShippingAddress.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_links" + "." + "shippingAddress")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_links" + "." + "shippingAddress")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this patch customer params body links based on the context it is used
func (o *PatchCustomerParamsBodyLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidatePaymentInstruments(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateShippingAddress(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerParamsBodyLinks) contextValidatePaymentInstruments(ctx context.Context, formats strfmt.Registry) error {

	if o.PaymentInstruments != nil {
		if err := o.PaymentInstruments.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_links" + "." + "paymentInstruments")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_links" + "." + "paymentInstruments")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerParamsBodyLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if o.Self != nil {
		if err := o.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_links" + "." + "self")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

func (o *PatchCustomerParamsBodyLinks) contextValidateShippingAddress(ctx context.Context, formats strfmt.Registry) error {

	if o.ShippingAddress != nil {
		if err := o.ShippingAddress.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("patchCustomerRequest" + "." + "_links" + "." + "shippingAddress")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("patchCustomerRequest" + "." + "_links" + "." + "shippingAddress")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerParamsBodyLinks) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerParamsBodyLinks) UnmarshalBinary(b []byte) error {
	var res PatchCustomerParamsBodyLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerParamsBodyLinksPaymentInstruments patch customer params body links payment instruments
swagger:model PatchCustomerParamsBodyLinksPaymentInstruments
*/
type PatchCustomerParamsBodyLinksPaymentInstruments struct {

	// Link to the Customers Payment Instruments.
	//
	// Example: /tms/v2/customers/1234567890123456789/payment-instruments
	// Read Only: true
	Href string `json:"href,omitempty"`
}

// Validate validates this patch customer params body links payment instruments
func (o *PatchCustomerParamsBodyLinksPaymentInstruments) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this patch customer params body links payment instruments based on the context it is used
func (o *PatchCustomerParamsBodyLinksPaymentInstruments) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateHref(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerParamsBodyLinksPaymentInstruments) contextValidateHref(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerRequest"+"."+"_links"+"."+"paymentInstruments"+"."+"href", "body", string(o.Href)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerParamsBodyLinksPaymentInstruments) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerParamsBodyLinksPaymentInstruments) UnmarshalBinary(b []byte) error {
	var res PatchCustomerParamsBodyLinksPaymentInstruments
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerParamsBodyLinksSelf patch customer params body links self
swagger:model PatchCustomerParamsBodyLinksSelf
*/
type PatchCustomerParamsBodyLinksSelf struct {

	// Link to the Customer.
	//
	// Example: /tms/v2/customers/1234567890123456789
	// Read Only: true
	Href string `json:"href,omitempty"`
}

// Validate validates this patch customer params body links self
func (o *PatchCustomerParamsBodyLinksSelf) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this patch customer params body links self based on the context it is used
func (o *PatchCustomerParamsBodyLinksSelf) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateHref(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerParamsBodyLinksSelf) contextValidateHref(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerRequest"+"."+"_links"+"."+"self"+"."+"href", "body", string(o.Href)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerParamsBodyLinksSelf) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerParamsBodyLinksSelf) UnmarshalBinary(b []byte) error {
	var res PatchCustomerParamsBodyLinksSelf
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerParamsBodyLinksShippingAddress patch customer params body links shipping address
swagger:model PatchCustomerParamsBodyLinksShippingAddress
*/
type PatchCustomerParamsBodyLinksShippingAddress struct {

	// Link to the Customers Shipping Addresses.
	//
	// Example: /tms/v2/customers/1234567890123456789/shipping-addresses
	// Read Only: true
	Href string `json:"href,omitempty"`
}

// Validate validates this patch customer params body links shipping address
func (o *PatchCustomerParamsBodyLinksShippingAddress) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this patch customer params body links shipping address based on the context it is used
func (o *PatchCustomerParamsBodyLinksShippingAddress) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateHref(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerParamsBodyLinksShippingAddress) contextValidateHref(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerRequest"+"."+"_links"+"."+"shippingAddress"+"."+"href", "body", string(o.Href)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerParamsBodyLinksShippingAddress) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerParamsBodyLinksShippingAddress) UnmarshalBinary(b []byte) error {
	var res PatchCustomerParamsBodyLinksShippingAddress
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerParamsBodyMerchantDefinedInformationItems0 patch customer params body merchant defined information items0
swagger:model PatchCustomerParamsBodyMerchantDefinedInformationItems0
*/
type PatchCustomerParamsBodyMerchantDefinedInformationItems0 struct {

	// The number you assign as the name for your merchant-defined data or secure field. Valid values are data1 to data4 and sensitive1 to sensitive4
	//
	// For example, to set the name for merchant-defined data 2 field, you would reference merchantDefinedInformation[x].name as data2
	// Valid values:
	// - data1
	// - data2
	// - data3
	// - data4
	// - sensitive1
	// - sensitive2
	// - sensitive3
	// - sensitive4
	//
	Name string `json:"name,omitempty"`

	// The value you assign for your merchant-defined data field.
	//
	// **Warning** Merchant-defined data fields are not intended to and must not be used to capture personally identifying information. Accordingly, merchants are prohibited from capturing, obtaining, and/or transmitting any personally identifying information in or via the merchant-defined data fields. Personally identifying information includes, but is not
	// limited to, address, credit card number, social security number, driver's license number, state-issued identification number, passport number, and card verification numbers (CVV,
	// CVC2, CVV2, CID, CVN). In the event CyberSource discovers that a merchant is capturing and/or transmitting personally identifying information via the merchant-defined data fields, whether or not intentionally, CyberSource will immediately suspend the merchant's account, which will result in a rejection of any and all transaction requests submitted by the merchant after the point of suspension.
	//
	// Max Length: 100
	Value string `json:"value,omitempty"`
}

// Validate validates this patch customer params body merchant defined information items0
func (o *PatchCustomerParamsBodyMerchantDefinedInformationItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateValue(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerParamsBodyMerchantDefinedInformationItems0) validateValue(formats strfmt.Registry) error {
	if swag.IsZero(o.Value) { // not required
		return nil
	}

	if err := validate.MaxLength("value", "body", o.Value, 100); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this patch customer params body merchant defined information items0 based on context it is used
func (o *PatchCustomerParamsBodyMerchantDefinedInformationItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerParamsBodyMerchantDefinedInformationItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerParamsBodyMerchantDefinedInformationItems0) UnmarshalBinary(b []byte) error {
	var res PatchCustomerParamsBodyMerchantDefinedInformationItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerParamsBodyMetadata patch customer params body metadata
swagger:model PatchCustomerParamsBodyMetadata
*/
type PatchCustomerParamsBodyMetadata struct {

	// The creator of the Customer token.
	//
	// Read Only: true
	Creator string `json:"creator,omitempty"`
}

// Validate validates this patch customer params body metadata
func (o *PatchCustomerParamsBodyMetadata) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this patch customer params body metadata based on the context it is used
func (o *PatchCustomerParamsBodyMetadata) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateCreator(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerParamsBodyMetadata) contextValidateCreator(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerRequest"+"."+"metadata"+"."+"creator", "body", string(o.Creator)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerParamsBodyMetadata) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerParamsBodyMetadata) UnmarshalBinary(b []byte) error {
	var res PatchCustomerParamsBodyMetadata
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerParamsBodyObjectInformation patch customer params body object information
swagger:model PatchCustomerParamsBodyObjectInformation
*/
type PatchCustomerParamsBodyObjectInformation struct {

	// Comments that you can make about the customer.
	//
	// Max Length: 150
	Comment string `json:"comment,omitempty"`

	// Name or title of the customer.
	//
	// Max Length: 60
	Title string `json:"title,omitempty"`
}

// Validate validates this patch customer params body object information
func (o *PatchCustomerParamsBodyObjectInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateComment(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTitle(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerParamsBodyObjectInformation) validateComment(formats strfmt.Registry) error {
	if swag.IsZero(o.Comment) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerRequest"+"."+"objectInformation"+"."+"comment", "body", o.Comment, 150); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerParamsBodyObjectInformation) validateTitle(formats strfmt.Registry) error {
	if swag.IsZero(o.Title) { // not required
		return nil
	}

	if err := validate.MaxLength("patchCustomerRequest"+"."+"objectInformation"+"."+"title", "body", o.Title, 60); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this patch customer params body object information based on context it is used
func (o *PatchCustomerParamsBodyObjectInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerParamsBodyObjectInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerParamsBodyObjectInformation) UnmarshalBinary(b []byte) error {
	var res PatchCustomerParamsBodyObjectInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerPreconditionFailedBody patch customer precondition failed body
swagger:model PatchCustomerPreconditionFailedBody
*/
type PatchCustomerPreconditionFailedBody struct {

	// errors
	// Read Only: true
	Errors []*PatchCustomerPreconditionFailedBodyErrorsItems0 `json:"errors"`
}

// Validate validates this patch customer precondition failed body
func (o *PatchCustomerPreconditionFailedBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateErrors(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerPreconditionFailedBody) validateErrors(formats strfmt.Registry) error {
	if swag.IsZero(o.Errors) { // not required
		return nil
	}

	for i := 0; i < len(o.Errors); i++ {
		if swag.IsZero(o.Errors[i]) { // not required
			continue
		}

		if o.Errors[i] != nil {
			if err := o.Errors[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("patchCustomerPreconditionFailed" + "." + "errors" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("patchCustomerPreconditionFailed" + "." + "errors" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this patch customer precondition failed body based on the context it is used
func (o *PatchCustomerPreconditionFailedBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateErrors(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerPreconditionFailedBody) contextValidateErrors(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "patchCustomerPreconditionFailed"+"."+"errors", "body", []*PatchCustomerPreconditionFailedBodyErrorsItems0(o.Errors)); err != nil {
		return err
	}

	for i := 0; i < len(o.Errors); i++ {

		if o.Errors[i] != nil {
			if err := o.Errors[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("patchCustomerPreconditionFailed" + "." + "errors" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("patchCustomerPreconditionFailed" + "." + "errors" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerPreconditionFailedBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerPreconditionFailedBody) UnmarshalBinary(b []byte) error {
	var res PatchCustomerPreconditionFailedBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerPreconditionFailedBodyErrorsItems0 patch customer precondition failed body errors items0
swagger:model PatchCustomerPreconditionFailedBodyErrorsItems0
*/
type PatchCustomerPreconditionFailedBodyErrorsItems0 struct {

	// details
	// Read Only: true
	Details []*PatchCustomerPreconditionFailedBodyErrorsItems0DetailsItems0 `json:"details"`

	// The detailed message related to the type stated above.
	// Read Only: true
	Message string `json:"message,omitempty"`

	// The type of error.
	// Read Only: true
	Type string `json:"type,omitempty"`
}

// Validate validates this patch customer precondition failed body errors items0
func (o *PatchCustomerPreconditionFailedBodyErrorsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerPreconditionFailedBodyErrorsItems0) validateDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.Details) { // not required
		return nil
	}

	for i := 0; i < len(o.Details); i++ {
		if swag.IsZero(o.Details[i]) { // not required
			continue
		}

		if o.Details[i] != nil {
			if err := o.Details[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this patch customer precondition failed body errors items0 based on the context it is used
func (o *PatchCustomerPreconditionFailedBodyErrorsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateMessage(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerPreconditionFailedBodyErrorsItems0) contextValidateDetails(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "details", "body", []*PatchCustomerPreconditionFailedBodyErrorsItems0DetailsItems0(o.Details)); err != nil {
		return err
	}

	for i := 0; i < len(o.Details); i++ {

		if o.Details[i] != nil {
			if err := o.Details[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *PatchCustomerPreconditionFailedBodyErrorsItems0) contextValidateMessage(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "message", "body", string(o.Message)); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerPreconditionFailedBodyErrorsItems0) contextValidateType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "type", "body", string(o.Type)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerPreconditionFailedBodyErrorsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerPreconditionFailedBodyErrorsItems0) UnmarshalBinary(b []byte) error {
	var res PatchCustomerPreconditionFailedBodyErrorsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*PatchCustomerPreconditionFailedBodyErrorsItems0DetailsItems0 patch customer precondition failed body errors items0 details items0
swagger:model PatchCustomerPreconditionFailedBodyErrorsItems0DetailsItems0
*/
type PatchCustomerPreconditionFailedBodyErrorsItems0DetailsItems0 struct {

	// The location of the field that caused the error.
	// Read Only: true
	Location string `json:"location,omitempty"`

	// The name of the field that caused the error.
	// Read Only: true
	Name string `json:"name,omitempty"`
}

// Validate validates this patch customer precondition failed body errors items0 details items0
func (o *PatchCustomerPreconditionFailedBodyErrorsItems0DetailsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validate this patch customer precondition failed body errors items0 details items0 based on the context it is used
func (o *PatchCustomerPreconditionFailedBodyErrorsItems0DetailsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateLocation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *PatchCustomerPreconditionFailedBodyErrorsItems0DetailsItems0) contextValidateLocation(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "location", "body", string(o.Location)); err != nil {
		return err
	}

	return nil
}

func (o *PatchCustomerPreconditionFailedBodyErrorsItems0DetailsItems0) contextValidateName(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "name", "body", string(o.Name)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *PatchCustomerPreconditionFailedBodyErrorsItems0DetailsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *PatchCustomerPreconditionFailedBodyErrorsItems0DetailsItems0) UnmarshalBinary(b []byte) error {
	var res PatchCustomerPreconditionFailedBodyErrorsItems0DetailsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}
