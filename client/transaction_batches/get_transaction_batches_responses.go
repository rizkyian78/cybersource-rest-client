// Code generated by go-swagger; DO NOT EDIT.

package transaction_batches

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"fmt"
	"io"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// GetTransactionBatchesReader is a Reader for the GetTransactionBatches structure.
type GetTransactionBatchesReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *GetTransactionBatchesReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 200:
		result := NewGetTransactionBatchesOK()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	case 400:
		result := NewGetTransactionBatchesBadRequest()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 401:
		result := NewGetTransactionBatchesUnauthorized()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 403:
		result := NewGetTransactionBatchesForbidden()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 404:
		result := NewGetTransactionBatchesNotFound()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 500:
		result := NewGetTransactionBatchesInternalServerError()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	default:
		return nil, runtime.NewAPIError("response status code does not match any response statuses defined for this endpoint in the swagger spec", response, response.Code())
	}
}

// NewGetTransactionBatchesOK creates a GetTransactionBatchesOK with default headers values
func NewGetTransactionBatchesOK() *GetTransactionBatchesOK {
	return &GetTransactionBatchesOK{}
}

/* GetTransactionBatchesOK describes a response with status code 200, with default header values.

OK
*/
type GetTransactionBatchesOK struct {
	Payload *GetTransactionBatchesOKBody
}

func (o *GetTransactionBatchesOK) Error() string {
	return fmt.Sprintf("[GET /pts/v1/transaction-batches][%d] getTransactionBatchesOK  %+v", 200, o.Payload)
}
func (o *GetTransactionBatchesOK) GetPayload() *GetTransactionBatchesOKBody {
	return o.Payload
}

func (o *GetTransactionBatchesOK) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(GetTransactionBatchesOKBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewGetTransactionBatchesBadRequest creates a GetTransactionBatchesBadRequest with default headers values
func NewGetTransactionBatchesBadRequest() *GetTransactionBatchesBadRequest {
	return &GetTransactionBatchesBadRequest{}
}

/* GetTransactionBatchesBadRequest describes a response with status code 400, with default header values.

Bad Request
*/
type GetTransactionBatchesBadRequest struct {
	Payload *GetTransactionBatchesBadRequestBody
}

func (o *GetTransactionBatchesBadRequest) Error() string {
	return fmt.Sprintf("[GET /pts/v1/transaction-batches][%d] getTransactionBatchesBadRequest  %+v", 400, o.Payload)
}
func (o *GetTransactionBatchesBadRequest) GetPayload() *GetTransactionBatchesBadRequestBody {
	return o.Payload
}

func (o *GetTransactionBatchesBadRequest) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(GetTransactionBatchesBadRequestBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewGetTransactionBatchesUnauthorized creates a GetTransactionBatchesUnauthorized with default headers values
func NewGetTransactionBatchesUnauthorized() *GetTransactionBatchesUnauthorized {
	return &GetTransactionBatchesUnauthorized{}
}

/* GetTransactionBatchesUnauthorized describes a response with status code 401, with default header values.

Not Authorized
*/
type GetTransactionBatchesUnauthorized struct {
	Payload *GetTransactionBatchesUnauthorizedBody
}

func (o *GetTransactionBatchesUnauthorized) Error() string {
	return fmt.Sprintf("[GET /pts/v1/transaction-batches][%d] getTransactionBatchesUnauthorized  %+v", 401, o.Payload)
}
func (o *GetTransactionBatchesUnauthorized) GetPayload() *GetTransactionBatchesUnauthorizedBody {
	return o.Payload
}

func (o *GetTransactionBatchesUnauthorized) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(GetTransactionBatchesUnauthorizedBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewGetTransactionBatchesForbidden creates a GetTransactionBatchesForbidden with default headers values
func NewGetTransactionBatchesForbidden() *GetTransactionBatchesForbidden {
	return &GetTransactionBatchesForbidden{}
}

/* GetTransactionBatchesForbidden describes a response with status code 403, with default header values.

No Authenticated
*/
type GetTransactionBatchesForbidden struct {
	Payload *GetTransactionBatchesForbiddenBody
}

func (o *GetTransactionBatchesForbidden) Error() string {
	return fmt.Sprintf("[GET /pts/v1/transaction-batches][%d] getTransactionBatchesForbidden  %+v", 403, o.Payload)
}
func (o *GetTransactionBatchesForbidden) GetPayload() *GetTransactionBatchesForbiddenBody {
	return o.Payload
}

func (o *GetTransactionBatchesForbidden) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(GetTransactionBatchesForbiddenBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewGetTransactionBatchesNotFound creates a GetTransactionBatchesNotFound with default headers values
func NewGetTransactionBatchesNotFound() *GetTransactionBatchesNotFound {
	return &GetTransactionBatchesNotFound{}
}

/* GetTransactionBatchesNotFound describes a response with status code 404, with default header values.

No Reports Found
*/
type GetTransactionBatchesNotFound struct {
	Payload *GetTransactionBatchesNotFoundBody
}

func (o *GetTransactionBatchesNotFound) Error() string {
	return fmt.Sprintf("[GET /pts/v1/transaction-batches][%d] getTransactionBatchesNotFound  %+v", 404, o.Payload)
}
func (o *GetTransactionBatchesNotFound) GetPayload() *GetTransactionBatchesNotFoundBody {
	return o.Payload
}

func (o *GetTransactionBatchesNotFound) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(GetTransactionBatchesNotFoundBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewGetTransactionBatchesInternalServerError creates a GetTransactionBatchesInternalServerError with default headers values
func NewGetTransactionBatchesInternalServerError() *GetTransactionBatchesInternalServerError {
	return &GetTransactionBatchesInternalServerError{}
}

/* GetTransactionBatchesInternalServerError describes a response with status code 500, with default header values.

Bad Gateway
*/
type GetTransactionBatchesInternalServerError struct {
	Payload *GetTransactionBatchesInternalServerErrorBody
}

func (o *GetTransactionBatchesInternalServerError) Error() string {
	return fmt.Sprintf("[GET /pts/v1/transaction-batches][%d] getTransactionBatchesInternalServerError  %+v", 500, o.Payload)
}
func (o *GetTransactionBatchesInternalServerError) GetPayload() *GetTransactionBatchesInternalServerErrorBody {
	return o.Payload
}

func (o *GetTransactionBatchesInternalServerError) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(GetTransactionBatchesInternalServerErrorBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

/*GetTransactionBatchesBadRequestBody ptsV1TransactionBatchesGet400Response
swagger:model GetTransactionBatchesBadRequestBody
*/
type GetTransactionBatchesBadRequestBody struct {

	// error information
	ErrorInformation *GetTransactionBatchesBadRequestBodyErrorInformation `json:"errorInformation,omitempty"`

	// Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ`
	// **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.).
	// The `T` separates the date and the time. The `Z` indicates UTC.
	//
	// Returned by Cybersource for all services.
	//
	SubmitTimeUtc string `json:"submitTimeUtc,omitempty"`
}

// Validate validates this get transaction batches bad request body
func (o *GetTransactionBatchesBadRequestBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateErrorInformation(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetTransactionBatchesBadRequestBody) validateErrorInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ErrorInformation) { // not required
		return nil
	}

	if o.ErrorInformation != nil {
		if err := o.ErrorInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getTransactionBatchesBadRequest" + "." + "errorInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getTransactionBatchesBadRequest" + "." + "errorInformation")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this get transaction batches bad request body based on the context it is used
func (o *GetTransactionBatchesBadRequestBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateErrorInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetTransactionBatchesBadRequestBody) contextValidateErrorInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ErrorInformation != nil {
		if err := o.ErrorInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getTransactionBatchesBadRequest" + "." + "errorInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getTransactionBatchesBadRequest" + "." + "errorInformation")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetTransactionBatchesBadRequestBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetTransactionBatchesBadRequestBody) UnmarshalBinary(b []byte) error {
	var res GetTransactionBatchesBadRequestBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetTransactionBatchesBadRequestBodyErrorInformation get transaction batches bad request body error information
swagger:model GetTransactionBatchesBadRequestBodyErrorInformation
*/
type GetTransactionBatchesBadRequestBodyErrorInformation struct {

	// details
	Details []*GetTransactionBatchesBadRequestBodyErrorInformationDetailsItems0 `json:"details"`

	// message
	Message string `json:"message,omitempty"`

	// reason
	Reason string `json:"reason,omitempty"`
}

// Validate validates this get transaction batches bad request body error information
func (o *GetTransactionBatchesBadRequestBodyErrorInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetTransactionBatchesBadRequestBodyErrorInformation) validateDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.Details) { // not required
		return nil
	}

	for i := 0; i < len(o.Details); i++ {
		if swag.IsZero(o.Details[i]) { // not required
			continue
		}

		if o.Details[i] != nil {
			if err := o.Details[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("getTransactionBatchesBadRequest" + "." + "errorInformation" + "." + "details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("getTransactionBatchesBadRequest" + "." + "errorInformation" + "." + "details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this get transaction batches bad request body error information based on the context it is used
func (o *GetTransactionBatchesBadRequestBodyErrorInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetTransactionBatchesBadRequestBodyErrorInformation) contextValidateDetails(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.Details); i++ {

		if o.Details[i] != nil {
			if err := o.Details[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("getTransactionBatchesBadRequest" + "." + "errorInformation" + "." + "details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("getTransactionBatchesBadRequest" + "." + "errorInformation" + "." + "details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetTransactionBatchesBadRequestBodyErrorInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetTransactionBatchesBadRequestBodyErrorInformation) UnmarshalBinary(b []byte) error {
	var res GetTransactionBatchesBadRequestBodyErrorInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetTransactionBatchesBadRequestBodyErrorInformationDetailsItems0 get transaction batches bad request body error information details items0
swagger:model GetTransactionBatchesBadRequestBodyErrorInformationDetailsItems0
*/
type GetTransactionBatchesBadRequestBodyErrorInformationDetailsItems0 struct {

	// This is the flattened JSON object field name/path that is either missing or invalid.
	//
	Field string `json:"field,omitempty"`

	// The detailed message related to the status and reason listed above.
	//
	Message string `json:"message,omitempty"`
}

// Validate validates this get transaction batches bad request body error information details items0
func (o *GetTransactionBatchesBadRequestBodyErrorInformationDetailsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this get transaction batches bad request body error information details items0 based on context it is used
func (o *GetTransactionBatchesBadRequestBodyErrorInformationDetailsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *GetTransactionBatchesBadRequestBodyErrorInformationDetailsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetTransactionBatchesBadRequestBodyErrorInformationDetailsItems0) UnmarshalBinary(b []byte) error {
	var res GetTransactionBatchesBadRequestBodyErrorInformationDetailsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetTransactionBatchesForbiddenBody ptsV1TransactionBatchesGet403Response
swagger:model GetTransactionBatchesForbiddenBody
*/
type GetTransactionBatchesForbiddenBody struct {

	// error information
	ErrorInformation *GetTransactionBatchesForbiddenBodyErrorInformation `json:"errorInformation,omitempty"`

	// Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ`
	// **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.).
	// The `T` separates the date and the time. The `Z` indicates UTC.
	//
	// Returned by Cybersource for all services.
	//
	SubmitTimeUtc string `json:"submitTimeUtc,omitempty"`
}

// Validate validates this get transaction batches forbidden body
func (o *GetTransactionBatchesForbiddenBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateErrorInformation(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetTransactionBatchesForbiddenBody) validateErrorInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ErrorInformation) { // not required
		return nil
	}

	if o.ErrorInformation != nil {
		if err := o.ErrorInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getTransactionBatchesForbidden" + "." + "errorInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getTransactionBatchesForbidden" + "." + "errorInformation")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this get transaction batches forbidden body based on the context it is used
func (o *GetTransactionBatchesForbiddenBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateErrorInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetTransactionBatchesForbiddenBody) contextValidateErrorInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ErrorInformation != nil {
		if err := o.ErrorInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getTransactionBatchesForbidden" + "." + "errorInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getTransactionBatchesForbidden" + "." + "errorInformation")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetTransactionBatchesForbiddenBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetTransactionBatchesForbiddenBody) UnmarshalBinary(b []byte) error {
	var res GetTransactionBatchesForbiddenBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetTransactionBatchesForbiddenBodyErrorInformation get transaction batches forbidden body error information
swagger:model GetTransactionBatchesForbiddenBodyErrorInformation
*/
type GetTransactionBatchesForbiddenBodyErrorInformation struct {

	// details
	Details []*GetTransactionBatchesForbiddenBodyErrorInformationDetailsItems0 `json:"details"`

	// message
	Message string `json:"message,omitempty"`

	// reason
	Reason string `json:"reason,omitempty"`
}

// Validate validates this get transaction batches forbidden body error information
func (o *GetTransactionBatchesForbiddenBodyErrorInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetTransactionBatchesForbiddenBodyErrorInformation) validateDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.Details) { // not required
		return nil
	}

	for i := 0; i < len(o.Details); i++ {
		if swag.IsZero(o.Details[i]) { // not required
			continue
		}

		if o.Details[i] != nil {
			if err := o.Details[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("getTransactionBatchesForbidden" + "." + "errorInformation" + "." + "details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("getTransactionBatchesForbidden" + "." + "errorInformation" + "." + "details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this get transaction batches forbidden body error information based on the context it is used
func (o *GetTransactionBatchesForbiddenBodyErrorInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetTransactionBatchesForbiddenBodyErrorInformation) contextValidateDetails(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.Details); i++ {

		if o.Details[i] != nil {
			if err := o.Details[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("getTransactionBatchesForbidden" + "." + "errorInformation" + "." + "details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("getTransactionBatchesForbidden" + "." + "errorInformation" + "." + "details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetTransactionBatchesForbiddenBodyErrorInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetTransactionBatchesForbiddenBodyErrorInformation) UnmarshalBinary(b []byte) error {
	var res GetTransactionBatchesForbiddenBodyErrorInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetTransactionBatchesForbiddenBodyErrorInformationDetailsItems0 get transaction batches forbidden body error information details items0
swagger:model GetTransactionBatchesForbiddenBodyErrorInformationDetailsItems0
*/
type GetTransactionBatchesForbiddenBodyErrorInformationDetailsItems0 struct {

	// This is the flattened JSON object field name/path that is either missing or invalid.
	//
	Field string `json:"field,omitempty"`

	// The detailed message related to the status and reason listed above.
	//
	Message string `json:"message,omitempty"`
}

// Validate validates this get transaction batches forbidden body error information details items0
func (o *GetTransactionBatchesForbiddenBodyErrorInformationDetailsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this get transaction batches forbidden body error information details items0 based on context it is used
func (o *GetTransactionBatchesForbiddenBodyErrorInformationDetailsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *GetTransactionBatchesForbiddenBodyErrorInformationDetailsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetTransactionBatchesForbiddenBodyErrorInformationDetailsItems0) UnmarshalBinary(b []byte) error {
	var res GetTransactionBatchesForbiddenBodyErrorInformationDetailsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetTransactionBatchesInternalServerErrorBody ptsV1TransactionBatchesGet500Response
swagger:model GetTransactionBatchesInternalServerErrorBody
*/
type GetTransactionBatchesInternalServerErrorBody struct {

	// error information
	ErrorInformation *GetTransactionBatchesInternalServerErrorBodyErrorInformation `json:"errorInformation,omitempty"`

	// Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ`
	// **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.).
	// The `T` separates the date and the time. The `Z` indicates UTC.
	//
	// Returned by Cybersource for all services.
	//
	SubmitTimeUtc string `json:"submitTimeUtc,omitempty"`
}

// Validate validates this get transaction batches internal server error body
func (o *GetTransactionBatchesInternalServerErrorBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateErrorInformation(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetTransactionBatchesInternalServerErrorBody) validateErrorInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ErrorInformation) { // not required
		return nil
	}

	if o.ErrorInformation != nil {
		if err := o.ErrorInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getTransactionBatchesInternalServerError" + "." + "errorInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getTransactionBatchesInternalServerError" + "." + "errorInformation")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this get transaction batches internal server error body based on the context it is used
func (o *GetTransactionBatchesInternalServerErrorBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateErrorInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetTransactionBatchesInternalServerErrorBody) contextValidateErrorInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ErrorInformation != nil {
		if err := o.ErrorInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getTransactionBatchesInternalServerError" + "." + "errorInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getTransactionBatchesInternalServerError" + "." + "errorInformation")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetTransactionBatchesInternalServerErrorBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetTransactionBatchesInternalServerErrorBody) UnmarshalBinary(b []byte) error {
	var res GetTransactionBatchesInternalServerErrorBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetTransactionBatchesInternalServerErrorBodyErrorInformation get transaction batches internal server error body error information
swagger:model GetTransactionBatchesInternalServerErrorBodyErrorInformation
*/
type GetTransactionBatchesInternalServerErrorBodyErrorInformation struct {

	// The detailed message related to the status and reason listed above.
	Message string `json:"message,omitempty"`

	// The reason of status
	Reason string `json:"reason,omitempty"`
}

// Validate validates this get transaction batches internal server error body error information
func (o *GetTransactionBatchesInternalServerErrorBodyErrorInformation) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this get transaction batches internal server error body error information based on context it is used
func (o *GetTransactionBatchesInternalServerErrorBodyErrorInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *GetTransactionBatchesInternalServerErrorBodyErrorInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetTransactionBatchesInternalServerErrorBodyErrorInformation) UnmarshalBinary(b []byte) error {
	var res GetTransactionBatchesInternalServerErrorBodyErrorInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetTransactionBatchesNotFoundBody ptsV1TransactionBatchesGet404Response
swagger:model GetTransactionBatchesNotFoundBody
*/
type GetTransactionBatchesNotFoundBody struct {

	// error information
	ErrorInformation *GetTransactionBatchesNotFoundBodyErrorInformation `json:"errorInformation,omitempty"`

	// Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ`
	// **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.).
	// The `T` separates the date and the time. The `Z` indicates UTC.
	//
	// Returned by Cybersource for all services.
	//
	SubmitTimeUtc string `json:"submitTimeUtc,omitempty"`
}

// Validate validates this get transaction batches not found body
func (o *GetTransactionBatchesNotFoundBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateErrorInformation(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetTransactionBatchesNotFoundBody) validateErrorInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ErrorInformation) { // not required
		return nil
	}

	if o.ErrorInformation != nil {
		if err := o.ErrorInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getTransactionBatchesNotFound" + "." + "errorInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getTransactionBatchesNotFound" + "." + "errorInformation")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this get transaction batches not found body based on the context it is used
func (o *GetTransactionBatchesNotFoundBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateErrorInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetTransactionBatchesNotFoundBody) contextValidateErrorInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ErrorInformation != nil {
		if err := o.ErrorInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getTransactionBatchesNotFound" + "." + "errorInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getTransactionBatchesNotFound" + "." + "errorInformation")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetTransactionBatchesNotFoundBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetTransactionBatchesNotFoundBody) UnmarshalBinary(b []byte) error {
	var res GetTransactionBatchesNotFoundBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetTransactionBatchesNotFoundBodyErrorInformation get transaction batches not found body error information
swagger:model GetTransactionBatchesNotFoundBodyErrorInformation
*/
type GetTransactionBatchesNotFoundBodyErrorInformation struct {

	// details
	Details []*GetTransactionBatchesNotFoundBodyErrorInformationDetailsItems0 `json:"details"`

	// message
	Message string `json:"message,omitempty"`

	// reason
	Reason string `json:"reason,omitempty"`
}

// Validate validates this get transaction batches not found body error information
func (o *GetTransactionBatchesNotFoundBodyErrorInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetTransactionBatchesNotFoundBodyErrorInformation) validateDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.Details) { // not required
		return nil
	}

	for i := 0; i < len(o.Details); i++ {
		if swag.IsZero(o.Details[i]) { // not required
			continue
		}

		if o.Details[i] != nil {
			if err := o.Details[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("getTransactionBatchesNotFound" + "." + "errorInformation" + "." + "details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("getTransactionBatchesNotFound" + "." + "errorInformation" + "." + "details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this get transaction batches not found body error information based on the context it is used
func (o *GetTransactionBatchesNotFoundBodyErrorInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetTransactionBatchesNotFoundBodyErrorInformation) contextValidateDetails(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.Details); i++ {

		if o.Details[i] != nil {
			if err := o.Details[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("getTransactionBatchesNotFound" + "." + "errorInformation" + "." + "details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("getTransactionBatchesNotFound" + "." + "errorInformation" + "." + "details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetTransactionBatchesNotFoundBodyErrorInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetTransactionBatchesNotFoundBodyErrorInformation) UnmarshalBinary(b []byte) error {
	var res GetTransactionBatchesNotFoundBodyErrorInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetTransactionBatchesNotFoundBodyErrorInformationDetailsItems0 get transaction batches not found body error information details items0
swagger:model GetTransactionBatchesNotFoundBodyErrorInformationDetailsItems0
*/
type GetTransactionBatchesNotFoundBodyErrorInformationDetailsItems0 struct {

	// This is the flattened JSON object field name/path that is either missing or invalid.
	//
	Field string `json:"field,omitempty"`

	// The detailed message related to the status and reason listed above.
	//
	Message string `json:"message,omitempty"`
}

// Validate validates this get transaction batches not found body error information details items0
func (o *GetTransactionBatchesNotFoundBodyErrorInformationDetailsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this get transaction batches not found body error information details items0 based on context it is used
func (o *GetTransactionBatchesNotFoundBodyErrorInformationDetailsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *GetTransactionBatchesNotFoundBodyErrorInformationDetailsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetTransactionBatchesNotFoundBodyErrorInformationDetailsItems0) UnmarshalBinary(b []byte) error {
	var res GetTransactionBatchesNotFoundBodyErrorInformationDetailsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetTransactionBatchesOKBody ptsV1TransactionBatchesGet200Response
swagger:model GetTransactionBatchesOKBody
*/
type GetTransactionBatchesOKBody struct {

	// links
	Links *GetTransactionBatchesOKBodyLinks `json:"_links,omitempty"`

	// Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ`
	// **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.).
	// The `T` separates the date and the time. The `Z` indicates UTC.
	//
	// Returned by Cybersource for all services.
	//
	SubmitTimeUtc string `json:"submitTimeUtc,omitempty"`

	// transaction batches
	TransactionBatches []*GetTransactionBatchesOKBodyTransactionBatchesItems0 `json:"transactionBatches"`
}

// Validate validates this get transaction batches o k body
func (o *GetTransactionBatchesOKBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTransactionBatches(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetTransactionBatchesOKBody) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(o.Links) { // not required
		return nil
	}

	if o.Links != nil {
		if err := o.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getTransactionBatchesOK" + "." + "_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getTransactionBatchesOK" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (o *GetTransactionBatchesOKBody) validateTransactionBatches(formats strfmt.Registry) error {
	if swag.IsZero(o.TransactionBatches) { // not required
		return nil
	}

	for i := 0; i < len(o.TransactionBatches); i++ {
		if swag.IsZero(o.TransactionBatches[i]) { // not required
			continue
		}

		if o.TransactionBatches[i] != nil {
			if err := o.TransactionBatches[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("getTransactionBatchesOK" + "." + "transactionBatches" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("getTransactionBatchesOK" + "." + "transactionBatches" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this get transaction batches o k body based on the context it is used
func (o *GetTransactionBatchesOKBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateTransactionBatches(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetTransactionBatchesOKBody) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if o.Links != nil {
		if err := o.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getTransactionBatchesOK" + "." + "_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getTransactionBatchesOK" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (o *GetTransactionBatchesOKBody) contextValidateTransactionBatches(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.TransactionBatches); i++ {

		if o.TransactionBatches[i] != nil {
			if err := o.TransactionBatches[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("getTransactionBatchesOK" + "." + "transactionBatches" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("getTransactionBatchesOK" + "." + "transactionBatches" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetTransactionBatchesOKBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetTransactionBatchesOKBody) UnmarshalBinary(b []byte) error {
	var res GetTransactionBatchesOKBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetTransactionBatchesOKBodyLinks get transaction batches o k body links
swagger:model GetTransactionBatchesOKBodyLinks
*/
type GetTransactionBatchesOKBodyLinks struct {

	// self
	Self *GetTransactionBatchesOKBodyLinksSelf `json:"self,omitempty"`
}

// Validate validates this get transaction batches o k body links
func (o *GetTransactionBatchesOKBodyLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetTransactionBatchesOKBodyLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(o.Self) { // not required
		return nil
	}

	if o.Self != nil {
		if err := o.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getTransactionBatchesOK" + "." + "_links" + "." + "self")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getTransactionBatchesOK" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this get transaction batches o k body links based on the context it is used
func (o *GetTransactionBatchesOKBodyLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetTransactionBatchesOKBodyLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if o.Self != nil {
		if err := o.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getTransactionBatchesOK" + "." + "_links" + "." + "self")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getTransactionBatchesOK" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetTransactionBatchesOKBodyLinks) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetTransactionBatchesOKBodyLinks) UnmarshalBinary(b []byte) error {
	var res GetTransactionBatchesOKBodyLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetTransactionBatchesOKBodyLinksSelf get transaction batches o k body links self
swagger:model GetTransactionBatchesOKBodyLinksSelf
*/
type GetTransactionBatchesOKBodyLinksSelf struct {

	// href
	// Example: /pts/v1/transaction-batches
	Href string `json:"href,omitempty"`

	// method
	// Example: GET
	Method string `json:"method,omitempty"`
}

// Validate validates this get transaction batches o k body links self
func (o *GetTransactionBatchesOKBodyLinksSelf) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this get transaction batches o k body links self based on context it is used
func (o *GetTransactionBatchesOKBodyLinksSelf) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *GetTransactionBatchesOKBodyLinksSelf) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetTransactionBatchesOKBodyLinksSelf) UnmarshalBinary(b []byte) error {
	var res GetTransactionBatchesOKBodyLinksSelf
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetTransactionBatchesOKBodyTransactionBatchesItems0 get transaction batches o k body transaction batches items0
swagger:model GetTransactionBatchesOKBodyTransactionBatchesItems0
*/
type GetTransactionBatchesOKBodyTransactionBatchesItems0 struct {

	// Number of transactions accepted.
	// Example: 50013
	AcceptedTransactionCount int64 `json:"acceptedTransactionCount,omitempty"`

	// The date when the batch template processing completed.
	// Example: 2018-01-01
	CompletionDate string `json:"completionDate,omitempty"`

	// Unique identifier assigned to the batch file.
	// Example: psy8s1d
	// Max Length: 8
	// Min Length: 1
	// Pattern: ^[a-zA-Z0-9_+-]*$
	ID string `json:"id,omitempty"`

	// Number of transactions rejected.
	// Example: 2508
	RejectedTransactionCount string `json:"rejectedTransactionCount,omitempty"`

	// The status of you batch template processing.
	// Example: Completed
	Status string `json:"status,omitempty"`

	// Number of transactions in the transaction.
	// Example: 7534
	TransactionCount int64 `json:"transactionCount,omitempty"`

	// Date when the batch template was update.
	// Example: 2018-01-01
	UploadDate string `json:"uploadDate,omitempty"`
}

// Validate validates this get transaction batches o k body transaction batches items0
func (o *GetTransactionBatchesOKBodyTransactionBatchesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetTransactionBatchesOKBodyTransactionBatchesItems0) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MinLength("id", "body", o.ID, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("id", "body", o.ID, 8); err != nil {
		return err
	}

	if err := validate.Pattern("id", "body", o.ID, `^[a-zA-Z0-9_+-]*$`); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this get transaction batches o k body transaction batches items0 based on context it is used
func (o *GetTransactionBatchesOKBodyTransactionBatchesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *GetTransactionBatchesOKBodyTransactionBatchesItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetTransactionBatchesOKBodyTransactionBatchesItems0) UnmarshalBinary(b []byte) error {
	var res GetTransactionBatchesOKBodyTransactionBatchesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetTransactionBatchesUnauthorizedBody ptsV1TransactionBatchesGet401Response
swagger:model GetTransactionBatchesUnauthorizedBody
*/
type GetTransactionBatchesUnauthorizedBody struct {

	// error information
	ErrorInformation *GetTransactionBatchesUnauthorizedBodyErrorInformation `json:"errorInformation,omitempty"`

	// Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ`
	// **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.).
	// The `T` separates the date and the time. The `Z` indicates UTC.
	//
	// Returned by Cybersource for all services.
	//
	SubmitTimeUtc string `json:"submitTimeUtc,omitempty"`
}

// Validate validates this get transaction batches unauthorized body
func (o *GetTransactionBatchesUnauthorizedBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateErrorInformation(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetTransactionBatchesUnauthorizedBody) validateErrorInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ErrorInformation) { // not required
		return nil
	}

	if o.ErrorInformation != nil {
		if err := o.ErrorInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getTransactionBatchesUnauthorized" + "." + "errorInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getTransactionBatchesUnauthorized" + "." + "errorInformation")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this get transaction batches unauthorized body based on the context it is used
func (o *GetTransactionBatchesUnauthorizedBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateErrorInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetTransactionBatchesUnauthorizedBody) contextValidateErrorInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ErrorInformation != nil {
		if err := o.ErrorInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("getTransactionBatchesUnauthorized" + "." + "errorInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("getTransactionBatchesUnauthorized" + "." + "errorInformation")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetTransactionBatchesUnauthorizedBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetTransactionBatchesUnauthorizedBody) UnmarshalBinary(b []byte) error {
	var res GetTransactionBatchesUnauthorizedBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetTransactionBatchesUnauthorizedBodyErrorInformation get transaction batches unauthorized body error information
swagger:model GetTransactionBatchesUnauthorizedBodyErrorInformation
*/
type GetTransactionBatchesUnauthorizedBodyErrorInformation struct {

	// details
	Details []*GetTransactionBatchesUnauthorizedBodyErrorInformationDetailsItems0 `json:"details"`

	// message
	Message string `json:"message,omitempty"`

	// reason
	Reason string `json:"reason,omitempty"`
}

// Validate validates this get transaction batches unauthorized body error information
func (o *GetTransactionBatchesUnauthorizedBodyErrorInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetTransactionBatchesUnauthorizedBodyErrorInformation) validateDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.Details) { // not required
		return nil
	}

	for i := 0; i < len(o.Details); i++ {
		if swag.IsZero(o.Details[i]) { // not required
			continue
		}

		if o.Details[i] != nil {
			if err := o.Details[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("getTransactionBatchesUnauthorized" + "." + "errorInformation" + "." + "details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("getTransactionBatchesUnauthorized" + "." + "errorInformation" + "." + "details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this get transaction batches unauthorized body error information based on the context it is used
func (o *GetTransactionBatchesUnauthorizedBodyErrorInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetTransactionBatchesUnauthorizedBodyErrorInformation) contextValidateDetails(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.Details); i++ {

		if o.Details[i] != nil {
			if err := o.Details[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("getTransactionBatchesUnauthorized" + "." + "errorInformation" + "." + "details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("getTransactionBatchesUnauthorized" + "." + "errorInformation" + "." + "details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *GetTransactionBatchesUnauthorizedBodyErrorInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetTransactionBatchesUnauthorizedBodyErrorInformation) UnmarshalBinary(b []byte) error {
	var res GetTransactionBatchesUnauthorizedBodyErrorInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*GetTransactionBatchesUnauthorizedBodyErrorInformationDetailsItems0 get transaction batches unauthorized body error information details items0
swagger:model GetTransactionBatchesUnauthorizedBodyErrorInformationDetailsItems0
*/
type GetTransactionBatchesUnauthorizedBodyErrorInformationDetailsItems0 struct {

	// This is the flattened JSON object field name/path that is either missing or invalid.
	//
	Field string `json:"field,omitempty"`

	// The detailed message related to the status and reason listed above.
	//
	Message string `json:"message,omitempty"`
}

// Validate validates this get transaction batches unauthorized body error information details items0
func (o *GetTransactionBatchesUnauthorizedBodyErrorInformationDetailsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this get transaction batches unauthorized body error information details items0 based on context it is used
func (o *GetTransactionBatchesUnauthorizedBodyErrorInformationDetailsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *GetTransactionBatchesUnauthorizedBodyErrorInformationDetailsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *GetTransactionBatchesUnauthorizedBodyErrorInformationDetailsItems0) UnmarshalBinary(b []byte) error {
	var res GetTransactionBatchesUnauthorizedBodyErrorInformationDetailsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}
