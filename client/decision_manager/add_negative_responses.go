// Code generated by go-swagger; DO NOT EDIT.

package decision_manager

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"fmt"
	"io"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// AddNegativeReader is a Reader for the AddNegative structure.
type AddNegativeReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *AddNegativeReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 201:
		result := NewAddNegativeCreated()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	case 400:
		result := NewAddNegativeBadRequest()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	default:
		return nil, runtime.NewAPIError("response status code does not match any response statuses defined for this endpoint in the swagger spec", response, response.Code())
	}
}

// NewAddNegativeCreated creates a AddNegativeCreated with default headers values
func NewAddNegativeCreated() *AddNegativeCreated {
	return &AddNegativeCreated{}
}

/* AddNegativeCreated describes a response with status code 201, with default header values.

Successful response
*/
type AddNegativeCreated struct {
	Payload *AddNegativeCreatedBody
}

func (o *AddNegativeCreated) Error() string {
	return fmt.Sprintf("[POST /risk/v1/lists/{type}/entries][%d] addNegativeCreated  %+v", 201, o.Payload)
}
func (o *AddNegativeCreated) GetPayload() *AddNegativeCreatedBody {
	return o.Payload
}

func (o *AddNegativeCreated) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(AddNegativeCreatedBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewAddNegativeBadRequest creates a AddNegativeBadRequest with default headers values
func NewAddNegativeBadRequest() *AddNegativeBadRequest {
	return &AddNegativeBadRequest{}
}

/* AddNegativeBadRequest describes a response with status code 400, with default header values.

Invalid request
*/
type AddNegativeBadRequest struct {
	Payload *AddNegativeBadRequestBody
}

func (o *AddNegativeBadRequest) Error() string {
	return fmt.Sprintf("[POST /risk/v1/lists/{type}/entries][%d] addNegativeBadRequest  %+v", 400, o.Payload)
}
func (o *AddNegativeBadRequest) GetPayload() *AddNegativeBadRequestBody {
	return o.Payload
}

func (o *AddNegativeBadRequest) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(AddNegativeBadRequestBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

/*AddNegativeBadRequestBody riskV1DecisionsPost400Response
swagger:model AddNegativeBadRequestBody
*/
type AddNegativeBadRequestBody struct {

	// details
	Details []*AddNegativeBadRequestBodyDetailsItems0 `json:"details"`

	// The detail message related to the status and reason listed above.
	Message string `json:"message,omitempty"`

	// The reason of the status.
	//
	// Possible Values:
	// - `MISSING_FIELD`
	// - `INVALID_DATA`
	//
	Reason string `json:"reason,omitempty"`

	// The status of the submitted transaction.
	//
	// Possible values:
	//  - INVALID_REQUEST
	//
	Status string `json:"status,omitempty"`

	// Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ`
	// **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.).
	// The `T` separates the date and the time. The `Z` indicates UTC.
	//
	// Returned by Cybersource for all services.
	//
	SubmitTimeUtc string `json:"submitTimeUtc,omitempty"`
}

// Validate validates this add negative bad request body
func (o *AddNegativeBadRequestBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *AddNegativeBadRequestBody) validateDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.Details) { // not required
		return nil
	}

	for i := 0; i < len(o.Details); i++ {
		if swag.IsZero(o.Details[i]) { // not required
			continue
		}

		if o.Details[i] != nil {
			if err := o.Details[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("addNegativeBadRequest" + "." + "details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("addNegativeBadRequest" + "." + "details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this add negative bad request body based on the context it is used
func (o *AddNegativeBadRequestBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *AddNegativeBadRequestBody) contextValidateDetails(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.Details); i++ {

		if o.Details[i] != nil {
			if err := o.Details[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("addNegativeBadRequest" + "." + "details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("addNegativeBadRequest" + "." + "details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *AddNegativeBadRequestBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *AddNegativeBadRequestBody) UnmarshalBinary(b []byte) error {
	var res AddNegativeBadRequestBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*AddNegativeBadRequestBodyDetailsItems0 add negative bad request body details items0
swagger:model AddNegativeBadRequestBodyDetailsItems0
*/
type AddNegativeBadRequestBodyDetailsItems0 struct {

	// This is the flattened JSON object field name/path that is either missing or invalid.
	Field string `json:"field,omitempty"`

	// Possible reasons for the error.
	//
	// Possible values:
	//  - MISSING_FIELD
	//  - INVALID_DATA
	//
	Reason string `json:"reason,omitempty"`
}

// Validate validates this add negative bad request body details items0
func (o *AddNegativeBadRequestBodyDetailsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this add negative bad request body details items0 based on context it is used
func (o *AddNegativeBadRequestBodyDetailsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *AddNegativeBadRequestBodyDetailsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *AddNegativeBadRequestBodyDetailsItems0) UnmarshalBinary(b []byte) error {
	var res AddNegativeBadRequestBodyDetailsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*AddNegativeBody add negative body
swagger:model AddNegativeBody
*/
type AddNegativeBody struct {

	// buyer information
	BuyerInformation *AddNegativeParamsBodyBuyerInformation `json:"buyerInformation,omitempty"`

	// client reference information
	ClientReferenceInformation *AddNegativeParamsBodyClientReferenceInformation `json:"clientReferenceInformation,omitempty"`

	// device information
	DeviceInformation *AddNegativeParamsBodyDeviceInformation `json:"deviceInformation,omitempty"`

	// order information
	OrderInformation *AddNegativeParamsBodyOrderInformation `json:"orderInformation,omitempty"`

	// payment information
	PaymentInformation *AddNegativeParamsBodyPaymentInformation `json:"paymentInformation,omitempty"`

	// risk information
	RiskInformation *AddNegativeParamsBodyRiskInformation `json:"riskInformation,omitempty"`
}

// Validate validates this add negative body
func (o *AddNegativeBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateBuyerInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateClientReferenceInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDeviceInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOrderInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePaymentInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRiskInformation(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *AddNegativeBody) validateBuyerInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.BuyerInformation) { // not required
		return nil
	}

	if o.BuyerInformation != nil {
		if err := o.BuyerInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("addNegativeListRequest" + "." + "buyerInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("addNegativeListRequest" + "." + "buyerInformation")
			}
			return err
		}
	}

	return nil
}

func (o *AddNegativeBody) validateClientReferenceInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ClientReferenceInformation) { // not required
		return nil
	}

	if o.ClientReferenceInformation != nil {
		if err := o.ClientReferenceInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("addNegativeListRequest" + "." + "clientReferenceInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("addNegativeListRequest" + "." + "clientReferenceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *AddNegativeBody) validateDeviceInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.DeviceInformation) { // not required
		return nil
	}

	if o.DeviceInformation != nil {
		if err := o.DeviceInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("addNegativeListRequest" + "." + "deviceInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("addNegativeListRequest" + "." + "deviceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *AddNegativeBody) validateOrderInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.OrderInformation) { // not required
		return nil
	}

	if o.OrderInformation != nil {
		if err := o.OrderInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("addNegativeListRequest" + "." + "orderInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("addNegativeListRequest" + "." + "orderInformation")
			}
			return err
		}
	}

	return nil
}

func (o *AddNegativeBody) validatePaymentInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.PaymentInformation) { // not required
		return nil
	}

	if o.PaymentInformation != nil {
		if err := o.PaymentInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("addNegativeListRequest" + "." + "paymentInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("addNegativeListRequest" + "." + "paymentInformation")
			}
			return err
		}
	}

	return nil
}

func (o *AddNegativeBody) validateRiskInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.RiskInformation) { // not required
		return nil
	}

	if o.RiskInformation != nil {
		if err := o.RiskInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("addNegativeListRequest" + "." + "riskInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("addNegativeListRequest" + "." + "riskInformation")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this add negative body based on the context it is used
func (o *AddNegativeBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateBuyerInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateClientReferenceInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateDeviceInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateOrderInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidatePaymentInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateRiskInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *AddNegativeBody) contextValidateBuyerInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.BuyerInformation != nil {
		if err := o.BuyerInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("addNegativeListRequest" + "." + "buyerInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("addNegativeListRequest" + "." + "buyerInformation")
			}
			return err
		}
	}

	return nil
}

func (o *AddNegativeBody) contextValidateClientReferenceInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ClientReferenceInformation != nil {
		if err := o.ClientReferenceInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("addNegativeListRequest" + "." + "clientReferenceInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("addNegativeListRequest" + "." + "clientReferenceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *AddNegativeBody) contextValidateDeviceInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.DeviceInformation != nil {
		if err := o.DeviceInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("addNegativeListRequest" + "." + "deviceInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("addNegativeListRequest" + "." + "deviceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *AddNegativeBody) contextValidateOrderInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.OrderInformation != nil {
		if err := o.OrderInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("addNegativeListRequest" + "." + "orderInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("addNegativeListRequest" + "." + "orderInformation")
			}
			return err
		}
	}

	return nil
}

func (o *AddNegativeBody) contextValidatePaymentInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.PaymentInformation != nil {
		if err := o.PaymentInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("addNegativeListRequest" + "." + "paymentInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("addNegativeListRequest" + "." + "paymentInformation")
			}
			return err
		}
	}

	return nil
}

func (o *AddNegativeBody) contextValidateRiskInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.RiskInformation != nil {
		if err := o.RiskInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("addNegativeListRequest" + "." + "riskInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("addNegativeListRequest" + "." + "riskInformation")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *AddNegativeBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *AddNegativeBody) UnmarshalBinary(b []byte) error {
	var res AddNegativeBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*AddNegativeCreatedBody riskV1UpdatePost201Response
swagger:model AddNegativeCreatedBody
*/
type AddNegativeCreatedBody struct {

	// links
	Links *AddNegativeCreatedBodyLinks `json:"_links,omitempty"`

	// client reference informaton
	ClientReferenceInformaton *AddNegativeCreatedBodyClientReferenceInformaton `json:"clientReferenceInformaton,omitempty"`

	// An unique identification number generated by Cybersource to identify the submitted request. Returned by all services.
	// It is also appended to the endpoint of the resource.
	// On incremental authorizations, this value with be the same as the identification number returned in the original authorization response.
	//
	// Max Length: 26
	ID string `json:"id,omitempty"`

	// The status for risk update 201 calls. Possible values are:
	// - INVALID_REQUEST
	// - COMPLETED
	//
	Status string `json:"status,omitempty"`

	// Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ`
	// **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.).
	// The `T` separates the date and the time. The `Z` indicates UTC.
	//
	// Returned by Cybersource for all services.
	//
	SubmitTimeUtc string `json:"submitTimeUtc,omitempty"`
}

// Validate validates this add negative created body
func (o *AddNegativeCreatedBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateClientReferenceInformaton(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *AddNegativeCreatedBody) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(o.Links) { // not required
		return nil
	}

	if o.Links != nil {
		if err := o.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("addNegativeCreated" + "." + "_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("addNegativeCreated" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (o *AddNegativeCreatedBody) validateClientReferenceInformaton(formats strfmt.Registry) error {
	if swag.IsZero(o.ClientReferenceInformaton) { // not required
		return nil
	}

	if o.ClientReferenceInformaton != nil {
		if err := o.ClientReferenceInformaton.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("addNegativeCreated" + "." + "clientReferenceInformaton")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("addNegativeCreated" + "." + "clientReferenceInformaton")
			}
			return err
		}
	}

	return nil
}

func (o *AddNegativeCreatedBody) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MaxLength("addNegativeCreated"+"."+"id", "body", o.ID, 26); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this add negative created body based on the context it is used
func (o *AddNegativeCreatedBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateClientReferenceInformaton(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *AddNegativeCreatedBody) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if o.Links != nil {
		if err := o.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("addNegativeCreated" + "." + "_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("addNegativeCreated" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (o *AddNegativeCreatedBody) contextValidateClientReferenceInformaton(ctx context.Context, formats strfmt.Registry) error {

	if o.ClientReferenceInformaton != nil {
		if err := o.ClientReferenceInformaton.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("addNegativeCreated" + "." + "clientReferenceInformaton")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("addNegativeCreated" + "." + "clientReferenceInformaton")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *AddNegativeCreatedBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *AddNegativeCreatedBody) UnmarshalBinary(b []byte) error {
	var res AddNegativeCreatedBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*AddNegativeCreatedBodyClientReferenceInformaton add negative created body client reference informaton
swagger:model AddNegativeCreatedBodyClientReferenceInformaton
*/
type AddNegativeCreatedBodyClientReferenceInformaton struct {

	// Merchant-generated order reference or tracking number. It is recommended that you send a unique value for each
	// transaction so that you can perform meaningful searches for the transaction.
	//
	// #### Used by
	// **Authorization**
	// Required field.
	//
	// #### PIN Debit
	// Requests for PIN debit reversals need to use the same merchant reference number that was used in the transaction that is being
	// reversed.
	//
	// Required field for all PIN Debit requests (purchase, credit, and reversal).
	//
	// #### FDC Nashville Global
	// Certain circumstances can cause the processor to truncate this value to 15 or 17 characters for Level II and Level III processing, which can cause a discrepancy between the value you submit and the value included in some processor reports.
	//
	// Max Length: 50
	Code string `json:"code,omitempty"`

	// Brief description of the order or any comment you wish to add to the order.
	//
	// Max Length: 255
	Comments string `json:"comments,omitempty"`

	// partner
	Partner *AddNegativeCreatedBodyClientReferenceInformatonPartner `json:"partner,omitempty"`
}

// Validate validates this add negative created body client reference informaton
func (o *AddNegativeCreatedBodyClientReferenceInformaton) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateComments(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePartner(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *AddNegativeCreatedBodyClientReferenceInformaton) validateCode(formats strfmt.Registry) error {
	if swag.IsZero(o.Code) { // not required
		return nil
	}

	if err := validate.MaxLength("addNegativeCreated"+"."+"clientReferenceInformaton"+"."+"code", "body", o.Code, 50); err != nil {
		return err
	}

	return nil
}

func (o *AddNegativeCreatedBodyClientReferenceInformaton) validateComments(formats strfmt.Registry) error {
	if swag.IsZero(o.Comments) { // not required
		return nil
	}

	if err := validate.MaxLength("addNegativeCreated"+"."+"clientReferenceInformaton"+"."+"comments", "body", o.Comments, 255); err != nil {
		return err
	}

	return nil
}

func (o *AddNegativeCreatedBodyClientReferenceInformaton) validatePartner(formats strfmt.Registry) error {
	if swag.IsZero(o.Partner) { // not required
		return nil
	}

	if o.Partner != nil {
		if err := o.Partner.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("addNegativeCreated" + "." + "clientReferenceInformaton" + "." + "partner")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("addNegativeCreated" + "." + "clientReferenceInformaton" + "." + "partner")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this add negative created body client reference informaton based on the context it is used
func (o *AddNegativeCreatedBodyClientReferenceInformaton) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidatePartner(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *AddNegativeCreatedBodyClientReferenceInformaton) contextValidatePartner(ctx context.Context, formats strfmt.Registry) error {

	if o.Partner != nil {
		if err := o.Partner.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("addNegativeCreated" + "." + "clientReferenceInformaton" + "." + "partner")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("addNegativeCreated" + "." + "clientReferenceInformaton" + "." + "partner")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *AddNegativeCreatedBodyClientReferenceInformaton) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *AddNegativeCreatedBodyClientReferenceInformaton) UnmarshalBinary(b []byte) error {
	var res AddNegativeCreatedBodyClientReferenceInformaton
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*AddNegativeCreatedBodyClientReferenceInformatonPartner add negative created body client reference informaton partner
swagger:model AddNegativeCreatedBodyClientReferenceInformatonPartner
*/
type AddNegativeCreatedBodyClientReferenceInformatonPartner struct {

	// Identifier for the developer that helped integrate a partner solution to CyberSource.
	//
	// Send this value in all requests that are sent through the partner solutions built by that developer.
	// CyberSource assigns the ID to the developer.
	//
	// **Note** When you see a developer ID of 999 in reports, the developer ID that was submitted is incorrect.
	//
	// Max Length: 8
	DeveloperID string `json:"developerId,omitempty"`

	// Identifier for the partner that is integrated to CyberSource.
	//
	// Send this value in all requests that are sent through the partner solution. CyberSource assigns the ID to the partner.
	//
	// **Note** When you see a solutionId of 999 in reports, the solutionId that was submitted is incorrect.
	//
	// Max Length: 8
	SolutionID string `json:"solutionId,omitempty"`
}

// Validate validates this add negative created body client reference informaton partner
func (o *AddNegativeCreatedBodyClientReferenceInformatonPartner) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDeveloperID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSolutionID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *AddNegativeCreatedBodyClientReferenceInformatonPartner) validateDeveloperID(formats strfmt.Registry) error {
	if swag.IsZero(o.DeveloperID) { // not required
		return nil
	}

	if err := validate.MaxLength("addNegativeCreated"+"."+"clientReferenceInformaton"+"."+"partner"+"."+"developerId", "body", o.DeveloperID, 8); err != nil {
		return err
	}

	return nil
}

func (o *AddNegativeCreatedBodyClientReferenceInformatonPartner) validateSolutionID(formats strfmt.Registry) error {
	if swag.IsZero(o.SolutionID) { // not required
		return nil
	}

	if err := validate.MaxLength("addNegativeCreated"+"."+"clientReferenceInformaton"+"."+"partner"+"."+"solutionId", "body", o.SolutionID, 8); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this add negative created body client reference informaton partner based on context it is used
func (o *AddNegativeCreatedBodyClientReferenceInformatonPartner) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *AddNegativeCreatedBodyClientReferenceInformatonPartner) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *AddNegativeCreatedBodyClientReferenceInformatonPartner) UnmarshalBinary(b []byte) error {
	var res AddNegativeCreatedBodyClientReferenceInformatonPartner
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*AddNegativeCreatedBodyLinks add negative created body links
swagger:model AddNegativeCreatedBodyLinks
*/
type AddNegativeCreatedBodyLinks struct {

	// self
	Self *AddNegativeCreatedBodyLinksSelf `json:"self,omitempty"`
}

// Validate validates this add negative created body links
func (o *AddNegativeCreatedBodyLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *AddNegativeCreatedBodyLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(o.Self) { // not required
		return nil
	}

	if o.Self != nil {
		if err := o.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("addNegativeCreated" + "." + "_links" + "." + "self")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("addNegativeCreated" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this add negative created body links based on the context it is used
func (o *AddNegativeCreatedBodyLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *AddNegativeCreatedBodyLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if o.Self != nil {
		if err := o.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("addNegativeCreated" + "." + "_links" + "." + "self")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("addNegativeCreated" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *AddNegativeCreatedBodyLinks) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *AddNegativeCreatedBodyLinks) UnmarshalBinary(b []byte) error {
	var res AddNegativeCreatedBodyLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*AddNegativeCreatedBodyLinksSelf add negative created body links self
swagger:model AddNegativeCreatedBodyLinksSelf
*/
type AddNegativeCreatedBodyLinksSelf struct {

	// This is the endpoint of the resource that was created by the successful request.
	Href string `json:"href,omitempty"`

	// `method` refers to the HTTP method that you can send to the `self` endpoint to retrieve details of the resource.
	Method string `json:"method,omitempty"`
}

// Validate validates this add negative created body links self
func (o *AddNegativeCreatedBodyLinksSelf) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this add negative created body links self based on context it is used
func (o *AddNegativeCreatedBodyLinksSelf) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *AddNegativeCreatedBodyLinksSelf) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *AddNegativeCreatedBodyLinksSelf) UnmarshalBinary(b []byte) error {
	var res AddNegativeCreatedBodyLinksSelf
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*AddNegativeParamsBodyBuyerInformation Contains information about the buyer.
swagger:model AddNegativeParamsBodyBuyerInformation
*/
type AddNegativeParamsBodyBuyerInformation struct {

	// personal identification
	PersonalIdentification []*AddNegativeParamsBodyBuyerInformationPersonalIdentificationItems0 `json:"personalIdentification"`
}

// Validate validates this add negative params body buyer information
func (o *AddNegativeParamsBodyBuyerInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validatePersonalIdentification(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *AddNegativeParamsBodyBuyerInformation) validatePersonalIdentification(formats strfmt.Registry) error {
	if swag.IsZero(o.PersonalIdentification) { // not required
		return nil
	}

	for i := 0; i < len(o.PersonalIdentification); i++ {
		if swag.IsZero(o.PersonalIdentification[i]) { // not required
			continue
		}

		if o.PersonalIdentification[i] != nil {
			if err := o.PersonalIdentification[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("addNegativeListRequest" + "." + "buyerInformation" + "." + "personalIdentification" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("addNegativeListRequest" + "." + "buyerInformation" + "." + "personalIdentification" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this add negative params body buyer information based on the context it is used
func (o *AddNegativeParamsBodyBuyerInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidatePersonalIdentification(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *AddNegativeParamsBodyBuyerInformation) contextValidatePersonalIdentification(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.PersonalIdentification); i++ {

		if o.PersonalIdentification[i] != nil {
			if err := o.PersonalIdentification[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("addNegativeListRequest" + "." + "buyerInformation" + "." + "personalIdentification" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("addNegativeListRequest" + "." + "buyerInformation" + "." + "personalIdentification" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *AddNegativeParamsBodyBuyerInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *AddNegativeParamsBodyBuyerInformation) UnmarshalBinary(b []byte) error {
	var res AddNegativeParamsBodyBuyerInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*AddNegativeParamsBodyBuyerInformationPersonalIdentificationItems0 add negative params body buyer information personal identification items0
swagger:model AddNegativeParamsBodyBuyerInformationPersonalIdentificationItems0
*/
type AddNegativeParamsBodyBuyerInformationPersonalIdentificationItems0 struct {

	// The value of the identification type. This field is supported only on the following processors.
	//
	// #### ComercioLatino
	// Set this field to the Cadastro de Pessoas Fisicas (CPF).
	//
	// #### CyberSource Latin American Processing
	// Supported for Redecard in Brazil. Set this field to the Cadastro de Pessoas Fisicas (CPF), which is required for AVS for Redecard in Brazil.
	// **Note** CyberSource Latin American Processing is the name of a specific processing connection that CyberSource supports. In the CyberSource API documentation, CyberSource Latin American Processing does not refer to the general topic of processing in Latin America. The information in this field description is for the specific processing connection called CyberSource Latin American Processing. It is not for any other Latin American processors that CyberSource supports.
	//
	// For processor-specific information, see the `personal_id` field in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// If `type = PASSPORT`, this is the cardholder's passport number.
	// Recommended for Discover ProtectBuy.
	//
	// Max Length: 26
	ID string `json:"id,omitempty"`

	// The government agency that issued the driver's license or passport.
	//
	// If **type**` = DRIVER_LICENSE`, this is the State or province where the customer’s driver’s license was issued.
	//
	// If **type**` = PASSPORT`, this is the Issuing country for the cardholder’s passport. Recommended for Discover ProtectBuy.
	//
	// Use the two-character [State, Province, and Territory Codes for the United States and Canada](https://developer.cybersource.com/library/documentation/sbc/quickref/states_and_provinces.pdf).
	//
	// #### TeleCheck
	// Contact your TeleCheck representative to find out whether this field is required or optional.
	//
	// #### All Other Processors
	// Not used.
	//
	// For details about the country that issued the passport, see `customer_passport_country` field description in [CyberSource Payer Authentication Using the SCMP API]
	// (https://apps.cybersource.com/library/documentation/dev_guides/Payer_Authentication_SCMP_API/html/)
	//
	// For details about the state or province that issued the passport, see `driver_license_state` field description in [Electronic Check Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/EChecks_SCMP_API/html/)
	//
	IssuedBy string `json:"issuedBy,omitempty"`

	// The type of the identification.
	//
	// Possible values:
	//   - `NATIONAL`
	//   - `CPF`
	//   - `CPNJ`
	//   - `CURP`
	//   - `SSN`
	//   - `DRIVER_LICENSE`
	//   - `PASSPORT_NUMBER`
	//   - `PERSONAL_ID`
	//   - `TAX_ID`
	//
	// This field is supported only on the following processors.
	//
	// #### ComercioLatino
	// Set this field to the Cadastro de Pessoas Fisicas (CPF).
	//
	// #### CyberSource Latin American Processing
	// Supported for Redecard in Brazil. Set this field to the Cadastro de Pessoas Fisicas (CPF), which is required for AVS for Redecard in Brazil.
	// **Note** CyberSource Latin American Processing is the name of a specific processing connection that CyberSource supports. In the CyberSource API documentation, CyberSource Latin American Processing does not refer to the general topic of processing in Latin America. The information in this field description is for the specific processing connection called CyberSource Latin American Processing. It is not for any other Latin American processors that CyberSource supports.
	//
	// For processor-specific information, see the `personal_id` field in [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	Type string `json:"type,omitempty"`

	// Verification results received from Issuer or Card Network for verification transactions. Response Only Field.
	//
	VerificationResults string `json:"verificationResults,omitempty"`
}

// Validate validates this add negative params body buyer information personal identification items0
func (o *AddNegativeParamsBodyBuyerInformationPersonalIdentificationItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *AddNegativeParamsBodyBuyerInformationPersonalIdentificationItems0) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MaxLength("id", "body", o.ID, 26); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this add negative params body buyer information personal identification items0 based on context it is used
func (o *AddNegativeParamsBodyBuyerInformationPersonalIdentificationItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *AddNegativeParamsBodyBuyerInformationPersonalIdentificationItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *AddNegativeParamsBodyBuyerInformationPersonalIdentificationItems0) UnmarshalBinary(b []byte) error {
	var res AddNegativeParamsBodyBuyerInformationPersonalIdentificationItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*AddNegativeParamsBodyClientReferenceInformation add negative params body client reference information
swagger:model AddNegativeParamsBodyClientReferenceInformation
*/
type AddNegativeParamsBodyClientReferenceInformation struct {

	// Merchant-generated order reference or tracking number. It is recommended that you send a unique value for each
	// transaction so that you can perform meaningful searches for the transaction.
	//
	// #### Used by
	// **Authorization**
	// Required field.
	//
	// #### PIN Debit
	// Requests for PIN debit reversals need to use the same merchant reference number that was used in the transaction that is being
	// reversed.
	//
	// Required field for all PIN Debit requests (purchase, credit, and reversal).
	//
	// #### FDC Nashville Global
	// Certain circumstances can cause the processor to truncate this value to 15 or 17 characters for Level II and Level III processing, which can cause a discrepancy between the value you submit and the value included in some processor reports.
	//
	// Required: true
	// Max Length: 50
	Code *string `json:"code"`

	// Brief description of the order or any comment you wish to add to the order.
	//
	// Max Length: 255
	Comments string `json:"comments,omitempty"`

	// partner
	Partner *AddNegativeParamsBodyClientReferenceInformationPartner `json:"partner,omitempty"`
}

// Validate validates this add negative params body client reference information
func (o *AddNegativeParamsBodyClientReferenceInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateComments(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePartner(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *AddNegativeParamsBodyClientReferenceInformation) validateCode(formats strfmt.Registry) error {

	if err := validate.Required("addNegativeListRequest"+"."+"clientReferenceInformation"+"."+"code", "body", o.Code); err != nil {
		return err
	}

	if err := validate.MaxLength("addNegativeListRequest"+"."+"clientReferenceInformation"+"."+"code", "body", *o.Code, 50); err != nil {
		return err
	}

	return nil
}

func (o *AddNegativeParamsBodyClientReferenceInformation) validateComments(formats strfmt.Registry) error {
	if swag.IsZero(o.Comments) { // not required
		return nil
	}

	if err := validate.MaxLength("addNegativeListRequest"+"."+"clientReferenceInformation"+"."+"comments", "body", o.Comments, 255); err != nil {
		return err
	}

	return nil
}

func (o *AddNegativeParamsBodyClientReferenceInformation) validatePartner(formats strfmt.Registry) error {
	if swag.IsZero(o.Partner) { // not required
		return nil
	}

	if o.Partner != nil {
		if err := o.Partner.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("addNegativeListRequest" + "." + "clientReferenceInformation" + "." + "partner")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("addNegativeListRequest" + "." + "clientReferenceInformation" + "." + "partner")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this add negative params body client reference information based on the context it is used
func (o *AddNegativeParamsBodyClientReferenceInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidatePartner(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *AddNegativeParamsBodyClientReferenceInformation) contextValidatePartner(ctx context.Context, formats strfmt.Registry) error {

	if o.Partner != nil {
		if err := o.Partner.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("addNegativeListRequest" + "." + "clientReferenceInformation" + "." + "partner")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("addNegativeListRequest" + "." + "clientReferenceInformation" + "." + "partner")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *AddNegativeParamsBodyClientReferenceInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *AddNegativeParamsBodyClientReferenceInformation) UnmarshalBinary(b []byte) error {
	var res AddNegativeParamsBodyClientReferenceInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*AddNegativeParamsBodyClientReferenceInformationPartner add negative params body client reference information partner
swagger:model AddNegativeParamsBodyClientReferenceInformationPartner
*/
type AddNegativeParamsBodyClientReferenceInformationPartner struct {

	// Identifier for the developer that helped integrate a partner solution to CyberSource.
	//
	// Send this value in all requests that are sent through the partner solutions built by that developer.
	// CyberSource assigns the ID to the developer.
	//
	// **Note** When you see a developer ID of 999 in reports, the developer ID that was submitted is incorrect.
	//
	// Max Length: 8
	DeveloperID string `json:"developerId,omitempty"`

	// Identifier for the partner that is integrated to CyberSource.
	//
	// Send this value in all requests that are sent through the partner solution. CyberSource assigns the ID to the partner.
	//
	// **Note** When you see a solutionId of 999 in reports, the solutionId that was submitted is incorrect.
	//
	// Max Length: 8
	SolutionID string `json:"solutionId,omitempty"`
}

// Validate validates this add negative params body client reference information partner
func (o *AddNegativeParamsBodyClientReferenceInformationPartner) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDeveloperID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSolutionID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *AddNegativeParamsBodyClientReferenceInformationPartner) validateDeveloperID(formats strfmt.Registry) error {
	if swag.IsZero(o.DeveloperID) { // not required
		return nil
	}

	if err := validate.MaxLength("addNegativeListRequest"+"."+"clientReferenceInformation"+"."+"partner"+"."+"developerId", "body", o.DeveloperID, 8); err != nil {
		return err
	}

	return nil
}

func (o *AddNegativeParamsBodyClientReferenceInformationPartner) validateSolutionID(formats strfmt.Registry) error {
	if swag.IsZero(o.SolutionID) { // not required
		return nil
	}

	if err := validate.MaxLength("addNegativeListRequest"+"."+"clientReferenceInformation"+"."+"partner"+"."+"solutionId", "body", o.SolutionID, 8); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this add negative params body client reference information partner based on context it is used
func (o *AddNegativeParamsBodyClientReferenceInformationPartner) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *AddNegativeParamsBodyClientReferenceInformationPartner) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *AddNegativeParamsBodyClientReferenceInformationPartner) UnmarshalBinary(b []byte) error {
	var res AddNegativeParamsBodyClientReferenceInformationPartner
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*AddNegativeParamsBodyDeviceInformation add negative params body device information
swagger:model AddNegativeParamsBodyDeviceInformation
*/
type AddNegativeParamsBodyDeviceInformation struct {

	// IP address of the customer.
	//
	// #### Used by
	// **Authorization, Capture, and Credit**
	// Optional field.
	//
	// Max Length: 45
	IPAddress string `json:"ipAddress,omitempty"`

	// Network IP address of the customer (for example, 10.1.27). A network IP address includes up to 256 IP addresses.
	//
	// Max Length: 11
	NetworkIPAddress string `json:"networkIpAddress,omitempty"`
}

// Validate validates this add negative params body device information
func (o *AddNegativeParamsBodyDeviceInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateIPAddress(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNetworkIPAddress(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *AddNegativeParamsBodyDeviceInformation) validateIPAddress(formats strfmt.Registry) error {
	if swag.IsZero(o.IPAddress) { // not required
		return nil
	}

	if err := validate.MaxLength("addNegativeListRequest"+"."+"deviceInformation"+"."+"ipAddress", "body", o.IPAddress, 45); err != nil {
		return err
	}

	return nil
}

func (o *AddNegativeParamsBodyDeviceInformation) validateNetworkIPAddress(formats strfmt.Registry) error {
	if swag.IsZero(o.NetworkIPAddress) { // not required
		return nil
	}

	if err := validate.MaxLength("addNegativeListRequest"+"."+"deviceInformation"+"."+"networkIpAddress", "body", o.NetworkIPAddress, 11); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this add negative params body device information based on context it is used
func (o *AddNegativeParamsBodyDeviceInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *AddNegativeParamsBodyDeviceInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *AddNegativeParamsBodyDeviceInformation) UnmarshalBinary(b []byte) error {
	var res AddNegativeParamsBodyDeviceInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*AddNegativeParamsBodyOrderInformation add negative params body order information
swagger:model AddNegativeParamsBodyOrderInformation
*/
type AddNegativeParamsBodyOrderInformation struct {

	// address
	Address *AddNegativeParamsBodyOrderInformationAddress `json:"address,omitempty"`

	// bill to
	BillTo *AddNegativeParamsBodyOrderInformationBillTo `json:"billTo,omitempty"`

	// This array contains detailed information about individual products in the order.
	LineItems []*AddNegativeParamsBodyOrderInformationLineItemsItems0 `json:"lineItems"`

	// ship to
	ShipTo *AddNegativeParamsBodyOrderInformationShipTo `json:"shipTo,omitempty"`
}

// Validate validates this add negative params body order information
func (o *AddNegativeParamsBodyOrderInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAddress(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBillTo(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLineItems(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateShipTo(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *AddNegativeParamsBodyOrderInformation) validateAddress(formats strfmt.Registry) error {
	if swag.IsZero(o.Address) { // not required
		return nil
	}

	if o.Address != nil {
		if err := o.Address.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("addNegativeListRequest" + "." + "orderInformation" + "." + "address")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("addNegativeListRequest" + "." + "orderInformation" + "." + "address")
			}
			return err
		}
	}

	return nil
}

func (o *AddNegativeParamsBodyOrderInformation) validateBillTo(formats strfmt.Registry) error {
	if swag.IsZero(o.BillTo) { // not required
		return nil
	}

	if o.BillTo != nil {
		if err := o.BillTo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("addNegativeListRequest" + "." + "orderInformation" + "." + "billTo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("addNegativeListRequest" + "." + "orderInformation" + "." + "billTo")
			}
			return err
		}
	}

	return nil
}

func (o *AddNegativeParamsBodyOrderInformation) validateLineItems(formats strfmt.Registry) error {
	if swag.IsZero(o.LineItems) { // not required
		return nil
	}

	for i := 0; i < len(o.LineItems); i++ {
		if swag.IsZero(o.LineItems[i]) { // not required
			continue
		}

		if o.LineItems[i] != nil {
			if err := o.LineItems[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("addNegativeListRequest" + "." + "orderInformation" + "." + "lineItems" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("addNegativeListRequest" + "." + "orderInformation" + "." + "lineItems" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *AddNegativeParamsBodyOrderInformation) validateShipTo(formats strfmt.Registry) error {
	if swag.IsZero(o.ShipTo) { // not required
		return nil
	}

	if o.ShipTo != nil {
		if err := o.ShipTo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("addNegativeListRequest" + "." + "orderInformation" + "." + "shipTo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("addNegativeListRequest" + "." + "orderInformation" + "." + "shipTo")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this add negative params body order information based on the context it is used
func (o *AddNegativeParamsBodyOrderInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateAddress(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateBillTo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateLineItems(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateShipTo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *AddNegativeParamsBodyOrderInformation) contextValidateAddress(ctx context.Context, formats strfmt.Registry) error {

	if o.Address != nil {
		if err := o.Address.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("addNegativeListRequest" + "." + "orderInformation" + "." + "address")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("addNegativeListRequest" + "." + "orderInformation" + "." + "address")
			}
			return err
		}
	}

	return nil
}

func (o *AddNegativeParamsBodyOrderInformation) contextValidateBillTo(ctx context.Context, formats strfmt.Registry) error {

	if o.BillTo != nil {
		if err := o.BillTo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("addNegativeListRequest" + "." + "orderInformation" + "." + "billTo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("addNegativeListRequest" + "." + "orderInformation" + "." + "billTo")
			}
			return err
		}
	}

	return nil
}

func (o *AddNegativeParamsBodyOrderInformation) contextValidateLineItems(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.LineItems); i++ {

		if o.LineItems[i] != nil {
			if err := o.LineItems[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("addNegativeListRequest" + "." + "orderInformation" + "." + "lineItems" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("addNegativeListRequest" + "." + "orderInformation" + "." + "lineItems" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *AddNegativeParamsBodyOrderInformation) contextValidateShipTo(ctx context.Context, formats strfmt.Registry) error {

	if o.ShipTo != nil {
		if err := o.ShipTo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("addNegativeListRequest" + "." + "orderInformation" + "." + "shipTo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("addNegativeListRequest" + "." + "orderInformation" + "." + "shipTo")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *AddNegativeParamsBodyOrderInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *AddNegativeParamsBodyOrderInformation) UnmarshalBinary(b []byte) error {
	var res AddNegativeParamsBodyOrderInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*AddNegativeParamsBodyOrderInformationAddress Contains address information related to the order
swagger:model AddNegativeParamsBodyOrderInformationAddress
*/
type AddNegativeParamsBodyOrderInformationAddress struct {

	// First line of the street address
	// Max Length: 60
	Address1 string `json:"address1,omitempty"`

	// Second line of the street address
	// Max Length: 60
	Address2 string `json:"address2,omitempty"`

	// State, province, or territory of the street address. Use the two-character codes located in the Support Center.
	// Max Length: 2
	AdministrativeArea string `json:"administrativeArea,omitempty"`

	// Country of the street address. Use the two-character codes located in the Support Center.
	// Required if address1 is present.
	//
	// Max Length: 2
	Country string `json:"country,omitempty"`

	// City of the street address.
	// Required when adding the address to a list.
	//
	// Max Length: 50
	Locality string `json:"locality,omitempty"`

	// Postal code of the street address. Required when adding the address to a list.
	// Max Length: 10
	PostalCode string `json:"postalCode,omitempty"`
}

// Validate validates this add negative params body order information address
func (o *AddNegativeParamsBodyOrderInformationAddress) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAddress1(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAddress2(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAdministrativeArea(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocality(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *AddNegativeParamsBodyOrderInformationAddress) validateAddress1(formats strfmt.Registry) error {
	if swag.IsZero(o.Address1) { // not required
		return nil
	}

	if err := validate.MaxLength("addNegativeListRequest"+"."+"orderInformation"+"."+"address"+"."+"address1", "body", o.Address1, 60); err != nil {
		return err
	}

	return nil
}

func (o *AddNegativeParamsBodyOrderInformationAddress) validateAddress2(formats strfmt.Registry) error {
	if swag.IsZero(o.Address2) { // not required
		return nil
	}

	if err := validate.MaxLength("addNegativeListRequest"+"."+"orderInformation"+"."+"address"+"."+"address2", "body", o.Address2, 60); err != nil {
		return err
	}

	return nil
}

func (o *AddNegativeParamsBodyOrderInformationAddress) validateAdministrativeArea(formats strfmt.Registry) error {
	if swag.IsZero(o.AdministrativeArea) { // not required
		return nil
	}

	if err := validate.MaxLength("addNegativeListRequest"+"."+"orderInformation"+"."+"address"+"."+"administrativeArea", "body", o.AdministrativeArea, 2); err != nil {
		return err
	}

	return nil
}

func (o *AddNegativeParamsBodyOrderInformationAddress) validateCountry(formats strfmt.Registry) error {
	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("addNegativeListRequest"+"."+"orderInformation"+"."+"address"+"."+"country", "body", o.Country, 2); err != nil {
		return err
	}

	return nil
}

func (o *AddNegativeParamsBodyOrderInformationAddress) validateLocality(formats strfmt.Registry) error {
	if swag.IsZero(o.Locality) { // not required
		return nil
	}

	if err := validate.MaxLength("addNegativeListRequest"+"."+"orderInformation"+"."+"address"+"."+"locality", "body", o.Locality, 50); err != nil {
		return err
	}

	return nil
}

func (o *AddNegativeParamsBodyOrderInformationAddress) validatePostalCode(formats strfmt.Registry) error {
	if swag.IsZero(o.PostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("addNegativeListRequest"+"."+"orderInformation"+"."+"address"+"."+"postalCode", "body", o.PostalCode, 10); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this add negative params body order information address based on context it is used
func (o *AddNegativeParamsBodyOrderInformationAddress) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *AddNegativeParamsBodyOrderInformationAddress) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *AddNegativeParamsBodyOrderInformationAddress) UnmarshalBinary(b []byte) error {
	var res AddNegativeParamsBodyOrderInformationAddress
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*AddNegativeParamsBodyOrderInformationBillTo add negative params body order information bill to
swagger:model AddNegativeParamsBodyOrderInformationBillTo
*/
type AddNegativeParamsBodyOrderInformationBillTo struct {

	// Payment card billing street address as it appears on the credit card issuer’s records.
	//
	// #### Atos
	// This field must not contain colons (:).
	//
	// #### CyberSource through VisaNet
	// **Important** When you populate orderInformation.billTo.address1 and orderInformation.billTo.address2,
	// CyberSource through VisaNet concatenates the two values. If the concatenated value exceeds 40 characters,
	// CyberSource through VisaNet truncates the value at 40 characters before sending it to Visa and the issuing bank.
	// Truncating this value affects AVS results and therefore might also affect risk decisions and chargebacks.
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet
	// accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations
	// of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the
	// credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless
	// ASCII characters for transmission to the credit card networks.
	//
	// #### FDMS Nashville
	// When the street name is numeric, it must be sent in numeric format. For example, if the address is _One First Street_,
	// it must be sent as _1 1st Street_.
	//
	// Required if keyed; not used if swiped.
	//
	// String (20)
	//
	// #### TSYS Acquiring Solutions
	// Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.
	//
	// #### All other processors:
	// Optional.
	// String (60)
	//
	// #### For Payouts
	// This field may be sent only for FDC Compass.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// Max Length: 60
	Address1 string `json:"address1,omitempty"`

	// Used for additional address information. For example: _Attention: Accounts Payable_
	// Optional field.
	//
	// For Payouts: This field may be sent only for FDC Compass.
	//
	// #### Atos
	// This field must not contain colons (:).
	//
	// #### CyberSource through VisaNet
	// **Important** When you populate `orderInformation.billTo.address1` and `orderInformation.billTo.address2`,
	// CyberSource through VisaNet concatenates the two values. If the concatenated value exceeds 40 characters,
	// CyberSource through VisaNet truncates the value at 40 characters before sending it to Visa and the issuing bank.
	// Truncating this value affects AVS results and therefore might also affect risk decisions and chargebacks.
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet
	// accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations
	// of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the
	// credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless
	// ASCII characters for transmission to the credit card networks.
	//
	// #### Chase Paymentech Solutions, FDC Compass, and TSYS Acquiring Solutions
	// This value is used for AVS.
	//
	// #### FDMS Nashville
	// `orderInformation.billTo.address1` and `orderInformation.billTo.address2` together cannot exceed 20 characters.
	// String (20)
	//
	// #### All Other Processors
	// String (60)
	//
	// Max Length: 60
	Address2 string `json:"address2,omitempty"`

	// State or province of the billing address. Use the [State, Province, and Territory Codes for the United States and Canada](https://developer.cybersource.com/library/documentation/sbc/quickref/states_and_provinces.pdf).
	//
	// For Payouts: This field may be sent only for FDC Compass.
	//
	// ##### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet
	// accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations
	// of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the
	// credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless
	// ASCII characters for transmission to the credit card networks.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// #### Chase Paymentech Solutions
	// Optional field.
	//
	// ####  Credit Mutuel-CIC
	// Optional field.
	//
	// #### OmniPay Direct
	// Optional field.
	//
	// #### SIX
	// Optional field.
	//
	// #### TSYS Acquiring Solutions
	// Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.
	//
	// #### Worldpay VAP
	// Optional field.
	//
	// #### All other processors
	// Not used.
	//
	// Max Length: 20
	AdministrativeArea string `json:"administrativeArea,omitempty"`

	// Payment card billing country. Use the two-character [ISO Standard Country Codes](http://apps.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf).
	//
	// #### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet
	// accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations
	// of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the
	// credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII
	// characters for transmission to the credit card networks.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// #### Chase Paymentech Solutions
	// Optional field.
	//
	// ####  Credit Mutuel-CIC
	// Optional field.
	//
	// #### OmniPay Direct
	// Optional field.
	//
	// #### SIX
	// Optional field.
	//
	// #### TSYS Acquiring Solutions
	// Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.
	//
	// #### Worldpay VAP
	// Optional field.
	//
	// #### All other processors
	// Not used.
	//
	// Max Length: 2
	Country string `json:"country,omitempty"`

	// Customer's email address, including the full domain name.
	//
	// #### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// For processor-specific information, see the `customer_email` request-level field description in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// #### Invoicing
	// Email address for the customer for sending the invoice. If the invoice is in SENT status and email is updated, the old email customer payment link won't work and you must resend the invoice with the new payment link.
	//
	// #### Chase Paymentech Solutions
	// Optional field.
	//
	// ####  Credit Mutuel-CIC
	// Optional field.
	//
	// #### OmniPay Direct
	// Optional field.
	//
	// #### SIX
	// Optional field.
	//
	// #### TSYS Acquiring Solutions
	// Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.
	//
	// #### Worldpay VAP
	// Optional field.
	//
	// #### All other processors
	// Not used.
	//
	// Max Length: 255
	Email string `json:"email,omitempty"`

	// Email domain of the customer. The domain of the email address comprises all characters that follow the @ symbol, such as mail.example.com. For the Risk Update service, if the email address and the domain are sent in the request, the domain supersedes the email address.
	//
	// Max Length: 100
	EmailDomain string `json:"emailDomain,omitempty"`

	// Customer’s first name. This name must be the same as the name on the card.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// #### CyberSource Latin American Processing
	// **Important** For an authorization request, CyberSource Latin American Processing concatenates `orderInformation.billTo.firstName` and `orderInformation.billTo.lastName`. If the concatenated value exceeds 30 characters, CyberSource Latin American Processing declines the authorization request.\
	// **Note** CyberSource Latin American Processing is the name of a specific processing connection that CyberSource supports. In the CyberSource API documentation, CyberSource Latin American Processing does not refer to the general topic of processing in Latin America. The information in this field description is for the specific processing connection called _CyberSource Latin American Processing_. It is not for any other Latin American processors that CyberSource supports.
	//
	// #### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.
	//
	// #### For Payouts:
	// This field may be sent only for FDC Compass.
	//
	// #### Chase Paymentech Solutions
	// Optional field.
	//
	// ####  Credit Mutuel-CIC
	// Optional field.
	//
	// #### OmniPay Direct
	// Optional field.
	//
	// #### SIX
	// Optional field.
	//
	// #### TSYS Acquiring Solutions
	// Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.
	//
	// #### Worldpay VAP
	// Optional field.
	//
	// #### All other processors
	// Not used.
	//
	// Max Length: 60
	FirstName string `json:"firstName,omitempty"`

	// Customer’s last name. This name must be the same as the name on the card.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// #### Chase Paymentech Solutions
	// Optional field.
	//
	// ####  Credit Mutuel-CIC
	// Optional field.
	//
	// #### CyberSource Latin American Processing
	// **Important** For an authorization request, CyberSource Latin American Processing concatenates `orderInformation.billTo.firstName` and `orderInformation.billTo.lastName`. If the concatenated value exceeds 30 characters, CyberSource Latin American Processing declines the authorization request.\
	// **Note** CyberSource Latin American Processing is the name of a specific processing connection that CyberSource supports. In the CyberSource API documentation, CyberSource Latin American Processing does not refer to the general topic of processing in Latin America. The information in this field description is for the specific processing connection called CyberSource Latin American Processing. It is not for any other Latin American processors that CyberSource supports.
	//
	// #### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.
	//
	// #### For Payouts:
	// This field may be sent only for FDC Compass.
	//
	// #### OmniPay Direct
	// Optional field.
	//
	// #### RBS WorldPay Atlanta
	// Optional field.
	//
	// #### SIX
	// Optional field.
	//
	// #### TSYS Acquiring Solutions
	// Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.
	//
	// #### Worldpay VAP
	// Optional field.
	//
	// #### All other processors
	// Not used.
	//
	// Max Length: 60
	LastName string `json:"lastName,omitempty"`

	// Payment card billing city.
	//
	// #### Atos
	// This field must not contain colons (:).
	//
	// #### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.
	//
	// #### For Payouts:
	// This field may be sent only for FDC Compass.
	//
	// #### Chase Paymentech Solutions
	// Optional field.
	//
	// ####  Credit Mutuel-CIC
	// Optional field.
	//
	// #### OmniPay Direct
	// Optional field.
	//
	// #### SIX
	// Optional field.
	//
	// #### TSYS Acquiring Solutions
	// Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.
	//
	// #### Worldpay VAP
	// Optional field.
	//
	// #### All other processors
	// Not used.
	//
	// Max Length: 50
	Locality string `json:"locality,omitempty"`

	// Customer’s phone number.
	//
	// It is recommended that you include the country code when the order is from outside the U.S.
	//
	// #### Chase Paymentech Solutions
	// Optional field.
	//
	// ####  Credit Mutuel-CIC
	// Optional field.
	//
	// #### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.
	//
	// #### For Payouts:
	// This field may be sent only for FDC Compass.
	//
	// #### OmniPay Direct
	// Optional field.
	//
	// #### SIX
	// Optional field.
	//
	// #### TSYS Acquiring Solutions
	// Optional field.
	//
	// #### Worldpay VAP
	// Optional field.
	//
	// #### All other processors
	// Not used.
	//
	// Max Length: 15
	PhoneNumber string `json:"phoneNumber,omitempty"`

	// Postal code for the billing address. The postal code must consist of 5 to 9 digits.
	//
	// When the billing country is the U.S., the 9-digit postal code must follow this format:
	// [5 digits][dash][4 digits]
	//
	// **Example** `12345-6789`
	//
	// When the billing country is Canada, the 6-digit postal code must follow this format:
	// [alpha][numeric][alpha][space][numeric][alpha][numeric]
	//
	// **Example** `A1B 2C3`
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// #### For Payouts:
	//  This field may be sent only for FDC Compass.
	//
	// #### American Express Direct
	// Before sending the postal code to the processor, CyberSource removes all nonalphanumeric characters and, if the remaining value is longer than nine characters, truncates the value starting from the right side.
	//
	// #### Atos
	// This field must not contain colons (:).
	//
	// #### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet
	// accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations
	// of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the
	// credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII
	// characters for transmission to the credit card networks.
	//
	// #### FDMS Nashville
	// Required if `pointOfSaleInformation.entryMode=keyed` and the address is in the U.S. or Canada.
	// Optional if `pointOfSaleInformation.entryMode=keyed` and the address is **not** in the U.S. or Canada.
	// Not used if swiped.
	//
	// #### RBS WorldPay Atlanta:
	// For best card-present keyed rates, send the postal code if `pointOfSaleInformation.entryMode=keyed`.
	//
	// #### TSYS Acquiring Solutions
	// Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.
	//
	// #### All other processors:
	// Optional field.
	//
	// Max Length: 10
	PostalCode string `json:"postalCode,omitempty"`
}

// Validate validates this add negative params body order information bill to
func (o *AddNegativeParamsBodyOrderInformationBillTo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAddress1(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAddress2(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAdministrativeArea(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEmail(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEmailDomain(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFirstName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLastName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocality(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePhoneNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *AddNegativeParamsBodyOrderInformationBillTo) validateAddress1(formats strfmt.Registry) error {
	if swag.IsZero(o.Address1) { // not required
		return nil
	}

	if err := validate.MaxLength("addNegativeListRequest"+"."+"orderInformation"+"."+"billTo"+"."+"address1", "body", o.Address1, 60); err != nil {
		return err
	}

	return nil
}

func (o *AddNegativeParamsBodyOrderInformationBillTo) validateAddress2(formats strfmt.Registry) error {
	if swag.IsZero(o.Address2) { // not required
		return nil
	}

	if err := validate.MaxLength("addNegativeListRequest"+"."+"orderInformation"+"."+"billTo"+"."+"address2", "body", o.Address2, 60); err != nil {
		return err
	}

	return nil
}

func (o *AddNegativeParamsBodyOrderInformationBillTo) validateAdministrativeArea(formats strfmt.Registry) error {
	if swag.IsZero(o.AdministrativeArea) { // not required
		return nil
	}

	if err := validate.MaxLength("addNegativeListRequest"+"."+"orderInformation"+"."+"billTo"+"."+"administrativeArea", "body", o.AdministrativeArea, 20); err != nil {
		return err
	}

	return nil
}

func (o *AddNegativeParamsBodyOrderInformationBillTo) validateCountry(formats strfmt.Registry) error {
	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("addNegativeListRequest"+"."+"orderInformation"+"."+"billTo"+"."+"country", "body", o.Country, 2); err != nil {
		return err
	}

	return nil
}

func (o *AddNegativeParamsBodyOrderInformationBillTo) validateEmail(formats strfmt.Registry) error {
	if swag.IsZero(o.Email) { // not required
		return nil
	}

	if err := validate.MaxLength("addNegativeListRequest"+"."+"orderInformation"+"."+"billTo"+"."+"email", "body", o.Email, 255); err != nil {
		return err
	}

	return nil
}

func (o *AddNegativeParamsBodyOrderInformationBillTo) validateEmailDomain(formats strfmt.Registry) error {
	if swag.IsZero(o.EmailDomain) { // not required
		return nil
	}

	if err := validate.MaxLength("addNegativeListRequest"+"."+"orderInformation"+"."+"billTo"+"."+"emailDomain", "body", o.EmailDomain, 100); err != nil {
		return err
	}

	return nil
}

func (o *AddNegativeParamsBodyOrderInformationBillTo) validateFirstName(formats strfmt.Registry) error {
	if swag.IsZero(o.FirstName) { // not required
		return nil
	}

	if err := validate.MaxLength("addNegativeListRequest"+"."+"orderInformation"+"."+"billTo"+"."+"firstName", "body", o.FirstName, 60); err != nil {
		return err
	}

	return nil
}

func (o *AddNegativeParamsBodyOrderInformationBillTo) validateLastName(formats strfmt.Registry) error {
	if swag.IsZero(o.LastName) { // not required
		return nil
	}

	if err := validate.MaxLength("addNegativeListRequest"+"."+"orderInformation"+"."+"billTo"+"."+"lastName", "body", o.LastName, 60); err != nil {
		return err
	}

	return nil
}

func (o *AddNegativeParamsBodyOrderInformationBillTo) validateLocality(formats strfmt.Registry) error {
	if swag.IsZero(o.Locality) { // not required
		return nil
	}

	if err := validate.MaxLength("addNegativeListRequest"+"."+"orderInformation"+"."+"billTo"+"."+"locality", "body", o.Locality, 50); err != nil {
		return err
	}

	return nil
}

func (o *AddNegativeParamsBodyOrderInformationBillTo) validatePhoneNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.PhoneNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("addNegativeListRequest"+"."+"orderInformation"+"."+"billTo"+"."+"phoneNumber", "body", o.PhoneNumber, 15); err != nil {
		return err
	}

	return nil
}

func (o *AddNegativeParamsBodyOrderInformationBillTo) validatePostalCode(formats strfmt.Registry) error {
	if swag.IsZero(o.PostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("addNegativeListRequest"+"."+"orderInformation"+"."+"billTo"+"."+"postalCode", "body", o.PostalCode, 10); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this add negative params body order information bill to based on context it is used
func (o *AddNegativeParamsBodyOrderInformationBillTo) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *AddNegativeParamsBodyOrderInformationBillTo) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *AddNegativeParamsBodyOrderInformationBillTo) UnmarshalBinary(b []byte) error {
	var res AddNegativeParamsBodyOrderInformationBillTo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*AddNegativeParamsBodyOrderInformationLineItemsItems0 add negative params body order information line items items0
swagger:model AddNegativeParamsBodyOrderInformationLineItemsItems0
*/
type AddNegativeParamsBodyOrderInformationLineItemsItems0 struct {

	// Per-item price of the product. This value for this field cannot be negative.
	//
	// You must include either this field or the request-level field `orderInformation.amountDetails.totalAmount` in your request.
	//
	// You can include a decimal point (.), but you cannot include any other special characters.
	// The value is truncated to the correct number of decimal places.
	//
	// #### DCC with a Third-Party Provider
	// Set this field to the converted amount that was returned by the DCC provider. You must include either
	// the 1st line item in the order and this field, or the request-level field `orderInformation.amountDetails.totalAmount` in your request.
	//
	// #### FDMS South
	// If you accept IDR or CLP currencies, see the entry for FDMS South in the [Merchant Descriptors Using the SCMP API Guide.]
	// (https://apps.cybersource.com/library/documentation/dev_guides/Merchant_Descriptors_SCMP_API/html/)
	//
	// #### Tax Calculation
	// Required field for U.S., Canadian, international and value added taxes.
	//
	// #### Zero Amount Authorizations
	// If your processor supports zero amount authorizations, you can set this field to 0 for the
	// authorization to check if the card is lost or stolen.
	//
	// #### Maximum Field Lengths
	// For GPN and JCN Gateway: Decimal (10)
	// All other processors: Decimal (15)
	//
	// Max Length: 15
	UnitPrice string `json:"unitPrice,omitempty"`
}

// Validate validates this add negative params body order information line items items0
func (o *AddNegativeParamsBodyOrderInformationLineItemsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateUnitPrice(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *AddNegativeParamsBodyOrderInformationLineItemsItems0) validateUnitPrice(formats strfmt.Registry) error {
	if swag.IsZero(o.UnitPrice) { // not required
		return nil
	}

	if err := validate.MaxLength("unitPrice", "body", o.UnitPrice, 15); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this add negative params body order information line items items0 based on context it is used
func (o *AddNegativeParamsBodyOrderInformationLineItemsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *AddNegativeParamsBodyOrderInformationLineItemsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *AddNegativeParamsBodyOrderInformationLineItemsItems0) UnmarshalBinary(b []byte) error {
	var res AddNegativeParamsBodyOrderInformationLineItemsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*AddNegativeParamsBodyOrderInformationShipTo Contains recipient shipping information.
swagger:model AddNegativeParamsBodyOrderInformationShipTo
*/
type AddNegativeParamsBodyOrderInformationShipTo struct {

	// First line of the shipping address.
	//
	// Required field for authorization if any shipping address information is included in the request; otherwise, optional.
	//
	// #### Tax Calculation
	// Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes.
	// Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present.
	//
	// Max Length: 60
	Address1 string `json:"address1,omitempty"`

	// Second line of the shipping address.
	//
	// Optional field.
	//
	// #### Tax Calculation
	// Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes.
	// Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present.
	//
	// Max Length: 60
	Address2 string `json:"address2,omitempty"`

	// State or province of the shipping address. Use the [State, Province, and Territory Codes for the United States and Canada](https://developer.cybersource.com/library/documentation/sbc/quickref/states_and_provinces.pdf)
	//
	// Required field for authorization if any shipping address information is included in the request and shipping to the U.S.
	// or Canada; otherwise, optional.
	//
	// #### Tax Calculation
	// Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes.
	// Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present.
	//
	// Max Length: 2
	AdministrativeArea string `json:"administrativeArea,omitempty"`

	// Country of the shipping address. Use the two-character [ISO Standard Country Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf)
	//
	// Required field for authorization if any shipping address information is included in the request; otherwise, optional.
	//
	// #### Tax Calculation
	// Optional field for U.S., Canadian, international tax, and value added taxes.
	// Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present.
	//
	// Max Length: 2
	Country string `json:"country,omitempty"`

	// City of the shipping address.
	//
	// Required field for authorization if any shipping address information is included in the request and shipping to the U.S. or
	// Canada; otherwise, optional.
	//
	// #### Tax Calculation
	// Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes.
	// Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present.
	//
	// Max Length: 50
	Locality string `json:"locality,omitempty"`

	// Postal code for the shipping address. The postal code must consist of 5 to 9 digits.
	//
	// Required field for authorization if any shipping address information is included in the request and
	// shipping to the U.S. or Canada; otherwise, optional.
	//
	// When the billing country is the U.S., the 9-digit postal code must follow this format:
	// [5 digits][dash][4 digits]
	//
	// Example 12345-6789
	//
	// When the billing country is Canada, the 6-digit postal code must follow this format:
	// [alpha][numeric][alpha][space][numeric][alpha][numeric]
	//
	// Example A1B 2C3
	//
	// #### American Express Direct
	// Before sending the postal code to the processor, all nonalphanumeric characters are removed and, if the
	// remaining value is longer than nine characters, the value is truncated starting from the right side.
	// #### Tax Calculation
	// Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes.
	// Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present.
	//
	// Max Length: 10
	PostalCode string `json:"postalCode,omitempty"`
}

// Validate validates this add negative params body order information ship to
func (o *AddNegativeParamsBodyOrderInformationShipTo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAddress1(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAddress2(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAdministrativeArea(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocality(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *AddNegativeParamsBodyOrderInformationShipTo) validateAddress1(formats strfmt.Registry) error {
	if swag.IsZero(o.Address1) { // not required
		return nil
	}

	if err := validate.MaxLength("addNegativeListRequest"+"."+"orderInformation"+"."+"shipTo"+"."+"address1", "body", o.Address1, 60); err != nil {
		return err
	}

	return nil
}

func (o *AddNegativeParamsBodyOrderInformationShipTo) validateAddress2(formats strfmt.Registry) error {
	if swag.IsZero(o.Address2) { // not required
		return nil
	}

	if err := validate.MaxLength("addNegativeListRequest"+"."+"orderInformation"+"."+"shipTo"+"."+"address2", "body", o.Address2, 60); err != nil {
		return err
	}

	return nil
}

func (o *AddNegativeParamsBodyOrderInformationShipTo) validateAdministrativeArea(formats strfmt.Registry) error {
	if swag.IsZero(o.AdministrativeArea) { // not required
		return nil
	}

	if err := validate.MaxLength("addNegativeListRequest"+"."+"orderInformation"+"."+"shipTo"+"."+"administrativeArea", "body", o.AdministrativeArea, 2); err != nil {
		return err
	}

	return nil
}

func (o *AddNegativeParamsBodyOrderInformationShipTo) validateCountry(formats strfmt.Registry) error {
	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("addNegativeListRequest"+"."+"orderInformation"+"."+"shipTo"+"."+"country", "body", o.Country, 2); err != nil {
		return err
	}

	return nil
}

func (o *AddNegativeParamsBodyOrderInformationShipTo) validateLocality(formats strfmt.Registry) error {
	if swag.IsZero(o.Locality) { // not required
		return nil
	}

	if err := validate.MaxLength("addNegativeListRequest"+"."+"orderInformation"+"."+"shipTo"+"."+"locality", "body", o.Locality, 50); err != nil {
		return err
	}

	return nil
}

func (o *AddNegativeParamsBodyOrderInformationShipTo) validatePostalCode(formats strfmt.Registry) error {
	if swag.IsZero(o.PostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("addNegativeListRequest"+"."+"orderInformation"+"."+"shipTo"+"."+"postalCode", "body", o.PostalCode, 10); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this add negative params body order information ship to based on context it is used
func (o *AddNegativeParamsBodyOrderInformationShipTo) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *AddNegativeParamsBodyOrderInformationShipTo) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *AddNegativeParamsBodyOrderInformationShipTo) UnmarshalBinary(b []byte) error {
	var res AddNegativeParamsBodyOrderInformationShipTo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*AddNegativeParamsBodyPaymentInformation Contains the payment data for updating in List Management.
swagger:model AddNegativeParamsBodyPaymentInformation
*/
type AddNegativeParamsBodyPaymentInformation struct {

	// bank
	Bank *AddNegativeParamsBodyPaymentInformationBank `json:"bank,omitempty"`

	// card
	Card *AddNegativeParamsBodyPaymentInformationCard `json:"card,omitempty"`
}

// Validate validates this add negative params body payment information
func (o *AddNegativeParamsBodyPaymentInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateBank(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCard(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *AddNegativeParamsBodyPaymentInformation) validateBank(formats strfmt.Registry) error {
	if swag.IsZero(o.Bank) { // not required
		return nil
	}

	if o.Bank != nil {
		if err := o.Bank.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("addNegativeListRequest" + "." + "paymentInformation" + "." + "bank")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("addNegativeListRequest" + "." + "paymentInformation" + "." + "bank")
			}
			return err
		}
	}

	return nil
}

func (o *AddNegativeParamsBodyPaymentInformation) validateCard(formats strfmt.Registry) error {
	if swag.IsZero(o.Card) { // not required
		return nil
	}

	if o.Card != nil {
		if err := o.Card.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("addNegativeListRequest" + "." + "paymentInformation" + "." + "card")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("addNegativeListRequest" + "." + "paymentInformation" + "." + "card")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this add negative params body payment information based on the context it is used
func (o *AddNegativeParamsBodyPaymentInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateBank(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateCard(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *AddNegativeParamsBodyPaymentInformation) contextValidateBank(ctx context.Context, formats strfmt.Registry) error {

	if o.Bank != nil {
		if err := o.Bank.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("addNegativeListRequest" + "." + "paymentInformation" + "." + "bank")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("addNegativeListRequest" + "." + "paymentInformation" + "." + "bank")
			}
			return err
		}
	}

	return nil
}

func (o *AddNegativeParamsBodyPaymentInformation) contextValidateCard(ctx context.Context, formats strfmt.Registry) error {

	if o.Card != nil {
		if err := o.Card.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("addNegativeListRequest" + "." + "paymentInformation" + "." + "card")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("addNegativeListRequest" + "." + "paymentInformation" + "." + "card")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *AddNegativeParamsBodyPaymentInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *AddNegativeParamsBodyPaymentInformation) UnmarshalBinary(b []byte) error {
	var res AddNegativeParamsBodyPaymentInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*AddNegativeParamsBodyPaymentInformationBank Customer's bank account details
swagger:model AddNegativeParamsBodyPaymentInformationBank
*/
type AddNegativeParamsBodyPaymentInformationBank struct {

	// Customer's bank account number. You can use this field only when scoring a direct debit transaction. Use this field if you do not or are not allowed to provide the IBAN. Note Do not use the IBAN in this field. Use nly the
	// traditional account number information. For the IBAN, use bank_iban.
	//
	// Max Length: 30
	AccountNumber string `json:"accountNumber,omitempty"`

	// Country-specific code used to identify the customer’s bank. Required for some countries if you do not or are not allowed to provide the IBAN instead. You can use this field only when scoring a direct debit transaction. For specific requirements, see "Required Bank Account Information by Country,"
	//
	// Max Length: 15
	Code string `json:"code,omitempty"`

	// Country where the bank is located. Use the two-character ISO codes. You can use this field only when scoring a direct debit transaction.
	//
	// Max Length: 2
	Country string `json:"country,omitempty"`

	// International Bank Account Number (IBAN) for the bank account. For some countries you can provide this number instead of the traditional bank account information. You can use this field only when scoring a direct debit transaction.
	// For specific requirements, see "Required Bank Account Information by Country,"
	//
	// Max Length: 30
	Iban string `json:"iban,omitempty"`
}

// Validate validates this add negative params body payment information bank
func (o *AddNegativeParamsBodyPaymentInformationBank) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAccountNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateIban(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *AddNegativeParamsBodyPaymentInformationBank) validateAccountNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.AccountNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("addNegativeListRequest"+"."+"paymentInformation"+"."+"bank"+"."+"accountNumber", "body", o.AccountNumber, 30); err != nil {
		return err
	}

	return nil
}

func (o *AddNegativeParamsBodyPaymentInformationBank) validateCode(formats strfmt.Registry) error {
	if swag.IsZero(o.Code) { // not required
		return nil
	}

	if err := validate.MaxLength("addNegativeListRequest"+"."+"paymentInformation"+"."+"bank"+"."+"code", "body", o.Code, 15); err != nil {
		return err
	}

	return nil
}

func (o *AddNegativeParamsBodyPaymentInformationBank) validateCountry(formats strfmt.Registry) error {
	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("addNegativeListRequest"+"."+"paymentInformation"+"."+"bank"+"."+"country", "body", o.Country, 2); err != nil {
		return err
	}

	return nil
}

func (o *AddNegativeParamsBodyPaymentInformationBank) validateIban(formats strfmt.Registry) error {
	if swag.IsZero(o.Iban) { // not required
		return nil
	}

	if err := validate.MaxLength("addNegativeListRequest"+"."+"paymentInformation"+"."+"bank"+"."+"iban", "body", o.Iban, 30); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this add negative params body payment information bank based on context it is used
func (o *AddNegativeParamsBodyPaymentInformationBank) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *AddNegativeParamsBodyPaymentInformationBank) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *AddNegativeParamsBodyPaymentInformationBank) UnmarshalBinary(b []byte) error {
	var res AddNegativeParamsBodyPaymentInformationBank
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*AddNegativeParamsBodyPaymentInformationCard add negative params body payment information card
swagger:model AddNegativeParamsBodyPaymentInformationCard
*/
type AddNegativeParamsBodyPaymentInformationCard struct {

	// description: The BIN is the first six digits of the card's Primary Account Number (PAN).
	//
	// Max Length: 6
	Bin string `json:"bin,omitempty"`

	// The customer’s payment card number, also known as the Primary Account Number (PAN). You can also use this field
	// for encoded account numbers.
	//
	// #### FDMS Nashville
	// Required. String (19)
	//
	// #### GPX
	// Required if `pointOfSaleInformation.entryMode=keyed`. However, this field is optional if your account is configured
	// for relaxed requirements for address data and expiration date. **Important** It is your responsibility to determine
	// whether a field is required for the transaction you are requesting.
	//
	// #### All other processors
	// Required if `pointOfSaleInformation.entryMode=keyed`. However, this field is optional if your account is configured
	// for relaxed requirements for address data and expiration date. **Important** It is your responsibility to determine
	// whether a field is required for the transaction you are requesting.
	//
	// Max Length: 20
	Number string `json:"number,omitempty"`

	// Three-digit value that indicates the card type.
	//
	// **IMPORTANT** It is strongly recommended that you include the card type field in request messages even if it is
	// optional for your processor and card type. Omitting the card type can cause the transaction to be processed with the wrong card type.
	//
	// Possible values:
	// - `001`: Visa. For card-present transactions on all processors except SIX, the Visa Electron card type is processed the same way that the Visa debit card is processed. Use card type value `001` for Visa Electron.
	// - `002`: Mastercard, Eurocard[^1], which is a European regional brand of Mastercard.
	// - `003`: American Express
	// - `004`: Discover
	// - `005`: Diners Club
	// - `006`: Carte Blanche[^1]
	// - `007`: JCB[^1]
	// - `014`: Enroute[^1]
	// - `021`: JAL[^1]
	// - `024`: Maestro (UK Domestic)[^1]
	// - `031`: Delta[^1]: Use this value only for Ingenico ePayments. For other processors, use `001` for all Visa card types.
	// - `033`: Visa Electron[^1]. Use this value only for Ingenico ePayments and SIX. For other processors, use `001` for all Visa card types.
	// - `034`: Dankort[^1]
	// - `036`: Cartes Bancaires[^1,4]
	// - `037`: Carta Si[^1]
	// - `039`: Encoded account number[^1]
	// - `040`: UATP[^1]
	// - `042`: Maestro (International)[^1]
	// - `050`: Hipercard[^2,3]
	// - `051`: Aura
	// - `054`: Elo[^3]
	// - `062`: China UnionPay
	//
	// [^1]: For this card type, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in your request for an authorization or a stand-alone credit.
	// [^2]: For this card type on Cielo 3.0, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in a request for an authorization or a stand-alone credit. This card type is not supported on Cielo 1.5.
	// [^3]: For this card type on Getnet and Rede, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in a request for an authorization or a stand-alone credit.
	// [^4]: For this card type, you must include the `paymentInformation.card.type` in your request for any payer authentication services.
	//
	// #### Used by
	// **Authorization**
	// Required for Carte Blanche and JCB.
	// Optional for all other card types.
	//
	// #### Card Present reply
	// This field is included in the reply message when the client software that is installed on the POS terminal uses
	// the token management service (TMS) to retrieve tokenized payment details. You must contact customer support to
	// have your account enabled to receive these fields in the credit reply message.
	//
	// Returned by the Credit service.
	//
	// This reply field is only supported by the following processors:
	// - American Express Direct
	// - Credit Mutuel-CIC
	// - FDC Nashville Global
	// - OmniPay Direct
	// - SIX
	//
	// #### Google Pay transactions
	// For PAN-based Google Pay transactions, this field is returned in the API response.
	//
	// #### GPX
	// This field only supports transactions from the following card types:
	// - Visa
	// - Mastercard
	// - AMEX
	// - Discover
	// - Diners
	// - JCB
	// - Union Pay International
	//
	Type string `json:"type,omitempty"`
}

// Validate validates this add negative params body payment information card
func (o *AddNegativeParamsBodyPaymentInformationCard) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateBin(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNumber(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *AddNegativeParamsBodyPaymentInformationCard) validateBin(formats strfmt.Registry) error {
	if swag.IsZero(o.Bin) { // not required
		return nil
	}

	if err := validate.MaxLength("addNegativeListRequest"+"."+"paymentInformation"+"."+"card"+"."+"bin", "body", o.Bin, 6); err != nil {
		return err
	}

	return nil
}

func (o *AddNegativeParamsBodyPaymentInformationCard) validateNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.Number) { // not required
		return nil
	}

	if err := validate.MaxLength("addNegativeListRequest"+"."+"paymentInformation"+"."+"card"+"."+"number", "body", o.Number, 20); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this add negative params body payment information card based on context it is used
func (o *AddNegativeParamsBodyPaymentInformationCard) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *AddNegativeParamsBodyPaymentInformationCard) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *AddNegativeParamsBodyPaymentInformationCard) UnmarshalBinary(b []byte) error {
	var res AddNegativeParamsBodyPaymentInformationCard
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*AddNegativeParamsBodyRiskInformation add negative params body risk information
swagger:model AddNegativeParamsBodyRiskInformation
*/
type AddNegativeParamsBodyRiskInformation struct {

	// marking details
	MarkingDetails *AddNegativeParamsBodyRiskInformationMarkingDetails `json:"markingDetails,omitempty"`
}

// Validate validates this add negative params body risk information
func (o *AddNegativeParamsBodyRiskInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateMarkingDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *AddNegativeParamsBodyRiskInformation) validateMarkingDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.MarkingDetails) { // not required
		return nil
	}

	if o.MarkingDetails != nil {
		if err := o.MarkingDetails.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("addNegativeListRequest" + "." + "riskInformation" + "." + "markingDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("addNegativeListRequest" + "." + "riskInformation" + "." + "markingDetails")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this add negative params body risk information based on the context it is used
func (o *AddNegativeParamsBodyRiskInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateMarkingDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *AddNegativeParamsBodyRiskInformation) contextValidateMarkingDetails(ctx context.Context, formats strfmt.Registry) error {

	if o.MarkingDetails != nil {
		if err := o.MarkingDetails.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("addNegativeListRequest" + "." + "riskInformation" + "." + "markingDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("addNegativeListRequest" + "." + "riskInformation" + "." + "markingDetails")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *AddNegativeParamsBodyRiskInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *AddNegativeParamsBodyRiskInformation) UnmarshalBinary(b []byte) error {
	var res AddNegativeParamsBodyRiskInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*AddNegativeParamsBodyRiskInformationMarkingDetails Details for marking the transaction as either positive or negative.
swagger:model AddNegativeParamsBodyRiskInformationMarkingDetails
*/
type AddNegativeParamsBodyRiskInformationMarkingDetails struct {

	// Indicates whether to add to or remove a customer’s identity from the negative or positive list. This field can
	// contain one of the following values:
	// - add: Add information to the list.
	// - convert: moves the data.
	// - delete: deletes the data from the list.
	//
	Action string `json:"action,omitempty"`

	// Notes or details that explain the reasons for adding the transaction to either the positive or negative list.
	// Max Length: 120
	Notes string `json:"notes,omitempty"`

	// Reason for adding the transaction to the negative list. This field can contain one of the following values:
	// - `fraud_chargeback:` You have received a fraud-related chargeback for the transaction.
	// - `non_fraud_chargeback:` You have received a non-fraudulent chargeback for the transaction.
	// - `suspected:` You believe that you will probably receive a chargeback for the transaction.
	// - `creditback:` You issued a refund to the customer to avoid a chargeback for the transaction.
	//
	// Max Length: 25
	Reason string `json:"reason,omitempty"`

	// Name of the customer’s record entered in the list.
	// For the positive list, it is required if `action_
	// code`=`add_positive`. If absent from the request, `ics_risk_update` creates the value for this field by concatenating the customer’s first and last names.
	// For the negative and the review lists, `record_name`, `customer_firstname`, and `customer_lastname` are optional.
	//
	// Max Length: 255
	RecordName string `json:"recordName,omitempty"`
}

// Validate validates this add negative params body risk information marking details
func (o *AddNegativeParamsBodyRiskInformationMarkingDetails) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateNotes(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateReason(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRecordName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *AddNegativeParamsBodyRiskInformationMarkingDetails) validateNotes(formats strfmt.Registry) error {
	if swag.IsZero(o.Notes) { // not required
		return nil
	}

	if err := validate.MaxLength("addNegativeListRequest"+"."+"riskInformation"+"."+"markingDetails"+"."+"notes", "body", o.Notes, 120); err != nil {
		return err
	}

	return nil
}

func (o *AddNegativeParamsBodyRiskInformationMarkingDetails) validateReason(formats strfmt.Registry) error {
	if swag.IsZero(o.Reason) { // not required
		return nil
	}

	if err := validate.MaxLength("addNegativeListRequest"+"."+"riskInformation"+"."+"markingDetails"+"."+"reason", "body", o.Reason, 25); err != nil {
		return err
	}

	return nil
}

func (o *AddNegativeParamsBodyRiskInformationMarkingDetails) validateRecordName(formats strfmt.Registry) error {
	if swag.IsZero(o.RecordName) { // not required
		return nil
	}

	if err := validate.MaxLength("addNegativeListRequest"+"."+"riskInformation"+"."+"markingDetails"+"."+"recordName", "body", o.RecordName, 255); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this add negative params body risk information marking details based on context it is used
func (o *AddNegativeParamsBodyRiskInformationMarkingDetails) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *AddNegativeParamsBodyRiskInformationMarkingDetails) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *AddNegativeParamsBodyRiskInformationMarkingDetails) UnmarshalBinary(b []byte) error {
	var res AddNegativeParamsBodyRiskInformationMarkingDetails
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}
