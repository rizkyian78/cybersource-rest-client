// Code generated by go-swagger; DO NOT EDIT.

package credit

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"fmt"
	"io"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// CreateCreditReader is a Reader for the CreateCredit structure.
type CreateCreditReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *CreateCreditReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 201:
		result := NewCreateCreditCreated()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	case 400:
		result := NewCreateCreditBadRequest()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 502:
		result := NewCreateCreditBadGateway()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	default:
		return nil, runtime.NewAPIError("response status code does not match any response statuses defined for this endpoint in the swagger spec", response, response.Code())
	}
}

// NewCreateCreditCreated creates a CreateCreditCreated with default headers values
func NewCreateCreditCreated() *CreateCreditCreated {
	return &CreateCreditCreated{}
}

/* CreateCreditCreated describes a response with status code 201, with default header values.

Successful response.
*/
type CreateCreditCreated struct {
	Payload *CreateCreditCreatedBody
}

func (o *CreateCreditCreated) Error() string {
	return fmt.Sprintf("[POST /pts/v2/credits][%d] createCreditCreated  %+v", 201, o.Payload)
}
func (o *CreateCreditCreated) GetPayload() *CreateCreditCreatedBody {
	return o.Payload
}

func (o *CreateCreditCreated) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(CreateCreditCreatedBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewCreateCreditBadRequest creates a CreateCreditBadRequest with default headers values
func NewCreateCreditBadRequest() *CreateCreditBadRequest {
	return &CreateCreditBadRequest{}
}

/* CreateCreditBadRequest describes a response with status code 400, with default header values.

Invalid request.
*/
type CreateCreditBadRequest struct {
	Payload *CreateCreditBadRequestBody
}

func (o *CreateCreditBadRequest) Error() string {
	return fmt.Sprintf("[POST /pts/v2/credits][%d] createCreditBadRequest  %+v", 400, o.Payload)
}
func (o *CreateCreditBadRequest) GetPayload() *CreateCreditBadRequestBody {
	return o.Payload
}

func (o *CreateCreditBadRequest) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(CreateCreditBadRequestBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewCreateCreditBadGateway creates a CreateCreditBadGateway with default headers values
func NewCreateCreditBadGateway() *CreateCreditBadGateway {
	return &CreateCreditBadGateway{}
}

/* CreateCreditBadGateway describes a response with status code 502, with default header values.

Unexpected system error or system timeout.
*/
type CreateCreditBadGateway struct {
	Payload *CreateCreditBadGatewayBody
}

func (o *CreateCreditBadGateway) Error() string {
	return fmt.Sprintf("[POST /pts/v2/credits][%d] createCreditBadGateway  %+v", 502, o.Payload)
}
func (o *CreateCreditBadGateway) GetPayload() *CreateCreditBadGatewayBody {
	return o.Payload
}

func (o *CreateCreditBadGateway) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(CreateCreditBadGatewayBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

/*CreateCreditBadGatewayBody ptsV2CreditsPost502Response
swagger:model CreateCreditBadGatewayBody
*/
type CreateCreditBadGatewayBody struct {

	// The detail message related to the status and reason listed above.
	Message string `json:"message,omitempty"`

	// The reason of the status.
	//
	// Possible values:
	//  - SYSTEM_ERROR
	//  - SERVER_TIMEOUT
	//  - SERVICE_TIMEOUT
	//
	Reason string `json:"reason,omitempty"`

	// The status of the submitted transaction.
	//
	// Possible values:
	//  - SERVER_ERROR
	//
	Status string `json:"status,omitempty"`

	// Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ`
	// **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.).
	// The `T` separates the date and the time. The `Z` indicates UTC.
	//
	// Returned by Cybersource for all services.
	//
	SubmitTimeUtc string `json:"submitTimeUtc,omitempty"`
}

// Validate validates this create credit bad gateway body
func (o *CreateCreditBadGatewayBody) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this create credit bad gateway body based on context it is used
func (o *CreateCreditBadGatewayBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditBadGatewayBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditBadGatewayBody) UnmarshalBinary(b []byte) error {
	var res CreateCreditBadGatewayBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditBadRequestBody ptsV2CreditsPost400Response
swagger:model CreateCreditBadRequestBody
*/
type CreateCreditBadRequestBody struct {

	// details
	Details []*CreateCreditBadRequestBodyDetailsItems0 `json:"details"`

	// The detail message related to the status and reason listed above.
	Message string `json:"message,omitempty"`

	// The reason of the status.
	//
	// Possible values:
	//  - MISSING_FIELD
	//  - INVALID_DATA
	//  - DUPLICATE_REQUEST
	//  - INVALID_CARD
	//  - INVALID_MERCHANT_CONFIGURATION
	//  - INVALID_AMOUNT
	//  - CAPTURE_ALREADY_VOIDED
	//  - ACCOUNT_NOT_ALLOWED_CREDIT
	//
	Reason string `json:"reason,omitempty"`

	// The status of the submitted transaction.
	//
	// Possible values:
	//  - INVALID_REQUEST
	//
	Status string `json:"status,omitempty"`

	// Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ`
	// **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.).
	// The `T` separates the date and the time. The `Z` indicates UTC.
	//
	// Returned by Cybersource for all services.
	//
	SubmitTimeUtc string `json:"submitTimeUtc,omitempty"`
}

// Validate validates this create credit bad request body
func (o *CreateCreditBadRequestBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditBadRequestBody) validateDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.Details) { // not required
		return nil
	}

	for i := 0; i < len(o.Details); i++ {
		if swag.IsZero(o.Details[i]) { // not required
			continue
		}

		if o.Details[i] != nil {
			if err := o.Details[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("createCreditBadRequest" + "." + "details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("createCreditBadRequest" + "." + "details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this create credit bad request body based on the context it is used
func (o *CreateCreditBadRequestBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditBadRequestBody) contextValidateDetails(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.Details); i++ {

		if o.Details[i] != nil {
			if err := o.Details[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("createCreditBadRequest" + "." + "details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("createCreditBadRequest" + "." + "details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditBadRequestBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditBadRequestBody) UnmarshalBinary(b []byte) error {
	var res CreateCreditBadRequestBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditBadRequestBodyDetailsItems0 create credit bad request body details items0
swagger:model CreateCreditBadRequestBodyDetailsItems0
*/
type CreateCreditBadRequestBodyDetailsItems0 struct {

	// This is the flattened JSON object field name/path that is either missing or invalid.
	Field string `json:"field,omitempty"`

	// Possible reasons for the error.
	//
	// Possible values:
	//  - MISSING_FIELD
	//  - INVALID_DATA
	//
	Reason string `json:"reason,omitempty"`
}

// Validate validates this create credit bad request body details items0
func (o *CreateCreditBadRequestBodyDetailsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this create credit bad request body details items0 based on context it is used
func (o *CreateCreditBadRequestBodyDetailsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditBadRequestBodyDetailsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditBadRequestBodyDetailsItems0) UnmarshalBinary(b []byte) error {
	var res CreateCreditBadRequestBodyDetailsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditBody create credit body
// Example: {"clientReferenceInformation":{"code":"12345678"},"orderInformation":{"amountDetails":{"currency":"usd","totalAmount":"200"},"billTo":{"address1":"test","administrativeArea":"MI","country":"US","email":"test@cybs.com","firstName":"Test","lastName":"test","locality":"Ann Arbor","phoneNumber":"9999999999","postalCode":"48104-2201"}},"paymentInformation":{"card":{"expirationMonth":"03","expirationYear":"2031","number":"4111111111111111","type":"001"}}}
swagger:model CreateCreditBody
*/
type CreateCreditBody struct {

	// aggregator information
	AggregatorInformation *CreateCreditParamsBodyAggregatorInformation `json:"aggregatorInformation,omitempty"`

	// buyer information
	BuyerInformation *CreateCreditParamsBodyBuyerInformation `json:"buyerInformation,omitempty"`

	// client reference information
	ClientReferenceInformation *CreateCreditParamsBodyClientReferenceInformation `json:"clientReferenceInformation,omitempty"`

	// device information
	DeviceInformation *CreateCreditParamsBodyDeviceInformation `json:"deviceInformation,omitempty"`

	// installment information
	InstallmentInformation *CreateCreditParamsBodyInstallmentInformation `json:"installmentInformation,omitempty"`

	// The object containing the custom data that the merchant defines.
	//
	MerchantDefinedInformation []*CreateCreditParamsBodyMerchantDefinedInformationItems0 `json:"merchantDefinedInformation"`

	// merchant information
	MerchantInformation *CreateCreditParamsBodyMerchantInformation `json:"merchantInformation,omitempty"`

	// order information
	OrderInformation *CreateCreditParamsBodyOrderInformation `json:"orderInformation,omitempty"`

	// payment information
	PaymentInformation *CreateCreditParamsBodyPaymentInformation `json:"paymentInformation,omitempty"`

	// point of sale information
	PointOfSaleInformation *CreateCreditParamsBodyPointOfSaleInformation `json:"pointOfSaleInformation,omitempty"`

	// processing information
	ProcessingInformation *CreateCreditParamsBodyProcessingInformation `json:"processingInformation,omitempty"`

	// promotion information
	PromotionInformation *CreateCreditParamsBodyPromotionInformation `json:"promotionInformation,omitempty"`

	// travel information
	TravelInformation *CreateCreditParamsBodyTravelInformation `json:"travelInformation,omitempty"`
}

// Validate validates this create credit body
func (o *CreateCreditBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAggregatorInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBuyerInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateClientReferenceInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDeviceInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateInstallmentInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMerchantDefinedInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMerchantInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOrderInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePaymentInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePointOfSaleInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProcessingInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePromotionInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTravelInformation(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditBody) validateAggregatorInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.AggregatorInformation) { // not required
		return nil
	}

	if o.AggregatorInformation != nil {
		if err := o.AggregatorInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "aggregatorInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "aggregatorInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditBody) validateBuyerInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.BuyerInformation) { // not required
		return nil
	}

	if o.BuyerInformation != nil {
		if err := o.BuyerInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "buyerInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "buyerInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditBody) validateClientReferenceInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ClientReferenceInformation) { // not required
		return nil
	}

	if o.ClientReferenceInformation != nil {
		if err := o.ClientReferenceInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "clientReferenceInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "clientReferenceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditBody) validateDeviceInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.DeviceInformation) { // not required
		return nil
	}

	if o.DeviceInformation != nil {
		if err := o.DeviceInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "deviceInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "deviceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditBody) validateInstallmentInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.InstallmentInformation) { // not required
		return nil
	}

	if o.InstallmentInformation != nil {
		if err := o.InstallmentInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "installmentInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "installmentInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditBody) validateMerchantDefinedInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.MerchantDefinedInformation) { // not required
		return nil
	}

	for i := 0; i < len(o.MerchantDefinedInformation); i++ {
		if swag.IsZero(o.MerchantDefinedInformation[i]) { // not required
			continue
		}

		if o.MerchantDefinedInformation[i] != nil {
			if err := o.MerchantDefinedInformation[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("createCreditRequest" + "." + "merchantDefinedInformation" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("createCreditRequest" + "." + "merchantDefinedInformation" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CreateCreditBody) validateMerchantInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.MerchantInformation) { // not required
		return nil
	}

	if o.MerchantInformation != nil {
		if err := o.MerchantInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "merchantInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "merchantInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditBody) validateOrderInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.OrderInformation) { // not required
		return nil
	}

	if o.OrderInformation != nil {
		if err := o.OrderInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "orderInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "orderInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditBody) validatePaymentInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.PaymentInformation) { // not required
		return nil
	}

	if o.PaymentInformation != nil {
		if err := o.PaymentInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "paymentInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "paymentInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditBody) validatePointOfSaleInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.PointOfSaleInformation) { // not required
		return nil
	}

	if o.PointOfSaleInformation != nil {
		if err := o.PointOfSaleInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "pointOfSaleInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "pointOfSaleInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditBody) validateProcessingInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ProcessingInformation) { // not required
		return nil
	}

	if o.ProcessingInformation != nil {
		if err := o.ProcessingInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "processingInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "processingInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditBody) validatePromotionInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.PromotionInformation) { // not required
		return nil
	}

	if o.PromotionInformation != nil {
		if err := o.PromotionInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "promotionInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "promotionInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditBody) validateTravelInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.TravelInformation) { // not required
		return nil
	}

	if o.TravelInformation != nil {
		if err := o.TravelInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "travelInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "travelInformation")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this create credit body based on the context it is used
func (o *CreateCreditBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateAggregatorInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateBuyerInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateClientReferenceInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateDeviceInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateInstallmentInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateMerchantDefinedInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateMerchantInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateOrderInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidatePaymentInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidatePointOfSaleInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateProcessingInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidatePromotionInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateTravelInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditBody) contextValidateAggregatorInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.AggregatorInformation != nil {
		if err := o.AggregatorInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "aggregatorInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "aggregatorInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditBody) contextValidateBuyerInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.BuyerInformation != nil {
		if err := o.BuyerInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "buyerInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "buyerInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditBody) contextValidateClientReferenceInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ClientReferenceInformation != nil {
		if err := o.ClientReferenceInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "clientReferenceInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "clientReferenceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditBody) contextValidateDeviceInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.DeviceInformation != nil {
		if err := o.DeviceInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "deviceInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "deviceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditBody) contextValidateInstallmentInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.InstallmentInformation != nil {
		if err := o.InstallmentInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "installmentInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "installmentInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditBody) contextValidateMerchantDefinedInformation(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.MerchantDefinedInformation); i++ {

		if o.MerchantDefinedInformation[i] != nil {
			if err := o.MerchantDefinedInformation[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("createCreditRequest" + "." + "merchantDefinedInformation" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("createCreditRequest" + "." + "merchantDefinedInformation" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CreateCreditBody) contextValidateMerchantInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.MerchantInformation != nil {
		if err := o.MerchantInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "merchantInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "merchantInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditBody) contextValidateOrderInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.OrderInformation != nil {
		if err := o.OrderInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "orderInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "orderInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditBody) contextValidatePaymentInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.PaymentInformation != nil {
		if err := o.PaymentInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "paymentInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "paymentInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditBody) contextValidatePointOfSaleInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.PointOfSaleInformation != nil {
		if err := o.PointOfSaleInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "pointOfSaleInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "pointOfSaleInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditBody) contextValidateProcessingInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ProcessingInformation != nil {
		if err := o.ProcessingInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "processingInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "processingInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditBody) contextValidatePromotionInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.PromotionInformation != nil {
		if err := o.PromotionInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "promotionInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "promotionInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditBody) contextValidateTravelInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.TravelInformation != nil {
		if err := o.TravelInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "travelInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "travelInformation")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditBody) UnmarshalBinary(b []byte) error {
	var res CreateCreditBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditCreatedBody ptsV2CreditsPost201Response
// Example: {"_links":{"self":{"href":"/pts/v2/credits/4963014324246004901546","method":"GET"},"void":{"href":"/pts/v2/credits/4963014324246004901546/voids","method":"POST"}},"clientReferenceInformation":{"code":"12345678"},"creditAmountDetails":{"creditAmount":"200.00","currency":"usd"},"id":"4963014324246004901546","orderInformation":{"amountDetails":{"currency":"usd"}},"reconciliationId":"39570714X3E1LBQ8","status":"200","statusInformation":{"message":"Successful transaction.","reason":"SUCCESS"},"submitTimeUtc":"2017-06-01T071712Z"}
swagger:model CreateCreditCreatedBody
*/
type CreateCreditCreatedBody struct {

	// links
	Links *CreateCreditCreatedBodyLinks `json:"_links,omitempty"`

	// client reference information
	ClientReferenceInformation *CreateCreditCreatedBodyClientReferenceInformation `json:"clientReferenceInformation,omitempty"`

	// credit amount details
	CreditAmountDetails *CreateCreditCreatedBodyCreditAmountDetails `json:"creditAmountDetails,omitempty"`

	// An unique identification number generated by Cybersource to identify the submitted request. Returned by all services.
	// It is also appended to the endpoint of the resource.
	// On incremental authorizations, this value with be the same as the identification number returned in the original authorization response.
	//
	// Max Length: 26
	ID string `json:"id,omitempty"`

	// order information
	OrderInformation *CreateCreditCreatedBodyOrderInformation `json:"orderInformation,omitempty"`

	// payment information
	PaymentInformation *CreateCreditCreatedBodyPaymentInformation `json:"paymentInformation,omitempty"`

	// point of sale information
	PointOfSaleInformation *CreateCreditCreatedBodyPointOfSaleInformation `json:"pointOfSaleInformation,omitempty"`

	// processing information
	ProcessingInformation *CreateCreditCreatedBodyProcessingInformation `json:"processingInformation,omitempty"`

	// processor information
	ProcessorInformation *CreateCreditCreatedBodyProcessorInformation `json:"processorInformation,omitempty"`

	// Reference number for the transaction.
	// Depending on how your Cybersource account is configured, this value could either be provided in the API request or generated by CyberSource.
	// The actual value used in the request to the processor is provided back to you by Cybersource in the response.
	//
	// Max Length: 60
	ReconciliationID string `json:"reconciliationId,omitempty"`

	// The status of the submitted transaction.
	//
	// Possible values:
	//  - PENDING
	//  - COMPLETED (as in the case of PIN Debit Full Financial Credit)
	//
	Status string `json:"status,omitempty"`

	// Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ`
	// **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.).
	// The `T` separates the date and the time. The `Z` indicates UTC.
	//
	// Returned by Cybersource for all services.
	//
	SubmitTimeUtc string `json:"submitTimeUtc,omitempty"`
}

// Validate validates this create credit created body
func (o *CreateCreditCreatedBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateClientReferenceInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCreditAmountDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOrderInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePaymentInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePointOfSaleInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProcessingInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProcessorInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateReconciliationID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditCreatedBody) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(o.Links) { // not required
		return nil
	}

	if o.Links != nil {
		if err := o.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditCreated" + "." + "_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditCreated" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditCreatedBody) validateClientReferenceInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ClientReferenceInformation) { // not required
		return nil
	}

	if o.ClientReferenceInformation != nil {
		if err := o.ClientReferenceInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditCreated" + "." + "clientReferenceInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditCreated" + "." + "clientReferenceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditCreatedBody) validateCreditAmountDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.CreditAmountDetails) { // not required
		return nil
	}

	if o.CreditAmountDetails != nil {
		if err := o.CreditAmountDetails.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditCreated" + "." + "creditAmountDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditCreated" + "." + "creditAmountDetails")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditCreatedBody) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditCreated"+"."+"id", "body", o.ID, 26); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditCreatedBody) validateOrderInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.OrderInformation) { // not required
		return nil
	}

	if o.OrderInformation != nil {
		if err := o.OrderInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditCreated" + "." + "orderInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditCreated" + "." + "orderInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditCreatedBody) validatePaymentInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.PaymentInformation) { // not required
		return nil
	}

	if o.PaymentInformation != nil {
		if err := o.PaymentInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditCreated" + "." + "paymentInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditCreated" + "." + "paymentInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditCreatedBody) validatePointOfSaleInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.PointOfSaleInformation) { // not required
		return nil
	}

	if o.PointOfSaleInformation != nil {
		if err := o.PointOfSaleInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditCreated" + "." + "pointOfSaleInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditCreated" + "." + "pointOfSaleInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditCreatedBody) validateProcessingInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ProcessingInformation) { // not required
		return nil
	}

	if o.ProcessingInformation != nil {
		if err := o.ProcessingInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditCreated" + "." + "processingInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditCreated" + "." + "processingInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditCreatedBody) validateProcessorInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ProcessorInformation) { // not required
		return nil
	}

	if o.ProcessorInformation != nil {
		if err := o.ProcessorInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditCreated" + "." + "processorInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditCreated" + "." + "processorInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditCreatedBody) validateReconciliationID(formats strfmt.Registry) error {
	if swag.IsZero(o.ReconciliationID) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditCreated"+"."+"reconciliationId", "body", o.ReconciliationID, 60); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this create credit created body based on the context it is used
func (o *CreateCreditCreatedBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateClientReferenceInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateCreditAmountDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateOrderInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidatePaymentInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidatePointOfSaleInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateProcessingInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateProcessorInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditCreatedBody) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if o.Links != nil {
		if err := o.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditCreated" + "." + "_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditCreated" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditCreatedBody) contextValidateClientReferenceInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ClientReferenceInformation != nil {
		if err := o.ClientReferenceInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditCreated" + "." + "clientReferenceInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditCreated" + "." + "clientReferenceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditCreatedBody) contextValidateCreditAmountDetails(ctx context.Context, formats strfmt.Registry) error {

	if o.CreditAmountDetails != nil {
		if err := o.CreditAmountDetails.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditCreated" + "." + "creditAmountDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditCreated" + "." + "creditAmountDetails")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditCreatedBody) contextValidateOrderInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.OrderInformation != nil {
		if err := o.OrderInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditCreated" + "." + "orderInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditCreated" + "." + "orderInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditCreatedBody) contextValidatePaymentInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.PaymentInformation != nil {
		if err := o.PaymentInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditCreated" + "." + "paymentInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditCreated" + "." + "paymentInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditCreatedBody) contextValidatePointOfSaleInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.PointOfSaleInformation != nil {
		if err := o.PointOfSaleInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditCreated" + "." + "pointOfSaleInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditCreated" + "." + "pointOfSaleInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditCreatedBody) contextValidateProcessingInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ProcessingInformation != nil {
		if err := o.ProcessingInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditCreated" + "." + "processingInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditCreated" + "." + "processingInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditCreatedBody) contextValidateProcessorInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ProcessorInformation != nil {
		if err := o.ProcessorInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditCreated" + "." + "processorInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditCreated" + "." + "processorInformation")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditCreatedBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditCreatedBody) UnmarshalBinary(b []byte) error {
	var res CreateCreditCreatedBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditCreatedBodyClientReferenceInformation create credit created body client reference information
swagger:model CreateCreditCreatedBodyClientReferenceInformation
*/
type CreateCreditCreatedBodyClientReferenceInformation struct {

	// Merchant-generated order reference or tracking number. It is recommended that you send a unique value for each
	// transaction so that you can perform meaningful searches for the transaction.
	//
	// #### Used by
	// **Authorization**
	// Required field.
	//
	// #### PIN Debit
	// Requests for PIN debit reversals need to use the same merchant reference number that was used in the transaction that is being
	// reversed.
	//
	// Required field for all PIN Debit requests (purchase, credit, and reversal).
	//
	// #### FDC Nashville Global
	// Certain circumstances can cause the processor to truncate this value to 15 or 17 characters for Level II and Level III processing, which can cause a discrepancy between the value you submit and the value included in some processor reports.
	//
	// Max Length: 50
	Code string `json:"code,omitempty"`

	// Merchant ID that was used to create the subscription or customer profile for which the service was requested.
	//
	// If your CyberSource account is enabled for Recurring Billing, this field is returned only if you are using
	// subscription sharing and if your merchant ID is in the same merchant ID pool as the owner merchant ID.
	//
	// If your CyberSource account is enabled for Payment Tokenization, this field is returned only if you are using
	// profile sharing and if your merchant ID is in the same merchant ID pool as the owner merchant ID.
	//
	OwnerMerchantID string `json:"ownerMerchantId,omitempty"`

	// Date and time at your physical location.
	//
	// Format: `YYYYMMDDhhmmss`, where YYYY = year, MM = month, DD = day, hh = hour, mm = minutes ss = seconds
	//
	// #### PIN Debit
	// Optional field for PIN Debit purchase and credit requests.
	//
	// Max Length: 14
	SubmitLocalDateTime string `json:"submitLocalDateTime,omitempty"`
}

// Validate validates this create credit created body client reference information
func (o *CreateCreditCreatedBodyClientReferenceInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSubmitLocalDateTime(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditCreatedBodyClientReferenceInformation) validateCode(formats strfmt.Registry) error {
	if swag.IsZero(o.Code) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditCreated"+"."+"clientReferenceInformation"+"."+"code", "body", o.Code, 50); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditCreatedBodyClientReferenceInformation) validateSubmitLocalDateTime(formats strfmt.Registry) error {
	if swag.IsZero(o.SubmitLocalDateTime) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditCreated"+"."+"clientReferenceInformation"+"."+"submitLocalDateTime", "body", o.SubmitLocalDateTime, 14); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create credit created body client reference information based on context it is used
func (o *CreateCreditCreatedBodyClientReferenceInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditCreatedBodyClientReferenceInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditCreatedBodyClientReferenceInformation) UnmarshalBinary(b []byte) error {
	var res CreateCreditCreatedBodyClientReferenceInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditCreatedBodyCreditAmountDetails create credit created body credit amount details
swagger:model CreateCreditCreatedBodyCreditAmountDetails
*/
type CreateCreditCreatedBodyCreditAmountDetails struct {

	// Amount that was credited to the cardholders account.
	//
	// Returned by PIN debit credit.
	//
	// Max Length: 15
	CreditAmount string `json:"creditAmount,omitempty"`

	// Currency used for the order. Use the three-character [ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)
	//
	// #### Used by
	// **Authorization**
	// Required field.
	//
	// **Authorization Reversal**
	// For an authorization reversal (`reversalInformation`) or a capture (`processingOptions.capture` is set to `true`), you must use the same currency that you used in your payment authorization request.
	//
	// #### PIN Debit
	// Currency for the amount you requested for the PIN debit purchase. This value is returned for partial authorizations. The issuing bank can approve a partial amount if the balance on the debit card is less than the requested transaction amount. For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf).
	// Returned by PIN debit purchase.
	//
	// For PIN debit reversal requests, you must use the same currency that was used for the PIN debit purchase or PIN debit credit that you are reversing.
	// For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf).
	//
	// Required field for PIN Debit purchase and PIN Debit credit requests.
	// Optional field for PIN Debit reversal requests.
	//
	// #### GPX
	// This field is optional for reversing an authorization or credit.
	//
	// #### DCC for First Data
	// Your local currency. For details, see the `currency` field description in [Dynamic Currency Conversion For First Data Using the SCMP API](http://apps.cybersource.com/library/documentation/dev_guides/DCC_FirstData_SCMP/DCC_FirstData_SCMP_API.pdf).
	//
	// #### Tax Calculation
	// Required for international tax and value added tax only.
	// Optional for U.S. and Canadian taxes.
	// Your local currency.
	//
	// Max Length: 3
	Currency string `json:"currency,omitempty"`
}

// Validate validates this create credit created body credit amount details
func (o *CreateCreditCreatedBodyCreditAmountDetails) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCreditAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCurrency(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditCreatedBodyCreditAmountDetails) validateCreditAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.CreditAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditCreated"+"."+"creditAmountDetails"+"."+"creditAmount", "body", o.CreditAmount, 15); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditCreatedBodyCreditAmountDetails) validateCurrency(formats strfmt.Registry) error {
	if swag.IsZero(o.Currency) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditCreated"+"."+"creditAmountDetails"+"."+"currency", "body", o.Currency, 3); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create credit created body credit amount details based on context it is used
func (o *CreateCreditCreatedBodyCreditAmountDetails) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditCreatedBodyCreditAmountDetails) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditCreatedBodyCreditAmountDetails) UnmarshalBinary(b []byte) error {
	var res CreateCreditCreatedBodyCreditAmountDetails
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditCreatedBodyLinks create credit created body links
swagger:model CreateCreditCreatedBodyLinks
*/
type CreateCreditCreatedBodyLinks struct {

	// self
	Self *CreateCreditCreatedBodyLinksSelf `json:"self,omitempty"`

	// void
	Void *CreateCreditCreatedBodyLinksVoid `json:"void,omitempty"`
}

// Validate validates this create credit created body links
func (o *CreateCreditCreatedBodyLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateVoid(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditCreatedBodyLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(o.Self) { // not required
		return nil
	}

	if o.Self != nil {
		if err := o.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditCreated" + "." + "_links" + "." + "self")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditCreated" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditCreatedBodyLinks) validateVoid(formats strfmt.Registry) error {
	if swag.IsZero(o.Void) { // not required
		return nil
	}

	if o.Void != nil {
		if err := o.Void.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditCreated" + "." + "_links" + "." + "void")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditCreated" + "." + "_links" + "." + "void")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this create credit created body links based on the context it is used
func (o *CreateCreditCreatedBodyLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateVoid(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditCreatedBodyLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if o.Self != nil {
		if err := o.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditCreated" + "." + "_links" + "." + "self")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditCreated" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditCreatedBodyLinks) contextValidateVoid(ctx context.Context, formats strfmt.Registry) error {

	if o.Void != nil {
		if err := o.Void.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditCreated" + "." + "_links" + "." + "void")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditCreated" + "." + "_links" + "." + "void")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditCreatedBodyLinks) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditCreatedBodyLinks) UnmarshalBinary(b []byte) error {
	var res CreateCreditCreatedBodyLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditCreatedBodyLinksSelf create credit created body links self
swagger:model CreateCreditCreatedBodyLinksSelf
*/
type CreateCreditCreatedBodyLinksSelf struct {

	// This is the endpoint of the resource that was created by the successful request.
	Href string `json:"href,omitempty"`

	// `method` refers to the HTTP method that you can send to the `self` endpoint to retrieve details of the resource.
	Method string `json:"method,omitempty"`
}

// Validate validates this create credit created body links self
func (o *CreateCreditCreatedBodyLinksSelf) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this create credit created body links self based on context it is used
func (o *CreateCreditCreatedBodyLinksSelf) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditCreatedBodyLinksSelf) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditCreatedBodyLinksSelf) UnmarshalBinary(b []byte) error {
	var res CreateCreditCreatedBodyLinksSelf
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditCreatedBodyLinksVoid create credit created body links void
swagger:model CreateCreditCreatedBodyLinksVoid
*/
type CreateCreditCreatedBodyLinksVoid struct {

	// This is the endpoint of the resource that was created by the successful request.
	Href string `json:"href,omitempty"`

	// `method` refers to the HTTP method that you can send to the `self` endpoint to retrieve details of the resource.
	Method string `json:"method,omitempty"`
}

// Validate validates this create credit created body links void
func (o *CreateCreditCreatedBodyLinksVoid) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this create credit created body links void based on context it is used
func (o *CreateCreditCreatedBodyLinksVoid) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditCreatedBodyLinksVoid) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditCreatedBodyLinksVoid) UnmarshalBinary(b []byte) error {
	var res CreateCreditCreatedBodyLinksVoid
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditCreatedBodyOrderInformation create credit created body order information
swagger:model CreateCreditCreatedBodyOrderInformation
*/
type CreateCreditCreatedBodyOrderInformation struct {

	// invoice details
	InvoiceDetails *CreateCreditCreatedBodyOrderInformationInvoiceDetails `json:"invoiceDetails,omitempty"`
}

// Validate validates this create credit created body order information
func (o *CreateCreditCreatedBodyOrderInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateInvoiceDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditCreatedBodyOrderInformation) validateInvoiceDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.InvoiceDetails) { // not required
		return nil
	}

	if o.InvoiceDetails != nil {
		if err := o.InvoiceDetails.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditCreated" + "." + "orderInformation" + "." + "invoiceDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditCreated" + "." + "orderInformation" + "." + "invoiceDetails")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this create credit created body order information based on the context it is used
func (o *CreateCreditCreatedBodyOrderInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateInvoiceDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditCreatedBodyOrderInformation) contextValidateInvoiceDetails(ctx context.Context, formats strfmt.Registry) error {

	if o.InvoiceDetails != nil {
		if err := o.InvoiceDetails.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditCreated" + "." + "orderInformation" + "." + "invoiceDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditCreated" + "." + "orderInformation" + "." + "invoiceDetails")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditCreatedBodyOrderInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditCreatedBodyOrderInformation) UnmarshalBinary(b []byte) error {
	var res CreateCreditCreatedBodyOrderInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditCreatedBodyOrderInformationInvoiceDetails create credit created body order information invoice details
swagger:model CreateCreditCreatedBodyOrderInformationInvoiceDetails
*/
type CreateCreditCreatedBodyOrderInformationInvoiceDetails struct {

	// Indicates whether CyberSource sent the Level III information to the processor. The possible values are:
	//
	// If your account is not enabled for Level III data or if you did not include the purchasing level field in your
	// request, CyberSource does not include the Level III data in the request sent to the processor.
	//
	// Possible values:
	// - **true**
	// - **false**
	//
	Level3TransmissionStatus bool `json:"level3TransmissionStatus,omitempty"`
}

// Validate validates this create credit created body order information invoice details
func (o *CreateCreditCreatedBodyOrderInformationInvoiceDetails) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this create credit created body order information invoice details based on context it is used
func (o *CreateCreditCreatedBodyOrderInformationInvoiceDetails) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditCreatedBodyOrderInformationInvoiceDetails) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditCreatedBodyOrderInformationInvoiceDetails) UnmarshalBinary(b []byte) error {
	var res CreateCreditCreatedBodyOrderInformationInvoiceDetails
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditCreatedBodyPaymentInformation create credit created body payment information
swagger:model CreateCreditCreatedBodyPaymentInformation
*/
type CreateCreditCreatedBodyPaymentInformation struct {

	// bank
	Bank *CreateCreditCreatedBodyPaymentInformationBank `json:"bank,omitempty"`

	// customer
	Customer *CreateCreditCreatedBodyPaymentInformationCustomer `json:"customer,omitempty"`

	// instrument identifier
	InstrumentIdentifier *CreateCreditCreatedBodyPaymentInformationInstrumentIdentifier `json:"instrumentIdentifier,omitempty"`

	// payment instrument
	PaymentInstrument *CreateCreditCreatedBodyPaymentInformationPaymentInstrument `json:"paymentInstrument,omitempty"`

	// shipping address
	ShippingAddress *CreateCreditCreatedBodyPaymentInformationShippingAddress `json:"shippingAddress,omitempty"`
}

// Validate validates this create credit created body payment information
func (o *CreateCreditCreatedBodyPaymentInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateBank(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCustomer(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateInstrumentIdentifier(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePaymentInstrument(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateShippingAddress(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditCreatedBodyPaymentInformation) validateBank(formats strfmt.Registry) error {
	if swag.IsZero(o.Bank) { // not required
		return nil
	}

	if o.Bank != nil {
		if err := o.Bank.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditCreated" + "." + "paymentInformation" + "." + "bank")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditCreated" + "." + "paymentInformation" + "." + "bank")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditCreatedBodyPaymentInformation) validateCustomer(formats strfmt.Registry) error {
	if swag.IsZero(o.Customer) { // not required
		return nil
	}

	if o.Customer != nil {
		if err := o.Customer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditCreated" + "." + "paymentInformation" + "." + "customer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditCreated" + "." + "paymentInformation" + "." + "customer")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditCreatedBodyPaymentInformation) validateInstrumentIdentifier(formats strfmt.Registry) error {
	if swag.IsZero(o.InstrumentIdentifier) { // not required
		return nil
	}

	if o.InstrumentIdentifier != nil {
		if err := o.InstrumentIdentifier.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditCreated" + "." + "paymentInformation" + "." + "instrumentIdentifier")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditCreated" + "." + "paymentInformation" + "." + "instrumentIdentifier")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditCreatedBodyPaymentInformation) validatePaymentInstrument(formats strfmt.Registry) error {
	if swag.IsZero(o.PaymentInstrument) { // not required
		return nil
	}

	if o.PaymentInstrument != nil {
		if err := o.PaymentInstrument.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditCreated" + "." + "paymentInformation" + "." + "paymentInstrument")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditCreated" + "." + "paymentInformation" + "." + "paymentInstrument")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditCreatedBodyPaymentInformation) validateShippingAddress(formats strfmt.Registry) error {
	if swag.IsZero(o.ShippingAddress) { // not required
		return nil
	}

	if o.ShippingAddress != nil {
		if err := o.ShippingAddress.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditCreated" + "." + "paymentInformation" + "." + "shippingAddress")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditCreated" + "." + "paymentInformation" + "." + "shippingAddress")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this create credit created body payment information based on the context it is used
func (o *CreateCreditCreatedBodyPaymentInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateBank(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateCustomer(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateInstrumentIdentifier(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidatePaymentInstrument(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateShippingAddress(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditCreatedBodyPaymentInformation) contextValidateBank(ctx context.Context, formats strfmt.Registry) error {

	if o.Bank != nil {
		if err := o.Bank.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditCreated" + "." + "paymentInformation" + "." + "bank")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditCreated" + "." + "paymentInformation" + "." + "bank")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditCreatedBodyPaymentInformation) contextValidateCustomer(ctx context.Context, formats strfmt.Registry) error {

	if o.Customer != nil {
		if err := o.Customer.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditCreated" + "." + "paymentInformation" + "." + "customer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditCreated" + "." + "paymentInformation" + "." + "customer")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditCreatedBodyPaymentInformation) contextValidateInstrumentIdentifier(ctx context.Context, formats strfmt.Registry) error {

	if o.InstrumentIdentifier != nil {
		if err := o.InstrumentIdentifier.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditCreated" + "." + "paymentInformation" + "." + "instrumentIdentifier")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditCreated" + "." + "paymentInformation" + "." + "instrumentIdentifier")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditCreatedBodyPaymentInformation) contextValidatePaymentInstrument(ctx context.Context, formats strfmt.Registry) error {

	if o.PaymentInstrument != nil {
		if err := o.PaymentInstrument.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditCreated" + "." + "paymentInformation" + "." + "paymentInstrument")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditCreated" + "." + "paymentInformation" + "." + "paymentInstrument")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditCreatedBodyPaymentInformation) contextValidateShippingAddress(ctx context.Context, formats strfmt.Registry) error {

	if o.ShippingAddress != nil {
		if err := o.ShippingAddress.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditCreated" + "." + "paymentInformation" + "." + "shippingAddress")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditCreated" + "." + "paymentInformation" + "." + "shippingAddress")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditCreatedBodyPaymentInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditCreatedBodyPaymentInformation) UnmarshalBinary(b []byte) error {
	var res CreateCreditCreatedBodyPaymentInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditCreatedBodyPaymentInformationBank create credit created body payment information bank
swagger:model CreateCreditCreatedBodyPaymentInformationBank
*/
type CreateCreditCreatedBodyPaymentInformationBank struct {

	// account
	Account *CreateCreditCreatedBodyPaymentInformationBankAccount `json:"account,omitempty"`

	// Corrected account number from the ACH verification service.
	//
	// For details, see `ecp_debit_corrected_routing_number` or `ecp_credit_corrected_routing_number` reply field descriptions in the [Electronic Check Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/EChecks_SCMP_API/html/)
	//
	// Max Length: 9
	CorrectedRoutingNumber string `json:"correctedRoutingNumber,omitempty"`
}

// Validate validates this create credit created body payment information bank
func (o *CreateCreditCreatedBodyPaymentInformationBank) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAccount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCorrectedRoutingNumber(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditCreatedBodyPaymentInformationBank) validateAccount(formats strfmt.Registry) error {
	if swag.IsZero(o.Account) { // not required
		return nil
	}

	if o.Account != nil {
		if err := o.Account.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditCreated" + "." + "paymentInformation" + "." + "bank" + "." + "account")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditCreated" + "." + "paymentInformation" + "." + "bank" + "." + "account")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditCreatedBodyPaymentInformationBank) validateCorrectedRoutingNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.CorrectedRoutingNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditCreated"+"."+"paymentInformation"+"."+"bank"+"."+"correctedRoutingNumber", "body", o.CorrectedRoutingNumber, 9); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this create credit created body payment information bank based on the context it is used
func (o *CreateCreditCreatedBodyPaymentInformationBank) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateAccount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditCreatedBodyPaymentInformationBank) contextValidateAccount(ctx context.Context, formats strfmt.Registry) error {

	if o.Account != nil {
		if err := o.Account.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditCreated" + "." + "paymentInformation" + "." + "bank" + "." + "account")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditCreated" + "." + "paymentInformation" + "." + "bank" + "." + "account")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditCreatedBodyPaymentInformationBank) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditCreatedBodyPaymentInformationBank) UnmarshalBinary(b []byte) error {
	var res CreateCreditCreatedBodyPaymentInformationBank
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditCreatedBodyPaymentInformationBankAccount create credit created body payment information bank account
swagger:model CreateCreditCreatedBodyPaymentInformationBankAccount
*/
type CreateCreditCreatedBodyPaymentInformationBankAccount struct {

	// Corrected account number from the ACH verification service.
	//
	// For details, see `ecp_debit_corrected_account_number` or `ecp_credit_corrected_account_number` field descriptions in [Electronic Check Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/EChecks_SCMP_API/html/)
	//
	// Max Length: 17
	CorrectedAccountNumber string `json:"correctedAccountNumber,omitempty"`
}

// Validate validates this create credit created body payment information bank account
func (o *CreateCreditCreatedBodyPaymentInformationBankAccount) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCorrectedAccountNumber(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditCreatedBodyPaymentInformationBankAccount) validateCorrectedAccountNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.CorrectedAccountNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditCreated"+"."+"paymentInformation"+"."+"bank"+"."+"account"+"."+"correctedAccountNumber", "body", o.CorrectedAccountNumber, 17); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create credit created body payment information bank account based on context it is used
func (o *CreateCreditCreatedBodyPaymentInformationBankAccount) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditCreatedBodyPaymentInformationBankAccount) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditCreatedBodyPaymentInformationBankAccount) UnmarshalBinary(b []byte) error {
	var res CreateCreditCreatedBodyPaymentInformationBankAccount
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditCreatedBodyPaymentInformationCustomer create credit created body payment information customer
swagger:model CreateCreditCreatedBodyPaymentInformationCustomer
*/
type CreateCreditCreatedBodyPaymentInformationCustomer struct {

	// Unique identifier for the customer's card and billing information.
	//
	// When you use Payment Tokenization or Recurring Billing and you include this value in
	// your request, many of the fields that are normally required for an authorization or credit
	// become optional.
	//
	// **NOTE** When you use Payment Tokenization or Recurring Billing, the value for the Customer ID is actually the Cybersource payment token for a customer. This token stores information such as the consumers card number so it can be applied towards bill payments, recurring payments, or one-time payments. By using this token in a payment API request, the merchant doesn't need to pass in data such as the card number or expiration date in the request itself.
	//
	// For details, see the `subscription_id` field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	CustomerID string `json:"customerId,omitempty"`

	// Unique identifier for the Customer token used in the transaction.
	// When you include this value in your request, many of the fields that are normally required for an authorization or credit
	// become optional.
	//
	// Max Length: 32
	// Min Length: 1
	ID string `json:"id,omitempty"`
}

// Validate validates this create credit created body payment information customer
func (o *CreateCreditCreatedBodyPaymentInformationCustomer) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditCreatedBodyPaymentInformationCustomer) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MinLength("createCreditCreated"+"."+"paymentInformation"+"."+"customer"+"."+"id", "body", o.ID, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("createCreditCreated"+"."+"paymentInformation"+"."+"customer"+"."+"id", "body", o.ID, 32); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create credit created body payment information customer based on context it is used
func (o *CreateCreditCreatedBodyPaymentInformationCustomer) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditCreatedBodyPaymentInformationCustomer) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditCreatedBodyPaymentInformationCustomer) UnmarshalBinary(b []byte) error {
	var res CreateCreditCreatedBodyPaymentInformationCustomer
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditCreatedBodyPaymentInformationInstrumentIdentifier create credit created body payment information instrument identifier
swagger:model CreateCreditCreatedBodyPaymentInformationInstrumentIdentifier
*/
type CreateCreditCreatedBodyPaymentInformationInstrumentIdentifier struct {

	// Unique identifier for the Instrument Identifier token used in the transaction.
	// When you include this value in your request, many of the fields that can be supplied for an authorization or credit
	// become optional.
	//
	// Max Length: 32
	// Min Length: 12
	ID string `json:"id,omitempty"`

	// Issuers state for the card number.
	// Valid values:
	// - ACTIVE
	// - CLOSED : The account has been closed.
	//
	State string `json:"state,omitempty"`
}

// Validate validates this create credit created body payment information instrument identifier
func (o *CreateCreditCreatedBodyPaymentInformationInstrumentIdentifier) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditCreatedBodyPaymentInformationInstrumentIdentifier) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MinLength("createCreditCreated"+"."+"paymentInformation"+"."+"instrumentIdentifier"+"."+"id", "body", o.ID, 12); err != nil {
		return err
	}

	if err := validate.MaxLength("createCreditCreated"+"."+"paymentInformation"+"."+"instrumentIdentifier"+"."+"id", "body", o.ID, 32); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create credit created body payment information instrument identifier based on context it is used
func (o *CreateCreditCreatedBodyPaymentInformationInstrumentIdentifier) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditCreatedBodyPaymentInformationInstrumentIdentifier) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditCreatedBodyPaymentInformationInstrumentIdentifier) UnmarshalBinary(b []byte) error {
	var res CreateCreditCreatedBodyPaymentInformationInstrumentIdentifier
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditCreatedBodyPaymentInformationPaymentInstrument create credit created body payment information payment instrument
swagger:model CreateCreditCreatedBodyPaymentInformationPaymentInstrument
*/
type CreateCreditCreatedBodyPaymentInformationPaymentInstrument struct {

	// Unique identifier for the Payment Instrument token used in the transaction.
	// When you include this value in your request, many of the fields that are normally required for an authorization or credit
	// become optional.
	//
	// Max Length: 32
	// Min Length: 1
	ID string `json:"id,omitempty"`
}

// Validate validates this create credit created body payment information payment instrument
func (o *CreateCreditCreatedBodyPaymentInformationPaymentInstrument) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditCreatedBodyPaymentInformationPaymentInstrument) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MinLength("createCreditCreated"+"."+"paymentInformation"+"."+"paymentInstrument"+"."+"id", "body", o.ID, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("createCreditCreated"+"."+"paymentInformation"+"."+"paymentInstrument"+"."+"id", "body", o.ID, 32); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create credit created body payment information payment instrument based on context it is used
func (o *CreateCreditCreatedBodyPaymentInformationPaymentInstrument) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditCreatedBodyPaymentInformationPaymentInstrument) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditCreatedBodyPaymentInformationPaymentInstrument) UnmarshalBinary(b []byte) error {
	var res CreateCreditCreatedBodyPaymentInformationPaymentInstrument
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditCreatedBodyPaymentInformationShippingAddress create credit created body payment information shipping address
swagger:model CreateCreditCreatedBodyPaymentInformationShippingAddress
*/
type CreateCreditCreatedBodyPaymentInformationShippingAddress struct {

	// Unique identifier for the Customers Shipping Address token used in the transaction.
	// When you include this value in your request, many of the shipping fields that can be supplied for an authorization or credit
	// become optional.
	//
	// Max Length: 32
	// Min Length: 1
	ID string `json:"id,omitempty"`
}

// Validate validates this create credit created body payment information shipping address
func (o *CreateCreditCreatedBodyPaymentInformationShippingAddress) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditCreatedBodyPaymentInformationShippingAddress) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MinLength("createCreditCreated"+"."+"paymentInformation"+"."+"shippingAddress"+"."+"id", "body", o.ID, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("createCreditCreated"+"."+"paymentInformation"+"."+"shippingAddress"+"."+"id", "body", o.ID, 32); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create credit created body payment information shipping address based on context it is used
func (o *CreateCreditCreatedBodyPaymentInformationShippingAddress) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditCreatedBodyPaymentInformationShippingAddress) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditCreatedBodyPaymentInformationShippingAddress) UnmarshalBinary(b []byte) error {
	var res CreateCreditCreatedBodyPaymentInformationShippingAddress
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditCreatedBodyPointOfSaleInformation create credit created body point of sale information
swagger:model CreateCreditCreatedBodyPointOfSaleInformation
*/
type CreateCreditCreatedBodyPointOfSaleInformation struct {

	// Identifier for the terminal at your retail location. You can define this value yourself, but consult the processor for requirements.
	//
	// #### CyberSource through VisaNet
	// A list of all possible values is stored in your CyberSource account. If terminal ID validation is enabled for
	// your CyberSource account, the value you send for this field is validated against the list each time you include
	// the field in a request. To enable or disable terminal ID validation, contact CyberSource Customer Support.
	//
	// When you do not include this field in a request, CyberSource uses the default value that is defined in your CyberSource account.
	//
	// #### FDC Nashville Global
	// To have your account configured to support this field, contact CyberSource Customer Support. This value must be a value that FDC Nashville Global issued to you.
	//
	// #### For Payouts
	// This field is applicable for CyberSource through VisaNet.
	//
	// #### GPX
	// Identifier for the terminal at your retail location. A list of all possible values is stored in your account.
	// If terminal ID validation is enabled for your account, the value you send for this field is validated against
	// the list each time you include the field in a request. To enable or disable terminal ID validation, contact
	// customer support.
	//
	// When you do not include this field in a request, the default value that is defined in your account is used.
	//
	// Optional for authorizations.
	//
	// #### Used by
	// **Authorization**
	// Optional for the following processors. When you do not include this field in a request, the default value that is
	// defined in your account is used.
	//   - American Express Direct
	//   - Credit Mutuel-CIC
	//   - FDC Nashville Global
	//   - SIX
	// - Chase Paymentech Solutions: Optional field. If you include this field in your request, you must also include `pointOfSaleInformation.catLevel`.
	// - FDMS Nashville: The default value that is defined in your account is used.
	// - GPX
	// - OmniPay Direct: Optional field.
	//
	// For the following processors, this field is not used.
	// - GPN
	// - JCN Gateway
	// - RBS WorldPay Atlanta
	// - TSYS Acquiring Solutions
	// - Worldpay VAP
	//
	// #### Card Present reply
	// Terminal identifier assigned by the acquirer. This value must be printed on the receipt.
	//
	// Max Length: 8
	TerminalID string `json:"terminalId,omitempty"`
}

// Validate validates this create credit created body point of sale information
func (o *CreateCreditCreatedBodyPointOfSaleInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateTerminalID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditCreatedBodyPointOfSaleInformation) validateTerminalID(formats strfmt.Registry) error {
	if swag.IsZero(o.TerminalID) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditCreated"+"."+"pointOfSaleInformation"+"."+"terminalId", "body", o.TerminalID, 8); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create credit created body point of sale information based on context it is used
func (o *CreateCreditCreatedBodyPointOfSaleInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditCreatedBodyPointOfSaleInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditCreatedBodyPointOfSaleInformation) UnmarshalBinary(b []byte) error {
	var res CreateCreditCreatedBodyPointOfSaleInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditCreatedBodyProcessingInformation create credit created body processing information
swagger:model CreateCreditCreatedBodyProcessingInformation
*/
type CreateCreditCreatedBodyProcessingInformation struct {

	// bank transfer options
	BankTransferOptions *CreateCreditCreatedBodyProcessingInformationBankTransferOptions `json:"bankTransferOptions,omitempty"`

	// The possible values for the reply field are:
	// - `true` : the airline data was included in the request to the processor.
	// - `false` : the airline data was not included in the request to the processor.
	//
	// Returned by authorization, capture, or credit services.
	//
	EnhancedDataEnabled bool `json:"enhancedDataEnabled,omitempty"`
}

// Validate validates this create credit created body processing information
func (o *CreateCreditCreatedBodyProcessingInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateBankTransferOptions(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditCreatedBodyProcessingInformation) validateBankTransferOptions(formats strfmt.Registry) error {
	if swag.IsZero(o.BankTransferOptions) { // not required
		return nil
	}

	if o.BankTransferOptions != nil {
		if err := o.BankTransferOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditCreated" + "." + "processingInformation" + "." + "bankTransferOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditCreated" + "." + "processingInformation" + "." + "bankTransferOptions")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this create credit created body processing information based on the context it is used
func (o *CreateCreditCreatedBodyProcessingInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateBankTransferOptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditCreatedBodyProcessingInformation) contextValidateBankTransferOptions(ctx context.Context, formats strfmt.Registry) error {

	if o.BankTransferOptions != nil {
		if err := o.BankTransferOptions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditCreated" + "." + "processingInformation" + "." + "bankTransferOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditCreated" + "." + "processingInformation" + "." + "bankTransferOptions")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditCreatedBodyProcessingInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditCreatedBodyProcessingInformation) UnmarshalBinary(b []byte) error {
	var res CreateCreditCreatedBodyProcessingInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditCreatedBodyProcessingInformationBankTransferOptions create credit created body processing information bank transfer options
swagger:model CreateCreditCreatedBodyProcessingInformationBankTransferOptions
*/
type CreateCreditCreatedBodyProcessingInformationBankTransferOptions struct {

	// Method used for settlement.
	//
	// Possible values:
	// - `A`: Automated Clearing House (default for credits and for transactions using Canadian dollars)
	// - `F`: Facsimile draft (U.S. dollars only)
	// - `B`: Best possible (U.S. dollars only) (default if the field has not already been configured for your
	// merchant ID)
	//
	// For details, see `ecp_settlement_method` field description for credit cars and `ecp_debit_settlement_method` for debit cards in the [Electronic Check Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/EChecks_SCMP_API/html/)
	//
	// Max Length: 1
	SettlementMethod string `json:"settlementMethod,omitempty"`
}

// Validate validates this create credit created body processing information bank transfer options
func (o *CreateCreditCreatedBodyProcessingInformationBankTransferOptions) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateSettlementMethod(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditCreatedBodyProcessingInformationBankTransferOptions) validateSettlementMethod(formats strfmt.Registry) error {
	if swag.IsZero(o.SettlementMethod) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditCreated"+"."+"processingInformation"+"."+"bankTransferOptions"+"."+"settlementMethod", "body", o.SettlementMethod, 1); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create credit created body processing information bank transfer options based on context it is used
func (o *CreateCreditCreatedBodyProcessingInformationBankTransferOptions) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditCreatedBodyProcessingInformationBankTransferOptions) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditCreatedBodyProcessingInformationBankTransferOptions) UnmarshalBinary(b []byte) error {
	var res CreateCreditCreatedBodyProcessingInformationBankTransferOptions
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditCreatedBodyProcessorInformation create credit created body processor information
swagger:model CreateCreditCreatedBodyProcessorInformation
*/
type CreateCreditCreatedBodyProcessorInformation struct {

	// ach verification
	AchVerification *CreateCreditCreatedBodyProcessorInformationAchVerification `json:"achVerification,omitempty"`

	// Name of the Japanese acquirer that processed the transaction. Returned only for JCN Gateway.
	// Please contact the CyberSource Japan Support Group for more information.
	//
	// Max Length: 32
	ForwardedAcquirerCode string `json:"forwardedAcquirerCode,omitempty"`

	// Identifier that was assigned to you by your acquirer. This value must be printed on the receipt.
	//
	// #### Returned by
	// Authorizations and Credits.
	//
	// This reply field is only supported by merchants who have installed client software on their POS terminals and
	// use these processors:
	// - American Express Direct
	// - Credit Mutuel-CIC
	// - FDC Nashville Global
	// - OmniPay Direct
	// - SIX
	//
	// Max Length: 15
	MerchantNumber string `json:"merchantNumber,omitempty"`

	// For most processors, this is the error message sent directly from the bank. Returned only when the processor
	// returns this value.
	//
	// **Important** Do not use this field to evaluate the result of the authorization.
	//
	// #### PIN debit
	// Response value that is returned by the processor or bank.
	// **Important** Do not use this field to evaluate the results of the transaction request.
	//
	// Returned by PIN debit credit, PIN debit purchase, and PIN debit reversal.
	//
	// #### AIBMS
	// If this value is `08`, you can accept the transaction if the customer provides you with identification.
	//
	// #### Atos
	// This value is the response code sent from Atos and it might also include the response code from the bank.
	// Format: `aa,bb` with the two values separated by a comma and where:
	// - `aa` is the two-digit error message from Atos.
	// - `bb` is the optional two-digit error message from the bank.
	//
	// #### Comercio Latino
	// This value is the status code and the error or response code received from the processor separated by a colon.
	// Format: [status code]:E[error code] or [status code]:R[response code]
	// Example `2:R06`
	//
	// #### JCN Gateway
	// Processor-defined detail error code. The associated response category code is in the `processorInformation.responseCategoryCode` field.
	// String (3)
	//
	// Max Length: 10
	ResponseCode string `json:"responseCode,omitempty"`

	// Processor transaction ID.
	//
	// This value identifies the transaction on a host system. This value is supported only for Moneris. It contains
	// this information:
	//
	//  - Terminal used to process the transaction
	//  - Shift during which the transaction took place
	//  - Batch number
	//  - Transaction number within the batch
	//
	// You must store this value. If you give the customer a receipt, display this value on the receipt.
	//
	// Example For the value 66012345001069003:
	//
	//  - Terminal ID = 66012345
	//  - Shift number = 001
	//  - Batch number = 069
	//  - Transaction number = 003
	//
	// Max Length: 18
	TransactionID string `json:"transactionId,omitempty"`
}

// Validate validates this create credit created body processor information
func (o *CreateCreditCreatedBodyProcessorInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAchVerification(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateForwardedAcquirerCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMerchantNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateResponseCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTransactionID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditCreatedBodyProcessorInformation) validateAchVerification(formats strfmt.Registry) error {
	if swag.IsZero(o.AchVerification) { // not required
		return nil
	}

	if o.AchVerification != nil {
		if err := o.AchVerification.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditCreated" + "." + "processorInformation" + "." + "achVerification")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditCreated" + "." + "processorInformation" + "." + "achVerification")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditCreatedBodyProcessorInformation) validateForwardedAcquirerCode(formats strfmt.Registry) error {
	if swag.IsZero(o.ForwardedAcquirerCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditCreated"+"."+"processorInformation"+"."+"forwardedAcquirerCode", "body", o.ForwardedAcquirerCode, 32); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditCreatedBodyProcessorInformation) validateMerchantNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.MerchantNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditCreated"+"."+"processorInformation"+"."+"merchantNumber", "body", o.MerchantNumber, 15); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditCreatedBodyProcessorInformation) validateResponseCode(formats strfmt.Registry) error {
	if swag.IsZero(o.ResponseCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditCreated"+"."+"processorInformation"+"."+"responseCode", "body", o.ResponseCode, 10); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditCreatedBodyProcessorInformation) validateTransactionID(formats strfmt.Registry) error {
	if swag.IsZero(o.TransactionID) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditCreated"+"."+"processorInformation"+"."+"transactionId", "body", o.TransactionID, 18); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this create credit created body processor information based on the context it is used
func (o *CreateCreditCreatedBodyProcessorInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateAchVerification(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditCreatedBodyProcessorInformation) contextValidateAchVerification(ctx context.Context, formats strfmt.Registry) error {

	if o.AchVerification != nil {
		if err := o.AchVerification.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditCreated" + "." + "processorInformation" + "." + "achVerification")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditCreated" + "." + "processorInformation" + "." + "achVerification")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditCreatedBodyProcessorInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditCreatedBodyProcessorInformation) UnmarshalBinary(b []byte) error {
	var res CreateCreditCreatedBodyProcessorInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditCreatedBodyProcessorInformationAchVerification create credit created body processor information ach verification
swagger:model CreateCreditCreatedBodyProcessorInformationAchVerification
*/
type CreateCreditCreatedBodyProcessorInformationAchVerification struct {

	// Results from the ACH verification service.
	// For details about this service and the possible values for the results, see "ACH Verification" and "Verification Codes" in the [Electronic Check Services Using the SCMP API](https://apps.cybersource.com/library/documentation/dev_guides/EChecks_SCMP_API/html/).
	//
	// Max Length: 2
	ResultCode string `json:"resultCode,omitempty"`

	// Raw results from the ACH verification service.
	// For details about this service and the possible values for the raw results, see "ACH Verification" and "Verification Codes" in the [Electronic Check Services Using the SCMP API](https://apps.cybersource.com/library/documentation/dev_guides/EChecks_SCMP_API/html/).
	//
	// Max Length: 10
	ResultCodeRaw string `json:"resultCodeRaw,omitempty"`
}

// Validate validates this create credit created body processor information ach verification
func (o *CreateCreditCreatedBodyProcessorInformationAchVerification) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateResultCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateResultCodeRaw(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditCreatedBodyProcessorInformationAchVerification) validateResultCode(formats strfmt.Registry) error {
	if swag.IsZero(o.ResultCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditCreated"+"."+"processorInformation"+"."+"achVerification"+"."+"resultCode", "body", o.ResultCode, 2); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditCreatedBodyProcessorInformationAchVerification) validateResultCodeRaw(formats strfmt.Registry) error {
	if swag.IsZero(o.ResultCodeRaw) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditCreated"+"."+"processorInformation"+"."+"achVerification"+"."+"resultCodeRaw", "body", o.ResultCodeRaw, 10); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create credit created body processor information ach verification based on context it is used
func (o *CreateCreditCreatedBodyProcessorInformationAchVerification) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditCreatedBodyProcessorInformationAchVerification) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditCreatedBodyProcessorInformationAchVerification) UnmarshalBinary(b []byte) error {
	var res CreateCreditCreatedBodyProcessorInformationAchVerification
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditParamsBodyAggregatorInformation create credit params body aggregator information
swagger:model CreateCreditParamsBodyAggregatorInformation
*/
type CreateCreditParamsBodyAggregatorInformation struct {

	// Value that identifies you as a payment aggregator. Get this value from the
	// processor.
	//
	// #### CyberSource through VisaNet
	// The value for this field corresponds to the following data in the TC 33 capture file5:
	// - Record: CP01 TCR6
	// - Position: 95-105
	// - Field: MasterCard Payment Facilitator ID
	//
	// **FDC Compass**\
	// This value must consist of uppercase characters.
	//
	// For processor-specific information, see the `aggregator_id` field in [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 20
	AggregatorID string `json:"aggregatorId,omitempty"`

	// Your payment aggregator business name.
	//
	// **American Express Direct**\
	// The maximum length of the aggregator name depends on the length of the sub-merchant name. The combined length for both values must not exceed 36 characters.\
	//
	// #### CyberSource through VisaNet
	// With American Express, the maximum length of the aggregator name depends on the length of the sub-merchant name. The combined length for both values must not exceed 36 characters. The value for this field does not map to the TC 33 capture file5.
	//
	// **FDC Compass**\
	// This value must consist of uppercase characters.
	//
	// For processor-specific information, see the aggregator_name field in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 37
	Name string `json:"name,omitempty"`

	// sub merchant
	SubMerchant *CreateCreditParamsBodyAggregatorInformationSubMerchant `json:"subMerchant,omitempty"`
}

// Validate validates this create credit params body aggregator information
func (o *CreateCreditParamsBodyAggregatorInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAggregatorID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSubMerchant(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyAggregatorInformation) validateAggregatorID(formats strfmt.Registry) error {
	if swag.IsZero(o.AggregatorID) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"aggregatorInformation"+"."+"aggregatorId", "body", o.AggregatorID, 20); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyAggregatorInformation) validateName(formats strfmt.Registry) error {
	if swag.IsZero(o.Name) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"aggregatorInformation"+"."+"name", "body", o.Name, 37); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyAggregatorInformation) validateSubMerchant(formats strfmt.Registry) error {
	if swag.IsZero(o.SubMerchant) { // not required
		return nil
	}

	if o.SubMerchant != nil {
		if err := o.SubMerchant.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "aggregatorInformation" + "." + "subMerchant")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "aggregatorInformation" + "." + "subMerchant")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this create credit params body aggregator information based on the context it is used
func (o *CreateCreditParamsBodyAggregatorInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateSubMerchant(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyAggregatorInformation) contextValidateSubMerchant(ctx context.Context, formats strfmt.Registry) error {

	if o.SubMerchant != nil {
		if err := o.SubMerchant.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "aggregatorInformation" + "." + "subMerchant")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "aggregatorInformation" + "." + "subMerchant")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditParamsBodyAggregatorInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditParamsBodyAggregatorInformation) UnmarshalBinary(b []byte) error {
	var res CreateCreditParamsBodyAggregatorInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditParamsBodyAggregatorInformationSubMerchant create credit params body aggregator information sub merchant
swagger:model CreateCreditParamsBodyAggregatorInformationSubMerchant
*/
type CreateCreditParamsBodyAggregatorInformationSubMerchant struct {

	// First line of the sub-merchants street address.
	//
	// For processor-specific details, see `submerchant_street` field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// #### CyberSource through VisaNet
	// The value for this field does not map to the TC 33 capture file5.
	//
	// #### FDC Compass
	// This value must consist of uppercase characters.
	//
	// Max Length: 38
	Address1 string `json:"address1,omitempty"`

	// Sub-merchants state or province.
	//
	// For possible values and also aggregator support, see `submerchant_state` request field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// #### CyberSource through VisaNet
	// The value for this field does not map to the TC 33 capture file5.
	//
	// #### FDC Compass
	// This value must consist of uppercase characters.
	//
	// Max Length: 3
	AdministrativeArea string `json:"administrativeArea,omitempty"`

	// Sub-merchants country. Use the [ISO Standard Country Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf).
	//
	// #### CyberSource through VisaNet
	// The value for this field does not map to the TC 33 capture file.
	//
	// #### FDC Compass
	// This value must consist of uppercase characters.
	//
	// For details, see the `submerchant_country` request-level field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// Max Length: 3
	Country string `json:"country,omitempty"`

	// Sub-merchants email address.
	//
	// **Maximum length for processors**
	//
	//  - American Express Direct: 40
	//  - CyberSource through VisaNet: 40
	//  - FDC Compass: 40
	//  - FDC Nashville Global: 19
	//
	// #### CyberSource through VisaNet
	// With American Express, the value for this field corresponds to the following data in the TC 33 capture file:
	// - Record: CP01 TCRB
	// - Position: 25-64
	// - Field: American Express Seller E-mail Address
	//
	// **Note** The TC 33 Capture file contains information about the purchases and refunds that a merchant submits to CyberSource. CyberSource through VisaNet creates the TC 33 Capture file at the end of the day and sends it to the merchants acquirer, who uses this information to facilitate end-of-day clearing processing with payment card companies.
	//
	// Max Length: 40
	Email string `json:"email,omitempty"`

	// The ID you assigned to your sub-merchant.
	// CyberSource through VisaNet: For American Express transaction, the value for this field corresponds to the following data in the TC 33 capture file:
	// - Record: CP01 TCRB
	// - Position: 65-84
	// - Field: American Express Seller ID
	// For  Mastercard transactions, the value for this field corresponds to the following data in the TC 33 capture file:
	// - Record: CP01 TCR6
	// - Position: 117-131
	// - Field: Mastercard Sub-Merchant ID
	// FDC Compass: This value must consist of uppercase characters.
	//
	// American Express Direct: String (20)
	// CyberSource through VisaNet with American Express: String (20)
	// CyberSource through VisaNet with Mastercard: String (15)
	// FDC Compass: String (20)
	// FDC Nashville Global: String (14)
	//
	// Max Length: 20
	ID string `json:"id,omitempty"`

	// Sub-merchants city.
	//
	// For processor-specific details, see `submerchant_city` request field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// #### CyberSource through VisaNet
	// The value for this field does not map to the TC 33 capture file5.
	//
	// #### FDC Compass
	// This value must consist of uppercase characters.
	//
	// Max Length: 21
	Locality string `json:"locality,omitempty"`

	// Sub-merchants business name.
	//
	// #### American Express Direct
	// The maximum length of the sub-merchant name depends on the length of the aggregator name. The combined length for both values must not exceed 36 characters.
	//
	// #### CyberSource through VisaNet
	// With American Express, the maximum length of the sub-merchant name depends on the length of the aggregator name. The combined length for both values must not exceed 36 characters. The value for this field does not map to the TC 33 capture file5.
	//
	// #### FDC Compass
	// This value must consist of uppercase characters.
	//
	// #### FDC Nashville Global
	// With Mastercard, the maximum length of the sub-merchant name depends on the length of the aggregator name:
	// - If aggregator name length is 1 through 3, maximum sub-merchant name length is 21.
	// - If aggregator name length is 4 through 7, maximum sub-merchant name length is 17.
	// - If aggregator name length is 8 through 12, maximum sub-merchant name length is 12.
	//
	// Max Length: 37
	Name string `json:"name,omitempty"`

	// Sub-merchants telephone number.
	//
	// **Maximum length for procesors**
	//
	//  - American Express Direct: 20
	//  - CyberSource through VisaNet: 20
	//  - FDC Compass: 13
	//  - FDC Nashville Global: 10
	//
	// #### CyberSource through VisaNet
	// With American Express, the value for this field corresponds to the following data in the TC 33 capture file5:
	// - Record: CP01 TCRB
	// - Position: 5-24
	// - Field: American Express Seller Telephone Number
	//
	// **FDC Compass**\
	// This value must consist of uppercase characters. Use one of these recommended formats:\
	// `NNN-NNN-NNNN`\
	// `NNN-AAAAAAA`
	//
	// Max Length: 20
	PhoneNumber string `json:"phoneNumber,omitempty"`

	// Partial postal code for the sub-merchants address.
	//
	// For processor-specific details, see `submerchant_postal_code` request field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// #### CyberSource through VisaNet
	// The value for this field does not map to the TC 33 capture file5.
	//
	// #### FDC Compass
	// This value must consist of uppercase characters.
	//
	// Max Length: 15
	PostalCode string `json:"postalCode,omitempty"`
}

// Validate validates this create credit params body aggregator information sub merchant
func (o *CreateCreditParamsBodyAggregatorInformationSubMerchant) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAddress1(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAdministrativeArea(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEmail(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocality(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePhoneNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyAggregatorInformationSubMerchant) validateAddress1(formats strfmt.Registry) error {
	if swag.IsZero(o.Address1) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"aggregatorInformation"+"."+"subMerchant"+"."+"address1", "body", o.Address1, 38); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyAggregatorInformationSubMerchant) validateAdministrativeArea(formats strfmt.Registry) error {
	if swag.IsZero(o.AdministrativeArea) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"aggregatorInformation"+"."+"subMerchant"+"."+"administrativeArea", "body", o.AdministrativeArea, 3); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyAggregatorInformationSubMerchant) validateCountry(formats strfmt.Registry) error {
	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"aggregatorInformation"+"."+"subMerchant"+"."+"country", "body", o.Country, 3); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyAggregatorInformationSubMerchant) validateEmail(formats strfmt.Registry) error {
	if swag.IsZero(o.Email) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"aggregatorInformation"+"."+"subMerchant"+"."+"email", "body", o.Email, 40); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyAggregatorInformationSubMerchant) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"aggregatorInformation"+"."+"subMerchant"+"."+"id", "body", o.ID, 20); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyAggregatorInformationSubMerchant) validateLocality(formats strfmt.Registry) error {
	if swag.IsZero(o.Locality) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"aggregatorInformation"+"."+"subMerchant"+"."+"locality", "body", o.Locality, 21); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyAggregatorInformationSubMerchant) validateName(formats strfmt.Registry) error {
	if swag.IsZero(o.Name) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"aggregatorInformation"+"."+"subMerchant"+"."+"name", "body", o.Name, 37); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyAggregatorInformationSubMerchant) validatePhoneNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.PhoneNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"aggregatorInformation"+"."+"subMerchant"+"."+"phoneNumber", "body", o.PhoneNumber, 20); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyAggregatorInformationSubMerchant) validatePostalCode(formats strfmt.Registry) error {
	if swag.IsZero(o.PostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"aggregatorInformation"+"."+"subMerchant"+"."+"postalCode", "body", o.PostalCode, 15); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create credit params body aggregator information sub merchant based on context it is used
func (o *CreateCreditParamsBodyAggregatorInformationSubMerchant) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditParamsBodyAggregatorInformationSubMerchant) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditParamsBodyAggregatorInformationSubMerchant) UnmarshalBinary(b []byte) error {
	var res CreateCreditParamsBodyAggregatorInformationSubMerchant
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditParamsBodyBuyerInformation create credit params body buyer information
swagger:model CreateCreditParamsBodyBuyerInformation
*/
type CreateCreditParamsBodyBuyerInformation struct {

	// Your identifier for the customer.
	//
	// When a subscription or customer profile is being created, the maximum length for this field for most processors is 30. Otherwise, the maximum length is 100.
	//
	// #### Comercio Latino
	// For recurring payments in Mexico, the value is the customers contract number.
	// Note Before you request the authorization, you must inform the issuer of the customer contract numbers that will be used for recurring transactions.
	//
	// #### Worldpay VAP
	// For a follow-on credit with Worldpay VAP, CyberSource checks the following locations, in the order
	// given, for a customer account ID value and uses the first value it finds:
	// 1. `customer_account_id` value in the follow-on credit request
	// 2. Customer account ID value that was used for the capture that is being credited
	// 3. Customer account ID value that was used for the original authorization
	// If a customer account ID value cannot be found in any of these locations, then no value is used.
	//
	// For processor-specific information, see the `customer_account_id` field description in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 100
	MerchantCustomerID string `json:"merchantCustomerId,omitempty"`

	// Customers government-assigned tax identification number.
	//
	// #### Tax Calculation
	// Optional for international and value added taxes only. Not applicable to U.S. and Canadian taxes.
	//
	// For processor-specific information, see the purchaser_vat_registration_number field in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 20
	VatRegistrationNumber string `json:"vatRegistrationNumber,omitempty"`
}

// Validate validates this create credit params body buyer information
func (o *CreateCreditParamsBodyBuyerInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateMerchantCustomerID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateVatRegistrationNumber(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyBuyerInformation) validateMerchantCustomerID(formats strfmt.Registry) error {
	if swag.IsZero(o.MerchantCustomerID) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"buyerInformation"+"."+"merchantCustomerId", "body", o.MerchantCustomerID, 100); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyBuyerInformation) validateVatRegistrationNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.VatRegistrationNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"buyerInformation"+"."+"vatRegistrationNumber", "body", o.VatRegistrationNumber, 20); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create credit params body buyer information based on context it is used
func (o *CreateCreditParamsBodyBuyerInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditParamsBodyBuyerInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditParamsBodyBuyerInformation) UnmarshalBinary(b []byte) error {
	var res CreateCreditParamsBodyBuyerInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditParamsBodyClientReferenceInformation create credit params body client reference information
swagger:model CreateCreditParamsBodyClientReferenceInformation
*/
type CreateCreditParamsBodyClientReferenceInformation struct {

	// The name of the Connection Method client (such as Virtual Terminal or SOAP Toolkit API) that the merchant uses to send a transaction request to CyberSource.
	//
	ApplicationName string `json:"applicationName,omitempty"`

	// The entity that is responsible for running the transaction and submitting the processing request to CyberSource. This could be a person, a system, or a connection method.
	//
	ApplicationUser string `json:"applicationUser,omitempty"`

	// Version of the CyberSource application or integration used for a transaction.
	//
	ApplicationVersion string `json:"applicationVersion,omitempty"`

	// Merchant-generated order reference or tracking number. It is recommended that you send a unique value for each
	// transaction so that you can perform meaningful searches for the transaction.
	//
	// #### Used by
	// **Authorization**
	// Required field.
	//
	// #### PIN Debit
	// Requests for PIN debit reversals need to use the same merchant reference number that was used in the transaction that is being
	// reversed.
	//
	// Required field for all PIN Debit requests (purchase, credit, and reversal).
	//
	// #### FDC Nashville Global
	// Certain circumstances can cause the processor to truncate this value to 15 or 17 characters for Level II and Level III processing, which can cause a discrepancy between the value you submit and the value included in some processor reports.
	//
	// Max Length: 50
	Code string `json:"code,omitempty"`

	// Comments
	Comments string `json:"comments,omitempty"`

	// partner
	Partner *CreateCreditParamsBodyClientReferenceInformationPartner `json:"partner,omitempty"`

	// Used to resume a transaction that was paused for an order modification rule to allow for payer authentication to complete. To resume and continue with the authorization/decision service flow, call the services and include the request id from the prior decision call.
	//
	// Max Length: 26
	PausedRequestID string `json:"pausedRequestId,omitempty"`

	// Identifier that you assign to the transaction. Normally generated by a client server to identify a unique API request.
	//
	// **Note** Use this field only if you want to support merchant-initiated reversal and void operations.
	//
	// #### Used by
	// **Authorization, Authorization Reversal, Capture, Credit, and Void**
	// Optional field.
	//
	// #### PIN Debit
	// For a PIN debit reversal, your request must include a request ID or a merchant transaction identifier.
	// Optional field for PIN debit purchase or credit requests.
	//
	// Max Length: 30
	TransactionID string `json:"transactionId,omitempty"`
}

// Validate validates this create credit params body client reference information
func (o *CreateCreditParamsBodyClientReferenceInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePartner(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePausedRequestID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTransactionID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyClientReferenceInformation) validateCode(formats strfmt.Registry) error {
	if swag.IsZero(o.Code) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"clientReferenceInformation"+"."+"code", "body", o.Code, 50); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyClientReferenceInformation) validatePartner(formats strfmt.Registry) error {
	if swag.IsZero(o.Partner) { // not required
		return nil
	}

	if o.Partner != nil {
		if err := o.Partner.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "clientReferenceInformation" + "." + "partner")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "clientReferenceInformation" + "." + "partner")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditParamsBodyClientReferenceInformation) validatePausedRequestID(formats strfmt.Registry) error {
	if swag.IsZero(o.PausedRequestID) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"clientReferenceInformation"+"."+"pausedRequestId", "body", o.PausedRequestID, 26); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyClientReferenceInformation) validateTransactionID(formats strfmt.Registry) error {
	if swag.IsZero(o.TransactionID) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"clientReferenceInformation"+"."+"transactionId", "body", o.TransactionID, 30); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this create credit params body client reference information based on the context it is used
func (o *CreateCreditParamsBodyClientReferenceInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidatePartner(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyClientReferenceInformation) contextValidatePartner(ctx context.Context, formats strfmt.Registry) error {

	if o.Partner != nil {
		if err := o.Partner.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "clientReferenceInformation" + "." + "partner")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "clientReferenceInformation" + "." + "partner")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditParamsBodyClientReferenceInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditParamsBodyClientReferenceInformation) UnmarshalBinary(b []byte) error {
	var res CreateCreditParamsBodyClientReferenceInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditParamsBodyClientReferenceInformationPartner create credit params body client reference information partner
swagger:model CreateCreditParamsBodyClientReferenceInformationPartner
*/
type CreateCreditParamsBodyClientReferenceInformationPartner struct {

	// Identifier for the developer that helped integrate a partner solution to CyberSource.
	//
	// Send this value in all requests that are sent through the partner solutions built by that developer.
	// CyberSource assigns the ID to the developer.
	//
	// **Note** When you see a developer ID of 999 in reports, the developer ID that was submitted is incorrect.
	//
	// Max Length: 8
	DeveloperID string `json:"developerId,omitempty"`

	// Value that links the previous transaction to the current follow-on request. This value is assigned by the client
	// software that is installed on the POS terminal, which makes it available to the terminals software and to
	// CyberSource. Therefore, you can use this value to reconcile transactions between CyberSource and the terminals
	// software.
	//
	// CyberSource does not forward this value to the processor. Instead, the value is forwarded to the CyberSource
	// reporting functionality.
	//
	// This field is supported only on these processors:
	// - American Express Direct
	// - Credit Mutuel-CIC
	// - FDC Nashville Global
	// - OmniPay Direct
	// - SIX
	//
	// Optional field.
	//
	// Max Length: 32
	OriginalTransactionID string `json:"originalTransactionId,omitempty"`

	// Identifier for the partner that is integrated to CyberSource.
	//
	// Send this value in all requests that are sent through the partner solution. CyberSource assigns the ID to the partner.
	//
	// **Note** When you see a solutionId of 999 in reports, the solutionId that was submitted is incorrect.
	//
	// Max Length: 8
	SolutionID string `json:"solutionId,omitempty"`

	// Value that identifies the application vendor and application version for a third party gateway.
	// CyberSource provides you with this value during testing and validation.
	// This field is supported only on CyberSource through VisaNet.
	//
	// #### Used by
	// **Authorization, Authorization Reversal, Capture, Credit, Incremental Authorization, and Void**
	// Optional field.
	//
	// #### PIN debit
	// Required field for PIN debit credit, PIN debit purchase, or PIN debit reversal request.
	//
	// Max Length: 12
	ThirdPartyCertificationNumber string `json:"thirdPartyCertificationNumber,omitempty"`
}

// Validate validates this create credit params body client reference information partner
func (o *CreateCreditParamsBodyClientReferenceInformationPartner) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDeveloperID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOriginalTransactionID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSolutionID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateThirdPartyCertificationNumber(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyClientReferenceInformationPartner) validateDeveloperID(formats strfmt.Registry) error {
	if swag.IsZero(o.DeveloperID) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"clientReferenceInformation"+"."+"partner"+"."+"developerId", "body", o.DeveloperID, 8); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyClientReferenceInformationPartner) validateOriginalTransactionID(formats strfmt.Registry) error {
	if swag.IsZero(o.OriginalTransactionID) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"clientReferenceInformation"+"."+"partner"+"."+"originalTransactionId", "body", o.OriginalTransactionID, 32); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyClientReferenceInformationPartner) validateSolutionID(formats strfmt.Registry) error {
	if swag.IsZero(o.SolutionID) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"clientReferenceInformation"+"."+"partner"+"."+"solutionId", "body", o.SolutionID, 8); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyClientReferenceInformationPartner) validateThirdPartyCertificationNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.ThirdPartyCertificationNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"clientReferenceInformation"+"."+"partner"+"."+"thirdPartyCertificationNumber", "body", o.ThirdPartyCertificationNumber, 12); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create credit params body client reference information partner based on context it is used
func (o *CreateCreditParamsBodyClientReferenceInformationPartner) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditParamsBodyClientReferenceInformationPartner) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditParamsBodyClientReferenceInformationPartner) UnmarshalBinary(b []byte) error {
	var res CreateCreditParamsBodyClientReferenceInformationPartner
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditParamsBodyDeviceInformation create credit params body device information
swagger:model CreateCreditParamsBodyDeviceInformation
*/
type CreateCreditParamsBodyDeviceInformation struct {

	// DNS resolved hostname from `ipAddress`.
	// Max Length: 60
	HostName string `json:"hostName,omitempty"`

	// IP address of the customer.
	//
	// #### Used by
	// **Authorization, Capture, and Credit**
	// Optional field.
	//
	// Max Length: 45
	IPAddress string `json:"ipAddress,omitempty"`

	// Customers browser as identified from the HTTP header data. For example, `Mozilla` is the value that identifies
	// the Netscape browser.
	//
	// Max Length: 40
	UserAgent string `json:"userAgent,omitempty"`
}

// Validate validates this create credit params body device information
func (o *CreateCreditParamsBodyDeviceInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateHostName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateIPAddress(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateUserAgent(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyDeviceInformation) validateHostName(formats strfmt.Registry) error {
	if swag.IsZero(o.HostName) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"deviceInformation"+"."+"hostName", "body", o.HostName, 60); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyDeviceInformation) validateIPAddress(formats strfmt.Registry) error {
	if swag.IsZero(o.IPAddress) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"deviceInformation"+"."+"ipAddress", "body", o.IPAddress, 45); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyDeviceInformation) validateUserAgent(formats strfmt.Registry) error {
	if swag.IsZero(o.UserAgent) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"deviceInformation"+"."+"userAgent", "body", o.UserAgent, 40); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create credit params body device information based on context it is used
func (o *CreateCreditParamsBodyDeviceInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditParamsBodyDeviceInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditParamsBodyDeviceInformation) UnmarshalBinary(b []byte) error {
	var res CreateCreditParamsBodyDeviceInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditParamsBodyInstallmentInformation create credit params body installment information
swagger:model CreateCreditParamsBodyInstallmentInformation
*/
type CreateCreditParamsBodyInstallmentInformation struct {

	// #### American Express Direct, Cielo, and CyberSource Latin American Processing
	// Flag that indicates the type of funding for the installment plan associated with the payment.
	//
	// Possible values:
	// - `1`: Merchant-funded installment plan
	// - `2`: Issuer-funded installment plan
	// If you do not include this field in the request, CyberSource uses the value in your CyberSource account.
	//
	// To change the value in your CyberSource account, contact CyberSource Customer Service.
	// For details, see `installment_plan_type` field description in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// #### CyberSource through VisaNet and American Express
	// Defined code that indicates the type of installment plan for this transaction.
	//
	// Contact American Express for:
	// - Information about the kinds of installment plans that American Express provides
	// - Values for this field
	//
	// For installment payments with American Express in Brazil, the value for this field corresponds to the following data in the TC 33 capture file*:
	// - Record: CP07 TCR3
	// - Position: 5-6
	// - Field: Plan Type
	//
	// * The TC 33 Capture file contains information about the purchases and refunds that a merchant submits to CyberSource. CyberSource through VisaNet creates the TC 33 Capture file at the end of the day and sends it to the merchants acquirer, who uses this information to facilitate end-of-day clearing processing with payment card companies.
	//
	// #### CyberSource through VisaNet with Visa or Mastercard
	// Flag indicating the type of funding for the installment plan associated with the payment.
	// Possible values:
	// - 1 or 01: Merchant-funded installment plan
	// - 2 or 02: Issuer-funded installment plan
	// - 43: Crediario installment planonly with Visa in Brazil
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// For installment payments with Visa in Brazil, the value for this field corresponds to the following data in the TC 33 capture file5:
	// - Record: CP07 TCR1
	// - Position: 5-6
	// - Field: Installment Type
	//
	// For all other kinds of installment payments, the value for this field corresponds to the following data in the TC 33 capture file5:
	// - Record: CP01 TCR5
	// - Position: 39-40
	// - Field: Installment Plan Type (Issuer or Merchant)
	//
	// Max Length: 1
	PlanType string `json:"planType,omitempty"`
}

// Validate validates this create credit params body installment information
func (o *CreateCreditParamsBodyInstallmentInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validatePlanType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyInstallmentInformation) validatePlanType(formats strfmt.Registry) error {
	if swag.IsZero(o.PlanType) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"installmentInformation"+"."+"planType", "body", o.PlanType, 1); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create credit params body installment information based on context it is used
func (o *CreateCreditParamsBodyInstallmentInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditParamsBodyInstallmentInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditParamsBodyInstallmentInformation) UnmarshalBinary(b []byte) error {
	var res CreateCreditParamsBodyInstallmentInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditParamsBodyMerchantDefinedInformationItems0 create credit params body merchant defined information items0
swagger:model CreateCreditParamsBodyMerchantDefinedInformationItems0
*/
type CreateCreditParamsBodyMerchantDefinedInformationItems0 struct {

	// The number you assign for as the key for your merchant-defined data field. Valid values are 0 to 100.
	//
	// For example, to set or access the key for the 2nd merchant-defined data field in the array, you would reference `merchantDefinedInformation[1].key`.
	//
	// #### CyberSource through VisaNet
	// For installment payments with Mastercard in Brazil, use `merchantDefinedInformation[0].key` and
	// `merchantDefinedInformation[1].key` for data that you want to provide to the issuer to identify the
	// transaction.
	//
	// For details, see the `merchant_defined_data1` request-level field description in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// Max Length: 50
	Key string `json:"key,omitempty"`

	// The value you assign for your merchant-defined data field.
	//
	// For details, see `merchant_defined_data1` field description in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// **Warning** Merchant-defined data fields are not intended to and must not be used to capture personally identifying information. Accordingly, merchants are prohibited from capturing, obtaining, and/or transmitting any personally identifying information in or via the merchant-defined data fields. Personally identifying information includes, but is not
	// limited to, address, credit card number, social security number, driver's license number, state-issued identification number, passport number, and card verification numbers (CVV,
	// CVC2, CVV2, CID, CVN). In the event CyberSource discovers that a merchant is capturing and/or transmitting personally identifying information via the merchant-defined data fields, whether or not intentionally, CyberSource will immediately suspend the merchant's account, which will result in a rejection of any and all transaction requests submitted by the merchant after the point of suspension.
	//
	// #### CyberSource through VisaNet
	// For installment payments with Mastercard in Brazil, use `merchantDefinedInformation[0].value` and
	// `merchantDefinedInformation[1].value` for data that you want to provide to the issuer to identify the
	// transaction. For details, see "Installment Payments on CyberSource through VisaNet" in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// For installment payments with Mastercard in Brazil:
	// - The value for merchantDefinedInformation[0].value corresponds to the following data in the TC 33 capture file5:
	//   - Record: CP07 TCR5
	//   - Position: 25-44
	//   - Field: Reference Field 2
	// - The value for merchantDefinedInformation[1].value corresponds to the following data in the TC 33 capture file5:
	//   - Record: CP07 TCR5
	//   - Position: 45-64
	//   - Field: Reference Field 3
	//
	// Max Length: 255
	Value string `json:"value,omitempty"`
}

// Validate validates this create credit params body merchant defined information items0
func (o *CreateCreditParamsBodyMerchantDefinedInformationItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateKey(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateValue(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyMerchantDefinedInformationItems0) validateKey(formats strfmt.Registry) error {
	if swag.IsZero(o.Key) { // not required
		return nil
	}

	if err := validate.MaxLength("key", "body", o.Key, 50); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyMerchantDefinedInformationItems0) validateValue(formats strfmt.Registry) error {
	if swag.IsZero(o.Value) { // not required
		return nil
	}

	if err := validate.MaxLength("value", "body", o.Value, 255); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create credit params body merchant defined information items0 based on context it is used
func (o *CreateCreditParamsBodyMerchantDefinedInformationItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditParamsBodyMerchantDefinedInformationItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditParamsBodyMerchantDefinedInformationItems0) UnmarshalBinary(b []byte) error {
	var res CreateCreditParamsBodyMerchantDefinedInformationItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditParamsBodyMerchantInformation create credit params body merchant information
swagger:model CreateCreditParamsBodyMerchantInformation
*/
type CreateCreditParamsBodyMerchantInformation struct {

	// Reference number that facilitates card acceptor/corporation communication and record keeping.
	//
	// For processor-specific information, see the `card_acceptor_ref_number` field description in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 25
	CardAcceptorReferenceNumber string `json:"cardAcceptorReferenceNumber,omitempty"`

	// The value for this field is a four-digit number that the payment card industry uses to classify
	// merchants into market segments. A payment card company assigned one or more of these values to your business when you started
	// accepting the payment card companys cards. When you do not include this field in your request, CyberSource uses the value in your
	// CyberSource account.
	//
	// For processor-specific information, see the `merchant_category_code` field description in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// #### CyberSource through VisaNet
	// The value for this field corresponds to the following data in the TC 33 capture file5:
	// - Record: CP01 TCR4
	// - Position: 150-153
	// - Field: Merchant Category Code
	//
	// Maximum: 9999
	CategoryCode int64 `json:"categoryCode,omitempty"`

	// merchant descriptor
	MerchantDescriptor *CreateCreditParamsBodyMerchantInformationMerchantDescriptor `json:"merchantDescriptor,omitempty"`

	// Your Cadastro Nacional da Pessoa Jurdica (CNPJ) number.
	//
	// This field is supported only for BNDES transactions on CyberSource through VisaNet.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file5:
	// - Record: CP07 TCR6
	// - Position: 40-59
	// - Field: BNDES Reference Field 1
	//
	// For details, see `bill_merchant_tax_id` field description in the [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// Max Length: 15
	TaxID string `json:"taxId,omitempty"`

	// Your government-assigned tax identification number.
	//
	// #### Tax Calculation
	// Required field for value added tax only. Not applicable to U.S. and Canadian taxes.
	//
	// #### CyberSource through VisaNet
	// For CtV processors, the maximum length is 20.
	//
	// For other processor-specific information, see the `merchant_vat_registration_number` field description in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 21
	VatRegistrationNumber string `json:"vatRegistrationNumber,omitempty"`
}

// Validate validates this create credit params body merchant information
func (o *CreateCreditParamsBodyMerchantInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCardAcceptorReferenceNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCategoryCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMerchantDescriptor(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateVatRegistrationNumber(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyMerchantInformation) validateCardAcceptorReferenceNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.CardAcceptorReferenceNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"merchantInformation"+"."+"cardAcceptorReferenceNumber", "body", o.CardAcceptorReferenceNumber, 25); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyMerchantInformation) validateCategoryCode(formats strfmt.Registry) error {
	if swag.IsZero(o.CategoryCode) { // not required
		return nil
	}

	if err := validate.MaximumInt("createCreditRequest"+"."+"merchantInformation"+"."+"categoryCode", "body", o.CategoryCode, 9999, false); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyMerchantInformation) validateMerchantDescriptor(formats strfmt.Registry) error {
	if swag.IsZero(o.MerchantDescriptor) { // not required
		return nil
	}

	if o.MerchantDescriptor != nil {
		if err := o.MerchantDescriptor.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "merchantInformation" + "." + "merchantDescriptor")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "merchantInformation" + "." + "merchantDescriptor")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditParamsBodyMerchantInformation) validateTaxID(formats strfmt.Registry) error {
	if swag.IsZero(o.TaxID) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"merchantInformation"+"."+"taxId", "body", o.TaxID, 15); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyMerchantInformation) validateVatRegistrationNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.VatRegistrationNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"merchantInformation"+"."+"vatRegistrationNumber", "body", o.VatRegistrationNumber, 21); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this create credit params body merchant information based on the context it is used
func (o *CreateCreditParamsBodyMerchantInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateMerchantDescriptor(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyMerchantInformation) contextValidateMerchantDescriptor(ctx context.Context, formats strfmt.Registry) error {

	if o.MerchantDescriptor != nil {
		if err := o.MerchantDescriptor.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "merchantInformation" + "." + "merchantDescriptor")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "merchantInformation" + "." + "merchantDescriptor")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditParamsBodyMerchantInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditParamsBodyMerchantInformation) UnmarshalBinary(b []byte) error {
	var res CreateCreditParamsBodyMerchantInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditParamsBodyMerchantInformationMerchantDescriptor create credit params body merchant information merchant descriptor
swagger:model CreateCreditParamsBodyMerchantInformationMerchantDescriptor
*/
type CreateCreditParamsBodyMerchantInformationMerchantDescriptor struct {

	// First line of merchant's address. For the descriptions, used-by information, data types, and lengths for these fields, see `merchant_descriptor_street` field description
	// in [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 60
	Address1 string `json:"address1,omitempty"`

	// The state where the merchant is located.
	//
	// #### PIN debit
	// State code or region code for your business. Use the Use the [State, Province, and Territory Codes for the United States and Canada](https://developer.cybersource.com/library/documentation/sbc/quickref/states_and_provinces.pdf) This value might be displayed on the cardholders statement.
	//
	// When you do not include this value in your PIN debit request, the merchant name from your account is used.
	// **Important** This value must consist of English characters.
	//
	// **Note** This field is supported only for businesses located in the U.S. or Canada.
	//
	// Optional field for PIN debit credit or PIN debit purchase.
	//
	AdministrativeArea string `json:"administrativeArea,omitempty"`

	// An alternate name for the merchant.
	//
	// For the descriptions, used-by information, data types, and lengths for these fields, see the `merchant_descriptor_alternate` field description
	// in [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)-->
	//
	// Max Length: 13
	AlternateName string `json:"alternateName,omitempty"`

	// For the descriptions, used-by information, data types, and lengths for these fields, see `merchant_descriptor_contact` field description
	// in [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)-->
	// Contact information for the merchant.
	//
	// **Note** These are the maximum data lengths for the following payment processors:
	// - FDCCompass (13)
	// - Paymentech (13)
	//
	// Max Length: 14
	Contact string `json:"contact,omitempty"`

	// Merchant's country.
	//
	// #### PIN debit
	// Country code for your business location. Use the [ISO Standard Country Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf)
	// This value might be displayed on the cardholders statement.
	//
	// When you do not include this value in your PIN debit request, the merchant name from your account is used.
	// **Important** This value must consist of English characters.
	// **Note** If your business is located in the U.S. or Canada and you include this field in a
	// request, you must also include `merchantInformation.merchantDescriptor.administrativeArea`.
	//
	// Optional field for PIN debit credit or PIN debit purchase.
	//
	// Max Length: 2
	Country string `json:"country,omitempty"`

	// Merchant's City.
	//
	// #### PIN debit
	// City for your business location. This value might be displayed on the cardholders statement.
	//
	// When you do not include this value in your PIN debit request, the merchant name from your account is used.
	// **Important** This value must consist of English characters.
	//
	// Optional field for PIN debit credit or PIN debit purchase requests.
	//
	// Max Length: 13
	Locality string `json:"locality,omitempty"`

	// Your merchant name.
	//
	// **Note** For Paymentech processor using Cybersource Payouts, the maximum data length is 22.
	//
	// #### PIN debit
	// Your business name. This name is displayed on the cardholders statement. When you
	// include more than one consecutive space, extra spaces are removed.
	//
	// When you do not include this value in your PIN debit request, the merchant name from your account is used.
	// **Important** This value must consist of English characters.
	//
	// Optional field for PIN debit credit or PIN debit purchase requests.
	//
	// #### Airline processing
	// Your merchant name. This name is displayed on the cardholders statement. When you include more than one consecutive space, extra spaces are removed.
	//
	// **Note** Some airline fee programs may require the original ticket number (ticket identifier) or the ancillary service description in positions 13 through 23 of this field.
	//
	// **Important** This value must consist of English characters.
	//
	// Required for captures and credits.
	//
	Name string `json:"name,omitempty"`

	// Merchnat phone as contact information for CNP transactions
	//
	// Max Length: 13
	Phone string `json:"phone,omitempty"`

	// Merchant's postal code.
	//
	// #### PIN debit
	// Postal code for your business location. This value might be displayed on the cardholders statement.
	//
	// If your business is domiciled in the U.S., you can use a 5-digit or 9-digit postal code. A 9-digit postal code must follow this format:
	// [5 digits][dash][4 digits]
	// Example: `12345-6789`
	//
	// If your business is domiciled in Canada, you can use a 6-digit or 9-digit postal code. A 6-digit postal code must follow this format:
	// [alpha][numeric][alpha][space]
	// [numeric][alpha][numeric]
	// Example: `A1B 2C3`
	//
	// When you do not include this value in your PIN debit request, the merchant name from your account is used.
	// **Important** This value must consist of English characters.
	//
	// **Note** This field is supported only for businesses located in the U.S. or Canada.
	// **Important** Mastercard requires a postal code for any country that uses postal codes.
	// You can provide the postal code in your account or you can include this field in your request.
	//
	// Optional field for PIN debit credit or PIN debit purchase.
	//
	// Max Length: 14
	PostalCode string `json:"postalCode,omitempty"`

	// Address of company's website provided by merchant
	//
	// Max Length: 255
	URL string `json:"url,omitempty"`
}

// Validate validates this create credit params body merchant information merchant descriptor
func (o *CreateCreditParamsBodyMerchantInformationMerchantDescriptor) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAddress1(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAlternateName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateContact(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocality(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePhone(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateURL(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyMerchantInformationMerchantDescriptor) validateAddress1(formats strfmt.Registry) error {
	if swag.IsZero(o.Address1) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"merchantInformation"+"."+"merchantDescriptor"+"."+"address1", "body", o.Address1, 60); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyMerchantInformationMerchantDescriptor) validateAlternateName(formats strfmt.Registry) error {
	if swag.IsZero(o.AlternateName) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"merchantInformation"+"."+"merchantDescriptor"+"."+"alternateName", "body", o.AlternateName, 13); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyMerchantInformationMerchantDescriptor) validateContact(formats strfmt.Registry) error {
	if swag.IsZero(o.Contact) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"merchantInformation"+"."+"merchantDescriptor"+"."+"contact", "body", o.Contact, 14); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyMerchantInformationMerchantDescriptor) validateCountry(formats strfmt.Registry) error {
	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"merchantInformation"+"."+"merchantDescriptor"+"."+"country", "body", o.Country, 2); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyMerchantInformationMerchantDescriptor) validateLocality(formats strfmt.Registry) error {
	if swag.IsZero(o.Locality) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"merchantInformation"+"."+"merchantDescriptor"+"."+"locality", "body", o.Locality, 13); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyMerchantInformationMerchantDescriptor) validatePhone(formats strfmt.Registry) error {
	if swag.IsZero(o.Phone) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"merchantInformation"+"."+"merchantDescriptor"+"."+"phone", "body", o.Phone, 13); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyMerchantInformationMerchantDescriptor) validatePostalCode(formats strfmt.Registry) error {
	if swag.IsZero(o.PostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"merchantInformation"+"."+"merchantDescriptor"+"."+"postalCode", "body", o.PostalCode, 14); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyMerchantInformationMerchantDescriptor) validateURL(formats strfmt.Registry) error {
	if swag.IsZero(o.URL) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"merchantInformation"+"."+"merchantDescriptor"+"."+"url", "body", o.URL, 255); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create credit params body merchant information merchant descriptor based on context it is used
func (o *CreateCreditParamsBodyMerchantInformationMerchantDescriptor) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditParamsBodyMerchantInformationMerchantDescriptor) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditParamsBodyMerchantInformationMerchantDescriptor) UnmarshalBinary(b []byte) error {
	var res CreateCreditParamsBodyMerchantInformationMerchantDescriptor
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditParamsBodyOrderInformation create credit params body order information
swagger:model CreateCreditParamsBodyOrderInformation
*/
type CreateCreditParamsBodyOrderInformation struct {

	// amount details
	AmountDetails *CreateCreditParamsBodyOrderInformationAmountDetails `json:"amountDetails,omitempty"`

	// bill to
	BillTo *CreateCreditParamsBodyOrderInformationBillTo `json:"billTo,omitempty"`

	// invoice details
	InvoiceDetails *CreateCreditParamsBodyOrderInformationInvoiceDetails `json:"invoiceDetails,omitempty"`

	// line items
	LineItems []*CreateCreditParamsBodyOrderInformationLineItemsItems0 `json:"lineItems"`

	// ship to
	ShipTo *CreateCreditParamsBodyOrderInformationShipTo `json:"shipTo,omitempty"`

	// shipping details
	ShippingDetails *CreateCreditParamsBodyOrderInformationShippingDetails `json:"shippingDetails,omitempty"`
}

// Validate validates this create credit params body order information
func (o *CreateCreditParamsBodyOrderInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAmountDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBillTo(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateInvoiceDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLineItems(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateShipTo(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateShippingDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyOrderInformation) validateAmountDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.AmountDetails) { // not required
		return nil
	}

	if o.AmountDetails != nil {
		if err := o.AmountDetails.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "orderInformation" + "." + "amountDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "orderInformation" + "." + "amountDetails")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformation) validateBillTo(formats strfmt.Registry) error {
	if swag.IsZero(o.BillTo) { // not required
		return nil
	}

	if o.BillTo != nil {
		if err := o.BillTo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "orderInformation" + "." + "billTo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "orderInformation" + "." + "billTo")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformation) validateInvoiceDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.InvoiceDetails) { // not required
		return nil
	}

	if o.InvoiceDetails != nil {
		if err := o.InvoiceDetails.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "orderInformation" + "." + "invoiceDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "orderInformation" + "." + "invoiceDetails")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformation) validateLineItems(formats strfmt.Registry) error {
	if swag.IsZero(o.LineItems) { // not required
		return nil
	}

	for i := 0; i < len(o.LineItems); i++ {
		if swag.IsZero(o.LineItems[i]) { // not required
			continue
		}

		if o.LineItems[i] != nil {
			if err := o.LineItems[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("createCreditRequest" + "." + "orderInformation" + "." + "lineItems" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("createCreditRequest" + "." + "orderInformation" + "." + "lineItems" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformation) validateShipTo(formats strfmt.Registry) error {
	if swag.IsZero(o.ShipTo) { // not required
		return nil
	}

	if o.ShipTo != nil {
		if err := o.ShipTo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "orderInformation" + "." + "shipTo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "orderInformation" + "." + "shipTo")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformation) validateShippingDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.ShippingDetails) { // not required
		return nil
	}

	if o.ShippingDetails != nil {
		if err := o.ShippingDetails.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "orderInformation" + "." + "shippingDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "orderInformation" + "." + "shippingDetails")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this create credit params body order information based on the context it is used
func (o *CreateCreditParamsBodyOrderInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateAmountDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateBillTo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateInvoiceDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateLineItems(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateShipTo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateShippingDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyOrderInformation) contextValidateAmountDetails(ctx context.Context, formats strfmt.Registry) error {

	if o.AmountDetails != nil {
		if err := o.AmountDetails.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "orderInformation" + "." + "amountDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "orderInformation" + "." + "amountDetails")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformation) contextValidateBillTo(ctx context.Context, formats strfmt.Registry) error {

	if o.BillTo != nil {
		if err := o.BillTo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "orderInformation" + "." + "billTo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "orderInformation" + "." + "billTo")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformation) contextValidateInvoiceDetails(ctx context.Context, formats strfmt.Registry) error {

	if o.InvoiceDetails != nil {
		if err := o.InvoiceDetails.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "orderInformation" + "." + "invoiceDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "orderInformation" + "." + "invoiceDetails")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformation) contextValidateLineItems(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.LineItems); i++ {

		if o.LineItems[i] != nil {
			if err := o.LineItems[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("createCreditRequest" + "." + "orderInformation" + "." + "lineItems" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("createCreditRequest" + "." + "orderInformation" + "." + "lineItems" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformation) contextValidateShipTo(ctx context.Context, formats strfmt.Registry) error {

	if o.ShipTo != nil {
		if err := o.ShipTo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "orderInformation" + "." + "shipTo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "orderInformation" + "." + "shipTo")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformation) contextValidateShippingDetails(ctx context.Context, formats strfmt.Registry) error {

	if o.ShippingDetails != nil {
		if err := o.ShippingDetails.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "orderInformation" + "." + "shippingDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "orderInformation" + "." + "shippingDetails")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditParamsBodyOrderInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditParamsBodyOrderInformation) UnmarshalBinary(b []byte) error {
	var res CreateCreditParamsBodyOrderInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditParamsBodyOrderInformationAmountDetails create credit params body order information amount details
swagger:model CreateCreditParamsBodyOrderInformationAmountDetails
*/
type CreateCreditParamsBodyOrderInformationAmountDetails struct {

	// amex additional amounts
	AmexAdditionalAmounts []*CreateCreditParamsBodyOrderInformationAmountDetailsAmexAdditionalAmountsItems0 `json:"amexAdditionalAmounts"`

	// Cashback amount in the acquirers currency. If a cashback amount is included in the request, it must be included
	// in the `orderInformation.amountDetails.totalAmount` value.
	//
	// This field is supported only on CyberSource through VisaNet.
	//
	// #### Used by
	// **Authorization**
	// Optional.
	// **Authorization Reversal**
	// Optional.
	//
	// #### PIN debit
	// Required field for PIN debit purchase, PIN debit credit or PIN debit reversal.
	//
	// Max Length: 13
	CashbackAmount string `json:"cashbackAmount,omitempty"`

	// Currency used for the order. Use the three-character [ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)
	//
	// #### Used by
	// **Authorization**
	// Required field.
	//
	// **Authorization Reversal**
	// For an authorization reversal (`reversalInformation`) or a capture (`processingOptions.capture` is set to `true`), you must use the same currency that you used in your payment authorization request.
	//
	// #### PIN Debit
	// Currency for the amount you requested for the PIN debit purchase. This value is returned for partial authorizations. The issuing bank can approve a partial amount if the balance on the debit card is less than the requested transaction amount. For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf).
	// Returned by PIN debit purchase.
	//
	// For PIN debit reversal requests, you must use the same currency that was used for the PIN debit purchase or PIN debit credit that you are reversing.
	// For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf).
	//
	// Required field for PIN Debit purchase and PIN Debit credit requests.
	// Optional field for PIN Debit reversal requests.
	//
	// #### GPX
	// This field is optional for reversing an authorization or credit.
	//
	// #### DCC for First Data
	// Your local currency. For details, see the `currency` field description in [Dynamic Currency Conversion For First Data Using the SCMP API](http://apps.cybersource.com/library/documentation/dev_guides/DCC_FirstData_SCMP/DCC_FirstData_SCMP_API.pdf).
	//
	// #### Tax Calculation
	// Required for international tax and value added tax only.
	// Optional for U.S. and Canadian taxes.
	// Your local currency.
	//
	// Max Length: 3
	Currency string `json:"currency,omitempty"`

	// Total discount amount applied to the order.
	//
	// Max Length: 15
	DiscountAmount string `json:"discountAmount,omitempty"`

	// Total charges for any import or export duties included in the order.
	//
	// Max Length: 15
	DutyAmount string `json:"dutyAmount,omitempty"`

	// Exchange rate returned by the DCC service. Includes a decimal point and a maximum of 4 decimal places.
	//
	// For details, see `exchange_rate` request-level field description in the [Dynamic Currency Conversion For First Data Using the SCMP API](http://apps.cybersource.com/library/documentation/dev_guides/DCC_FirstData_SCMP/DCC_FirstData_SCMP_API.pdf)
	//
	// Max Length: 13
	ExchangeRate string `json:"exchangeRate,omitempty"`

	// Time stamp for the exchange rate. This value is returned by the DCC service.
	//
	// Format: `YYYYMMDD~HH:MM`  where ~ denotes a space.
	//
	// Max Length: 14
	ExchangeRateTimeStamp string `json:"exchangeRateTimeStamp,omitempty"`

	// Set this field to the converted amount that was returned by the DCC provider.
	// For processor-specific information, see the `foreign_amount` field description in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// Max Length: 15
	ForeignAmount string `json:"foreignAmount,omitempty"`

	// Set this field to the converted amount that was returned by the DCC provider.
	//
	// Max Length: 5
	ForeignCurrency string `json:"foreignCurrency,omitempty"`

	// Total freight or shipping and handling charges for the order. When you include this field in your request, you
	// must also include the **totalAmount** field.
	//
	// For processor-specific information, see the freight_amount field in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 13
	FreightAmount string `json:"freightAmount,omitempty"`

	// Gratuity or tip amount for restaurants. Allowed only when industryDatatype=restaurant.
	// When your customer uses a debit card or prepaid card, and you receive a partial authorization, the payment networks recommend that you do not
	// submit a capture amount that is higher than the authorized amount. When the capture amount exceeds the partial amount that was approved, the
	// issuer has chargeback rights for the excess amount.
	//
	// Used by **Capture**
	// Optional field.
	//
	// #### CyberSource through VisaNet
	// Restaurant data is supported only on CyberSource through VisaNet when card is present.
	//
	// Max Length: 13
	GratuityAmount string `json:"gratuityAmount,omitempty"`

	// Flag that indicates whether a national tax is included in the order total.
	//
	// Possible values:
	//
	//  - **0**: national tax not included
	//  - **1**: national tax included
	//
	// Max Length: 1
	NationalTaxIncluded string `json:"nationalTaxIncluded,omitempty"`

	// Your local pricing currency code.
	//
	// For the possible values, see the [ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)
	//
	// Max Length: 15
	OriginalCurrency string `json:"originalCurrency,omitempty"`

	// Service fee. Required for service fee transactions.
	//
	// Max Length: 15
	ServiceFeeAmount string `json:"serviceFeeAmount,omitempty"`

	// Total tax amount for all the items in the order.
	//
	// Max Length: 12
	TaxAmount string `json:"taxAmount,omitempty"`

	// Flag that indicates how the merchant manages discounts.
	//
	// Possible values:
	//
	//  - **0**: no invoice level discount included
	//  - **1**: tax calculated on the postdiscount invoice total
	//  - **2**: tax calculated on the prediscount invoice total
	//
	// Max Length: 1
	TaxAppliedAfterDiscount string `json:"taxAppliedAfterDiscount,omitempty"`

	// Flag that indicates how you calculate tax.
	//
	// Possible values:
	//
	//  - **0**: net prices with tax calculated at line item level
	//  - **1**: net prices with tax calculated at invoice level
	//  - **2**: gross prices with tax provided at line item level
	//  - **3**: gross prices with tax provided at invoice level
	//  - **4**: no tax applies on the invoice for the transaction
	//
	// Max Length: 1
	TaxAppliedLevel string `json:"taxAppliedLevel,omitempty"`

	// tax details
	TaxDetails []*CreateCreditParamsBodyOrderInformationAmountDetailsTaxDetailsItems0 `json:"taxDetails"`

	// For tax amounts that can be categorized as one tax type.
	//
	// This field contains the tax type code that corresponds to the entry in the _lineItems.taxAmount_ field.
	//
	// Possible values:
	//
	//  - **056**: sales tax (U.S only)
	//  - **TX~**: all taxes (Canada only)   Note ~ = space.
	//
	// Max Length: 3
	TaxTypeCode string `json:"taxTypeCode,omitempty"`

	// Grand total for the order. This value cannot be negative. You can include a decimal point (.), but no other special characters.
	// CyberSource truncates the amount to the correct number of decimal places.
	//
	// **Note** For CTV, FDCCompass, Paymentech processors, the maximum length for this field is 12.
	//
	// **Important** Some processors have specific requirements and limitations, such as maximum amounts and maximum field lengths. For details, see:
	// - "Authorization Information for Specific Processors" in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/).
	// - "Capture Information for Specific Processors" in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/).
	// - "Credit Information for Specific Processors" in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/).
	//
	// If your processor supports zero amount authorizations, you can set this field to 0 for the authorization to check if the card is lost or stolen. For details, see "Zero Amount Authorizations," "Credit Information for Specific Processors" in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// #### Card Present
	// Required to include either this field or `orderInformation.lineItems[].unitPrice` for the order.
	//
	// #### Invoicing
	// Required for creating a new invoice.
	//
	// #### PIN Debit
	// Amount you requested for the PIN debit purchase. This value is returned for partial authorizations. The issuing bank can approve a partial amount if the balance on the debit card is less than the requested transaction amount.
	//
	// Required field for PIN Debit purchase and PIN Debit credit requests.
	// Optional field for PIN Debit reversal requests.
	//
	// #### GPX
	// This field is optional for reversing an authorization or credit; however, for all other processors, these fields are required.
	//
	// #### DCC with a Third-Party Provider
	// Set this field to the converted amount that was returned by the DCC provider. You must include either this field or the 1st line item in the order and the specific line-order amount in your request. For details, see `grand_total_amount` field description in [Dynamic Currency Conversion For First Data Using the SCMP API](http://apps.cybersource.com/library/documentation/dev_guides/DCC_FirstData_SCMP/DCC_FirstData_SCMP_API.pdf).
	//
	// #### FDMS South
	// If you accept IDR or CLP currencies, see the entry for FDMS South in "Authorization Information for Specific Processors" of the [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// #### DCC for First Data
	// Not used.
	//
	// Max Length: 19
	TotalAmount string `json:"totalAmount,omitempty"`
}

// Validate validates this create credit params body order information amount details
func (o *CreateCreditParamsBodyOrderInformationAmountDetails) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAmexAdditionalAmounts(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCashbackAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCurrency(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDiscountAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDutyAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExchangeRate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExchangeRateTimeStamp(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateForeignAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateForeignCurrency(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFreightAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateGratuityAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNationalTaxIncluded(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOriginalCurrency(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateServiceFeeAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxAppliedAfterDiscount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxAppliedLevel(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxTypeCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTotalAmount(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyOrderInformationAmountDetails) validateAmexAdditionalAmounts(formats strfmt.Registry) error {
	if swag.IsZero(o.AmexAdditionalAmounts) { // not required
		return nil
	}

	for i := 0; i < len(o.AmexAdditionalAmounts); i++ {
		if swag.IsZero(o.AmexAdditionalAmounts[i]) { // not required
			continue
		}

		if o.AmexAdditionalAmounts[i] != nil {
			if err := o.AmexAdditionalAmounts[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("createCreditRequest" + "." + "orderInformation" + "." + "amountDetails" + "." + "amexAdditionalAmounts" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("createCreditRequest" + "." + "orderInformation" + "." + "amountDetails" + "." + "amexAdditionalAmounts" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformationAmountDetails) validateCashbackAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.CashbackAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"cashbackAmount", "body", o.CashbackAmount, 13); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformationAmountDetails) validateCurrency(formats strfmt.Registry) error {
	if swag.IsZero(o.Currency) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"currency", "body", o.Currency, 3); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformationAmountDetails) validateDiscountAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.DiscountAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"discountAmount", "body", o.DiscountAmount, 15); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformationAmountDetails) validateDutyAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.DutyAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"dutyAmount", "body", o.DutyAmount, 15); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformationAmountDetails) validateExchangeRate(formats strfmt.Registry) error {
	if swag.IsZero(o.ExchangeRate) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"exchangeRate", "body", o.ExchangeRate, 13); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformationAmountDetails) validateExchangeRateTimeStamp(formats strfmt.Registry) error {
	if swag.IsZero(o.ExchangeRateTimeStamp) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"exchangeRateTimeStamp", "body", o.ExchangeRateTimeStamp, 14); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformationAmountDetails) validateForeignAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.ForeignAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"foreignAmount", "body", o.ForeignAmount, 15); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformationAmountDetails) validateForeignCurrency(formats strfmt.Registry) error {
	if swag.IsZero(o.ForeignCurrency) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"foreignCurrency", "body", o.ForeignCurrency, 5); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformationAmountDetails) validateFreightAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.FreightAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"freightAmount", "body", o.FreightAmount, 13); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformationAmountDetails) validateGratuityAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.GratuityAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"gratuityAmount", "body", o.GratuityAmount, 13); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformationAmountDetails) validateNationalTaxIncluded(formats strfmt.Registry) error {
	if swag.IsZero(o.NationalTaxIncluded) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"nationalTaxIncluded", "body", o.NationalTaxIncluded, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformationAmountDetails) validateOriginalCurrency(formats strfmt.Registry) error {
	if swag.IsZero(o.OriginalCurrency) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"originalCurrency", "body", o.OriginalCurrency, 15); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformationAmountDetails) validateServiceFeeAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.ServiceFeeAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"serviceFeeAmount", "body", o.ServiceFeeAmount, 15); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformationAmountDetails) validateTaxAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.TaxAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"taxAmount", "body", o.TaxAmount, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformationAmountDetails) validateTaxAppliedAfterDiscount(formats strfmt.Registry) error {
	if swag.IsZero(o.TaxAppliedAfterDiscount) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"taxAppliedAfterDiscount", "body", o.TaxAppliedAfterDiscount, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformationAmountDetails) validateTaxAppliedLevel(formats strfmt.Registry) error {
	if swag.IsZero(o.TaxAppliedLevel) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"taxAppliedLevel", "body", o.TaxAppliedLevel, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformationAmountDetails) validateTaxDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.TaxDetails) { // not required
		return nil
	}

	for i := 0; i < len(o.TaxDetails); i++ {
		if swag.IsZero(o.TaxDetails[i]) { // not required
			continue
		}

		if o.TaxDetails[i] != nil {
			if err := o.TaxDetails[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("createCreditRequest" + "." + "orderInformation" + "." + "amountDetails" + "." + "taxDetails" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("createCreditRequest" + "." + "orderInformation" + "." + "amountDetails" + "." + "taxDetails" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformationAmountDetails) validateTaxTypeCode(formats strfmt.Registry) error {
	if swag.IsZero(o.TaxTypeCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"taxTypeCode", "body", o.TaxTypeCode, 3); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformationAmountDetails) validateTotalAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.TotalAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"totalAmount", "body", o.TotalAmount, 19); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this create credit params body order information amount details based on the context it is used
func (o *CreateCreditParamsBodyOrderInformationAmountDetails) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateAmexAdditionalAmounts(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateTaxDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyOrderInformationAmountDetails) contextValidateAmexAdditionalAmounts(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.AmexAdditionalAmounts); i++ {

		if o.AmexAdditionalAmounts[i] != nil {
			if err := o.AmexAdditionalAmounts[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("createCreditRequest" + "." + "orderInformation" + "." + "amountDetails" + "." + "amexAdditionalAmounts" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("createCreditRequest" + "." + "orderInformation" + "." + "amountDetails" + "." + "amexAdditionalAmounts" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformationAmountDetails) contextValidateTaxDetails(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.TaxDetails); i++ {

		if o.TaxDetails[i] != nil {
			if err := o.TaxDetails[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("createCreditRequest" + "." + "orderInformation" + "." + "amountDetails" + "." + "taxDetails" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("createCreditRequest" + "." + "orderInformation" + "." + "amountDetails" + "." + "taxDetails" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditParamsBodyOrderInformationAmountDetails) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditParamsBodyOrderInformationAmountDetails) UnmarshalBinary(b []byte) error {
	var res CreateCreditParamsBodyOrderInformationAmountDetails
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditParamsBodyOrderInformationAmountDetailsAmexAdditionalAmountsItems0 create credit params body order information amount details amex additional amounts items0
swagger:model CreateCreditParamsBodyOrderInformationAmountDetailsAmexAdditionalAmountsItems0
*/
type CreateCreditParamsBodyOrderInformationAmountDetailsAmexAdditionalAmountsItems0 struct {

	// Additional amount. This field is supported only for **American Express Direct**.
	//
	// Max Length: 12
	Amount string `json:"amount,omitempty"`

	// Additional amount type. This field is supported only for **American Express Direct**.
	//
	// For processor-specific information, see the `additional_amount_type0` request-level field description in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 3
	Code string `json:"code,omitempty"`
}

// Validate validates this create credit params body order information amount details amex additional amounts items0
func (o *CreateCreditParamsBodyOrderInformationAmountDetailsAmexAdditionalAmountsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyOrderInformationAmountDetailsAmexAdditionalAmountsItems0) validateAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.Amount) { // not required
		return nil
	}

	if err := validate.MaxLength("amount", "body", o.Amount, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformationAmountDetailsAmexAdditionalAmountsItems0) validateCode(formats strfmt.Registry) error {
	if swag.IsZero(o.Code) { // not required
		return nil
	}

	if err := validate.MaxLength("code", "body", o.Code, 3); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create credit params body order information amount details amex additional amounts items0 based on context it is used
func (o *CreateCreditParamsBodyOrderInformationAmountDetailsAmexAdditionalAmountsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditParamsBodyOrderInformationAmountDetailsAmexAdditionalAmountsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditParamsBodyOrderInformationAmountDetailsAmexAdditionalAmountsItems0) UnmarshalBinary(b []byte) error {
	var res CreateCreditParamsBodyOrderInformationAmountDetailsAmexAdditionalAmountsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditParamsBodyOrderInformationAmountDetailsTaxDetailsItems0 create credit params body order information amount details tax details items0
swagger:model CreateCreditParamsBodyOrderInformationAmountDetailsTaxDetailsItems0
*/
type CreateCreditParamsBodyOrderInformationAmountDetailsTaxDetailsItems0 struct {

	// Indicates the amount of tax based on the `type` field as described in the table below:
	//
	// | type      | type description |
	// | ------------- |:-------------:|
	// | `alternate` | Total amount of alternate tax for the order. |
	// | `local`     | Sales tax for the order. |
	// | `national`  | National tax for the order. |
	// | `vat`       | Total amount of value added tax (VAT) included in the order. |
	// | `other`     | Other tax. |
	//
	// Max Length: 13
	Amount string `json:"amount,omitempty"`

	// Flag that indicates whether the alternate tax amount (`orderInformation.amountDetails.taxDetails[].amount`) is
	// included in the request.
	//
	// Possible values:
	// - `false`: alternate tax amount is not included in the request.
	// - `true`: alternate tax amount is included in the request.
	//
	// For processor-specific details, see `alternate_tax_amount_indicator` field description in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/)
	//
	Applied bool `json:"applied,omitempty"`

	// Type of tax being applied to the item.
	//
	// For possible values, see the processor-specific field descriptions in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/):
	//
	// #### FDC Nashville Global
	// - `alternate_tax_type_applied`
	// - `alternate_tax_type_identifier`
	//
	// #### Worldpay VAP
	// - `alternate_tax_type_identifier`
	//
	// #### RBS WorldPay Atlanta
	// - `tax_type_applied`
	//
	// #### TSYS Acquiring Solutions
	// - `tax_type_applied`
	// - `local_tax_indicator`
	//
	// #### Chase Paymentech Solutions
	// - `tax_type_applied`
	//
	// #### Elavon Americas
	// - `local_tax_indicator`
	//
	// #### FDC Compass
	// - `tax_type_applied`
	//
	// #### OmniPay Direct
	// - `local_tax_indicator`
	//
	// Max Length: 4
	Code string `json:"code,omitempty"`

	// Status code for exemption from sales and use tax. This field is a pass-through, which means that
	// CyberSource does not verify the value or modify it in any way before sending it to the processor.
	//
	// For possible values and important information for using this field, see _Appendix B, "Exemption
	// Status Values_ and _Offer-Level Tax Fields_ in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/)
	//
	// Max Length: 1
	ExemptionCode string `json:"exemptionCode,omitempty"`

	// Rate of VAT or other tax for the order.
	//
	// Example 0.040 (=4%)
	//
	// Valid range: 0.01 to 0.99 (1% to 99%, with only whole percentage values accepted; values with additional
	// decimal places will be truncated)
	//
	// For processor-specific details, see the `alternate_tax_amount`, `vat_rate`, `vat_tax_rate`, `local_tax`, `national_tax`, `vat_tax_amount` or `other_tax#_rate` field descriptions in the [Level II and Level III Processing Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/)
	//
	// Max Length: 6
	Rate string `json:"rate,omitempty"`

	// Your tax ID number to use for the alternate tax amount. Required if you set alternate tax amount to any value,
	// including zero. You may send this field without sending alternate tax amount.
	//
	// For processor-specific details, see `alternate_tax_id` field description in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/)
	//
	// Max Length: 15
	TaxID string `json:"taxId,omitempty"`

	// Indicates the type of tax data for the _taxDetails_ object.
	//
	// Possible values:
	//
	// - `alternate`
	// - `local`
	// - `national`
	// - `vat`
	// - `other`
	//
	// For processor-specific details, see the `alternate_tax_amount`, `local_tax`, `national_tax` or `vat_tax_amount` field
	// descriptions in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/)
	//
	Type string `json:"type,omitempty"`
}

// Validate validates this create credit params body order information amount details tax details items0
func (o *CreateCreditParamsBodyOrderInformationAmountDetailsTaxDetailsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExemptionCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyOrderInformationAmountDetailsTaxDetailsItems0) validateAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.Amount) { // not required
		return nil
	}

	if err := validate.MaxLength("amount", "body", o.Amount, 13); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformationAmountDetailsTaxDetailsItems0) validateCode(formats strfmt.Registry) error {
	if swag.IsZero(o.Code) { // not required
		return nil
	}

	if err := validate.MaxLength("code", "body", o.Code, 4); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformationAmountDetailsTaxDetailsItems0) validateExemptionCode(formats strfmt.Registry) error {
	if swag.IsZero(o.ExemptionCode) { // not required
		return nil
	}

	if err := validate.MaxLength("exemptionCode", "body", o.ExemptionCode, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformationAmountDetailsTaxDetailsItems0) validateRate(formats strfmt.Registry) error {
	if swag.IsZero(o.Rate) { // not required
		return nil
	}

	if err := validate.MaxLength("rate", "body", o.Rate, 6); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformationAmountDetailsTaxDetailsItems0) validateTaxID(formats strfmt.Registry) error {
	if swag.IsZero(o.TaxID) { // not required
		return nil
	}

	if err := validate.MaxLength("taxId", "body", o.TaxID, 15); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create credit params body order information amount details tax details items0 based on context it is used
func (o *CreateCreditParamsBodyOrderInformationAmountDetailsTaxDetailsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditParamsBodyOrderInformationAmountDetailsTaxDetailsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditParamsBodyOrderInformationAmountDetailsTaxDetailsItems0) UnmarshalBinary(b []byte) error {
	var res CreateCreditParamsBodyOrderInformationAmountDetailsTaxDetailsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditParamsBodyOrderInformationBillTo create credit params body order information bill to
swagger:model CreateCreditParamsBodyOrderInformationBillTo
*/
type CreateCreditParamsBodyOrderInformationBillTo struct {

	// Payment card billing street address as it appears on the credit card issuers records.
	//
	// #### Atos
	// This field must not contain colons (:).
	//
	// #### CyberSource through VisaNet
	// **Important** When you populate orderInformation.billTo.address1 and orderInformation.billTo.address2,
	// CyberSource through VisaNet concatenates the two values. If the concatenated value exceeds 40 characters,
	// CyberSource through VisaNet truncates the value at 40 characters before sending it to Visa and the issuing bank.
	// Truncating this value affects AVS results and therefore might also affect risk decisions and chargebacks.
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet
	// accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations
	// of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the
	// credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless
	// ASCII characters for transmission to the credit card networks.
	//
	// #### FDMS Nashville
	// When the street name is numeric, it must be sent in numeric format. For example, if the address is _One First Street_,
	// it must be sent as _1 1st Street_.
	//
	// Required if keyed; not used if swiped.
	//
	// String (20)
	//
	// #### TSYS Acquiring Solutions
	// Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.
	//
	// #### All other processors:
	// Optional.
	// String (60)
	//
	// #### For Payouts
	// This field may be sent only for FDC Compass.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// Max Length: 60
	Address1 string `json:"address1,omitempty"`

	// Used for additional address information. For example: _Attention: Accounts Payable_
	// Optional field.
	//
	// For Payouts: This field may be sent only for FDC Compass.
	//
	// #### Atos
	// This field must not contain colons (:).
	//
	// #### CyberSource through VisaNet
	// **Important** When you populate `orderInformation.billTo.address1` and `orderInformation.billTo.address2`,
	// CyberSource through VisaNet concatenates the two values. If the concatenated value exceeds 40 characters,
	// CyberSource through VisaNet truncates the value at 40 characters before sending it to Visa and the issuing bank.
	// Truncating this value affects AVS results and therefore might also affect risk decisions and chargebacks.
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet
	// accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations
	// of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the
	// credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless
	// ASCII characters for transmission to the credit card networks.
	//
	// #### Chase Paymentech Solutions, FDC Compass, and TSYS Acquiring Solutions
	// This value is used for AVS.
	//
	// #### FDMS Nashville
	// `orderInformation.billTo.address1` and `orderInformation.billTo.address2` together cannot exceed 20 characters.
	// String (20)
	//
	// #### All Other Processors
	// String (60)
	//
	// Max Length: 60
	Address2 string `json:"address2,omitempty"`

	// State or province of the billing address. Use the [State, Province, and Territory Codes for the United States and Canada](https://developer.cybersource.com/library/documentation/sbc/quickref/states_and_provinces.pdf).
	//
	// For Payouts: This field may be sent only for FDC Compass.
	//
	// ##### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet
	// accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations
	// of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the
	// credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless
	// ASCII characters for transmission to the credit card networks.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// #### Chase Paymentech Solutions
	// Optional field.
	//
	// ####  Credit Mutuel-CIC
	// Optional field.
	//
	// #### OmniPay Direct
	// Optional field.
	//
	// #### SIX
	// Optional field.
	//
	// #### TSYS Acquiring Solutions
	// Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.
	//
	// #### Worldpay VAP
	// Optional field.
	//
	// #### All other processors
	// Not used.
	//
	// Max Length: 20
	AdministrativeArea string `json:"administrativeArea,omitempty"`

	// company
	Company *CreateCreditParamsBodyOrderInformationBillToCompany `json:"company,omitempty"`

	// Payment card billing country. Use the two-character [ISO Standard Country Codes](http://apps.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf).
	//
	// #### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet
	// accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations
	// of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the
	// credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII
	// characters for transmission to the credit card networks.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// #### Chase Paymentech Solutions
	// Optional field.
	//
	// ####  Credit Mutuel-CIC
	// Optional field.
	//
	// #### OmniPay Direct
	// Optional field.
	//
	// #### SIX
	// Optional field.
	//
	// #### TSYS Acquiring Solutions
	// Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.
	//
	// #### Worldpay VAP
	// Optional field.
	//
	// #### All other processors
	// Not used.
	//
	// Max Length: 2
	Country string `json:"country,omitempty"`

	// Customer's email address, including the full domain name.
	//
	// #### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// For processor-specific information, see the `customer_email` request-level field description in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// #### Invoicing
	// Email address for the customer for sending the invoice. If the invoice is in SENT status and email is updated, the old email customer payment link won't work and you must resend the invoice with the new payment link.
	//
	// #### Chase Paymentech Solutions
	// Optional field.
	//
	// ####  Credit Mutuel-CIC
	// Optional field.
	//
	// #### OmniPay Direct
	// Optional field.
	//
	// #### SIX
	// Optional field.
	//
	// #### TSYS Acquiring Solutions
	// Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.
	//
	// #### Worldpay VAP
	// Optional field.
	//
	// #### All other processors
	// Not used.
	//
	// Max Length: 255
	Email string `json:"email,omitempty"`

	// Customers first name. This name must be the same as the name on the card.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// #### CyberSource Latin American Processing
	// **Important** For an authorization request, CyberSource Latin American Processing concatenates `orderInformation.billTo.firstName` and `orderInformation.billTo.lastName`. If the concatenated value exceeds 30 characters, CyberSource Latin American Processing declines the authorization request.\
	// **Note** CyberSource Latin American Processing is the name of a specific processing connection that CyberSource supports. In the CyberSource API documentation, CyberSource Latin American Processing does not refer to the general topic of processing in Latin America. The information in this field description is for the specific processing connection called _CyberSource Latin American Processing_. It is not for any other Latin American processors that CyberSource supports.
	//
	// #### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.
	//
	// #### For Payouts:
	// This field may be sent only for FDC Compass.
	//
	// #### Chase Paymentech Solutions
	// Optional field.
	//
	// ####  Credit Mutuel-CIC
	// Optional field.
	//
	// #### OmniPay Direct
	// Optional field.
	//
	// #### SIX
	// Optional field.
	//
	// #### TSYS Acquiring Solutions
	// Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.
	//
	// #### Worldpay VAP
	// Optional field.
	//
	// #### All other processors
	// Not used.
	//
	// Max Length: 60
	FirstName string `json:"firstName,omitempty"`

	// Customers last name. This name must be the same as the name on the card.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// #### Chase Paymentech Solutions
	// Optional field.
	//
	// ####  Credit Mutuel-CIC
	// Optional field.
	//
	// #### CyberSource Latin American Processing
	// **Important** For an authorization request, CyberSource Latin American Processing concatenates `orderInformation.billTo.firstName` and `orderInformation.billTo.lastName`. If the concatenated value exceeds 30 characters, CyberSource Latin American Processing declines the authorization request.\
	// **Note** CyberSource Latin American Processing is the name of a specific processing connection that CyberSource supports. In the CyberSource API documentation, CyberSource Latin American Processing does not refer to the general topic of processing in Latin America. The information in this field description is for the specific processing connection called CyberSource Latin American Processing. It is not for any other Latin American processors that CyberSource supports.
	//
	// #### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.
	//
	// #### For Payouts:
	// This field may be sent only for FDC Compass.
	//
	// #### OmniPay Direct
	// Optional field.
	//
	// #### RBS WorldPay Atlanta
	// Optional field.
	//
	// #### SIX
	// Optional field.
	//
	// #### TSYS Acquiring Solutions
	// Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.
	//
	// #### Worldpay VAP
	// Optional field.
	//
	// #### All other processors
	// Not used.
	//
	// Max Length: 60
	LastName string `json:"lastName,omitempty"`

	// Payment card billing city.
	//
	// #### Atos
	// This field must not contain colons (:).
	//
	// #### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.
	//
	// #### For Payouts:
	// This field may be sent only for FDC Compass.
	//
	// #### Chase Paymentech Solutions
	// Optional field.
	//
	// ####  Credit Mutuel-CIC
	// Optional field.
	//
	// #### OmniPay Direct
	// Optional field.
	//
	// #### SIX
	// Optional field.
	//
	// #### TSYS Acquiring Solutions
	// Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.
	//
	// #### Worldpay VAP
	// Optional field.
	//
	// #### All other processors
	// Not used.
	//
	// Max Length: 50
	Locality string `json:"locality,omitempty"`

	// Customers phone number.
	//
	// It is recommended that you include the country code when the order is from outside the U.S.
	//
	// #### Chase Paymentech Solutions
	// Optional field.
	//
	// ####  Credit Mutuel-CIC
	// Optional field.
	//
	// #### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.
	//
	// #### For Payouts:
	// This field may be sent only for FDC Compass.
	//
	// #### OmniPay Direct
	// Optional field.
	//
	// #### SIX
	// Optional field.
	//
	// #### TSYS Acquiring Solutions
	// Optional field.
	//
	// #### Worldpay VAP
	// Optional field.
	//
	// #### All other processors
	// Not used.
	//
	// Max Length: 15
	PhoneNumber string `json:"phoneNumber,omitempty"`

	// Postal code for the billing address. The postal code must consist of 5 to 9 digits.
	//
	// When the billing country is the U.S., the 9-digit postal code must follow this format:
	// [5 digits][dash][4 digits]
	//
	// **Example** `12345-6789`
	//
	// When the billing country is Canada, the 6-digit postal code must follow this format:
	// [alpha][numeric][alpha][space][numeric][alpha][numeric]
	//
	// **Example** `A1B 2C3`
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// #### For Payouts:
	//  This field may be sent only for FDC Compass.
	//
	// #### American Express Direct
	// Before sending the postal code to the processor, CyberSource removes all nonalphanumeric characters and, if the remaining value is longer than nine characters, truncates the value starting from the right side.
	//
	// #### Atos
	// This field must not contain colons (:).
	//
	// #### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet
	// accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations
	// of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the
	// credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII
	// characters for transmission to the credit card networks.
	//
	// #### FDMS Nashville
	// Required if `pointOfSaleInformation.entryMode=keyed` and the address is in the U.S. or Canada.
	// Optional if `pointOfSaleInformation.entryMode=keyed` and the address is **not** in the U.S. or Canada.
	// Not used if swiped.
	//
	// #### RBS WorldPay Atlanta:
	// For best card-present keyed rates, send the postal code if `pointOfSaleInformation.entryMode=keyed`.
	//
	// #### TSYS Acquiring Solutions
	// Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.
	//
	// #### All other processors:
	// Optional field.
	//
	// Max Length: 10
	PostalCode string `json:"postalCode,omitempty"`
}

// Validate validates this create credit params body order information bill to
func (o *CreateCreditParamsBodyOrderInformationBillTo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAddress1(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAddress2(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAdministrativeArea(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCompany(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEmail(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFirstName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLastName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocality(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePhoneNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyOrderInformationBillTo) validateAddress1(formats strfmt.Registry) error {
	if swag.IsZero(o.Address1) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"orderInformation"+"."+"billTo"+"."+"address1", "body", o.Address1, 60); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformationBillTo) validateAddress2(formats strfmt.Registry) error {
	if swag.IsZero(o.Address2) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"orderInformation"+"."+"billTo"+"."+"address2", "body", o.Address2, 60); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformationBillTo) validateAdministrativeArea(formats strfmt.Registry) error {
	if swag.IsZero(o.AdministrativeArea) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"orderInformation"+"."+"billTo"+"."+"administrativeArea", "body", o.AdministrativeArea, 20); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformationBillTo) validateCompany(formats strfmt.Registry) error {
	if swag.IsZero(o.Company) { // not required
		return nil
	}

	if o.Company != nil {
		if err := o.Company.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "orderInformation" + "." + "billTo" + "." + "company")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "orderInformation" + "." + "billTo" + "." + "company")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformationBillTo) validateCountry(formats strfmt.Registry) error {
	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"orderInformation"+"."+"billTo"+"."+"country", "body", o.Country, 2); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformationBillTo) validateEmail(formats strfmt.Registry) error {
	if swag.IsZero(o.Email) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"orderInformation"+"."+"billTo"+"."+"email", "body", o.Email, 255); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformationBillTo) validateFirstName(formats strfmt.Registry) error {
	if swag.IsZero(o.FirstName) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"orderInformation"+"."+"billTo"+"."+"firstName", "body", o.FirstName, 60); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformationBillTo) validateLastName(formats strfmt.Registry) error {
	if swag.IsZero(o.LastName) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"orderInformation"+"."+"billTo"+"."+"lastName", "body", o.LastName, 60); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformationBillTo) validateLocality(formats strfmt.Registry) error {
	if swag.IsZero(o.Locality) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"orderInformation"+"."+"billTo"+"."+"locality", "body", o.Locality, 50); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformationBillTo) validatePhoneNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.PhoneNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"orderInformation"+"."+"billTo"+"."+"phoneNumber", "body", o.PhoneNumber, 15); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformationBillTo) validatePostalCode(formats strfmt.Registry) error {
	if swag.IsZero(o.PostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"orderInformation"+"."+"billTo"+"."+"postalCode", "body", o.PostalCode, 10); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this create credit params body order information bill to based on the context it is used
func (o *CreateCreditParamsBodyOrderInformationBillTo) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateCompany(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyOrderInformationBillTo) contextValidateCompany(ctx context.Context, formats strfmt.Registry) error {

	if o.Company != nil {
		if err := o.Company.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "orderInformation" + "." + "billTo" + "." + "company")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "orderInformation" + "." + "billTo" + "." + "company")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditParamsBodyOrderInformationBillTo) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditParamsBodyOrderInformationBillTo) UnmarshalBinary(b []byte) error {
	var res CreateCreditParamsBodyOrderInformationBillTo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditParamsBodyOrderInformationBillToCompany create credit params body order information bill to company
swagger:model CreateCreditParamsBodyOrderInformationBillToCompany
*/
type CreateCreditParamsBodyOrderInformationBillToCompany struct {

	// First line in the street address of the company purchasing the product.
	// Max Length: 40
	Address1 string `json:"address1,omitempty"`

	// Additional address information for the company purchasing the product.
	// Max Length: 40
	Address2 string `json:"address2,omitempty"`

	// State or province in the address of the company purchasing the product. Use the State, Province, and Territory
	// Codes for the United States and Canada.
	//
	// Max Length: 2
	AdministrativeArea string `json:"administrativeArea,omitempty"`

	// Country in the address of the company purchasing the product. Use the [ISO Standard Country Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf).
	//
	// Max Length: 2
	Country string `json:"country,omitempty"`

	// City in the address of the company purchasing the product.
	// Max Length: 30
	Locality string `json:"locality,omitempty"`

	// Name of the customers company.
	//
	// **CyberSource through VisaNet**
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.
	//
	// For processor-specific information, see the `company_name` field in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 60
	Name string `json:"name,omitempty"`

	// Postal code in the address of the company purchasing the product. The postal code must consist of 5 to 9 digits.
	//
	// When the company country is the U.S., the 9-digit postal code must follow this format:
	// **[5 digits][dash][4 digits]**
	// #### Example
	// `12345-6789`
	//
	// When the company country is Canada, the 6-digit postal code must follow this format:
	// **[alpha][numeric][alpha][space][numeric][alpha][numeric]**
	// #### Example
	// `A1B 2C3`
	//
	// Max Length: 10
	PostalCode string `json:"postalCode,omitempty"`
}

// Validate validates this create credit params body order information bill to company
func (o *CreateCreditParamsBodyOrderInformationBillToCompany) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAddress1(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAddress2(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAdministrativeArea(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocality(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyOrderInformationBillToCompany) validateAddress1(formats strfmt.Registry) error {
	if swag.IsZero(o.Address1) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"orderInformation"+"."+"billTo"+"."+"company"+"."+"address1", "body", o.Address1, 40); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformationBillToCompany) validateAddress2(formats strfmt.Registry) error {
	if swag.IsZero(o.Address2) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"orderInformation"+"."+"billTo"+"."+"company"+"."+"address2", "body", o.Address2, 40); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformationBillToCompany) validateAdministrativeArea(formats strfmt.Registry) error {
	if swag.IsZero(o.AdministrativeArea) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"orderInformation"+"."+"billTo"+"."+"company"+"."+"administrativeArea", "body", o.AdministrativeArea, 2); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformationBillToCompany) validateCountry(formats strfmt.Registry) error {
	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"orderInformation"+"."+"billTo"+"."+"company"+"."+"country", "body", o.Country, 2); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformationBillToCompany) validateLocality(formats strfmt.Registry) error {
	if swag.IsZero(o.Locality) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"orderInformation"+"."+"billTo"+"."+"company"+"."+"locality", "body", o.Locality, 30); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformationBillToCompany) validateName(formats strfmt.Registry) error {
	if swag.IsZero(o.Name) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"orderInformation"+"."+"billTo"+"."+"company"+"."+"name", "body", o.Name, 60); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformationBillToCompany) validatePostalCode(formats strfmt.Registry) error {
	if swag.IsZero(o.PostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"orderInformation"+"."+"billTo"+"."+"company"+"."+"postalCode", "body", o.PostalCode, 10); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create credit params body order information bill to company based on context it is used
func (o *CreateCreditParamsBodyOrderInformationBillToCompany) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditParamsBodyOrderInformationBillToCompany) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditParamsBodyOrderInformationBillToCompany) UnmarshalBinary(b []byte) error {
	var res CreateCreditParamsBodyOrderInformationBillToCompany
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditParamsBodyOrderInformationInvoiceDetails create credit params body order information invoice details
swagger:model CreateCreditParamsBodyOrderInformationInvoiceDetails
*/
type CreateCreditParamsBodyOrderInformationInvoiceDetails struct {

	// International description code of the overall orders goods or services or the Categorizes purchases for VAT
	// reporting. Contact your acquirer for a list of codes.
	//
	// For processor-specific information, see the `summary_commodity_code` field in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 4
	CommodityCode string `json:"commodityCode,omitempty"`

	// The name of the individual or the company contacted for company authorized purchases.
	//
	// For processor-specific information, see the `authorized_contact_name` field in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 36
	PurchaseContactName string `json:"purchaseContactName,omitempty"`

	// Date the order was processed. `Format: YYYY-MM-DD`.
	//
	// For processor-specific information, see the `purchaser_order_date` field in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 10
	PurchaseOrderDate string `json:"purchaseOrderDate,omitempty"`

	// Value used by your customer to identify the order. This value is typically a purchase order number. CyberSource
	// recommends that you do not populate the field with all zeros or nines.
	//
	// For processor-specific information, see the `user_po` field in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 25
	PurchaseOrderNumber string `json:"purchaseOrderNumber,omitempty"`

	// Flag that indicates whether an order is taxable. This value must be true if the sum of all _lineItems[].taxAmount_ values > 0.
	//
	// If you do not include any `lineItems[].taxAmount` values in your request, CyberSource does not include
	// `invoiceDetails.taxable` in the data it sends to the processor.
	//
	// For processor-specific information, see the `tax_indicator` field in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Possible values:
	//  - **true**
	//  - **false**
	//
	Taxable bool `json:"taxable,omitempty"`

	// transaction advice addendum
	TransactionAdviceAddendum []*CreateCreditParamsBodyOrderInformationInvoiceDetailsTransactionAdviceAddendumItems0 `json:"transactionAdviceAddendum"`

	// VAT invoice number associated with the transaction.
	//
	// For processor-specific information, see the `vat_invoice_ref_number` field in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 15
	VatInvoiceReferenceNumber string `json:"vatInvoiceReferenceNumber,omitempty"`
}

// Validate validates this create credit params body order information invoice details
func (o *CreateCreditParamsBodyOrderInformationInvoiceDetails) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCommodityCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePurchaseContactName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePurchaseOrderDate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePurchaseOrderNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTransactionAdviceAddendum(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateVatInvoiceReferenceNumber(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyOrderInformationInvoiceDetails) validateCommodityCode(formats strfmt.Registry) error {
	if swag.IsZero(o.CommodityCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"orderInformation"+"."+"invoiceDetails"+"."+"commodityCode", "body", o.CommodityCode, 4); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformationInvoiceDetails) validatePurchaseContactName(formats strfmt.Registry) error {
	if swag.IsZero(o.PurchaseContactName) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"orderInformation"+"."+"invoiceDetails"+"."+"purchaseContactName", "body", o.PurchaseContactName, 36); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformationInvoiceDetails) validatePurchaseOrderDate(formats strfmt.Registry) error {
	if swag.IsZero(o.PurchaseOrderDate) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"orderInformation"+"."+"invoiceDetails"+"."+"purchaseOrderDate", "body", o.PurchaseOrderDate, 10); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformationInvoiceDetails) validatePurchaseOrderNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.PurchaseOrderNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"orderInformation"+"."+"invoiceDetails"+"."+"purchaseOrderNumber", "body", o.PurchaseOrderNumber, 25); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformationInvoiceDetails) validateTransactionAdviceAddendum(formats strfmt.Registry) error {
	if swag.IsZero(o.TransactionAdviceAddendum) { // not required
		return nil
	}

	for i := 0; i < len(o.TransactionAdviceAddendum); i++ {
		if swag.IsZero(o.TransactionAdviceAddendum[i]) { // not required
			continue
		}

		if o.TransactionAdviceAddendum[i] != nil {
			if err := o.TransactionAdviceAddendum[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("createCreditRequest" + "." + "orderInformation" + "." + "invoiceDetails" + "." + "transactionAdviceAddendum" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("createCreditRequest" + "." + "orderInformation" + "." + "invoiceDetails" + "." + "transactionAdviceAddendum" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformationInvoiceDetails) validateVatInvoiceReferenceNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.VatInvoiceReferenceNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"orderInformation"+"."+"invoiceDetails"+"."+"vatInvoiceReferenceNumber", "body", o.VatInvoiceReferenceNumber, 15); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this create credit params body order information invoice details based on the context it is used
func (o *CreateCreditParamsBodyOrderInformationInvoiceDetails) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateTransactionAdviceAddendum(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyOrderInformationInvoiceDetails) contextValidateTransactionAdviceAddendum(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.TransactionAdviceAddendum); i++ {

		if o.TransactionAdviceAddendum[i] != nil {
			if err := o.TransactionAdviceAddendum[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("createCreditRequest" + "." + "orderInformation" + "." + "invoiceDetails" + "." + "transactionAdviceAddendum" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("createCreditRequest" + "." + "orderInformation" + "." + "invoiceDetails" + "." + "transactionAdviceAddendum" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditParamsBodyOrderInformationInvoiceDetails) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditParamsBodyOrderInformationInvoiceDetails) UnmarshalBinary(b []byte) error {
	var res CreateCreditParamsBodyOrderInformationInvoiceDetails
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditParamsBodyOrderInformationInvoiceDetailsTransactionAdviceAddendumItems0 create credit params body order information invoice details transaction advice addendum items0
swagger:model CreateCreditParamsBodyOrderInformationInvoiceDetailsTransactionAdviceAddendumItems0
*/
type CreateCreditParamsBodyOrderInformationInvoiceDetailsTransactionAdviceAddendumItems0 struct {

	// Four Transaction Advice Addendum (TAA) fields. These fields are used to display descriptive information
	// about a transaction on the customers American Express card statement. When you send TAA fields, start
	// with amexdata_taa1, then ...taa2, and so on. Skipping a TAA field causes subsequent TAA fields to be
	// ignored.
	//
	// To use these fields, contact CyberSource Customer Support to have your account enabled for this feature.
	//
	// Max Length: 40
	Data string `json:"data,omitempty"`
}

// Validate validates this create credit params body order information invoice details transaction advice addendum items0
func (o *CreateCreditParamsBodyOrderInformationInvoiceDetailsTransactionAdviceAddendumItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateData(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyOrderInformationInvoiceDetailsTransactionAdviceAddendumItems0) validateData(formats strfmt.Registry) error {
	if swag.IsZero(o.Data) { // not required
		return nil
	}

	if err := validate.MaxLength("data", "body", o.Data, 40); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create credit params body order information invoice details transaction advice addendum items0 based on context it is used
func (o *CreateCreditParamsBodyOrderInformationInvoiceDetailsTransactionAdviceAddendumItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditParamsBodyOrderInformationInvoiceDetailsTransactionAdviceAddendumItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditParamsBodyOrderInformationInvoiceDetailsTransactionAdviceAddendumItems0) UnmarshalBinary(b []byte) error {
	var res CreateCreditParamsBodyOrderInformationInvoiceDetailsTransactionAdviceAddendumItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditParamsBodyOrderInformationLineItemsItems0 create credit params body order information line items items0
swagger:model CreateCreditParamsBodyOrderInformationLineItemsItems0
*/
type CreateCreditParamsBodyOrderInformationLineItemsItems0 struct {

	// Flag that indicates whether the tax amount is included in the Line Item Total.
	//
	// Possible values:
	//  - **true**
	//  - **false**
	//
	AmountIncludesTax bool `json:"amountIncludesTax,omitempty"`

	// Commodity code or International description code used to classify the item. Contact your acquirer for a list of
	// codes.
	//
	// Max Length: 15
	CommodityCode string `json:"commodityCode,omitempty"`

	// Discount applied to the item.
	// Max Length: 13
	DiscountAmount string `json:"discountAmount,omitempty"`

	// Flag that indicates whether the amount is discounted.
	//
	// If you do not provide a value but you set Discount Amount to a value greater than zero, then CyberSource sets
	// this field to **true**.
	//
	// Possible values:
	//  - **true**
	//  - **false**
	//
	DiscountApplied bool `json:"discountApplied,omitempty"`

	// Rate the item is discounted. Maximum of 2 decimal places.
	//
	// Example 5.25 (=5.25%)
	//
	// Max Length: 6
	DiscountRate string `json:"discountRate,omitempty"`

	// Field to support an invoice number for a transaction. You must specify the number of line items that will
	// include an invoice number. By default, the first line item will include an invoice number field. The invoice
	// number field can be included for up to 10 line items.
	//
	// Max Length: 23
	InvoiceNumber string `json:"invoiceNumber,omitempty"`

	// Type of product. The value for this field is used to identify the product category (electronic, handling, physical,
	// service, or shipping). The default value is `default`.
	//
	// If you are performing an authorization transaction (`processingOptions.capture` is set to `false`), and you set
	// this field to a value other than `default` or one of the values related to shipping and/or handling, then
	// `orderInformation.lineItems[].quantity`, `orderInformation.lineItems[].productName`, and
	// `orderInformation.lineItems[].productSku` fields are required.
	//
	// Optional field.
	//
	// For details, see the `product_code` field description in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/).
	//
	// #### Tax Calculation
	// Optional field for U.S., Canadian, international tax, and value added taxes.
	//
	// To use the tax calculation service, use values listed in the Tax Product Code Guide. For information about this
	// document, contact customer support. See "Product Codes," page 14, for more information.
	//
	// Max Length: 255
	ProductCode string `json:"productCode,omitempty"`

	// For an authorization or capture transaction (`processingOptions.capture` is `true` or `false`),
	// this field is required when `orderInformation.lineItems[].productCode` is not `default` or one of
	// the other values that are related to shipping and/or handling.
	//
	// #### Tax Calculation
	// Optional field for U.S., Canadian, international tax, and value added taxes.
	//
	// Max Length: 255
	ProductName string `json:"productName,omitempty"`

	// Product identifier code. Also known as the Stock Keeping Unit (SKU) code for the product.
	//
	// For an authorization or capture transaction (`processingOptions.capture` is set to `true` or `false`), this field is required when `orderInformation.lineItems[].productCode` is not set to **default** or one of the other values that are related to shipping and/or handling.
	//
	// #### Tax Calculation
	// Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes.
	// For an authorization or capture transaction (`processingOptions.capture` is set to `true` or `false`), this field is
	// required when `orderInformation.lineItems[].productCode` is not `default` or one of the values related to shipping and/or handling.
	//
	// Max Length: 255
	ProductSku string `json:"productSku,omitempty"`

	// Number of units for this order. Must be a non-negative integer.
	//
	// The default is `1`. For an authorization or capture transaction (`processingOptions.capture` is set to `true` or `false`),
	// this field is required when `orderInformation.lineItems[].productCode` is not `default` or one of the other values
	// related to shipping and/or handling.
	//
	// #### Tax Calculation
	// Optional field for U.S., Canadian, international tax, and value added taxes.
	//
	// Maximum: 9.99999999e+08
	// Minimum: 1
	Quantity int64 `json:"quantity,omitempty"`

	// Total tax to apply to the product. This value cannot be negative. The tax amount and the offer amount must
	// be in the same currency. The tax amount field is additive.
	//
	// The following example uses a two-exponent currency such as USD:
	//
	//  1. You include each line item in your request.
	//  ..- 1st line item has amount=10.00, quantity=1, and taxAmount=0.80
	//  ..- 2nd line item has amount=20.00, quantity=1, and taxAmount=1.60
	//  2. The total amount authorized will be 32.40, not 30.00 with 2.40 of tax included.
	//
	// Optional field.
	//
	// #### Airlines processing
	// Tax portion of the order amount. This value cannot exceed 99999999999999 (fourteen 9s).
	// Format: English characters only.
	// Optional request field for a line item.
	//
	// #### Tax Calculation
	// Optional field for U.S., Canadian, international tax, and value added taxes.
	//
	// Note if you send this field in your tax request, the value in the field will override the tax engine
	//
	// Max Length: 15
	TaxAmount string `json:"taxAmount,omitempty"`

	// Flag to indicate how you handle discount at the line item level.
	//
	//  - 0: no line level discount provided
	//  - 1: tax was calculated on the post-discount line item total
	//  - 2: tax was calculated on the pre-discount line item total
	//
	// `Note` Visa will inset 0 (zero) if an invalid value is included in this field.
	//
	// This field relates to the value in the _lineItems[].discountAmount_ field.
	//
	// Max Length: 1
	TaxAppliedAfterDiscount string `json:"taxAppliedAfterDiscount,omitempty"`

	// tax details
	TaxDetails []*CreateCreditParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0 `json:"taxDetails"`

	// Tax rate applied to the item.
	//
	// For details, see `tax_rate` field description in the [Level II and Level III Processing Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/)
	//
	// **Visa**: Valid range is 0.01 to 0.99 (1% to 99%, with only whole percentage values accepted; values with additional
	// decimal places will be truncated).
	//
	// **Mastercard**: Valid range is 0.00001 to 0.99999 (0.001% to 99.999%).
	//
	// Max Length: 7
	TaxRate string `json:"taxRate,omitempty"`

	// Flag to indicate whether tax is exempted or not included.
	//
	//  - 0: tax not included
	//  - 1: tax included
	//  - 2: transaction is not subject to tax
	//
	// Max Length: 1
	TaxStatusIndicator string `json:"taxStatusIndicator,omitempty"`

	// Type of tax being applied to the item.
	//
	// For possible values, see the processor-specific field descriptions in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/):
	//
	// #### FDC Nashville Global
	// - `alternate_tax_type_applied`
	// - `alternate_tax_type_identifier`
	//
	// #### Worldpay VAP
	// - `alternate_tax_type_identifier`
	//
	// #### RBS WorldPay Atlanta
	// - `tax_type_applied`
	//
	// #### TSYS Acquiring Solutions
	// - `tax_type_applied`
	// - `local_tax_indicator`
	//
	// #### Chase Paymentech Solutions
	// - `tax_type_applied`
	//
	// #### Elavon Americas
	// - `local_tax_indicator`
	//
	// #### FDC Compass
	// - `tax_type_applied`
	//
	// #### OmniPay Direct
	// - `local_tax_indicator`
	//
	// Max Length: 4
	TaxTypeCode string `json:"taxTypeCode,omitempty"`

	// Total amount for the item. Normally calculated as the unit price times quantity.
	//
	// When `orderInformation.lineItems[].productCode` is "gift_card", this is the purchase amount total
	// for prepaid gift cards in major units.
	//
	// Example: 123.45 USD = 123
	//
	// Max Length: 13
	TotalAmount string `json:"totalAmount,omitempty"`

	// Flag to indicate whether the purchase is categorized as goods or services.
	// Possible values:
	//
	//  - 00: goods
	//  - 01: services
	//
	// Max Length: 2
	TypeOfSupply string `json:"typeOfSupply,omitempty"`

	// Unit of measure, or unit of measure code, for the item.
	//
	// Max Length: 12
	UnitOfMeasure string `json:"unitOfMeasure,omitempty"`

	// Per-item price of the product. This value for this field cannot be negative.
	//
	// You must include either this field or the request-level field `orderInformation.amountDetails.totalAmount` in your request.
	//
	// You can include a decimal point (.), but you cannot include any other special characters.
	// The value is truncated to the correct number of decimal places.
	//
	// #### DCC with a Third-Party Provider
	// Set this field to the converted amount that was returned by the DCC provider. You must include either
	// the 1st line item in the order and this field, or the request-level field `orderInformation.amountDetails.totalAmount` in your request.
	//
	// #### FDMS South
	// If you accept IDR or CLP currencies, see the entry for FDMS South in the [Merchant Descriptors Using the SCMP API Guide.]
	// (https://apps.cybersource.com/library/documentation/dev_guides/Merchant_Descriptors_SCMP_API/html/)
	//
	// #### Tax Calculation
	// Required field for U.S., Canadian, international and value added taxes.
	//
	// #### Zero Amount Authorizations
	// If your processor supports zero amount authorizations, you can set this field to 0 for the
	// authorization to check if the card is lost or stolen.
	//
	// #### Maximum Field Lengths
	// For GPN and JCN Gateway: Decimal (10)
	// All other processors: Decimal (15)
	//
	// Max Length: 15
	UnitPrice string `json:"unitPrice,omitempty"`
}

// Validate validates this create credit params body order information line items items0
func (o *CreateCreditParamsBodyOrderInformationLineItemsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCommodityCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDiscountAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDiscountRate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateInvoiceNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProductCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProductName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProductSku(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateQuantity(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxAppliedAfterDiscount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxRate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxStatusIndicator(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxTypeCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTotalAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTypeOfSupply(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateUnitOfMeasure(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateUnitPrice(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyOrderInformationLineItemsItems0) validateCommodityCode(formats strfmt.Registry) error {
	if swag.IsZero(o.CommodityCode) { // not required
		return nil
	}

	if err := validate.MaxLength("commodityCode", "body", o.CommodityCode, 15); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformationLineItemsItems0) validateDiscountAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.DiscountAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("discountAmount", "body", o.DiscountAmount, 13); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformationLineItemsItems0) validateDiscountRate(formats strfmt.Registry) error {
	if swag.IsZero(o.DiscountRate) { // not required
		return nil
	}

	if err := validate.MaxLength("discountRate", "body", o.DiscountRate, 6); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformationLineItemsItems0) validateInvoiceNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.InvoiceNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("invoiceNumber", "body", o.InvoiceNumber, 23); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformationLineItemsItems0) validateProductCode(formats strfmt.Registry) error {
	if swag.IsZero(o.ProductCode) { // not required
		return nil
	}

	if err := validate.MaxLength("productCode", "body", o.ProductCode, 255); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformationLineItemsItems0) validateProductName(formats strfmt.Registry) error {
	if swag.IsZero(o.ProductName) { // not required
		return nil
	}

	if err := validate.MaxLength("productName", "body", o.ProductName, 255); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformationLineItemsItems0) validateProductSku(formats strfmt.Registry) error {
	if swag.IsZero(o.ProductSku) { // not required
		return nil
	}

	if err := validate.MaxLength("productSku", "body", o.ProductSku, 255); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformationLineItemsItems0) validateQuantity(formats strfmt.Registry) error {
	if swag.IsZero(o.Quantity) { // not required
		return nil
	}

	if err := validate.MinimumInt("quantity", "body", o.Quantity, 1, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("quantity", "body", o.Quantity, 9.99999999e+08, false); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformationLineItemsItems0) validateTaxAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.TaxAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("taxAmount", "body", o.TaxAmount, 15); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformationLineItemsItems0) validateTaxAppliedAfterDiscount(formats strfmt.Registry) error {
	if swag.IsZero(o.TaxAppliedAfterDiscount) { // not required
		return nil
	}

	if err := validate.MaxLength("taxAppliedAfterDiscount", "body", o.TaxAppliedAfterDiscount, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformationLineItemsItems0) validateTaxDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.TaxDetails) { // not required
		return nil
	}

	for i := 0; i < len(o.TaxDetails); i++ {
		if swag.IsZero(o.TaxDetails[i]) { // not required
			continue
		}

		if o.TaxDetails[i] != nil {
			if err := o.TaxDetails[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("taxDetails" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("taxDetails" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformationLineItemsItems0) validateTaxRate(formats strfmt.Registry) error {
	if swag.IsZero(o.TaxRate) { // not required
		return nil
	}

	if err := validate.MaxLength("taxRate", "body", o.TaxRate, 7); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformationLineItemsItems0) validateTaxStatusIndicator(formats strfmt.Registry) error {
	if swag.IsZero(o.TaxStatusIndicator) { // not required
		return nil
	}

	if err := validate.MaxLength("taxStatusIndicator", "body", o.TaxStatusIndicator, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformationLineItemsItems0) validateTaxTypeCode(formats strfmt.Registry) error {
	if swag.IsZero(o.TaxTypeCode) { // not required
		return nil
	}

	if err := validate.MaxLength("taxTypeCode", "body", o.TaxTypeCode, 4); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformationLineItemsItems0) validateTotalAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.TotalAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("totalAmount", "body", o.TotalAmount, 13); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformationLineItemsItems0) validateTypeOfSupply(formats strfmt.Registry) error {
	if swag.IsZero(o.TypeOfSupply) { // not required
		return nil
	}

	if err := validate.MaxLength("typeOfSupply", "body", o.TypeOfSupply, 2); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformationLineItemsItems0) validateUnitOfMeasure(formats strfmt.Registry) error {
	if swag.IsZero(o.UnitOfMeasure) { // not required
		return nil
	}

	if err := validate.MaxLength("unitOfMeasure", "body", o.UnitOfMeasure, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformationLineItemsItems0) validateUnitPrice(formats strfmt.Registry) error {
	if swag.IsZero(o.UnitPrice) { // not required
		return nil
	}

	if err := validate.MaxLength("unitPrice", "body", o.UnitPrice, 15); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this create credit params body order information line items items0 based on the context it is used
func (o *CreateCreditParamsBodyOrderInformationLineItemsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateTaxDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyOrderInformationLineItemsItems0) contextValidateTaxDetails(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.TaxDetails); i++ {

		if o.TaxDetails[i] != nil {
			if err := o.TaxDetails[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("taxDetails" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("taxDetails" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditParamsBodyOrderInformationLineItemsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditParamsBodyOrderInformationLineItemsItems0) UnmarshalBinary(b []byte) error {
	var res CreateCreditParamsBodyOrderInformationLineItemsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0 create credit params body order information line items items0 tax details items0
swagger:model CreateCreditParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0
*/
type CreateCreditParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0 struct {

	// Indicates the amount of tax based on the `type` field as described in the table below:
	//
	// | type      | type description |
	// | ------------- |:-------------:|
	// | `alternate` | Total amount of alternate tax for the order. |
	// | `local`     | Sales tax for the order. |
	// | `national`  | National tax for the order. |
	// | `vat`       | Total amount of value added tax (VAT) included in the order. |
	// | `other`     | Other tax. |
	//
	// Max Length: 13
	Amount string `json:"amount,omitempty"`

	// Flag that indicates whether the alternate tax amount (`orderInformation.amountDetails.taxDetails[].amount`) is
	// included in the request.
	//
	// Possible values:
	// - `false`: alternate tax amount is not included in the request.
	// - `true`: alternate tax amount is included in the request.
	//
	// For processor-specific details, see `alternate_tax_amount_indicator` field description in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/)
	//
	Applied bool `json:"applied,omitempty"`

	// Type of tax being applied to the item.
	//
	// For possible values, see the processor-specific field descriptions in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/):
	//
	// #### FDC Nashville Global
	// - `alternate_tax_type_applied`
	// - `alternate_tax_type_identifier`
	//
	// #### Worldpay VAP
	// - `alternate_tax_type_identifier`
	//
	// #### RBS WorldPay Atlanta
	// - `tax_type_applied`
	//
	// #### TSYS Acquiring Solutions
	// - `tax_type_applied`
	// - `local_tax_indicator`
	//
	// #### Chase Paymentech Solutions
	// - `tax_type_applied`
	//
	// #### Elavon Americas
	// - `local_tax_indicator`
	//
	// #### FDC Compass
	// - `tax_type_applied`
	//
	// #### OmniPay Direct
	// - `local_tax_indicator`
	//
	// Max Length: 4
	Code string `json:"code,omitempty"`

	// Status code for exemption from sales and use tax. This field is a pass-through, which means that
	// CyberSource does not verify the value or modify it in any way before sending it to the processor.
	//
	// For possible values and important information for using this field, see _Appendix B, "Exemption
	// Status Values_ and _Offer-Level Tax Fields_ in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/)
	//
	// Max Length: 1
	ExemptionCode string `json:"exemptionCode,omitempty"`

	// Rate of VAT or other tax for the order.
	//
	// Example 0.040 (=4%)
	//
	// Valid range: 0.01 to 0.99 (1% to 99%, with only whole percentage values accepted; values with additional
	// decimal places will be truncated)
	//
	// For processor-specific details, see the `alternate_tax_amount`, `vat_rate`, `vat_tax_rate`, `local_tax`, `national_tax`, `vat_tax_amount` or `other_tax#_rate` field descriptions in the [Level II and Level III Processing Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/)
	//
	// Max Length: 6
	Rate string `json:"rate,omitempty"`

	// Your tax ID number to use for the alternate tax amount. Required if you set alternate tax amount to any value,
	// including zero. You may send this field without sending alternate tax amount.
	//
	// For processor-specific details, see `alternate_tax_id` field description in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/)
	//
	// Max Length: 15
	TaxID string `json:"taxId,omitempty"`

	// Indicates the type of tax data for the _taxDetails_ object.
	//
	// Possible values:
	//
	// - `alternate`
	// - `local`
	// - `national`
	// - `vat`
	// - `other`
	//
	// For processor-specific details, see the `alternate_tax_amount`, `local_tax`, `national_tax` or `vat_tax_amount` field
	// descriptions in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/)
	//
	Type string `json:"type,omitempty"`
}

// Validate validates this create credit params body order information line items items0 tax details items0
func (o *CreateCreditParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExemptionCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0) validateAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.Amount) { // not required
		return nil
	}

	if err := validate.MaxLength("amount", "body", o.Amount, 13); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0) validateCode(formats strfmt.Registry) error {
	if swag.IsZero(o.Code) { // not required
		return nil
	}

	if err := validate.MaxLength("code", "body", o.Code, 4); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0) validateExemptionCode(formats strfmt.Registry) error {
	if swag.IsZero(o.ExemptionCode) { // not required
		return nil
	}

	if err := validate.MaxLength("exemptionCode", "body", o.ExemptionCode, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0) validateRate(formats strfmt.Registry) error {
	if swag.IsZero(o.Rate) { // not required
		return nil
	}

	if err := validate.MaxLength("rate", "body", o.Rate, 6); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0) validateTaxID(formats strfmt.Registry) error {
	if swag.IsZero(o.TaxID) { // not required
		return nil
	}

	if err := validate.MaxLength("taxId", "body", o.TaxID, 15); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create credit params body order information line items items0 tax details items0 based on context it is used
func (o *CreateCreditParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0) UnmarshalBinary(b []byte) error {
	var res CreateCreditParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditParamsBodyOrderInformationShipTo create credit params body order information ship to
swagger:model CreateCreditParamsBodyOrderInformationShipTo
*/
type CreateCreditParamsBodyOrderInformationShipTo struct {

	// State or province of the shipping address. Use the [State, Province, and Territory Codes for the United States and Canada](https://developer.cybersource.com/library/documentation/sbc/quickref/states_and_provinces.pdf)
	//
	// Required field for authorization if any shipping address information is included in the request and shipping to the U.S.
	// or Canada; otherwise, optional.
	//
	// #### Tax Calculation
	// Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes.
	// Billing address objects will be used to determine the cardholders location when shipTo objects are not present.
	//
	// Max Length: 2
	AdministrativeArea string `json:"administrativeArea,omitempty"`

	// Country of the shipping address. Use the two-character [ISO Standard Country Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf)
	//
	// Required field for authorization if any shipping address information is included in the request; otherwise, optional.
	//
	// #### Tax Calculation
	// Optional field for U.S., Canadian, international tax, and value added taxes.
	// Billing address objects will be used to determine the cardholders location when shipTo objects are not present.
	//
	// Max Length: 2
	Country string `json:"country,omitempty"`

	// Postal code for the shipping address. The postal code must consist of 5 to 9 digits.
	//
	// Required field for authorization if any shipping address information is included in the request and
	// shipping to the U.S. or Canada; otherwise, optional.
	//
	// When the billing country is the U.S., the 9-digit postal code must follow this format:
	// [5 digits][dash][4 digits]
	//
	// Example 12345-6789
	//
	// When the billing country is Canada, the 6-digit postal code must follow this format:
	// [alpha][numeric][alpha][space][numeric][alpha][numeric]
	//
	// Example A1B 2C3
	//
	// #### American Express Direct
	// Before sending the postal code to the processor, all nonalphanumeric characters are removed and, if the
	// remaining value is longer than nine characters, the value is truncated starting from the right side.
	// #### Tax Calculation
	// Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes.
	// Billing address objects will be used to determine the cardholders location when shipTo objects are not present.
	//
	// Max Length: 10
	PostalCode string `json:"postalCode,omitempty"`
}

// Validate validates this create credit params body order information ship to
func (o *CreateCreditParamsBodyOrderInformationShipTo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAdministrativeArea(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyOrderInformationShipTo) validateAdministrativeArea(formats strfmt.Registry) error {
	if swag.IsZero(o.AdministrativeArea) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"orderInformation"+"."+"shipTo"+"."+"administrativeArea", "body", o.AdministrativeArea, 2); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformationShipTo) validateCountry(formats strfmt.Registry) error {
	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"orderInformation"+"."+"shipTo"+"."+"country", "body", o.Country, 2); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyOrderInformationShipTo) validatePostalCode(formats strfmt.Registry) error {
	if swag.IsZero(o.PostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"orderInformation"+"."+"shipTo"+"."+"postalCode", "body", o.PostalCode, 10); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create credit params body order information ship to based on context it is used
func (o *CreateCreditParamsBodyOrderInformationShipTo) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditParamsBodyOrderInformationShipTo) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditParamsBodyOrderInformationShipTo) UnmarshalBinary(b []byte) error {
	var res CreateCreditParamsBodyOrderInformationShipTo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditParamsBodyOrderInformationShippingDetails create credit params body order information shipping details
swagger:model CreateCreditParamsBodyOrderInformationShippingDetails
*/
type CreateCreditParamsBodyOrderInformationShippingDetails struct {

	// Postal code for the address from which the goods are shipped, which is used to establish nexus. The default is
	// the postal code associated with your CyberSource account.
	//
	// The postal code must consist of 5 to 9 digits. When the billing country is the U.S., the 9-digit postal code
	// must follow this format:
	//
	// `[5 digits][dash][4 digits]`
	//
	// Example 12345-6789
	//
	// When the billing country is Canada, the 6-digit postal code must follow this format:
	//
	// `[alpha][numeric][alpha][space] [numeric][alpha][numeric]`
	//
	// Example A1B 2C3
	//
	// This field is frequently used for Level II and Level III transactions.
	//
	// Max Length: 10
	ShipFromPostalCode string `json:"shipFromPostalCode,omitempty"`
}

// Validate validates this create credit params body order information shipping details
func (o *CreateCreditParamsBodyOrderInformationShippingDetails) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateShipFromPostalCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyOrderInformationShippingDetails) validateShipFromPostalCode(formats strfmt.Registry) error {
	if swag.IsZero(o.ShipFromPostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"orderInformation"+"."+"shippingDetails"+"."+"shipFromPostalCode", "body", o.ShipFromPostalCode, 10); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create credit params body order information shipping details based on context it is used
func (o *CreateCreditParamsBodyOrderInformationShippingDetails) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditParamsBodyOrderInformationShippingDetails) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditParamsBodyOrderInformationShippingDetails) UnmarshalBinary(b []byte) error {
	var res CreateCreditParamsBodyOrderInformationShippingDetails
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditParamsBodyPaymentInformation create credit params body payment information
swagger:model CreateCreditParamsBodyPaymentInformation
*/
type CreateCreditParamsBodyPaymentInformation struct {

	// bank
	Bank *CreateCreditParamsBodyPaymentInformationBank `json:"bank,omitempty"`

	// card
	Card *CreateCreditParamsBodyPaymentInformationCard `json:"card,omitempty"`

	// customer
	Customer *CreateCreditParamsBodyPaymentInformationCustomer `json:"customer,omitempty"`

	// fluid data
	FluidData *CreateCreditParamsBodyPaymentInformationFluidData `json:"fluidData,omitempty"`

	// instrument identifier
	InstrumentIdentifier *CreateCreditParamsBodyPaymentInformationInstrumentIdentifier `json:"instrumentIdentifier,omitempty"`

	// legacy token
	LegacyToken *CreateCreditParamsBodyPaymentInformationLegacyToken `json:"legacyToken,omitempty"`

	// payment instrument
	PaymentInstrument *CreateCreditParamsBodyPaymentInformationPaymentInstrument `json:"paymentInstrument,omitempty"`

	// payment type
	PaymentType *CreateCreditParamsBodyPaymentInformationPaymentType `json:"paymentType,omitempty"`

	// shipping address
	ShippingAddress *CreateCreditParamsBodyPaymentInformationShippingAddress `json:"shippingAddress,omitempty"`

	// tokenized card
	TokenizedCard *CreateCreditParamsBodyPaymentInformationTokenizedCard `json:"tokenizedCard,omitempty"`
}

// Validate validates this create credit params body payment information
func (o *CreateCreditParamsBodyPaymentInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateBank(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCard(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCustomer(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFluidData(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateInstrumentIdentifier(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLegacyToken(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePaymentInstrument(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePaymentType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateShippingAddress(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTokenizedCard(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyPaymentInformation) validateBank(formats strfmt.Registry) error {
	if swag.IsZero(o.Bank) { // not required
		return nil
	}

	if o.Bank != nil {
		if err := o.Bank.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "paymentInformation" + "." + "bank")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "paymentInformation" + "." + "bank")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditParamsBodyPaymentInformation) validateCard(formats strfmt.Registry) error {
	if swag.IsZero(o.Card) { // not required
		return nil
	}

	if o.Card != nil {
		if err := o.Card.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "paymentInformation" + "." + "card")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "paymentInformation" + "." + "card")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditParamsBodyPaymentInformation) validateCustomer(formats strfmt.Registry) error {
	if swag.IsZero(o.Customer) { // not required
		return nil
	}

	if o.Customer != nil {
		if err := o.Customer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "paymentInformation" + "." + "customer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "paymentInformation" + "." + "customer")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditParamsBodyPaymentInformation) validateFluidData(formats strfmt.Registry) error {
	if swag.IsZero(o.FluidData) { // not required
		return nil
	}

	if o.FluidData != nil {
		if err := o.FluidData.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "paymentInformation" + "." + "fluidData")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "paymentInformation" + "." + "fluidData")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditParamsBodyPaymentInformation) validateInstrumentIdentifier(formats strfmt.Registry) error {
	if swag.IsZero(o.InstrumentIdentifier) { // not required
		return nil
	}

	if o.InstrumentIdentifier != nil {
		if err := o.InstrumentIdentifier.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "paymentInformation" + "." + "instrumentIdentifier")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "paymentInformation" + "." + "instrumentIdentifier")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditParamsBodyPaymentInformation) validateLegacyToken(formats strfmt.Registry) error {
	if swag.IsZero(o.LegacyToken) { // not required
		return nil
	}

	if o.LegacyToken != nil {
		if err := o.LegacyToken.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "paymentInformation" + "." + "legacyToken")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "paymentInformation" + "." + "legacyToken")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditParamsBodyPaymentInformation) validatePaymentInstrument(formats strfmt.Registry) error {
	if swag.IsZero(o.PaymentInstrument) { // not required
		return nil
	}

	if o.PaymentInstrument != nil {
		if err := o.PaymentInstrument.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "paymentInformation" + "." + "paymentInstrument")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "paymentInformation" + "." + "paymentInstrument")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditParamsBodyPaymentInformation) validatePaymentType(formats strfmt.Registry) error {
	if swag.IsZero(o.PaymentType) { // not required
		return nil
	}

	if o.PaymentType != nil {
		if err := o.PaymentType.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "paymentInformation" + "." + "paymentType")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "paymentInformation" + "." + "paymentType")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditParamsBodyPaymentInformation) validateShippingAddress(formats strfmt.Registry) error {
	if swag.IsZero(o.ShippingAddress) { // not required
		return nil
	}

	if o.ShippingAddress != nil {
		if err := o.ShippingAddress.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "paymentInformation" + "." + "shippingAddress")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "paymentInformation" + "." + "shippingAddress")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditParamsBodyPaymentInformation) validateTokenizedCard(formats strfmt.Registry) error {
	if swag.IsZero(o.TokenizedCard) { // not required
		return nil
	}

	if o.TokenizedCard != nil {
		if err := o.TokenizedCard.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "paymentInformation" + "." + "tokenizedCard")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "paymentInformation" + "." + "tokenizedCard")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this create credit params body payment information based on the context it is used
func (o *CreateCreditParamsBodyPaymentInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateBank(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateCard(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateCustomer(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateFluidData(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateInstrumentIdentifier(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateLegacyToken(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidatePaymentInstrument(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidatePaymentType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateShippingAddress(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateTokenizedCard(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyPaymentInformation) contextValidateBank(ctx context.Context, formats strfmt.Registry) error {

	if o.Bank != nil {
		if err := o.Bank.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "paymentInformation" + "." + "bank")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "paymentInformation" + "." + "bank")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditParamsBodyPaymentInformation) contextValidateCard(ctx context.Context, formats strfmt.Registry) error {

	if o.Card != nil {
		if err := o.Card.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "paymentInformation" + "." + "card")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "paymentInformation" + "." + "card")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditParamsBodyPaymentInformation) contextValidateCustomer(ctx context.Context, formats strfmt.Registry) error {

	if o.Customer != nil {
		if err := o.Customer.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "paymentInformation" + "." + "customer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "paymentInformation" + "." + "customer")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditParamsBodyPaymentInformation) contextValidateFluidData(ctx context.Context, formats strfmt.Registry) error {

	if o.FluidData != nil {
		if err := o.FluidData.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "paymentInformation" + "." + "fluidData")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "paymentInformation" + "." + "fluidData")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditParamsBodyPaymentInformation) contextValidateInstrumentIdentifier(ctx context.Context, formats strfmt.Registry) error {

	if o.InstrumentIdentifier != nil {
		if err := o.InstrumentIdentifier.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "paymentInformation" + "." + "instrumentIdentifier")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "paymentInformation" + "." + "instrumentIdentifier")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditParamsBodyPaymentInformation) contextValidateLegacyToken(ctx context.Context, formats strfmt.Registry) error {

	if o.LegacyToken != nil {
		if err := o.LegacyToken.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "paymentInformation" + "." + "legacyToken")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "paymentInformation" + "." + "legacyToken")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditParamsBodyPaymentInformation) contextValidatePaymentInstrument(ctx context.Context, formats strfmt.Registry) error {

	if o.PaymentInstrument != nil {
		if err := o.PaymentInstrument.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "paymentInformation" + "." + "paymentInstrument")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "paymentInformation" + "." + "paymentInstrument")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditParamsBodyPaymentInformation) contextValidatePaymentType(ctx context.Context, formats strfmt.Registry) error {

	if o.PaymentType != nil {
		if err := o.PaymentType.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "paymentInformation" + "." + "paymentType")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "paymentInformation" + "." + "paymentType")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditParamsBodyPaymentInformation) contextValidateShippingAddress(ctx context.Context, formats strfmt.Registry) error {

	if o.ShippingAddress != nil {
		if err := o.ShippingAddress.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "paymentInformation" + "." + "shippingAddress")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "paymentInformation" + "." + "shippingAddress")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditParamsBodyPaymentInformation) contextValidateTokenizedCard(ctx context.Context, formats strfmt.Registry) error {

	if o.TokenizedCard != nil {
		if err := o.TokenizedCard.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "paymentInformation" + "." + "tokenizedCard")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "paymentInformation" + "." + "tokenizedCard")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditParamsBodyPaymentInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditParamsBodyPaymentInformation) UnmarshalBinary(b []byte) error {
	var res CreateCreditParamsBodyPaymentInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditParamsBodyPaymentInformationBank create credit params body payment information bank
swagger:model CreateCreditParamsBodyPaymentInformationBank
*/
type CreateCreditParamsBodyPaymentInformationBank struct {

	// account
	Account *CreateCreditParamsBodyPaymentInformationBankAccount `json:"account,omitempty"`

	// International Bank Account Number (IBAN) for the bank account. For some countries you can provide this number instead of the traditional bank account information. You can use this field only when scoring a direct debit transaction.
	//
	// For all possible values, see the `bank_iban` field description in the _Decision Manager Using the SCMP API Developer Guide_ on the [CyberSource Business Center.](https://ebc2.cybersource.com/ebc2/) Click **Decision Manager** > **Documentation** > **Guides** > _Decision Manager Using the SCMP API Developer Guide_ (PDF link).
	//
	// Max Length: 50
	Iban string `json:"iban,omitempty"`

	// Bank routing number. This is also called the _transit number_.
	//
	// For details, see `ecp_rdfi` request field description in the [Electronic Check Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/EChecks_SCMP_API/html/)
	//
	// Max Length: 9
	RoutingNumber string `json:"routingNumber,omitempty"`
}

// Validate validates this create credit params body payment information bank
func (o *CreateCreditParamsBodyPaymentInformationBank) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAccount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateIban(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRoutingNumber(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyPaymentInformationBank) validateAccount(formats strfmt.Registry) error {
	if swag.IsZero(o.Account) { // not required
		return nil
	}

	if o.Account != nil {
		if err := o.Account.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "paymentInformation" + "." + "bank" + "." + "account")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "paymentInformation" + "." + "bank" + "." + "account")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditParamsBodyPaymentInformationBank) validateIban(formats strfmt.Registry) error {
	if swag.IsZero(o.Iban) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"paymentInformation"+"."+"bank"+"."+"iban", "body", o.Iban, 50); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyPaymentInformationBank) validateRoutingNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.RoutingNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"paymentInformation"+"."+"bank"+"."+"routingNumber", "body", o.RoutingNumber, 9); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this create credit params body payment information bank based on the context it is used
func (o *CreateCreditParamsBodyPaymentInformationBank) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateAccount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyPaymentInformationBank) contextValidateAccount(ctx context.Context, formats strfmt.Registry) error {

	if o.Account != nil {
		if err := o.Account.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "paymentInformation" + "." + "bank" + "." + "account")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "paymentInformation" + "." + "bank" + "." + "account")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditParamsBodyPaymentInformationBank) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditParamsBodyPaymentInformationBank) UnmarshalBinary(b []byte) error {
	var res CreateCreditParamsBodyPaymentInformationBank
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditParamsBodyPaymentInformationBankAccount create credit params body payment information bank account
swagger:model CreateCreditParamsBodyPaymentInformationBankAccount
*/
type CreateCreditParamsBodyPaymentInformationBankAccount struct {

	// Image reference number associated with the check. You cannot include any special characters.
	//
	// Max Length: 32
	CheckImageReferenceNumber string `json:"checkImageReferenceNumber,omitempty"`

	// Check number.
	//
	// Chase Paymentech Solutions - Optional.
	// CyberSource ACH Service - Not used.
	// RBS WorldPay Atlanta - Optional on debits. Required on credits.
	// TeleCheck - Strongly recommended on debit requests. Optional on credits.
	//
	// Max Length: 8
	CheckNumber string `json:"checkNumber,omitempty"`

	// Identifier for the bank that provided the customers encoded account number.
	//
	// To obtain the bank identifier, contact your processor.
	//
	// For details, see `account_encoder_id` request-level field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// Max Length: 3
	EncoderID string `json:"encoderId,omitempty"`

	// Account number.
	//
	// When processing encoded account numbers, use this field for the encoded account number.
	//
	// Max Length: 17
	Number string `json:"number,omitempty"`

	// Account type.
	//
	// Possible values:
	//  - **C**: Checking.
	//  - **G**: General ledger. This value is supported only on Wells Fargo ACH.
	//  - **S**: Savings (U.S. dollars only).
	//  - **X**: Corporate checking (U.S. dollars only).
	//
	// Max Length: 1
	Type string `json:"type,omitempty"`
}

// Validate validates this create credit params body payment information bank account
func (o *CreateCreditParamsBodyPaymentInformationBankAccount) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCheckImageReferenceNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCheckNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEncoderID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyPaymentInformationBankAccount) validateCheckImageReferenceNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.CheckImageReferenceNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"paymentInformation"+"."+"bank"+"."+"account"+"."+"checkImageReferenceNumber", "body", o.CheckImageReferenceNumber, 32); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyPaymentInformationBankAccount) validateCheckNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.CheckNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"paymentInformation"+"."+"bank"+"."+"account"+"."+"checkNumber", "body", o.CheckNumber, 8); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyPaymentInformationBankAccount) validateEncoderID(formats strfmt.Registry) error {
	if swag.IsZero(o.EncoderID) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"paymentInformation"+"."+"bank"+"."+"account"+"."+"encoderId", "body", o.EncoderID, 3); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyPaymentInformationBankAccount) validateNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.Number) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"paymentInformation"+"."+"bank"+"."+"account"+"."+"number", "body", o.Number, 17); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyPaymentInformationBankAccount) validateType(formats strfmt.Registry) error {
	if swag.IsZero(o.Type) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"paymentInformation"+"."+"bank"+"."+"account"+"."+"type", "body", o.Type, 1); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create credit params body payment information bank account based on context it is used
func (o *CreateCreditParamsBodyPaymentInformationBankAccount) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditParamsBodyPaymentInformationBankAccount) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditParamsBodyPaymentInformationBankAccount) UnmarshalBinary(b []byte) error {
	var res CreateCreditParamsBodyPaymentInformationBankAccount
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditParamsBodyPaymentInformationCard create credit params body payment information card
swagger:model CreateCreditParamsBodyPaymentInformationCard
*/
type CreateCreditParamsBodyPaymentInformationCard struct {

	// Identifier for the issuing bank that provided the customers encoded account number. Contact your processor for the banks ID.
	//
	// Max Length: 3
	AccountEncoderID string `json:"accountEncoderId,omitempty"`

	// Two-digit month in which the payment card expires.
	//
	// Format: `MM`.
	//
	// Valid values: `01` through `12`. Leading 0 is required.
	//
	// #### Barclays and Streamline
	// For Maestro (UK Domestic) and Maestro (International) cards on Barclays and Streamline, this must be a valid value
	// (`01` through `12`) but is not required to be a valid expiration date. In other words, an expiration date that is
	// in the past does not cause CyberSource to reject your request. However, an invalid expiration date might cause
	// the issuer to reject your request.
	//
	// #### Encoded Account Numbers
	// For encoded account numbers (_type_=039), if there is no expiration date on the card, use `12`.
	//
	// #### FDMS Nashville
	// Required field.
	//
	// #### All other processors
	// Required if `pointOfSaleInformation.entryMode=keyed`. However, this field is optional if your account is configured
	// for relaxed requirements for address data and expiration date. **Important** It is your responsibility to determine
	// whether a field is required for the transaction you are requesting.
	//
	// #### Google Pay transactions
	// For PAN-based Google Pay transactions, this field is returned in the API response.
	//
	// Max Length: 2
	ExpirationMonth string `json:"expirationMonth,omitempty"`

	// Four-digit year in which the payment card expires.
	//
	// Format: `YYYY`.
	//
	// #### Barclays and Streamline
	// For Maestro (UK Domestic) and Maestro (International) cards on Barclays and Streamline, this must be a valid value (`1900` through `3000`) but is not required to be a valid expiration date. In other words, an expiration date that is in the past does not cause CyberSource to reject your request. However, an invalid expiration date might cause the issuer to reject your request.
	//
	// #### Encoded Account Numbers
	// For encoded account numbers (**_type_**`=039`), if there is no expiration date on the card, use `2021`.
	//
	// #### FDMS Nashville
	// Required field.
	//
	// #### FDC Nashville Global and FDMS South
	// You can send in 2 digits or 4 digits. If you send in 2 digits, they must be the last 2 digits of the year.
	//
	// #### All other processors
	// Required if `pointOfSaleInformation.entryMode=keyed`. However, this field is optional if your account is configured
	// for relaxed requirements for address data and expiration date. **Important** It is your responsibility to determine
	// whether a field is required for the transaction you are requesting.
	//
	// #### Google Pay transactions
	// For PAN-based Google Pay transactions, this field is returned in the API response.
	//
	// Max Length: 4
	ExpirationYear string `json:"expirationYear,omitempty"`

	// Number of times a Maestro (UK Domestic) card has been issued to the account holder. The card might or might not have an issue number. The number can consist of one or two digits, and the first digit might be a zero. When you include this value in your request, include exactly what is printed on the card. A value of 2 is different than a value of 02. Do not include the field, even with a blank value, if the card is not a Maestro (UK Domestic) card.
	//
	// **Note** The issue number is not required for Maestro (UK Domestic) transactions.
	//
	// Max Length: 5
	IssueNumber string `json:"issueNumber,omitempty"`

	// The customers payment card number, also known as the Primary Account Number (PAN). You can also use this field
	// for encoded account numbers.
	//
	// #### FDMS Nashville
	// Required. String (19)
	//
	// #### GPX
	// Required if `pointOfSaleInformation.entryMode=keyed`. However, this field is optional if your account is configured
	// for relaxed requirements for address data and expiration date. **Important** It is your responsibility to determine
	// whether a field is required for the transaction you are requesting.
	//
	// #### All other processors
	// Required if `pointOfSaleInformation.entryMode=keyed`. However, this field is optional if your account is configured
	// for relaxed requirements for address data and expiration date. **Important** It is your responsibility to determine
	// whether a field is required for the transaction you are requesting.
	//
	// Max Length: 20
	Number string `json:"number,omitempty"`

	// Flag that specifies the type of account associated with the card. The cardholder provides this information
	// during the payment process.
	//
	// This field is required in the following cases:
	//   - Debit transactions on Cielo and Comercio Latino.
	//   - Transactions with Brazilian-issued cards on CyberSource through VisaNet.
	//   - Applicable only for CyberSource through VisaNet (CtV).
	//
	// **Note** Combo cards in Brazil contain credit and debit functionality in a single card. Visa systems use a credit bank
	// identification number (BIN) for this type of card. Using the BIN to determine whether a card is debit or
	// credit can cause transactions with these cards to be processed incorrectly. CyberSource strongly recommends
	// that you include this field for combo card transactions.
	//
	// Possible values include the following.
	//
	//  - `CHECKING`: Checking account
	//  - `CREDIT`: Credit card account
	//  - `SAVING`: Saving account
	//  - `LINE_OF_CREDIT`: Line of credit or credit portion of combo card
	//  - `PREPAID`: Prepaid card account or prepaid portion of combo card
	//  - `UNIVERSAL`: Universal account
	//
	// Max Length: 20
	SourceAccountType string `json:"sourceAccountType,omitempty"`

	// Type of account that is being used when the value for the override_payment_method field is line of credit (LI) or prepaid card (PP).
	// Possible values for line of credit:
	// - `AGRC`: Visa Agro Custeio
	// - `AGRE`: Visa Agro Electron
	// - `AGRI`: Visa Agro Investimento
	// - `AGRO`: Visa Agro
	// Possible values for prepaid card:
	// - `VVA`: Visa Vale Alimentacao
	// - `VVF`: Visa Vale Flex
	// - `VVR`: Visa Vale Refeicao
	// This field is supported only for combo card transactions in Brazil on CyberSource through VisaNet.
	//
	// Max Length: 4
	SourceAccountTypeDetails string `json:"sourceAccountTypeDetails,omitempty"`

	// Month of the start of the Maestro (UK Domestic) card validity period. Do not include the field, even with a blank value, if the card is not a Maestro (UK Domestic) card. `Format: MM`. Possible values: 01 through 12.
	//
	// **Note** The start date is not required for Maestro (UK Domestic) transactions.
	//
	// Max Length: 2
	StartMonth string `json:"startMonth,omitempty"`

	// Year of the start of the Maestro (UK Domestic) card validity period. Do not include the field, even with a blank value, if the card is not a Maestro (UK Domestic) card. `Format: YYYY`.
	//
	// **Note** The start date is not required for Maestro (UK Domestic) transactions.
	//
	// Max Length: 4
	StartYear string `json:"startYear,omitempty"`

	// Three-digit value that indicates the card type.
	//
	// **IMPORTANT** It is strongly recommended that you include the card type field in request messages even if it is
	// optional for your processor and card type. Omitting the card type can cause the transaction to be processed with the wrong card type.
	//
	// Possible values:
	// - `001`: Visa. For card-present transactions on all processors except SIX, the Visa Electron card type is processed the same way that the Visa debit card is processed. Use card type value `001` for Visa Electron.
	// - `002`: Mastercard, Eurocard[^1], which is a European regional brand of Mastercard.
	// - `003`: American Express
	// - `004`: Discover
	// - `005`: Diners Club
	// - `006`: Carte Blanche[^1]
	// - `007`: JCB[^1]
	// - `014`: Enroute[^1]
	// - `021`: JAL[^1]
	// - `024`: Maestro (UK Domestic)[^1]
	// - `031`: Delta[^1]: Use this value only for Ingenico ePayments. For other processors, use `001` for all Visa card types.
	// - `033`: Visa Electron[^1]. Use this value only for Ingenico ePayments and SIX. For other processors, use `001` for all Visa card types.
	// - `034`: Dankort[^1]
	// - `036`: Cartes Bancaires[^1,4]
	// - `037`: Carta Si[^1]
	// - `039`: Encoded account number[^1]
	// - `040`: UATP[^1]
	// - `042`: Maestro (International)[^1]
	// - `050`: Hipercard[^2,3]
	// - `051`: Aura
	// - `054`: Elo[^3]
	// - `062`: China UnionPay
	//
	// [^1]: For this card type, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in your request for an authorization or a stand-alone credit.
	// [^2]: For this card type on Cielo 3.0, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in a request for an authorization or a stand-alone credit. This card type is not supported on Cielo 1.5.
	// [^3]: For this card type on Getnet and Rede, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in a request for an authorization or a stand-alone credit.
	// [^4]: For this card type, you must include the `paymentInformation.card.type` in your request for any payer authentication services.
	//
	// #### Used by
	// **Authorization**
	// Required for Carte Blanche and JCB.
	// Optional for all other card types.
	//
	// #### Card Present reply
	// This field is included in the reply message when the client software that is installed on the POS terminal uses
	// the token management service (TMS) to retrieve tokenized payment details. You must contact customer support to
	// have your account enabled to receive these fields in the credit reply message.
	//
	// Returned by the Credit service.
	//
	// This reply field is only supported by the following processors:
	// - American Express Direct
	// - Credit Mutuel-CIC
	// - FDC Nashville Global
	// - OmniPay Direct
	// - SIX
	//
	// #### Google Pay transactions
	// For PAN-based Google Pay transactions, this field is returned in the API response.
	//
	// #### GPX
	// This field only supports transactions from the following card types:
	// - Visa
	// - Mastercard
	// - AMEX
	// - Discover
	// - Diners
	// - JCB
	// - Union Pay International
	//
	Type string `json:"type,omitempty"`
}

// Validate validates this create credit params body payment information card
func (o *CreateCreditParamsBodyPaymentInformationCard) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAccountEncoderID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpirationMonth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpirationYear(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateIssueNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSourceAccountType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSourceAccountTypeDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateStartMonth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateStartYear(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyPaymentInformationCard) validateAccountEncoderID(formats strfmt.Registry) error {
	if swag.IsZero(o.AccountEncoderID) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"paymentInformation"+"."+"card"+"."+"accountEncoderId", "body", o.AccountEncoderID, 3); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyPaymentInformationCard) validateExpirationMonth(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationMonth) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"paymentInformation"+"."+"card"+"."+"expirationMonth", "body", o.ExpirationMonth, 2); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyPaymentInformationCard) validateExpirationYear(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationYear) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"paymentInformation"+"."+"card"+"."+"expirationYear", "body", o.ExpirationYear, 4); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyPaymentInformationCard) validateIssueNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.IssueNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"paymentInformation"+"."+"card"+"."+"issueNumber", "body", o.IssueNumber, 5); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyPaymentInformationCard) validateNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.Number) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"paymentInformation"+"."+"card"+"."+"number", "body", o.Number, 20); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyPaymentInformationCard) validateSourceAccountType(formats strfmt.Registry) error {
	if swag.IsZero(o.SourceAccountType) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"paymentInformation"+"."+"card"+"."+"sourceAccountType", "body", o.SourceAccountType, 20); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyPaymentInformationCard) validateSourceAccountTypeDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.SourceAccountTypeDetails) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"paymentInformation"+"."+"card"+"."+"sourceAccountTypeDetails", "body", o.SourceAccountTypeDetails, 4); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyPaymentInformationCard) validateStartMonth(formats strfmt.Registry) error {
	if swag.IsZero(o.StartMonth) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"paymentInformation"+"."+"card"+"."+"startMonth", "body", o.StartMonth, 2); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyPaymentInformationCard) validateStartYear(formats strfmt.Registry) error {
	if swag.IsZero(o.StartYear) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"paymentInformation"+"."+"card"+"."+"startYear", "body", o.StartYear, 4); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create credit params body payment information card based on context it is used
func (o *CreateCreditParamsBodyPaymentInformationCard) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditParamsBodyPaymentInformationCard) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditParamsBodyPaymentInformationCard) UnmarshalBinary(b []byte) error {
	var res CreateCreditParamsBodyPaymentInformationCard
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditParamsBodyPaymentInformationCustomer create credit params body payment information customer
swagger:model CreateCreditParamsBodyPaymentInformationCustomer
*/
type CreateCreditParamsBodyPaymentInformationCustomer struct {

	// Unique identifier for the customer's card and billing information.
	//
	// When you use Payment Tokenization or Recurring Billing and you include this value in
	// your request, many of the fields that are normally required for an authorization or credit
	// become optional.
	//
	// **NOTE** When you use Payment Tokenization or Recurring Billing, the value for the Customer ID is actually the Cybersource payment token for a customer. This token stores information such as the consumers card number so it can be applied towards bill payments, recurring payments, or one-time payments. By using this token in a payment API request, the merchant doesn't need to pass in data such as the card number or expiration date in the request itself.
	//
	// For details, see the `subscription_id` field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	CustomerID string `json:"customerId,omitempty"`

	// Unique identifier for the Customer token used in the transaction.
	// When you include this value in your request, many of the fields that are normally required for an authorization or credit
	// become optional.
	//
	// Max Length: 32
	// Min Length: 1
	ID string `json:"id,omitempty"`
}

// Validate validates this create credit params body payment information customer
func (o *CreateCreditParamsBodyPaymentInformationCustomer) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyPaymentInformationCustomer) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MinLength("createCreditRequest"+"."+"paymentInformation"+"."+"customer"+"."+"id", "body", o.ID, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"paymentInformation"+"."+"customer"+"."+"id", "body", o.ID, 32); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create credit params body payment information customer based on context it is used
func (o *CreateCreditParamsBodyPaymentInformationCustomer) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditParamsBodyPaymentInformationCustomer) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditParamsBodyPaymentInformationCustomer) UnmarshalBinary(b []byte) error {
	var res CreateCreditParamsBodyPaymentInformationCustomer
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditParamsBodyPaymentInformationFluidData create credit params body payment information fluid data
swagger:model CreateCreditParamsBodyPaymentInformationFluidData
*/
type CreateCreditParamsBodyPaymentInformationFluidData struct {

	// The identifier for a payment solution, which is sending the encrypted payment data for decryption. Valid values:
	// Samsung Pay: RklEPUNPTU1PTi5TQU1TVU5HLklOQVBQLlBBWU1FTlQ=
	// Note: For other payment solutions, the value may be specific to the terminal or device initiatinf the payment. For example, the descriptor for a Bluefin payment encryption would be a device-generated descriptor.
	// Used by Authorization and Standalone Credits. Required for authorizations and standalone credits.
	//
	// Card Present processing:
	// Format of the encrypted payment data.
	// The value for Bluefin PCI P2PE is `Ymx1ZWZpbg==`. paymentInformation.fluidData.encoding must be `Base64`.
	// The value for Cybersource P2PE decryption depends on the encoding method used and identified in encoding field.
	// If paymentInformation.fluidData.encoding is `Base64`, the value is: `RklEPUVNVi5QQVlNRU5ULkFQSQ==`
	// If paymentInformation.fluidData.encoding is `HEX`, the value is: `4649443D454D562E5041594D454E542E41504`
	//
	// Max Length: 128
	Descriptor string `json:"descriptor,omitempty"`

	// Encoding method used to encrypt the payment data.
	// Valid values: `Base64`, `HEX`
	// If no value is provided, `Base64` is taken as the default value. And the `Base64` descriptor is used for paymentInformation.fluidData.encoding
	//
	// Max Length: 6
	Encoding string `json:"encoding,omitempty"`

	// The encoded or encrypted value that a payment solution returns for an authorization request. For details about the valid values for a key, see [Creating an Online Authorization](https://developer.cybersource.com/api/developer-guides/dita-payments/CreatingOnlineAuth.html)
	//
	KeySerialNumber string `json:"keySerialNumber,omitempty"`

	// Represents the encrypted payment data BLOB. The entry for this field is dependent on the payment solution used by the merchant.
	// Used by Authorization and Standalone Credits. Required for authorizations and standalone credits that use a Cybersource suppored Point-to-Point encryption method.
	// Card Present processing
	// This field represents the encrypted payment data generated by the payment terminal/device.
	//
	// Max Length: 3072
	Value string `json:"value,omitempty"`
}

// Validate validates this create credit params body payment information fluid data
func (o *CreateCreditParamsBodyPaymentInformationFluidData) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDescriptor(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEncoding(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateValue(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyPaymentInformationFluidData) validateDescriptor(formats strfmt.Registry) error {
	if swag.IsZero(o.Descriptor) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"paymentInformation"+"."+"fluidData"+"."+"descriptor", "body", o.Descriptor, 128); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyPaymentInformationFluidData) validateEncoding(formats strfmt.Registry) error {
	if swag.IsZero(o.Encoding) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"paymentInformation"+"."+"fluidData"+"."+"encoding", "body", o.Encoding, 6); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyPaymentInformationFluidData) validateValue(formats strfmt.Registry) error {
	if swag.IsZero(o.Value) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"paymentInformation"+"."+"fluidData"+"."+"value", "body", o.Value, 3072); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create credit params body payment information fluid data based on context it is used
func (o *CreateCreditParamsBodyPaymentInformationFluidData) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditParamsBodyPaymentInformationFluidData) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditParamsBodyPaymentInformationFluidData) UnmarshalBinary(b []byte) error {
	var res CreateCreditParamsBodyPaymentInformationFluidData
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditParamsBodyPaymentInformationInstrumentIdentifier create credit params body payment information instrument identifier
swagger:model CreateCreditParamsBodyPaymentInformationInstrumentIdentifier
*/
type CreateCreditParamsBodyPaymentInformationInstrumentIdentifier struct {

	// Unique identifier for the Instrument Identifier token used in the transaction.
	// When you include this value in your request, many of the fields that can be supplied for an authorization or credit
	// become optional.
	//
	// Max Length: 32
	// Min Length: 12
	ID string `json:"id,omitempty"`
}

// Validate validates this create credit params body payment information instrument identifier
func (o *CreateCreditParamsBodyPaymentInformationInstrumentIdentifier) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyPaymentInformationInstrumentIdentifier) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MinLength("createCreditRequest"+"."+"paymentInformation"+"."+"instrumentIdentifier"+"."+"id", "body", o.ID, 12); err != nil {
		return err
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"paymentInformation"+"."+"instrumentIdentifier"+"."+"id", "body", o.ID, 32); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create credit params body payment information instrument identifier based on context it is used
func (o *CreateCreditParamsBodyPaymentInformationInstrumentIdentifier) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditParamsBodyPaymentInformationInstrumentIdentifier) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditParamsBodyPaymentInformationInstrumentIdentifier) UnmarshalBinary(b []byte) error {
	var res CreateCreditParamsBodyPaymentInformationInstrumentIdentifier
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditParamsBodyPaymentInformationLegacyToken create credit params body payment information legacy token
swagger:model CreateCreditParamsBodyPaymentInformationLegacyToken
*/
type CreateCreditParamsBodyPaymentInformationLegacyToken struct {

	// Unique identifier for the legacy Secure Storage token used in the transaction.
	// When you include this value in your request, many of the fields that are normally required for an authorization or credit
	// become optional.
	//
	// Max Length: 22
	// Min Length: 16
	ID string `json:"id,omitempty"`
}

// Validate validates this create credit params body payment information legacy token
func (o *CreateCreditParamsBodyPaymentInformationLegacyToken) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyPaymentInformationLegacyToken) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MinLength("createCreditRequest"+"."+"paymentInformation"+"."+"legacyToken"+"."+"id", "body", o.ID, 16); err != nil {
		return err
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"paymentInformation"+"."+"legacyToken"+"."+"id", "body", o.ID, 22); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create credit params body payment information legacy token based on context it is used
func (o *CreateCreditParamsBodyPaymentInformationLegacyToken) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditParamsBodyPaymentInformationLegacyToken) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditParamsBodyPaymentInformationLegacyToken) UnmarshalBinary(b []byte) error {
	var res CreateCreditParamsBodyPaymentInformationLegacyToken
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditParamsBodyPaymentInformationPaymentInstrument create credit params body payment information payment instrument
swagger:model CreateCreditParamsBodyPaymentInformationPaymentInstrument
*/
type CreateCreditParamsBodyPaymentInformationPaymentInstrument struct {

	// Unique identifier for the Payment Instrument token used in the transaction.
	// When you include this value in your request, many of the fields that are normally required for an authorization or credit
	// become optional.
	//
	// Max Length: 32
	// Min Length: 1
	ID string `json:"id,omitempty"`
}

// Validate validates this create credit params body payment information payment instrument
func (o *CreateCreditParamsBodyPaymentInformationPaymentInstrument) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyPaymentInformationPaymentInstrument) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MinLength("createCreditRequest"+"."+"paymentInformation"+"."+"paymentInstrument"+"."+"id", "body", o.ID, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"paymentInformation"+"."+"paymentInstrument"+"."+"id", "body", o.ID, 32); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create credit params body payment information payment instrument based on context it is used
func (o *CreateCreditParamsBodyPaymentInformationPaymentInstrument) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditParamsBodyPaymentInformationPaymentInstrument) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditParamsBodyPaymentInformationPaymentInstrument) UnmarshalBinary(b []byte) error {
	var res CreateCreditParamsBodyPaymentInformationPaymentInstrument
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditParamsBodyPaymentInformationPaymentType create credit params body payment information payment type
swagger:model CreateCreditParamsBodyPaymentInformationPaymentType
*/
type CreateCreditParamsBodyPaymentInformationPaymentType struct {

	// method
	Method *CreateCreditParamsBodyPaymentInformationPaymentTypeMethod `json:"method,omitempty"`

	// A Payment Type is an agreed means for a payee to receive legal tender from a payer. The way one pays for a commercial financial transaction. Examples: Card, Bank Transfer, Digital, Direct Debit.
	// Possible values:
	// - `CARD` (use this for a PIN debit transaction)
	// - `CHECK` (use this for all eCheck payment transactions - ECP Debit, ECP Follow-on Credit, ECP StandAlone Credit)
	//
	Name string `json:"name,omitempty"`

	// Detailed information about the Payment Type. Possible values:
	// - `DEBIT`: Use this value to indicate a PIN debit transaction.
	//
	// Examples: For Card, if Credit or Debit or PrePaid. For Bank Transfer, if Online Bank Transfer or Wire Transfers.
	//
	SubTypeName string `json:"subTypeName,omitempty"`
}

// Validate validates this create credit params body payment information payment type
func (o *CreateCreditParamsBodyPaymentInformationPaymentType) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateMethod(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyPaymentInformationPaymentType) validateMethod(formats strfmt.Registry) error {
	if swag.IsZero(o.Method) { // not required
		return nil
	}

	if o.Method != nil {
		if err := o.Method.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "paymentInformation" + "." + "paymentType" + "." + "method")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "paymentInformation" + "." + "paymentType" + "." + "method")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this create credit params body payment information payment type based on the context it is used
func (o *CreateCreditParamsBodyPaymentInformationPaymentType) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateMethod(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyPaymentInformationPaymentType) contextValidateMethod(ctx context.Context, formats strfmt.Registry) error {

	if o.Method != nil {
		if err := o.Method.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "paymentInformation" + "." + "paymentType" + "." + "method")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "paymentInformation" + "." + "paymentType" + "." + "method")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditParamsBodyPaymentInformationPaymentType) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditParamsBodyPaymentInformationPaymentType) UnmarshalBinary(b []byte) error {
	var res CreateCreditParamsBodyPaymentInformationPaymentType
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditParamsBodyPaymentInformationPaymentTypeMethod create credit params body payment information payment type method
swagger:model CreateCreditParamsBodyPaymentInformationPaymentTypeMethod
*/
type CreateCreditParamsBodyPaymentInformationPaymentTypeMethod struct {

	// A Payment Type is enabled through a Method. Examples: Visa, Master Card, ApplePay, iDeal
	//
	Name string `json:"name,omitempty"`
}

// Validate validates this create credit params body payment information payment type method
func (o *CreateCreditParamsBodyPaymentInformationPaymentTypeMethod) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this create credit params body payment information payment type method based on context it is used
func (o *CreateCreditParamsBodyPaymentInformationPaymentTypeMethod) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditParamsBodyPaymentInformationPaymentTypeMethod) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditParamsBodyPaymentInformationPaymentTypeMethod) UnmarshalBinary(b []byte) error {
	var res CreateCreditParamsBodyPaymentInformationPaymentTypeMethod
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditParamsBodyPaymentInformationShippingAddress create credit params body payment information shipping address
swagger:model CreateCreditParamsBodyPaymentInformationShippingAddress
*/
type CreateCreditParamsBodyPaymentInformationShippingAddress struct {

	// Unique identifier for the Customers Shipping Address token used in the transaction.
	// When you include this value in your request, many of the shipping fields that can be supplied for an authorization or credit
	// become optional.
	//
	// Max Length: 32
	// Min Length: 1
	ID string `json:"id,omitempty"`
}

// Validate validates this create credit params body payment information shipping address
func (o *CreateCreditParamsBodyPaymentInformationShippingAddress) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyPaymentInformationShippingAddress) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MinLength("createCreditRequest"+"."+"paymentInformation"+"."+"shippingAddress"+"."+"id", "body", o.ID, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"paymentInformation"+"."+"shippingAddress"+"."+"id", "body", o.ID, 32); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create credit params body payment information shipping address based on context it is used
func (o *CreateCreditParamsBodyPaymentInformationShippingAddress) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditParamsBodyPaymentInformationShippingAddress) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditParamsBodyPaymentInformationShippingAddress) UnmarshalBinary(b []byte) error {
	var res CreateCreditParamsBodyPaymentInformationShippingAddress
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditParamsBodyPaymentInformationTokenizedCard create credit params body payment information tokenized card
swagger:model CreateCreditParamsBodyPaymentInformationTokenizedCard
*/
type CreateCreditParamsBodyPaymentInformationTokenizedCard struct {

	// Confidence level of the tokenization. This value is assigned by the token service provider.
	//
	// **Note** This field is supported only for **CyberSource through VisaNet** and **FDC Nashville Global**.
	//
	// Returned by PIN debit credit or PIN debit purchase.
	//
	// Max Length: 2
	AssuranceLevel string `json:"assuranceLevel,omitempty"`

	// This field is used internally.
	// Max Length: 40
	Cryptogram string `json:"cryptogram,omitempty"`

	// One of two possible meanings:
	// - The two-digit month in which a token expires.
	// - The two-digit month in which a card expires.
	// Format: `MM`
	// Possible values: `01` through `12`
	//
	// **NOTE** The meaning of this field is dependent on the payment processor that is returning the value in an authorization reply. Please see the processor-specific details below.
	//
	// #### Barclays and Streamline
	// For Maestro (UK Domestic) and Maestro (International) cards on Barclays and Streamline, this must be a valid value (`01` through `12`) but is not required to be a valid expiration date. In other words, an expiration date that is in the past does not cause CyberSource to reject your request. However, an invalid expiration date might cause the issuer to reject your request.
	//
	// #### Encoded Account Numbers
	// For encoded account numbers (`card_type=039`), if there is no expiration date on the card, use `12`.\
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// #### Samsung Pay and Apple Pay
	// Month in which the token expires. CyberSource includes this field in the reply message when it decrypts the payment blob for the tokenized transaction.
	//
	// For processor-specific information, see the `customer_cc_expmo` field in [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 2
	ExpirationMonth string `json:"expirationMonth,omitempty"`

	// One of two possible meanings:
	// - The four-digit year in which a token expires.
	// - The four-digit year in which a card expires.
	// Format: `YYYY`
	// Possible values: `1900` through `3000`
	// Data type: Non-negative integer
	//
	// **NOTE** The meaning of this field is dependent on the payment processor that is returning the value in an authorization reply. Please see the processor-specific details below.
	//
	// #### Barclays and Streamline
	// For Maestro (UK Domestic) and Maestro (International) cards on Barclays and Streamline, this must be a valid value (1900 through
	// 3000) but is not required to be a valid expiration date. In other words, an expiration date that is in the past does not cause CyberSource to reject your request. However, an invalid expiration date might cause the issuer to reject your request.
	//
	// #### Encoded Account Numbers
	// For encoded account numbers (`card_ type=039`), if there is no expiration date on the card, use `2021`.
	//
	// #### FDC Nashville Global and FDMS South
	// You can send in 2 digits or 4 digits. When you send in 2 digits, they must be the last 2 digits of
	// the year.
	//
	// #### Samsung Pay and Apple Pay
	// Year in which the token expires. CyberSource includes this field in the reply message when it decrypts the payment blob for the tokenized transaction.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction
	// you are requesting.
	//
	// For processor-specific information, see the `customer_cc_expyr` or `token_expiration_year` field in [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 4
	ExpirationYear string `json:"expirationYear,omitempty"`

	// Customers payment network token value.
	//
	// Max Length: 20
	Number string `json:"number,omitempty"`

	// Value that identifies your business and indicates that the cardholders account number is tokenized. This value
	// is assigned by the token service provider and is unique within the token service providers database.
	//
	// **Note** This field is supported only for **CyberSource through VisaNet** and **FDC Nashville Global**.
	//
	// #### PIN debit
	// Optional field for PIN debit credit or PIN debit purchase transactions that use payment network tokens; otherwise, not used.
	//
	// Max Length: 11
	RequestorID string `json:"requestorId,omitempty"`

	// Card Verification Number (CVN).
	//
	// #### Ingenico ePayments
	// Do not include this field when **commerceIndicator=recurring**.
	// **Note** Ingenico ePayments was previously called _Global Collect_.
	//
	// For details, see `customer_cc_cv_number` field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// Max Length: 4
	SecurityCode string `json:"securityCode,omitempty"`

	// Type of technology used in the device to store token data. Possible values:
	//
	// - `001`: Secure Element (SE). Smart card or memory with restricted access and encryption to prevent data tampering. For storing payment
	//    credentials, a SE is tested against a set of requirements defined by the payment networks.
	//
	//    **Note** This field is supported only for _FDC Compass_.
	//
	// - 002: Host Card Emulation (HCE). Emulation of a smart card by using software to create a virtual and exact representation of the card.
	// Sensitive data is stored in a database that is hosted in the cloud. For storing payment credentials, a database
	// must meet very stringent security requirements that exceed PCI DSS.
	//
	// **Note** This field is supported only for _FDC Compass_.
	//
	// Max Length: 3
	StorageMethod string `json:"storageMethod,omitempty"`

	// Type of transaction that provided the token data. This value does not specify the token service provider; it specifies the entity that
	// provided you with information about the token.
	//
	// Possible value:
	// - `2`: Near-field communication (NFC) transaction. The customers mobile device provided the token data for a contactless EMV transaction. For recurring
	// transactions, use this value if the original transaction was a contactless EMV transaction.
	//
	// **NOTE** No CyberSource through VisaNet acquirers support EMV at this time.
	//
	// Required field for PIN debit credit or PIN debit purchase transactions that use payment network tokens; otherwise, not used.
	//
	// Max Length: 1
	TransactionType string `json:"transactionType,omitempty"`

	// Three-digit value that indicates the card type.
	//
	// **IMPORTANT** It is strongly recommended that you include the card type field in request messages even if it is
	// optional for your processor and card type. Omitting the card type can cause the transaction to be processed with the wrong card type.
	//
	// Possible values:
	// - `001`: Visa. For card-present transactions on all processors except SIX, the Visa Electron card type is processed the same way that the Visa debit card is processed. Use card type value `001` for Visa Electron.
	// - `002`: Mastercard, Eurocard[^1], which is a European regional brand of Mastercard.
	// - `003`: American Express
	// - `004`: Discover
	// - `005`: Diners Club
	// - `006`: Carte Blanche[^1]
	// - `007`: JCB[^1]
	// - `014`: Enroute[^1]
	// - `021`: JAL[^1]
	// - `024`: Maestro (UK Domestic)[^1]
	// - `031`: Delta[^1]: Use this value only for Ingenico ePayments. For other processors, use `001` for all Visa card types.
	// - `033`: Visa Electron[^1]. Use this value only for Ingenico ePayments and SIX. For other processors, use `001` for all Visa card types.
	// - `034`: Dankort[^1]
	// - `036`: Cartes Bancaires[^1,4]
	// - `037`: Carta Si[^1]
	// - `039`: Encoded account number[^1]
	// - `040`: UATP[^1]
	// - `042`: Maestro (International)[^1]
	// - `050`: Hipercard[^2,3]
	// - `051`: Aura
	// - `054`: Elo[^3]
	// - `062`: China UnionPay
	//
	// [^1]: For this card type, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in your request for an authorization or a stand-alone credit.
	// [^2]: For this card type on Cielo 3.0, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in a request for an authorization or a stand-alone credit. This card type is not supported on Cielo 1.5.
	// [^3]: For this card type on Getnet and Rede, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in a request for an authorization or a stand-alone credit.
	// [^4]: For this card type, you must include the `paymentInformation.card.type` in your request for any payer authentication services.
	//
	// #### Used by
	// **Authorization**
	// Required for Carte Blanche and JCB.
	// Optional for all other card types.
	//
	// #### Card Present reply
	// This field is included in the reply message when the client software that is installed on the POS terminal uses
	// the token management service (TMS) to retrieve tokenized payment details. You must contact customer support to
	// have your account enabled to receive these fields in the credit reply message.
	//
	// Returned by the Credit service.
	//
	// This reply field is only supported by the following processors:
	// - American Express Direct
	// - Credit Mutuel-CIC
	// - FDC Nashville Global
	// - OmniPay Direct
	// - SIX
	//
	// #### Google Pay transactions
	// For PAN-based Google Pay transactions, this field is returned in the API response.
	//
	// #### GPX
	// This field only supports transactions from the following card types:
	// - Visa
	// - Mastercard
	// - AMEX
	// - Discover
	// - Diners
	// - JCB
	// - Union Pay International
	//
	Type string `json:"type,omitempty"`
}

// Validate validates this create credit params body payment information tokenized card
func (o *CreateCreditParamsBodyPaymentInformationTokenizedCard) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAssuranceLevel(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCryptogram(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpirationMonth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpirationYear(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRequestorID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSecurityCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateStorageMethod(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTransactionType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyPaymentInformationTokenizedCard) validateAssuranceLevel(formats strfmt.Registry) error {
	if swag.IsZero(o.AssuranceLevel) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"paymentInformation"+"."+"tokenizedCard"+"."+"assuranceLevel", "body", o.AssuranceLevel, 2); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyPaymentInformationTokenizedCard) validateCryptogram(formats strfmt.Registry) error {
	if swag.IsZero(o.Cryptogram) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"paymentInformation"+"."+"tokenizedCard"+"."+"cryptogram", "body", o.Cryptogram, 40); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyPaymentInformationTokenizedCard) validateExpirationMonth(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationMonth) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"paymentInformation"+"."+"tokenizedCard"+"."+"expirationMonth", "body", o.ExpirationMonth, 2); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyPaymentInformationTokenizedCard) validateExpirationYear(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationYear) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"paymentInformation"+"."+"tokenizedCard"+"."+"expirationYear", "body", o.ExpirationYear, 4); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyPaymentInformationTokenizedCard) validateNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.Number) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"paymentInformation"+"."+"tokenizedCard"+"."+"number", "body", o.Number, 20); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyPaymentInformationTokenizedCard) validateRequestorID(formats strfmt.Registry) error {
	if swag.IsZero(o.RequestorID) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"paymentInformation"+"."+"tokenizedCard"+"."+"requestorId", "body", o.RequestorID, 11); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyPaymentInformationTokenizedCard) validateSecurityCode(formats strfmt.Registry) error {
	if swag.IsZero(o.SecurityCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"paymentInformation"+"."+"tokenizedCard"+"."+"securityCode", "body", o.SecurityCode, 4); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyPaymentInformationTokenizedCard) validateStorageMethod(formats strfmt.Registry) error {
	if swag.IsZero(o.StorageMethod) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"paymentInformation"+"."+"tokenizedCard"+"."+"storageMethod", "body", o.StorageMethod, 3); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyPaymentInformationTokenizedCard) validateTransactionType(formats strfmt.Registry) error {
	if swag.IsZero(o.TransactionType) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"paymentInformation"+"."+"tokenizedCard"+"."+"transactionType", "body", o.TransactionType, 1); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create credit params body payment information tokenized card based on context it is used
func (o *CreateCreditParamsBodyPaymentInformationTokenizedCard) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditParamsBodyPaymentInformationTokenizedCard) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditParamsBodyPaymentInformationTokenizedCard) UnmarshalBinary(b []byte) error {
	var res CreateCreditParamsBodyPaymentInformationTokenizedCard
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditParamsBodyPointOfSaleInformation create credit params body point of sale information
swagger:model CreateCreditParamsBodyPointOfSaleInformation
*/
type CreateCreditParamsBodyPointOfSaleInformation struct {

	// Point-of-sale details for the transaction. This value is returned only for **American Express Direct**.
	// CyberSource generates this value, which consists of a series of codes that identify terminal capability,
	// security data, and specific conditions present at the time the transaction occurred. To comply with the CAPN
	// requirements, this value must be included in all subsequent follow-on requests, such as captures and follow-on
	// credits.
	//
	// When you perform authorizations, captures, and credits through CyberSource, CyberSource passes this value from
	// the authorization service to the subsequent services for you. However, when you perform authorizations through
	// CyberSource and perform subsequent services through other financial institutions, you must ensure that your
	// requests for captures and credits include this value.
	//
	// For details, see `auth_pos_data` field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// Max Length: 15
	AmexCapnData string `json:"amexCapnData,omitempty"`

	// Complete list of cardholder verification methods (CVMs) supported by the terminal.
	// Optional field.
	// Possible values:
	// - `PIN`: For terminals with a PIN Pad
	// - `Signature`: For terminals capable of receiving a signature
	// - `pinOnGlass`: For terminals where PIN is entered on a glass-based capture mechanism
	//
	// **EXAMPLE**: ["PIN","Signature"]; ["pinOnGlass","Signature"]
	//
	CardholderVerificationMethod []string `json:"cardholderVerificationMethod"`

	// Type of cardholder-activated terminal. Possible values:
	//
	//  - 1: Automated dispensing machine
	//  - 2: Self-service terminal
	//  - 3: Limited amount terminal
	//  - 4: In-flight commerce (IFC) terminal
	//  - 5: Radio frequency device
	//  - 6: Mobile acceptance terminal
	//  - 7: Electronic cash register
	//  - 8: E-commerce device at your location
	//  - 9: Terminal or cash register that uses a dialup connection to connect to the transaction processing network
	//
	// #### Chase Paymentech Solutions
	// Only values 1, 2, and 3 are supported.
	//
	// Required if `pointOfSaleInformation.terminalID` is included in the request; otherwise, optional.
	//
	// #### CyberSource through VisaNet
	// Values 1 through 6 are supported on
	// CyberSource through VisaNet, but some
	// acquirers do not support all six values.
	//
	// Optional field.
	//
	// #### FDC Nashville Global
	// Only values 7, 8, and 9 are supported.
	//
	// Optional field for EMV transactions; otherwise, not used.
	//
	// #### GPN
	// Only values 6, 7, 8, and 9 are supported.
	//
	// Required field.
	//
	// #### JCN Gateway
	// Only values 6, 7, 8, and 9 are supported.
	//
	// Required field.
	//
	// #### TSYS Acquiring Solutions
	// Only value 6 is supported.
	//
	// Required for transactions from mobile devices; otherwise, not used.
	//
	// #### All other processors
	// Not used.
	//
	// Nonnegative integer.
	//
	// Maximum: 9
	// Minimum: 1
	CatLevel int64 `json:"catLevel,omitempty"`

	// Value created by the client software that uniquely identifies the POS device. This value is provided by the
	// client software that is installed on the POS terminal.
	//
	// CyberSource does not forward this value to the processor. Instead, the value is forwarded to the CyberSource
	// reporting functionality.
	//
	// This field is supported only on American Express Direct, FDC Nashville Global, and SIX.
	//
	// Max Length: 32
	DeviceID string `json:"deviceId,omitempty"`

	// emv
	Emv *CreateCreditParamsBodyPointOfSaleInformationEmv `json:"emv,omitempty"`

	// This 32 byte length-maximum EBCDIC-K value is used to identify which chip application was performed between the terminal and the chip product.
	// The included values are the Application Identifier (AID) and the Dedicated File (DF) name. It is available to early- or full-option VSDC issuers.
	// Only single byte Katakana characters that can map to the EBCDIC-K table expected in the name.
	//
	// Max Length: 32
	EmvApplicationIdentifierAndDedicatedFileName string `json:"emvApplicationIdentifierAndDedicatedFileName,omitempty"`

	// Combination of the device's unique identifier and a transaction counter that is used in the process of
	// decrypting the encrypted PIN. The entity that injected the PIN encryption keys into the terminal decrypts the
	// encrypted PIN and creates this value.
	//
	// For all terminals that are using derived unique key per transaction (DUKPT) encryption, this is generated as a
	// single number within the terminal.
	//
	// #### Used by
	// **Authorization, PIN Debit**
	// - Required when the cardholder enters a PIN and the card cannot verify the PIN, which means that the issuer must verify the PIN.
	// - Required for PIN debit credit or PIN debit purchase.
	// - Required for online PIN transactions
	//
	// For authorizations, this field is supported only on these processors:
	// - American Express Direct
	// - Credit Mutuel-CIC
	// - FDC Nashville Global
	// - OmniPay Direct
	// - SIX
	//
	// This field is also used by processors that support chip and online PIN transactions. The following table lists the EMV Cards
	// and Cardholder Verification Methods (CVMs) that these processors support:
	//
	// | Processor | Chip and Offline PIN | Chip and Online PIN | Chip and Signature |
	// | --- | --- | --- | --- |
	// | American Express Direct | Yes | Yes | Yes |
	// | Chase Paymentech Solutions | No | No | Yes |
	// | Credit Mutuel-CIC | Yes | Yes | Yes |
	// | CyberSource through VisaNet | Yes | No | Yes |
	// | FDC Nashville Global | Yes | Yes | Yes |
	// | GPN | No | No | Yes |
	// | OmniPay Direct | Yes | No | Yes |
	// | SIX | Yes | Yes | Yes |
	//
	// Max Length: 20
	EncryptedKeySerialNumber string `json:"encryptedKeySerialNumber,omitempty"`

	// Encrypted PIN.
	//
	// This value is provided by the client software that is installed on the POS terminal.
	//
	// #### Used by
	// **Authorization, PIN Debit**
	// Required when the cardholder enters a PIN and the card cannot verify the PIN, which means that the issuer must verify the PIN.
	// Required for PIN debit credit or PIN debit purchase.
	// Required for online PIN transactions.
	//
	// For authorizations, this field is supported only on these processors:
	// - American Express Direct
	// - Credit Mutuel-CIC
	// - FDC Nashville Global
	// - OmniPay Direct
	// - SIX
	//
	// This field is also used by processors that support chip and online PIN transactions. The following table lists the EMV Cards
	// and Cardholder Verification Methods (CVMs) that these processors support:
	//
	// | Processor | Chip and Offline PIN | Chip and Online PIN | Chip and Signature |
	// | --- | --- | --- | --- |
	// | American Express Direct | Yes | Yes | Yes |
	// | Chase Paymentech Solutions | No | No | Yes |
	// | Credit Mutuel-CIC | Yes | Yes | Yes |
	// | CyberSource through VisaNet | Yes | No | Yes |
	// | FDC Nashville Global | Yes | Yes | Yes |
	// | GPN | No | No | Yes |
	// | OmniPay Direct | Yes | No | Yes |
	// | SIX | Yes | Yes | Yes |
	//
	// Max Length: 16
	EncryptedPin string `json:"encryptedPin,omitempty"`

	// Method of entering payment card information into the POS terminal. Possible values:
	//
	//  - `contact`: Read from direct contact with chip card.
	//  - `contactless`: Read from a contactless interface using chip data.
	//  - `keyed`: Manually keyed into POS terminal. This value is not supported on OmniPay Direct.
	//  - `msd`: Read from a contactless interface using magnetic stripe data (MSD). This value is not supported on OmniPay Direct.
	//  - `swiped`: Read from credit card magnetic stripe.
	//
	// The `contact`, `contactless`, and `msd` values are supported only for EMV transactions.
	//
	// #### Used by
	// **Authorization**
	// Required field.
	//
	// #### Card Present
	// Card present information about EMV applies only to credit card processing and PIN debit processing. All other
	// card present information applies only to credit card processing.
	//
	// #### PIN debit
	// Required for a PIN debit purchase and a PIN debit credit request.
	//
	// Max Length: 11
	EntryMode string `json:"entryMode,omitempty"`

	// Type of mPOS device. Possible values:
	// - 0: Dongle
	// - 1: Phone or tablet
	//
	// This optional field is supported only for Mastercard transactions on CyberSource through VisaNet.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file:
	// - Record: CP01 TCR6
	// - Position: 141
	// - Field: Mastercard mPOS Transaction
	//
	// The TC 33 Capture file contains information about the purchases and refunds that a merchant submits to CyberSource.
	// CyberSource through VisaNet creates the TC 33 Capture file at the end of the day and sends it to the merchants
	// acquirer, who uses this information to facilitate end-of-day clearing processing with payment networks.
	//
	// Max Length: 1
	IsDedicatedHardwareTerminal string `json:"isDedicatedHardwareTerminal,omitempty"`

	// Identifier for an alternate terminal at your retail location. You define the value for this field.
	//
	// This field is supported only for MasterCard transactions on FDC Nashville Global. Otherwise, this field is not used by all other processors.
	// Use the `terminalId` field to identify the main terminal at your retail location. If your retail location has multiple terminals,
	// use this `laneNumber` field to identify the terminal used for the transaction.
	//
	// This field is a pass-through, which means that the value is not checked or modified in any way before sending it to the processor.
	//
	// Optional field.
	//
	// #### Card present reply messaging
	// Identifier for an alternate terminal at your retail location. You defined the value for this field in the request
	// message. This value must be printed on the receipt.
	//
	// This field is supported only for MasterCard transactions on FDC Nashville Global.
	//
	// Max Length: 8
	LaneNumber string `json:"laneNumber,omitempty"`

	// Operating environment.
	//
	// Possible values for all card types except Mastercard:
	// - `0`: No terminal used or unknown environment.
	// - `1`: On merchant premises, attended.
	// - `2`: On merchant premises, unattended. Examples: oil, kiosks, self-checkout, mobile telephone, personal digital assistant (PDA).
	// - `3`: Off merchant premises, attended. Examples: portable POS devices at trade shows, at service calls, or in taxis.
	// - `4`: Off merchant premises, unattended. Examples: vending machines, home computer, mobile telephone, PDA.
	// - `5`: On premises of cardholder, unattended.
	// - `9`: Unknown delivery mode.
	// - `S`: Electronic delivery of product. Examples: music, software, or eTickets that are downloaded over the internet.
	// - `T`: Physical delivery of product. Examples: music or software that is delivered by mail or by a courier.
	//
	// #### Possible values for Mastercard:
	// - `2`: On merchant premises, unattended, or cardholder terminal. Examples: oil, kiosks, self-checkout, home computer, mobile telephone, personal digital assistant (PDA). Cardholder terminal is supported only for Mastercard transactions on CyberSource through VisaNet.
	// - `4`: Off merchant premises, unattended, or cardholder terminal. Examples: vending machines, home computer, mobile telephone, PDA. Cardholder terminal is supported only for Mastercard transactions on CyberSource through VisaNet.
	//
	// This field is supported only for American Express Direct and CyberSource through VisaNet.
	//
	// Max Length: 1
	OperatingEnvironment string `json:"operatingEnvironment,omitempty"`

	// Version of the software installed on the POS terminal. This value is provided by the client software that is
	// installed on the POS terminal.
	//
	// CyberSource does not forward this value to the processor. Instead, the value is forwarded to the CyberSource
	// reporting functionality.
	//
	// This field is supported only on American Express Direct, FDC Nashville Global, and SIX.
	//
	// For authorizations and credits, this field is supported only on these processors:
	// - American Express Direct
	// - Credit Mutuel-CIC
	// - FDC Nashville Global
	// - OmniPay Direct
	// - SIX
	//
	// Max Length: 32
	PartnerSdkVersion string `json:"partnerSdkVersion,omitempty"`

	// Format that is used to encode the PIN block. This value is provided by the client software that is installed on
	// the POS terminal.
	//
	// Possible values:
	// - `0`: ISO 9564 format 0
	// - `1`: ISO 9564 format 1
	// - `2`: ISO 9564 format 2
	// - `3`: ISO 9564 format 3
	//
	// #### Used by
	// **Authorization, PIN Debit**
	// - Required when the cardholder enters a PIN and the card cannot verify the PIN, which means that the issuer must verify the PIN.
	// - Required for PIN debit credit or PIN debit purchase.
	//
	// For authorizations, this field is supported only on these processors:
	// - American Express Direct
	// - Credit Mutuel-CIC
	// - FDC Nashville Global
	// - OmniPay Direct
	// - SIX
	//
	// This field is also supported by processors that support chip and online PIN transactions. The following table lists the EMV Cards
	// and Cardholder Verification Methods (CVMs) that these processors support:
	//
	// | Processor | Chip and Offline PIN | Chip and Online PIN | Chip and Signature |
	// | --- | --- | --- | --- |
	// | American Express Direct | Yes | Yes | Yes |
	// | Chase Paymentech Solutions | No | No | Yes |
	// | Credit Mutuel-CIC | Yes | Yes | Yes |
	// | CyberSource through VisaNet | Yes | No | Yes |
	// | FDC Nashville Global | Yes | Yes | Yes |
	// | GPN | No | No | Yes |
	// | OmniPay Direct | Yes | No | Yes |
	// | SIX | Yes | Yes | Yes |
	//
	// #### GPX
	// For chip and online PIN transactions for authorization, GPX supports the following EMV Cards and Cardholder Verification Methods (CVMs):
	// - Chip and Offline PIN
	// - Chip and Signature
	//
	// For PIN Debit Purchase and Credit Service transactions, GPX supports the following EMV Cards and Cardholder Verification Methods (CVMs):
	// - Chip and Online PIN
	//
	// Maximum: 9
	PinBlockEncodingFormat int64 `json:"pinBlockEncodingFormat,omitempty"`

	// When connectivity is unavailable, the client software that is installed on the POS terminal can store a
	// transaction in its memory and send it for authorization when connectivity is restored. This value is provided by
	// the client software that is installed on the POS terminal.
	//
	// This value is not forwarded to the processor. Instead, the value is forwarded to the reporting functionality.
	//
	// Possible values:
	// - `Y`: Transaction was stored and then forwarded.
	// - `N` (default): Transaction was not stored and then forwarded.
	//
	// For authorizations and credits, this field is supported only on these processors:
	// - American Express Direct
	// - FDC Nashville Global
	// - OmniPay Direct
	// - SIX
	//
	// Optional field.
	//
	// Max Length: 1
	StoreAndForwardIndicator string `json:"storeAndForwardIndicator,omitempty"`

	// POS terminals capability. Possible values:
	//
	//  - `1`: Terminal has a magnetic stripe reader only.
	//  - `2`: Terminal has a magnetic stripe reader and manual entry capability.
	//  - `3`: Terminal has manual entry capability only.
	//  - `4`: Terminal can read chip cards.
	//  - `5`: Terminal can read contactless chip cards; cannot use contact to read chip cards.
	//
	// For an EMV transaction, the value of this field must be `4` or `5`.
	//
	// #### PIN debit
	// Required for PIN debit purchase and PIN debit credit request.
	//
	// #### Used by
	// **Authorization**
	// Required for the following processors:
	// - American Express Direct
	// - Chase Paymentech Solutions
	// - Credit Mutuel-CIC
	// - FDC Nashville Global
	// - FDMS Nashville
	// - OmniPay Direct
	// - SIX
	// - Worldpay VAP
	//
	// Optional for the following processors:
	// - CyberSource through VisaNet
	// - GPN
	// - GPX
	// - JCN Gateway
	// - RBS WorldPay Atlanta
	// - TSYS Acquiring Solutions
	//
	// Maximum: 5
	// Minimum: 1
	TerminalCapability int64 `json:"terminalCapability,omitempty"`

	// Indicates whether the terminal can capture the card.
	//
	// Possible values:
	// - `1`: Terminal can capture card.
	// - `0`: Terminal cannot capture card.
	//
	// For authorizations and credits, this field is supported only by these processors:
	// - American Express Direct
	// - Credit Mutuel-CIC
	// - OmniPay Direct
	//
	// Optional field.
	//
	// Max Length: 1
	TerminalCardCaptureCapability string `json:"terminalCardCaptureCapability,omitempty"`

	// Flag that indicates whether the terminal is compliant with standards mandated by the Reserve Bank of India for card-present domestic transactions in India.
	//
	// Format:
	// - First character indicates whether the terminal supports terminal line encryption (TLE). Possible values:
	//   - 1: Not certified
	//   - 2: Certified
	// - Second character indicates whether the terminal supports Unique Key Per Transaction (UKPT) and Derived Unique Key Per Transaction (DUKPT). Possible values:
	//   - 1: Not certified
	//   - 2: Certified
	//
	// **Example** `21` indicates that the terminal supports TLE but does not support UKPT/DUKPT.
	//
	// You and the terminal vendors are responsible for terminal certification. If you have questions, contact your acquirer.
	//
	// This field is supported only for Mastercard transactions on CyberSource through VisaNet.
	//
	// **Note** On CyberSource through VisaNet, the value for this field corresponds to the following data in the TC 33 capture file:
	// - Record: CP01 TCR6
	// - Position: 92-93
	// - Field: Mastercard Terminal Compliance Indicator
	//
	// The TC 33 Capture file contains information about the purchases and refunds that a merchant submits to CyberSource. CyberSource through VisaNet creates the TC 33 Capture file at the end of the day and sends it to the merchants acquirer, who uses this information to facilitate end-of-day clearing processing with payment networks.
	//
	// #### Used by
	// **Authorization**
	// Required for card-present transactions in India. Otherwise, not used.
	//
	// Max Length: 2
	TerminalCompliance string `json:"terminalCompliance,omitempty"`

	// Identifier for the terminal at your retail location. You can define this value yourself, but consult the processor for requirements.
	//
	// #### CyberSource through VisaNet
	// A list of all possible values is stored in your CyberSource account. If terminal ID validation is enabled for
	// your CyberSource account, the value you send for this field is validated against the list each time you include
	// the field in a request. To enable or disable terminal ID validation, contact CyberSource Customer Support.
	//
	// When you do not include this field in a request, CyberSource uses the default value that is defined in your CyberSource account.
	//
	// #### FDC Nashville Global
	// To have your account configured to support this field, contact CyberSource Customer Support. This value must be a value that FDC Nashville Global issued to you.
	//
	// #### For Payouts
	// This field is applicable for CyberSource through VisaNet.
	//
	// #### GPX
	// Identifier for the terminal at your retail location. A list of all possible values is stored in your account.
	// If terminal ID validation is enabled for your account, the value you send for this field is validated against
	// the list each time you include the field in a request. To enable or disable terminal ID validation, contact
	// customer support.
	//
	// When you do not include this field in a request, the default value that is defined in your account is used.
	//
	// Optional for authorizations.
	//
	// #### Used by
	// **Authorization**
	// Optional for the following processors. When you do not include this field in a request, the default value that is
	// defined in your account is used.
	//   - American Express Direct
	//   - Credit Mutuel-CIC
	//   - FDC Nashville Global
	//   - SIX
	// - Chase Paymentech Solutions: Optional field. If you include this field in your request, you must also include `pointOfSaleInformation.catLevel`.
	// - FDMS Nashville: The default value that is defined in your account is used.
	// - GPX
	// - OmniPay Direct: Optional field.
	//
	// For the following processors, this field is not used.
	// - GPN
	// - JCN Gateway
	// - RBS WorldPay Atlanta
	// - TSYS Acquiring Solutions
	// - Worldpay VAP
	//
	// #### Card Present reply
	// Terminal identifier assigned by the acquirer. This value must be printed on the receipt.
	//
	// Max Length: 8
	TerminalID string `json:"terminalId,omitempty"`

	// Complete list of card input methods supported by the terminal.
	//
	// Possible values:
	// - `Keyed`: Terminal can accept card data that is entered manually.
	// - `Swiped`: Terminal can accept card data from a magnetic stripe reader.
	// - `Contact`: Terminal can accept card data in EMV contact mode ("dipping a card").
	// - `Contactless`: Terminal can accept card data in EMV contactless mode ("tapping a card").
	// - `BarCode`: Terminal can read bar codes.
	// - `QRcode`: Terminal can read or scan QR codes.
	// - `OCR`: Terminal can perform optical character recognition (OCT) on the card.
	//
	// **EXAMPLE**: ["Keyed","Swiped","Contact","Contactless"]
	//
	// #### Used by
	// **Authorization and Credit**
	// Optional. This field is supported only by client software that is installed on your POS terminals for the
	// following processors:
	// - American Express Direct
	// - Credit Mutuel-CIC
	// - FDC Nashville Global
	// - OmniPay Direct
	// - SIX
	//
	TerminalInputCapability []string `json:"terminalInputCapability"`

	// This is the manufacturer name of the reader which is used to accept the payment.
	// Possible values:
	//  - PAX
	//  - Verifone
	//  - Ingenico
	//
	// Max Length: 32
	TerminalMake string `json:"terminalMake,omitempty"`

	// This is the model name of the reader which is used to accept the payment.
	// Possible values:
	//  - E3555
	//  - P400
	//  - A920
	//
	// Max Length: 32
	TerminalModel string `json:"terminalModel,omitempty"`

	// Indicates whether the terminal can print or display messages.
	//
	// Possible values:
	// - 1: Neither
	// - 2: Print only
	// - 3: Display only
	// - 4: Print and display
	//
	// This field is supported for authorizations and credits only on the following processors:
	// - American Express Direct
	// - Credit Mutuel-CIC
	// - FDC Nashville Global
	// - OmniPay Direct
	// - SIX
	//
	// Optional field.
	//
	// Max Length: 1
	TerminalOutputCapability string `json:"terminalOutputCapability,omitempty"`

	// Maximum PIN length that the terminal can capture.
	//
	// Possible values:
	// -  0: No PIN capture capability
	// -  1: PIN capture capability unknown
	// -  4: Four characters
	// -  5: Five characters
	// -  6: Six characters
	// -  7: Seven characters
	// -  8: Eight characters
	// -  9: Nine characters
	// - 10: Ten characters
	// - 11: Eleven characters
	// - 12: Twelve characters
	//
	// This field is supported for authorizations and credits only on the following processors:
	// - American Express Direct
	// - Credit Mutuel-CIC
	// - OmniPay Direct
	// - SIX
	//
	// Required field for authorization or credit of PIN transactions.
	//
	TerminalPinCapability int64 `json:"terminalPinCapability,omitempty"`

	// Terminal serial number assigned by the hardware manufacturer. This value is provided by the client software that
	// is installed on the POS terminal.
	//
	// This value is not forwarded to the processor. Instead, the value is forwarded to the reporting functionality.
	//
	// #### Used by
	// **Authorization and Credit**
	// Optional. This field is supported only by client software that is installed on your POS terminals for the
	// following processors:
	// - American Express Direct
	// - Credit Mutuel-CIC
	// - FDC Nashville Global
	// - OmniPay Direct
	// - SIX
	//
	// Max Length: 32
	TerminalSerialNumber string `json:"terminalSerialNumber,omitempty"`

	// Cards track 1 and 2 data. For all processors except FDMS Nashville, this value consists of
	// one of the following:
	//
	//  - Track 1 data
	//  - Track 2 data
	//  - Data for both tracks 1 and 2
	//
	// For FDMS Nashville, this value consists of one of the following:
	//  - Track 1 data
	//  - Data for both tracks 1 and 2
	//
	// Example: %B4111111111111111^SMITH/JOHN ^1612101976110000868000000?;4111111111111111=16121019761186800000?
	//
	// #### Used by
	// **Authorization**
	// Required for Chase Paymentech Solutions, Credit Mutuel-CIC, CyberSource through VisaNet, FDC Nashville Global,
	// JCN Gateway, OmniPay Direct, and SIX if `pointOfSaleInformation.entryMode` is equal to one of these values:
	// - `contact`
	// - `contactless`
	// - `msd`
	// - `swiped`
	// Otherwise, this field not used.
	//
	// Required for all other processors if `pointOfSaleInformation.entryMode=swiped`; otherwise, this field is not used.
	//
	// #### GPX
	// This field only supports transactions from the following card types:
	// - Visa
	// - Mastercard
	// - AMEX
	// - Discover
	// - Diners
	// - JCB
	// - Union Pay International
	//
	// #### PIN debit
	// Track 2 data from the debit card. The sentinels are required.
	// Required field for a PIN debit purchase and a PIN debit credit.
	//
	TrackData string `json:"trackData,omitempty"`
}

// Validate validates this create credit params body point of sale information
func (o *CreateCreditParamsBodyPointOfSaleInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAmexCapnData(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCatLevel(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDeviceID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEmv(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEmvApplicationIdentifierAndDedicatedFileName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEncryptedKeySerialNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEncryptedPin(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEntryMode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateIsDedicatedHardwareTerminal(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLaneNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOperatingEnvironment(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePartnerSdkVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePinBlockEncodingFormat(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateStoreAndForwardIndicator(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTerminalCapability(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTerminalCardCaptureCapability(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTerminalCompliance(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTerminalID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTerminalMake(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTerminalModel(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTerminalOutputCapability(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTerminalSerialNumber(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyPointOfSaleInformation) validateAmexCapnData(formats strfmt.Registry) error {
	if swag.IsZero(o.AmexCapnData) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"pointOfSaleInformation"+"."+"amexCapnData", "body", o.AmexCapnData, 15); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyPointOfSaleInformation) validateCatLevel(formats strfmt.Registry) error {
	if swag.IsZero(o.CatLevel) { // not required
		return nil
	}

	if err := validate.MinimumInt("createCreditRequest"+"."+"pointOfSaleInformation"+"."+"catLevel", "body", o.CatLevel, 1, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("createCreditRequest"+"."+"pointOfSaleInformation"+"."+"catLevel", "body", o.CatLevel, 9, false); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyPointOfSaleInformation) validateDeviceID(formats strfmt.Registry) error {
	if swag.IsZero(o.DeviceID) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"pointOfSaleInformation"+"."+"deviceId", "body", o.DeviceID, 32); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyPointOfSaleInformation) validateEmv(formats strfmt.Registry) error {
	if swag.IsZero(o.Emv) { // not required
		return nil
	}

	if o.Emv != nil {
		if err := o.Emv.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "pointOfSaleInformation" + "." + "emv")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "pointOfSaleInformation" + "." + "emv")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditParamsBodyPointOfSaleInformation) validateEmvApplicationIdentifierAndDedicatedFileName(formats strfmt.Registry) error {
	if swag.IsZero(o.EmvApplicationIdentifierAndDedicatedFileName) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"pointOfSaleInformation"+"."+"emvApplicationIdentifierAndDedicatedFileName", "body", o.EmvApplicationIdentifierAndDedicatedFileName, 32); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyPointOfSaleInformation) validateEncryptedKeySerialNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.EncryptedKeySerialNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"pointOfSaleInformation"+"."+"encryptedKeySerialNumber", "body", o.EncryptedKeySerialNumber, 20); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyPointOfSaleInformation) validateEncryptedPin(formats strfmt.Registry) error {
	if swag.IsZero(o.EncryptedPin) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"pointOfSaleInformation"+"."+"encryptedPin", "body", o.EncryptedPin, 16); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyPointOfSaleInformation) validateEntryMode(formats strfmt.Registry) error {
	if swag.IsZero(o.EntryMode) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"pointOfSaleInformation"+"."+"entryMode", "body", o.EntryMode, 11); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyPointOfSaleInformation) validateIsDedicatedHardwareTerminal(formats strfmt.Registry) error {
	if swag.IsZero(o.IsDedicatedHardwareTerminal) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"pointOfSaleInformation"+"."+"isDedicatedHardwareTerminal", "body", o.IsDedicatedHardwareTerminal, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyPointOfSaleInformation) validateLaneNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.LaneNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"pointOfSaleInformation"+"."+"laneNumber", "body", o.LaneNumber, 8); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyPointOfSaleInformation) validateOperatingEnvironment(formats strfmt.Registry) error {
	if swag.IsZero(o.OperatingEnvironment) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"pointOfSaleInformation"+"."+"operatingEnvironment", "body", o.OperatingEnvironment, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyPointOfSaleInformation) validatePartnerSdkVersion(formats strfmt.Registry) error {
	if swag.IsZero(o.PartnerSdkVersion) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"pointOfSaleInformation"+"."+"partnerSdkVersion", "body", o.PartnerSdkVersion, 32); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyPointOfSaleInformation) validatePinBlockEncodingFormat(formats strfmt.Registry) error {
	if swag.IsZero(o.PinBlockEncodingFormat) { // not required
		return nil
	}

	if err := validate.MaximumInt("createCreditRequest"+"."+"pointOfSaleInformation"+"."+"pinBlockEncodingFormat", "body", o.PinBlockEncodingFormat, 9, false); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyPointOfSaleInformation) validateStoreAndForwardIndicator(formats strfmt.Registry) error {
	if swag.IsZero(o.StoreAndForwardIndicator) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"pointOfSaleInformation"+"."+"storeAndForwardIndicator", "body", o.StoreAndForwardIndicator, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyPointOfSaleInformation) validateTerminalCapability(formats strfmt.Registry) error {
	if swag.IsZero(o.TerminalCapability) { // not required
		return nil
	}

	if err := validate.MinimumInt("createCreditRequest"+"."+"pointOfSaleInformation"+"."+"terminalCapability", "body", o.TerminalCapability, 1, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("createCreditRequest"+"."+"pointOfSaleInformation"+"."+"terminalCapability", "body", o.TerminalCapability, 5, false); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyPointOfSaleInformation) validateTerminalCardCaptureCapability(formats strfmt.Registry) error {
	if swag.IsZero(o.TerminalCardCaptureCapability) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"pointOfSaleInformation"+"."+"terminalCardCaptureCapability", "body", o.TerminalCardCaptureCapability, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyPointOfSaleInformation) validateTerminalCompliance(formats strfmt.Registry) error {
	if swag.IsZero(o.TerminalCompliance) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"pointOfSaleInformation"+"."+"terminalCompliance", "body", o.TerminalCompliance, 2); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyPointOfSaleInformation) validateTerminalID(formats strfmt.Registry) error {
	if swag.IsZero(o.TerminalID) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"pointOfSaleInformation"+"."+"terminalId", "body", o.TerminalID, 8); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyPointOfSaleInformation) validateTerminalMake(formats strfmt.Registry) error {
	if swag.IsZero(o.TerminalMake) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"pointOfSaleInformation"+"."+"terminalMake", "body", o.TerminalMake, 32); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyPointOfSaleInformation) validateTerminalModel(formats strfmt.Registry) error {
	if swag.IsZero(o.TerminalModel) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"pointOfSaleInformation"+"."+"terminalModel", "body", o.TerminalModel, 32); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyPointOfSaleInformation) validateTerminalOutputCapability(formats strfmt.Registry) error {
	if swag.IsZero(o.TerminalOutputCapability) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"pointOfSaleInformation"+"."+"terminalOutputCapability", "body", o.TerminalOutputCapability, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyPointOfSaleInformation) validateTerminalSerialNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.TerminalSerialNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"pointOfSaleInformation"+"."+"terminalSerialNumber", "body", o.TerminalSerialNumber, 32); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this create credit params body point of sale information based on the context it is used
func (o *CreateCreditParamsBodyPointOfSaleInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateEmv(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyPointOfSaleInformation) contextValidateEmv(ctx context.Context, formats strfmt.Registry) error {

	if o.Emv != nil {
		if err := o.Emv.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "pointOfSaleInformation" + "." + "emv")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "pointOfSaleInformation" + "." + "emv")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditParamsBodyPointOfSaleInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditParamsBodyPointOfSaleInformation) UnmarshalBinary(b []byte) error {
	var res CreateCreditParamsBodyPointOfSaleInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditParamsBodyPointOfSaleInformationEmv create credit params body point of sale information emv
swagger:model CreateCreditParamsBodyPointOfSaleInformationEmv
*/
type CreateCreditParamsBodyPointOfSaleInformationEmv struct {

	// Number assigned to a specific card when two or more cards are associated with the same primary account number.
	// This value enables issuers to distinguish among multiple cards that are linked to the same account. This value
	// can also act as a tracking tool when reissuing cards. When this value is available, it is provided by the chip
	// reader. When the chip reader does not provide this value, do not include this field in your request.
	//
	// **Note** Card present information about EMV applies only to credit card processing and PIN debit processing.
	// All other card present information applies only to credit card processing. PIN debit processing is
	// available only on CyberSource through VisaNet and FDC Nashville Global.
	//
	// #### Used by
	// Authorization: Optional
	// PIN Debit processing: Optional
	//
	// #### GPX
	//
	// This field only supports transactions from the following card types:
	// - Visa
	// - Mastercard
	// - AMEX
	// - Discover
	// - Diners
	// - JCB
	// - Union Pay International
	//
	// Max Length: 3
	CardSequenceNumber string `json:"cardSequenceNumber,omitempty"`

	// Method that was used to verify the cardholder's identity.
	//
	// Possible values:
	//  - `0`: No verification
	//  - `1`: Signature
	//
	// This field is supported only on **American Express Direct**.
	//
	CardholderVerificationMethodUsed int64 `json:"cardholderVerificationMethodUsed,omitempty"`

	// Indicates whether a fallback method was used to enter credit card information into the POS terminal. When a
	// technical problem prevents a successful exchange of information between a chip card and a chip-capable terminal:
	//
	//  1. Swipe the card or key the credit card information into the POS terminal.
	//  2. Use the pointOfSaleInformation.entryMode field to indicate whether the information was swiped or keyed.
	//
	//
	// Possible values:
	// - `true`: Fallback method was used.
	// - `false` (default): Fallback method was not used.
	//
	// This field is supported only on American Express Direct, Chase Paymentech Solutions, CyberSource through VisaNet,
	// FDC Nashville Global, GPN, JCN Gateway, OmniPay Direct, and SIX.
	//
	Fallback *bool `json:"fallback,omitempty"`

	// Reason for the EMV fallback transaction. An EMV fallback transaction occurs when an EMV transaction fails for
	// one of these reasons:
	//
	//  - Technical failure: the EMV terminal or EMV card cannot read and process chip data.
	//  - Empty candidate list failure: the EMV terminal does not have any applications in common with the EMV card.
	//    EMV terminals are coded to determine whether the terminal and EMV card have any applications in common.
	//    EMV terminals provide this information to you.
	//
	// Possible values:
	//
	//  - `1`: Transaction was initiated with information from a magnetic stripe, and the previous transaction at the
	//       EMV terminal either used information from a successful chip read or it was not a chip transaction.
	//  - `2`: Transaction was initiated with information from a magnetic stripe, and the previous transaction at the
	//       EMV terminal was an EMV fallback transaction because the attempted chip read was unsuccessful.
	//
	// This field is supported only on **GPN** and **JCN Gateway**.
	//
	// **NOTE**: This field is required when an EMV transaction fails for a technical reason. Do not include this field
	//  when the EMV terminal does not have any applications in common with the EMV card.
	//
	FallbackCondition int64 `json:"fallbackCondition,omitempty"`

	// EMV data that is transmitted from the chip card to the issuer, and from the issuer to the chip card. The EMV
	// data is in the tag-length-value format and includes chip card tags, terminal tags, and transaction detail tags.
	//
	// For information about the individual tags, see the Application Specification section in the EMV 4.3 Specifications: http://emvco.com
	//
	// **Note** Card present information about EMV applies only to credit card processing and PIN debit processing.
	// All other card present information applies only to credit card processing. PIN debit processing is available only
	// on FDC Nashville Global.
	//
	// **Important** The following tags contain sensitive information and **must not** be included in this field:
	//
	//  - `56`: Track 1 equivalent data
	//  - `57`: Track 2 equivalent data
	//  - `5A`: Application PAN
	//  - `5F20`: Cardholder name
	//  - `5F24`: Application expiration date (This sensitivity has been relaxed for Credit Mutuel-CIC, American Express Direct, FDC Nashville Global, First Data Merchant Solutions, and SIX)
	//  - `99`: Transaction PIN
	//  - `9F0B`: Cardholder name (extended)
	//  - `9F1F`: Track 1 discretionary data
	//  - `9F20`: Track 2 discretionary data
	//
	// For captures, this field is required for contact EMV transactions. Otherwise, it is optional.
	//
	// For credits, this field is required for contact EMV stand-alone credits and contactless EMV stand-alone credits.
	// Otherwise, it is optional.
	//
	// **Important** For contact EMV captures, contact EMV stand-alone credits, and contactless EMV stand-alone credits,
	// you must include the following tags in this field. For all other types of EMV transactions, the following tags
	// are optional.
	//
	//  - `95`: Terminal verification results
	//  - `9F10`: Issuer application data
	//  - `9F26`: Application cryptogram
	//
	//
	// #### CyberSource through VisaNet
	// - In Japan: 199 bytes
	// - In other countries: String (252)
	//
	// #### GPX
	// This field only supports transactions from the following card types:
	// - Visa
	// - Mastercard
	// - AMEX
	// - Discover
	// - Diners
	// - JCB
	// - Union Pay International
	//
	// #### JCN Gateway
	// The following tags must be included:
	// - `4F`: Application identifier
	// - `84`: Dedicated file name
	//
	// Data length: 199 bytes
	//
	// #### All other processors:
	// String (999)
	//
	// #### Used by
	// Authorization: Optional
	// Authorization Reversal: Optional
	// Credit: Optional
	// PIN Debit processing (purchase, credit and reversal): Optional
	//
	// Max Length: 1998
	Tags string `json:"tags,omitempty"`
}

// Validate validates this create credit params body point of sale information emv
func (o *CreateCreditParamsBodyPointOfSaleInformationEmv) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCardSequenceNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTags(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyPointOfSaleInformationEmv) validateCardSequenceNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.CardSequenceNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"pointOfSaleInformation"+"."+"emv"+"."+"cardSequenceNumber", "body", o.CardSequenceNumber, 3); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyPointOfSaleInformationEmv) validateTags(formats strfmt.Registry) error {
	if swag.IsZero(o.Tags) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"pointOfSaleInformation"+"."+"emv"+"."+"tags", "body", o.Tags, 1998); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create credit params body point of sale information emv based on context it is used
func (o *CreateCreditParamsBodyPointOfSaleInformationEmv) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditParamsBodyPointOfSaleInformationEmv) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditParamsBodyPointOfSaleInformationEmv) UnmarshalBinary(b []byte) error {
	var res CreateCreditParamsBodyPointOfSaleInformationEmv
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditParamsBodyProcessingInformation create credit params body processing information
swagger:model CreateCreditParamsBodyProcessingInformation
*/
type CreateCreditParamsBodyProcessingInformation struct {

	// bank transfer options
	BankTransferOptions *CreateCreditParamsBodyProcessingInformationBankTransferOptions `json:"bankTransferOptions,omitempty"`

	// Type of transaction. Some payment card companies use this information when determining discount rates.
	//
	// #### Used by
	// **Authorization**
	// Required payer authentication transactions; otherwise, optional.
	// **Credit**
	// Required for standalone credits on Chase Paymentech solutions; otherwise, optional.
	//
	// The list of valid values in this field depends on your processor.
	// See Appendix I, "Commerce Indicators," on page 441 of the Cybersource Credit Card Guide.
	//
	// #### Ingenico ePayments
	// When you omit this field for Ingenico ePayments, the processor uses the default transaction type they have on file for you
	// instead of the default value (listed in Appendix I, "Commerce Indicators," on page 441.)
	//
	// #### Payer Authentication Transactions
	// For the possible values and requirements, see "Payer Authentication," page 195.
	//
	// #### Card Present
	// You must set this field to `retail`. This field is required for a card-present transaction. Note that this should ONLY be
	// used when the cardholder and card are present at the time of the transaction.
	// For all keyed transactions originated from a POS terminal where the cardholder and card are not present, commerceIndicator
	// should be submitted as moto"
	//
	// Max Length: 20
	CommerceIndicator string `json:"commerceIndicator,omitempty"`

	// electronic benefits transfer
	ElectronicBenefitsTransfer *CreateCreditParamsBodyProcessingInformationElectronicBenefitsTransfer `json:"electronicBenefitsTransfer,omitempty"`

	// Indicates that the transaction includes industry-specific data.
	//
	// Possible Values:
	// - `airline`
	// - `restaurant`
	// - `lodging`
	// - `auto_rental`
	// - `transit`
	// - `healthcare_medical`
	// - `healthcare_transit`
	// - `transit`
	//
	// #### Card Present, Airlines and Auto Rental
	// You must set this field to `airline` in order for airline data to be sent to the processor. For example, if this
	// field is not set to `airline` or is not included in the request, no airline data is sent to the processor.
	//
	// You must set this field to `restaurant` in order for restaurant data to be sent to the processor. When this field
	// is not set to `restaurant` or is not included in the request, no restaurant data is sent to the processor.
	//
	// You must set this field to `auto_rental` in order for auto rental data to be sent to the processor. For example, if this
	// field is not set to `auto_rental` or is not included in the request, no auto rental data is sent to the processor.
	//
	// Restaurant data is supported only on CyberSource through VisaNet.
	//
	// Max Length: 20
	IndustryDataType string `json:"industryDataType,omitempty"`

	// japan payment options
	JapanPaymentOptions *CreateCreditParamsBodyProcessingInformationJapanPaymentOptions `json:"japanPaymentOptions,omitempty"`

	// Value that links the current authorization request to the original authorization request. Set this value
	// to the ID that was returned in the reply message from the original authorization request.
	//
	// This value is used for:
	//
	// - Partial authorizations
	// - Split shipments
	//
	// For details, see `link_to_request` field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// Max Length: 26
	LinkID string `json:"linkId,omitempty"`

	// loan options
	LoanOptions *CreateCreditParamsBodyProcessingInformationLoanOptions `json:"loanOptions,omitempty"`

	// Supplementary domestic transaction information provided by the acquirer for National Net Settlement Service (NNSS) transactions. NNSS is a settlement service that Visa provides.
	// For transactions on CyberSource through VisaNet in countries that subscribe to NNSS:
	// VisaNet clears transactions; VisaNet transfers funds to the acquirer after deducting processing fees and interchange fees.
	// VisaNet settles transactions in the local pricing currency through a local financial institution.
	// This field is supported only on CyberSource through VisaNet for domestic data in Colombia
	//
	// Max Length: 123
	NationalNetDomesticData string `json:"nationalNetDomesticData,omitempty"`

	// On PIN Debit Gateways: This U.S.-only field is optionally used by  participants (merchants and acquirers) to specify the network access priority.
	// VisaNet checks to determine if there are issuer routing preferences for any of the networks specified by the sharing group code.
	// If an issuer preference exists for one of the specified debit networks, VisaNet makes a routing selection based on the issuers preference.
	// If an issuer preference exists for more than one of the specified debit networks, or if no issuer preference exists,
	// VisaNet makes a selection based on the acquirers routing priorities.
	//
	// #### PIN debit
	// Priority order of the networks through which he transaction will be routed. Set this value to a series of one-character network codes in your preferred order. This is a list of the network codes:
	//
	// | Network | Code |
	// | --- | --- |
	// | Accel | E |
	// | AFFN | U |
	// | Alaska Option | 3 |
	// | CU24 | C |
	// | Interlink | G |
	// | Maestro | 8 |
	// | NETS | P |
	// | NYCE | F |
	// | Pulse | H |
	// | Shazam | 7 |
	// | Star | M |
	// | Visa | V |
	//
	// For example, if the Star network is your first preference and Pulse is your second preference, set this field to a value of `MH`.
	//
	// When you do not include this value in your PIN debit request, the list of network codes from your account is used.
	// **Note** This field is supported only for businesses located in the U.S.
	//
	// Optional field for PIN debit credit or PIN debit purchase.
	//
	// Max Length: 30
	NetworkRoutingOrder string `json:"networkRoutingOrder,omitempty"`

	// Type of digital payment solution for the transaction. Possible Values:
	//
	//  - `visacheckout`: Visa Checkout. This value is required for Visa Checkout transactions. For details, see `payment_solution` field description in [Visa Checkout Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/VCO_SCMP_API/html/)
	//  - `001`: Apple Pay.
	//  - `004`: Cybersource In-App Solution.
	//  - `005`: Masterpass. This value is required for Masterpass transactions on OmniPay Direct. For details, see "Masterpass" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//  - `006`: Android Pay.
	//  - `007`: Chase Pay.
	//  - `008`: Samsung Pay.
	//  - `012`: Google Pay.
	//  - `013`: Cybersource P2PE Decryption
	//  - `014`: Mastercard credential on file (COF) payment network token. Returned in authorizations that use a payment network token associated with a TMS token.
	//  - `015`: Visa credential on file (COF) payment network token. Returned in authorizations that use a payment network token associated with a TMS token.
	//  - `027`: Click to Pay.
	//
	// Max Length: 12
	PaymentSolution string `json:"paymentSolution,omitempty"`

	// Value that identifies the processor/acquirer to use for the transaction. This value is supported only for
	// **CyberSource through VisaNet**.
	//
	// Contact CyberSource Customer Support to get the value for this field.
	//
	// Max Length: 3
	ProcessorID string `json:"processorId,omitempty"`

	// Set this field to 3 to indicate that the request includes Level III data.
	// Max Length: 1
	PurchaseLevel string `json:"purchaseLevel,omitempty"`

	// purchase options
	PurchaseOptions *CreateCreditParamsBodyProcessingInformationPurchaseOptions `json:"purchaseOptions,omitempty"`

	// Please check with Cybersource customer support to see if your merchant account is configured correctly so you
	// can include this field in your request.
	// * For Payouts: max length for FDCCompass is String (22).
	//
	// Max Length: 60
	ReconciliationID string `json:"reconciliationId,omitempty"`

	// recurring options
	RecurringOptions *CreateCreditParamsBodyProcessingInformationRecurringOptions `json:"recurringOptions,omitempty"`

	// Attribute that lets you define custom grouping for your processor reports. This field is supported only for **Worldpay VAP**.
	//
	// For details, see `report_group` field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// Max Length: 25
	ReportGroup string `json:"reportGroup,omitempty"`

	// Identifier for the **Visa Checkout** order. Visa Checkout provides a unique order ID for every transaction in
	// the Visa Checkout **callID** field.
	//
	// Max Length: 48
	VisaCheckoutID string `json:"visaCheckoutId,omitempty"`

	// This field carries the wallet type in authorization requests and credit requests. Possible value are:
	// - `101`: Masterpass remote payment. The customer created the wallet by manually interacting with a customer-controlled device such as a computer, tablet, or phone. This value is supported only for Masterpass transactions on Chase Paymentech Solutions and CyberSource through VisaNet.
	// - `102`: Masterpass remote near field communication (NFC) payment. The customer created the wallet by tapping a PayPass card or customer-controlled device at a contactless card reader. This value is supported only for card-present Masterpass transactions on CyberSource through VisaNet.
	// - `103`: Masterpass Apple Pay payment. The payment was made with a combination of Masterpass and Apple Pay. This value is supported only for Masterpass Apple Pay transactions on CyberSource through VisaNet.
	// - `216`: Masterpass Google Pay payment. The payment was made with a combination of Masterpass and Google Pay. This value is supported only for Masterpass Google Pay transactions on CyberSource through VisaNet.
	// - `217`: Masterpass Samsung Pay payment. The payment was made with a combination of Masterpass and Samsung Pay. This value is supported only for Masterpass Samsung Pay transactions on CyberSource through VisaNet.
	// - `SDW`: Staged digital wallet. An issuer or operator created the wallet. This value is supported only for Masterpass transactions on Chase Paymentech Solutions.
	// - `VCIND`: Visa Checkout payment. This value is supported only on CyberSource through VisaNet, FDC Compass, FDC Nashville Global, FDI Australia, and TSYS Acquiring Solutions. See Getting Started with Visa Checkout. For Visa Checkout transactions, the way CyberSource processes the value for this field depends on the processor. See the Visa Checkout section below.
	// For all other values, this field is a passthrough; therefore, CyberSource does not verify the value or modify it in any way before sending it to the processor.
	// Masterpass (101, 102, 103, 216, and 217): The Masterpass platform generates the wallet type value and passes it to you along with the customers checkout information.
	//
	// Visa Checkout:
	// This field is optional for Visa Checkout authorizations on FDI Australia. For all other processors, this field is required for Visa Checkout authorizations.
	// For Visa Checkout transactions on the following processors, CyberSource sends the value that the processor expects for this field:FDC Compass,FDC Nashville Global,FDI Australia,TSYS Acquiring
	// Solutions For all other processors, this field is a passthrough; therefore, CyberSource does not verify the value or modify it in any way before sending it to the processor.
	// For incremental authorizations, this field is supported only for Mastercard and the supported values are 101 and 102.
	// Payment card companies can introduce new values without notice. Your order management system should be able to process new values without problems.
	//
	// CyberSource through VisaNet
	// When the value for this field is 101, 102, 103, 216, or 217, it corresponds to the following data in the TC 33 capture file5: Record: CP01 TCR6, Position: 88-90,  Field: Mastercard Wallet Identifier.
	// When the value for this field is VCIND, it corresponds to the following data in the TC 33 capture file5: Record: CP01 TCR8, Position: 72-76, Field: Agent Unique ID.
	//
	// Max Length: 5
	WalletType string `json:"walletType,omitempty"`
}

// Validate validates this create credit params body processing information
func (o *CreateCreditParamsBodyProcessingInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateBankTransferOptions(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCommerceIndicator(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateElectronicBenefitsTransfer(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateIndustryDataType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateJapanPaymentOptions(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLinkID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLoanOptions(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNationalNetDomesticData(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNetworkRoutingOrder(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePaymentSolution(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProcessorID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePurchaseLevel(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePurchaseOptions(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateReconciliationID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRecurringOptions(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateReportGroup(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateVisaCheckoutID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateWalletType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyProcessingInformation) validateBankTransferOptions(formats strfmt.Registry) error {
	if swag.IsZero(o.BankTransferOptions) { // not required
		return nil
	}

	if o.BankTransferOptions != nil {
		if err := o.BankTransferOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "processingInformation" + "." + "bankTransferOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "processingInformation" + "." + "bankTransferOptions")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditParamsBodyProcessingInformation) validateCommerceIndicator(formats strfmt.Registry) error {
	if swag.IsZero(o.CommerceIndicator) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"processingInformation"+"."+"commerceIndicator", "body", o.CommerceIndicator, 20); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyProcessingInformation) validateElectronicBenefitsTransfer(formats strfmt.Registry) error {
	if swag.IsZero(o.ElectronicBenefitsTransfer) { // not required
		return nil
	}

	if o.ElectronicBenefitsTransfer != nil {
		if err := o.ElectronicBenefitsTransfer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "processingInformation" + "." + "electronicBenefitsTransfer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "processingInformation" + "." + "electronicBenefitsTransfer")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditParamsBodyProcessingInformation) validateIndustryDataType(formats strfmt.Registry) error {
	if swag.IsZero(o.IndustryDataType) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"processingInformation"+"."+"industryDataType", "body", o.IndustryDataType, 20); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyProcessingInformation) validateJapanPaymentOptions(formats strfmt.Registry) error {
	if swag.IsZero(o.JapanPaymentOptions) { // not required
		return nil
	}

	if o.JapanPaymentOptions != nil {
		if err := o.JapanPaymentOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "processingInformation" + "." + "japanPaymentOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "processingInformation" + "." + "japanPaymentOptions")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditParamsBodyProcessingInformation) validateLinkID(formats strfmt.Registry) error {
	if swag.IsZero(o.LinkID) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"processingInformation"+"."+"linkId", "body", o.LinkID, 26); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyProcessingInformation) validateLoanOptions(formats strfmt.Registry) error {
	if swag.IsZero(o.LoanOptions) { // not required
		return nil
	}

	if o.LoanOptions != nil {
		if err := o.LoanOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "processingInformation" + "." + "loanOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "processingInformation" + "." + "loanOptions")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditParamsBodyProcessingInformation) validateNationalNetDomesticData(formats strfmt.Registry) error {
	if swag.IsZero(o.NationalNetDomesticData) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"processingInformation"+"."+"nationalNetDomesticData", "body", o.NationalNetDomesticData, 123); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyProcessingInformation) validateNetworkRoutingOrder(formats strfmt.Registry) error {
	if swag.IsZero(o.NetworkRoutingOrder) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"processingInformation"+"."+"networkRoutingOrder", "body", o.NetworkRoutingOrder, 30); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyProcessingInformation) validatePaymentSolution(formats strfmt.Registry) error {
	if swag.IsZero(o.PaymentSolution) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"processingInformation"+"."+"paymentSolution", "body", o.PaymentSolution, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyProcessingInformation) validateProcessorID(formats strfmt.Registry) error {
	if swag.IsZero(o.ProcessorID) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"processingInformation"+"."+"processorId", "body", o.ProcessorID, 3); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyProcessingInformation) validatePurchaseLevel(formats strfmt.Registry) error {
	if swag.IsZero(o.PurchaseLevel) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"processingInformation"+"."+"purchaseLevel", "body", o.PurchaseLevel, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyProcessingInformation) validatePurchaseOptions(formats strfmt.Registry) error {
	if swag.IsZero(o.PurchaseOptions) { // not required
		return nil
	}

	if o.PurchaseOptions != nil {
		if err := o.PurchaseOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "processingInformation" + "." + "purchaseOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "processingInformation" + "." + "purchaseOptions")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditParamsBodyProcessingInformation) validateReconciliationID(formats strfmt.Registry) error {
	if swag.IsZero(o.ReconciliationID) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"processingInformation"+"."+"reconciliationId", "body", o.ReconciliationID, 60); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyProcessingInformation) validateRecurringOptions(formats strfmt.Registry) error {
	if swag.IsZero(o.RecurringOptions) { // not required
		return nil
	}

	if o.RecurringOptions != nil {
		if err := o.RecurringOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "processingInformation" + "." + "recurringOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "processingInformation" + "." + "recurringOptions")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditParamsBodyProcessingInformation) validateReportGroup(formats strfmt.Registry) error {
	if swag.IsZero(o.ReportGroup) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"processingInformation"+"."+"reportGroup", "body", o.ReportGroup, 25); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyProcessingInformation) validateVisaCheckoutID(formats strfmt.Registry) error {
	if swag.IsZero(o.VisaCheckoutID) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"processingInformation"+"."+"visaCheckoutId", "body", o.VisaCheckoutID, 48); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyProcessingInformation) validateWalletType(formats strfmt.Registry) error {
	if swag.IsZero(o.WalletType) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"processingInformation"+"."+"walletType", "body", o.WalletType, 5); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this create credit params body processing information based on the context it is used
func (o *CreateCreditParamsBodyProcessingInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateBankTransferOptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateElectronicBenefitsTransfer(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateJapanPaymentOptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateLoanOptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidatePurchaseOptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateRecurringOptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyProcessingInformation) contextValidateBankTransferOptions(ctx context.Context, formats strfmt.Registry) error {

	if o.BankTransferOptions != nil {
		if err := o.BankTransferOptions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "processingInformation" + "." + "bankTransferOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "processingInformation" + "." + "bankTransferOptions")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditParamsBodyProcessingInformation) contextValidateElectronicBenefitsTransfer(ctx context.Context, formats strfmt.Registry) error {

	if o.ElectronicBenefitsTransfer != nil {
		if err := o.ElectronicBenefitsTransfer.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "processingInformation" + "." + "electronicBenefitsTransfer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "processingInformation" + "." + "electronicBenefitsTransfer")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditParamsBodyProcessingInformation) contextValidateJapanPaymentOptions(ctx context.Context, formats strfmt.Registry) error {

	if o.JapanPaymentOptions != nil {
		if err := o.JapanPaymentOptions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "processingInformation" + "." + "japanPaymentOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "processingInformation" + "." + "japanPaymentOptions")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditParamsBodyProcessingInformation) contextValidateLoanOptions(ctx context.Context, formats strfmt.Registry) error {

	if o.LoanOptions != nil {
		if err := o.LoanOptions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "processingInformation" + "." + "loanOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "processingInformation" + "." + "loanOptions")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditParamsBodyProcessingInformation) contextValidatePurchaseOptions(ctx context.Context, formats strfmt.Registry) error {

	if o.PurchaseOptions != nil {
		if err := o.PurchaseOptions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "processingInformation" + "." + "purchaseOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "processingInformation" + "." + "purchaseOptions")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditParamsBodyProcessingInformation) contextValidateRecurringOptions(ctx context.Context, formats strfmt.Registry) error {

	if o.RecurringOptions != nil {
		if err := o.RecurringOptions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "processingInformation" + "." + "recurringOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "processingInformation" + "." + "recurringOptions")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditParamsBodyProcessingInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditParamsBodyProcessingInformation) UnmarshalBinary(b []byte) error {
	var res CreateCreditParamsBodyProcessingInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditParamsBodyProcessingInformationBankTransferOptions create credit params body processing information bank transfer options
swagger:model CreateCreditParamsBodyProcessingInformationBankTransferOptions
*/
type CreateCreditParamsBodyProcessingInformationBankTransferOptions struct {

	// Payment related information.
	//
	// This information is included on the customers statement.
	//
	// Max Length: 80
	CustomerMemo string `json:"customerMemo,omitempty"`

	// Effective date for the transaction. The effective date must be within 45 days of the current day. If you do not
	// include this value, CyberSource sets the effective date to the next business day.
	//
	// Format: `MMDDYYYY`
	//
	// Supported only for the CyberSource ACH Service.
	//
	// Max Length: 8
	EffectiveDate string `json:"effectiveDate,omitempty"`

	// Identifier for a partial payment or partial credit.
	//
	// The value for each debit request or credit request must be unique within the scope of the order.
	// For details, see `partial_payment_id` field description in the [Electronic Check Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/EChecks_SCMP_API/html/)
	//
	// Max Length: 25
	PartialPaymentID string `json:"partialPaymentId,omitempty"`

	// Specifies the authorization method for the transaction.
	//
	// #### TeleCheck
	// Accepts only the following values:
	// - `ARC`: account receivable conversion
	// - `CCD`: corporate cash disbursement
	// - `POP`: point of purchase conversion
	// - `PPD`: prearranged payment and deposit entry
	// - `TEL`: telephone-initiated entry
	// - `WEB`: internet-initiated entry
	//
	// For details, see `ecp_sec_code` field description in the [Electronic Check Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/EChecks_SCMP_API/html/)
	//
	// Max Length: 3
	SecCode string `json:"secCode,omitempty"`

	// Method used for settlement.
	//
	// Possible values:
	// - `A`: Automated Clearing House (default for credits and for transactions using Canadian dollars)
	// - `F`: Facsimile draft (U.S. dollars only)
	// - `B`: Best possible (U.S. dollars only) (default if the field has not already been configured for your
	// merchant ID)
	//
	// For details, see `ecp_settlement_method` field description for credit cars and `ecp_debit_settlement_method` for debit cards in the [Electronic Check Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/EChecks_SCMP_API/html/)
	//
	// Max Length: 1
	SettlementMethod string `json:"settlementMethod,omitempty"`

	// City in which the terminal is located. If more than four alphanumeric characters are submitted, the transaction
	// will be declined.
	//
	// You cannot include any special characters.
	//
	// Max Length: 4
	TerminalCity string `json:"terminalCity,omitempty"`

	// State in which the terminal is located. If more than two alphanumeric characters are submitted, the transaction
	// will be declined.
	//
	// You cannot include any special characters.
	//
	// Max Length: 2
	TerminalState string `json:"terminalState,omitempty"`
}

// Validate validates this create credit params body processing information bank transfer options
func (o *CreateCreditParamsBodyProcessingInformationBankTransferOptions) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCustomerMemo(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEffectiveDate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePartialPaymentID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSecCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSettlementMethod(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTerminalCity(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTerminalState(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyProcessingInformationBankTransferOptions) validateCustomerMemo(formats strfmt.Registry) error {
	if swag.IsZero(o.CustomerMemo) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"processingInformation"+"."+"bankTransferOptions"+"."+"customerMemo", "body", o.CustomerMemo, 80); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyProcessingInformationBankTransferOptions) validateEffectiveDate(formats strfmt.Registry) error {
	if swag.IsZero(o.EffectiveDate) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"processingInformation"+"."+"bankTransferOptions"+"."+"effectiveDate", "body", o.EffectiveDate, 8); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyProcessingInformationBankTransferOptions) validatePartialPaymentID(formats strfmt.Registry) error {
	if swag.IsZero(o.PartialPaymentID) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"processingInformation"+"."+"bankTransferOptions"+"."+"partialPaymentId", "body", o.PartialPaymentID, 25); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyProcessingInformationBankTransferOptions) validateSecCode(formats strfmt.Registry) error {
	if swag.IsZero(o.SecCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"processingInformation"+"."+"bankTransferOptions"+"."+"secCode", "body", o.SecCode, 3); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyProcessingInformationBankTransferOptions) validateSettlementMethod(formats strfmt.Registry) error {
	if swag.IsZero(o.SettlementMethod) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"processingInformation"+"."+"bankTransferOptions"+"."+"settlementMethod", "body", o.SettlementMethod, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyProcessingInformationBankTransferOptions) validateTerminalCity(formats strfmt.Registry) error {
	if swag.IsZero(o.TerminalCity) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"processingInformation"+"."+"bankTransferOptions"+"."+"terminalCity", "body", o.TerminalCity, 4); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyProcessingInformationBankTransferOptions) validateTerminalState(formats strfmt.Registry) error {
	if swag.IsZero(o.TerminalState) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"processingInformation"+"."+"bankTransferOptions"+"."+"terminalState", "body", o.TerminalState, 2); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create credit params body processing information bank transfer options based on context it is used
func (o *CreateCreditParamsBodyProcessingInformationBankTransferOptions) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditParamsBodyProcessingInformationBankTransferOptions) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditParamsBodyProcessingInformationBankTransferOptions) UnmarshalBinary(b []byte) error {
	var res CreateCreditParamsBodyProcessingInformationBankTransferOptions
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditParamsBodyProcessingInformationElectronicBenefitsTransfer create credit params body processing information electronic benefits transfer
swagger:model CreateCreditParamsBodyProcessingInformationElectronicBenefitsTransfer
*/
type CreateCreditParamsBodyProcessingInformationElectronicBenefitsTransfer struct {

	// Flag that specifies the category for the EBT transaction.
	//
	// Possible values:
	// - `CASH`: Cash benefits, which can be used to purchase any item at a participating retailer, as well as to obtain cash-back or make a cash withdrawal from a participating ATM.
	// - `FOOD`: Food stamp benefits, which can be used only to purchase food items authorized by the USDA SNAP program.
	//
	// #### PIN debit
	// Required field for EBT transactions that use PIN debit credit or PIN debit purchase; otherwise, not used.
	//
	// Max Length: 4
	Category string `json:"category,omitempty"`
}

// Validate validates this create credit params body processing information electronic benefits transfer
func (o *CreateCreditParamsBodyProcessingInformationElectronicBenefitsTransfer) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCategory(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyProcessingInformationElectronicBenefitsTransfer) validateCategory(formats strfmt.Registry) error {
	if swag.IsZero(o.Category) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"processingInformation"+"."+"electronicBenefitsTransfer"+"."+"category", "body", o.Category, 4); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create credit params body processing information electronic benefits transfer based on context it is used
func (o *CreateCreditParamsBodyProcessingInformationElectronicBenefitsTransfer) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditParamsBodyProcessingInformationElectronicBenefitsTransfer) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditParamsBodyProcessingInformationElectronicBenefitsTransfer) UnmarshalBinary(b []byte) error {
	var res CreateCreditParamsBodyProcessingInformationElectronicBenefitsTransfer
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditParamsBodyProcessingInformationJapanPaymentOptions create credit params body processing information japan payment options
swagger:model CreateCreditParamsBodyProcessingInformationJapanPaymentOptions
*/
type CreateCreditParamsBodyProcessingInformationJapanPaymentOptions struct {

	// Number of Installments.
	//
	Installments string `json:"installments,omitempty"`

	// This value is a 2-digit code indicating the payment method.
	// Use Payment Method Code value that applies to the tranasction.
	// - 10 (One-time payment)
	// - 21, 22, 23, 24  (Bonus(one-time)payment)
	// - 61 (Installment payment)
	// - 31, 32, 33, 34  (Integrated (Bonus + Installment)payment)
	// - 80 (Revolving payment)
	//
	// Max Length: 2
	PaymentMethod string `json:"paymentMethod,omitempty"`
}

// Validate validates this create credit params body processing information japan payment options
func (o *CreateCreditParamsBodyProcessingInformationJapanPaymentOptions) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validatePaymentMethod(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyProcessingInformationJapanPaymentOptions) validatePaymentMethod(formats strfmt.Registry) error {
	if swag.IsZero(o.PaymentMethod) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"processingInformation"+"."+"japanPaymentOptions"+"."+"paymentMethod", "body", o.PaymentMethod, 2); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create credit params body processing information japan payment options based on context it is used
func (o *CreateCreditParamsBodyProcessingInformationJapanPaymentOptions) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditParamsBodyProcessingInformationJapanPaymentOptions) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditParamsBodyProcessingInformationJapanPaymentOptions) UnmarshalBinary(b []byte) error {
	var res CreateCreditParamsBodyProcessingInformationJapanPaymentOptions
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditParamsBodyProcessingInformationLoanOptions create credit params body processing information loan options
swagger:model CreateCreditParamsBodyProcessingInformationLoanOptions
*/
type CreateCreditParamsBodyProcessingInformationLoanOptions struct {

	// Indicates whether a loan is for a recoverable item or a non-recoverable item.
	// Possible values:
	// - `N`: non-recoverable item
	// - `R`: recoverable item
	// This field is supported only for BNDES transactions on CyberSource through VisaNet.
	// The value for this field corresponds to the following data in the TC 33 capture file5:
	//  Record: CP07 TCR2, Position: 26, Field: Asset Indicator
	//
	// Max Length: 1
	AssetType string `json:"assetType,omitempty"`

	// Type of loan based on an agreement between you and the issuer.
	// Examples: AGROCUSTEIO, AGRO-INVEST, BNDES-Type1, CBN, FINAME.
	// This field is supported only for these kinds of payments:
	// - BNDES transactions on CyberSource through VisaNet.
	// - Installment payments with Mastercard on CyberSource through VisaNet in Brazil.
	//
	// See ""Installment Payments on CyberSource through VisaNet,"" in the SCMP/SO guide
	//
	// For BNDES transactions, the value for this field corresponds to the following data in the TC 33 capture file:
	// - Record: CP07 TCR2, Position: 27-46, Field: Loan Type
	//
	// For installment payments with Mastercard in Brazil, the value for this field corresponds to the following data in the TC 33 capture file:
	// - Record: CP07 TCR4, Position: 5-24,Field: Financing Type
	//
	// Max Length: 20
	Type string `json:"type,omitempty"`
}

// Validate validates this create credit params body processing information loan options
func (o *CreateCreditParamsBodyProcessingInformationLoanOptions) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAssetType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyProcessingInformationLoanOptions) validateAssetType(formats strfmt.Registry) error {
	if swag.IsZero(o.AssetType) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"processingInformation"+"."+"loanOptions"+"."+"assetType", "body", o.AssetType, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyProcessingInformationLoanOptions) validateType(formats strfmt.Registry) error {
	if swag.IsZero(o.Type) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"processingInformation"+"."+"loanOptions"+"."+"type", "body", o.Type, 20); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create credit params body processing information loan options based on context it is used
func (o *CreateCreditParamsBodyProcessingInformationLoanOptions) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditParamsBodyProcessingInformationLoanOptions) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditParamsBodyProcessingInformationLoanOptions) UnmarshalBinary(b []byte) error {
	var res CreateCreditParamsBodyProcessingInformationLoanOptions
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditParamsBodyProcessingInformationPurchaseOptions create credit params body processing information purchase options
swagger:model CreateCreditParamsBodyProcessingInformationPurchaseOptions
*/
type CreateCreditParamsBodyProcessingInformationPurchaseOptions struct {

	// Flag that indicates whether this transaction is an EBT transaction. Possible values:
	// - `true`
	// - `false`
	//
	// #### PIN debit
	// Required field for EBT and EBT voucher transactions that use PIN debit credit or PIN debit purchase; otherwise, not used.
	//
	IsElectronicBenefitsTransfer bool `json:"isElectronicBenefitsTransfer,omitempty"`
}

// Validate validates this create credit params body processing information purchase options
func (o *CreateCreditParamsBodyProcessingInformationPurchaseOptions) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this create credit params body processing information purchase options based on context it is used
func (o *CreateCreditParamsBodyProcessingInformationPurchaseOptions) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditParamsBodyProcessingInformationPurchaseOptions) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditParamsBodyProcessingInformationPurchaseOptions) UnmarshalBinary(b []byte) error {
	var res CreateCreditParamsBodyProcessingInformationPurchaseOptions
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditParamsBodyProcessingInformationRecurringOptions create credit params body processing information recurring options
swagger:model CreateCreditParamsBodyProcessingInformationRecurringOptions
*/
type CreateCreditParamsBodyProcessingInformationRecurringOptions struct {

	// Flag that indicates whether this is a payment towards an existing contractual loan.
	//
	// Possible values:
	// - `true`: Loan payment
	// - `false`: (default) Not a loan payment
	//
	// For processor-specific details, see `debt_indicator` field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	LoanPayment *bool `json:"loanPayment,omitempty"`
}

// Validate validates this create credit params body processing information recurring options
func (o *CreateCreditParamsBodyProcessingInformationRecurringOptions) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this create credit params body processing information recurring options based on context it is used
func (o *CreateCreditParamsBodyProcessingInformationRecurringOptions) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditParamsBodyProcessingInformationRecurringOptions) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditParamsBodyProcessingInformationRecurringOptions) UnmarshalBinary(b []byte) error {
	var res CreateCreditParamsBodyProcessingInformationRecurringOptions
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditParamsBodyPromotionInformation create credit params body promotion information
swagger:model CreateCreditParamsBodyPromotionInformation
*/
type CreateCreditParamsBodyPromotionInformation struct {

	// Additional rental agency marketed coupons for consumers to discount the rate of the vehicle rental agreement.
	//
	// Max Length: 12
	AdditionalCode string `json:"additionalCode,omitempty"`

	// Code for a promotion or discount.
	//
	// Max Length: 12
	Code string `json:"code,omitempty"`
}

// Validate validates this create credit params body promotion information
func (o *CreateCreditParamsBodyPromotionInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAdditionalCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyPromotionInformation) validateAdditionalCode(formats strfmt.Registry) error {
	if swag.IsZero(o.AdditionalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"promotionInformation"+"."+"additionalCode", "body", o.AdditionalCode, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyPromotionInformation) validateCode(formats strfmt.Registry) error {
	if swag.IsZero(o.Code) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"promotionInformation"+"."+"code", "body", o.Code, 12); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create credit params body promotion information based on context it is used
func (o *CreateCreditParamsBodyPromotionInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditParamsBodyPromotionInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditParamsBodyPromotionInformation) UnmarshalBinary(b []byte) error {
	var res CreateCreditParamsBodyPromotionInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditParamsBodyTravelInformation create credit params body travel information
swagger:model CreateCreditParamsBodyTravelInformation
*/
type CreateCreditParamsBodyTravelInformation struct {

	// agency
	Agency *CreateCreditParamsBodyTravelInformationAgency `json:"agency,omitempty"`

	// auto rental
	AutoRental *CreateCreditParamsBodyTravelInformationAutoRental `json:"autoRental,omitempty"`

	// Duration of the auto rental or lodging rental.
	//
	// #### Auto rental
	// This field is supported for Visa, MasterCard, and American Express.
	// **Important** If this field is not included when the `processingInformation.industryDataType` is auto rental,
	// the transaction is declined.
	//
	// Max Length: 2
	Duration string `json:"duration,omitempty"`

	// lodging
	Lodging *CreateCreditParamsBodyTravelInformationLodging `json:"lodging,omitempty"`

	// transit
	Transit *CreateCreditParamsBodyTravelInformationTransit `json:"transit,omitempty"`
}

// Validate validates this create credit params body travel information
func (o *CreateCreditParamsBodyTravelInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAgency(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAutoRental(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDuration(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLodging(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTransit(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyTravelInformation) validateAgency(formats strfmt.Registry) error {
	if swag.IsZero(o.Agency) { // not required
		return nil
	}

	if o.Agency != nil {
		if err := o.Agency.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "travelInformation" + "." + "agency")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "travelInformation" + "." + "agency")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformation) validateAutoRental(formats strfmt.Registry) error {
	if swag.IsZero(o.AutoRental) { // not required
		return nil
	}

	if o.AutoRental != nil {
		if err := o.AutoRental.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "travelInformation" + "." + "autoRental")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "travelInformation" + "." + "autoRental")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformation) validateDuration(formats strfmt.Registry) error {
	if swag.IsZero(o.Duration) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"duration", "body", o.Duration, 2); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformation) validateLodging(formats strfmt.Registry) error {
	if swag.IsZero(o.Lodging) { // not required
		return nil
	}

	if o.Lodging != nil {
		if err := o.Lodging.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "travelInformation" + "." + "lodging")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "travelInformation" + "." + "lodging")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformation) validateTransit(formats strfmt.Registry) error {
	if swag.IsZero(o.Transit) { // not required
		return nil
	}

	if o.Transit != nil {
		if err := o.Transit.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "travelInformation" + "." + "transit")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "travelInformation" + "." + "transit")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this create credit params body travel information based on the context it is used
func (o *CreateCreditParamsBodyTravelInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateAgency(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateAutoRental(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateLodging(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateTransit(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyTravelInformation) contextValidateAgency(ctx context.Context, formats strfmt.Registry) error {

	if o.Agency != nil {
		if err := o.Agency.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "travelInformation" + "." + "agency")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "travelInformation" + "." + "agency")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformation) contextValidateAutoRental(ctx context.Context, formats strfmt.Registry) error {

	if o.AutoRental != nil {
		if err := o.AutoRental.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "travelInformation" + "." + "autoRental")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "travelInformation" + "." + "autoRental")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformation) contextValidateLodging(ctx context.Context, formats strfmt.Registry) error {

	if o.Lodging != nil {
		if err := o.Lodging.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "travelInformation" + "." + "lodging")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "travelInformation" + "." + "lodging")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformation) contextValidateTransit(ctx context.Context, formats strfmt.Registry) error {

	if o.Transit != nil {
		if err := o.Transit.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "travelInformation" + "." + "transit")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "travelInformation" + "." + "transit")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditParamsBodyTravelInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditParamsBodyTravelInformation) UnmarshalBinary(b []byte) error {
	var res CreateCreditParamsBodyTravelInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditParamsBodyTravelInformationAgency create credit params body travel information agency
swagger:model CreateCreditParamsBodyTravelInformationAgency
*/
type CreateCreditParamsBodyTravelInformationAgency struct {

	// International Air Transport Association (IATA) code of travel agency that made the vehicle rental reservation.
	//
	// Max Length: 8
	Code string `json:"code,omitempty"`

	// Name of travel agency that made the reservation.
	//
	// Max Length: 25
	Name string `json:"name,omitempty"`
}

// Validate validates this create credit params body travel information agency
func (o *CreateCreditParamsBodyTravelInformationAgency) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyTravelInformationAgency) validateCode(formats strfmt.Registry) error {
	if swag.IsZero(o.Code) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"agency"+"."+"code", "body", o.Code, 8); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationAgency) validateName(formats strfmt.Registry) error {
	if swag.IsZero(o.Name) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"agency"+"."+"name", "body", o.Name, 25); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create credit params body travel information agency based on context it is used
func (o *CreateCreditParamsBodyTravelInformationAgency) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditParamsBodyTravelInformationAgency) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditParamsBodyTravelInformationAgency) UnmarshalBinary(b []byte) error {
	var res CreateCreditParamsBodyTravelInformationAgency
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditParamsBodyTravelInformationAutoRental create credit params body travel information auto rental
swagger:model CreateCreditParamsBodyTravelInformationAutoRental
*/
type CreateCreditParamsBodyTravelInformationAutoRental struct {

	// Adjusted Amount indicates whether any miscellaneous charges were incurred after the vehicle was returned.
	//
	// For authorizations, this field is supported only for American Express.
	//
	// For captures, this field is supported only for MasterCard and American Express.
	// **NOTE** For American Express, this field is required if the `travelInformation.autoRental.adjustedAmountIndicator` field
	// is included in the request and has a value; otherwise, this field is optional.
	//
	// For all other card types, this field is ignored.
	//
	// Max Length: 12
	AdjustedAmount string `json:"adjustedAmount,omitempty"`

	// For **MasterCard** and **Discover**:
	// Adjusted amount indicator code that indicates
	// any miscellaneous charges incurred after the
	// auto was returned. Possible values:
	// - `A` - Drop-off charges
	// - `B` - Delivery charges
	// - `C` - Parking expenses
	// - `D` - Extra hours
	// - `E` - Violations
	// - `X` - More than one of the above charges
	//
	// For **American Express**:
	// Audit indicator code that indicates any
	// adjustment for mileage, fuel, auto damage,
	// etc. made to a rental agreement and whether
	// the cardholder was notified.
	//
	// Possible value for the authorization service:
	// - `A` (default): adjustment amount greater than 0 (zero)
	//
	// Possible values for the capture service:
	// - `X` - Multiple adjustments
	// - `Y` - One adjustment only; Cardmember notified
	// - `Z` - One adjustment only; Cardmember not notified. This value is used as the default if the request does not include this field and includes an adjustment amount greater than 0 (zero).
	// This is an optional field.
	//
	// Max Length: 1
	AdjustedAmountIndicator string `json:"adjustedAmountIndicator,omitempty"`

	// Auto rental agencys agreement (invoice) number provided to the customer. It is used to trace any inquiries about transactions.
	// This field is supported for Visa, MasterCard, and American Express.
	// This Merchant-defined value, which may be composed of any combination of characters and/or numerals, may become
	// part of the descriptive bill on the Cardmember's statement.
	//
	// Max Length: 25
	AgreementNumber string `json:"agreementNumber,omitempty"`

	// Commodity code or International description code used to classify the item. Contact your acquirer for a list of
	// codes.
	//
	// Max Length: 15
	CommodityCode string `json:"commodityCode,omitempty"`

	// Corporate Identifier provides the unique identifier of the corporation or entity renting the vehicle:
	//
	// |Card Specific Validation|VISA|MasterCard|Discover|AMEX|
	// |--- |--- |--- |--- |
	// | Filed Length| NA| 12| NA| NA|
	// | Field Type| NA| AN| NA| NA|
	// | M/O/C| NA| O| NA| NA|
	//
	// Max Length: 12
	CompanyID string `json:"companyId,omitempty"`

	// Name of the individual making the rental agreement.
	//
	// Valid data lengths by card:
	//
	// |Card Specific Validation|VISA|MasterCard|Discover|AMEX|
	// |--- |--- |--- |--- |
	// | Filed Length| 40| 40| 29| 26|
	// | Field Type| AN| ANS| AN| AN|
	// | M/O/C| O| M| M| M|
	//
	// Max Length: 40
	CustomerName string `json:"customerName,omitempty"`

	// Customer service telephone number that is used to resolve questions or disputes. Include the area code, exchange, and number.
	// This field is supported only for MasterCard and American Express.
	//
	// Max Length: 17
	CustomerServicePhoneNumber string `json:"customerServicePhoneNumber,omitempty"`

	// Daily auto rental rate charged.
	// This field is supported only for MasterCard and American Express.
	//
	// Field - Time Period needs to be populated with Daily if this field is present
	//
	// Max Length: 12
	DailyRentalRate string `json:"dailyRentalRate,omitempty"`

	// Total number of miles driven by the customer.
	// This field is supported only for MasterCard and American Express.
	//
	// Max Length: 5
	DistanceTravelled string `json:"distanceTravelled,omitempty"`

	// Miles/Kilometers Indicator shows whether the miles fields are expressed in miles or kilometers.
	//
	// Allowed values:
	// - `K` - Kilometers
	// - `M` - Miles
	//
	// Max Length: 1
	DistanceUnit string `json:"distanceUnit,omitempty"`

	// Age of the driver renting the vehicle.
	//
	// Max Length: 3
	DriverAge string `json:"driverAge,omitempty"`

	// (Extra Charges) provides the extra charges associated with the vehicle rental.
	//
	// Max Length: 12
	ExtraCharge string `json:"extraCharge,omitempty"`

	// Extra mileage charges that extend beyond the basic rental agreement.
	// This field is supported only for Visa.
	//
	// Max Length: 12
	ExtraMileageCharge string `json:"extraMileageCharge,omitempty"`

	// Extra gasoline charges that extend beyond the basic rental agreement.
	// This field is supported only for Visa.
	//
	// Max Length: 12
	FuelCharges string `json:"fuelCharges,omitempty"`

	// Amount charged for renting a Global Positioning Service (GPS).
	//
	// Max Length: 12
	GpsCharge string `json:"gpsCharge,omitempty"`

	// Insurance charges.
	// Field is conditional and can include decimal point.
	//
	// Max Length: 12
	InsuranceAmount string `json:"insuranceAmount,omitempty"`

	// Used for MC and Discover
	//
	// Valid values:
	// - `true` - Yes (insurance was purchased)
	// - `false` - No (insurance was not purchased)
	//
	InsuranceIndicator bool `json:"insuranceIndicator,omitempty"`

	// Extra charges related to a late return of the rented auto.
	// This field is supported only for Visa.
	//
	// Max Length: 12
	LateFeeAmount string `json:"lateFeeAmount,omitempty"`

	// Maximum number of free miles or kilometers allowed to a customer for the duration of the auto rental agreement.
	// This field is supported only for MasterCard and American Express.
	//
	// Max Length: 4
	MaxFreeDistance string `json:"maxFreeDistance,omitempty"`

	// Regular Mileage Charge provides the amount charged for regular miles traveled during vehicle rental. Two decimal places
	//
	// Max Length: 12
	MileageCharge string `json:"mileageCharge,omitempty"`

	// No Show Indicator provides an indicator noting that the individual did not show up after making a reservation for a vehicle.
	// Possible values:
	// - true
	// - false
	//
	NoShowIndicator bool `json:"noShowIndicator,omitempty"`

	// The number of additional drivers included on the rental agreement not including the individual who signed the rental agreement.
	//
	// Max Length: 1
	NumberOfAdditionalDrivers string `json:"numberOfAdditionalDrivers,omitempty"`

	// Odometer reading at time of vehicle rental.
	//
	// Max Length: 8
	OdometerReading string `json:"odometerReading,omitempty"`

	// Extra charges incurred for a one-way rental agreement for the auto.
	// This field is supported only for Visa.
	//
	// Max Length: 12
	OneWayDropOffAmount string `json:"oneWayDropOffAmount,omitempty"`

	// Total amount charged for all other miscellaneous charges not previously defined.
	//
	// Max Length: 12
	OtherCharges string `json:"otherCharges,omitempty"`

	// Extra charges incurred due to a parking violation for the auto.
	// This field is supported only for Visa.
	//
	// Max Length: 12
	ParkingViolationCharge string `json:"parkingViolationCharge,omitempty"`

	// Additional charges incurred for phone usage included on the total bill.
	//
	// Max Length: 12
	PhoneCharge string `json:"phoneCharge,omitempty"`

	// Used to identify special circumstances applicable to the Card Transaction or Cardholder, such as "renter or show.
	//
	// This code is `2 digit` value agreed by Merchant and processor.
	//
	// Max Length: 2
	ProgramCode string `json:"programCode,omitempty"`

	// Rate charged for each mile.
	// This field is supported only for MasterCard and American Express.
	//
	// Max Length: 12
	RatePerMile string `json:"ratePerMile,omitempty"`

	// rental address
	RentalAddress *CreateCreditParamsBodyTravelInformationAutoRentalRentalAddress `json:"rentalAddress,omitempty"`

	// Date/time the auto was picked up from the rental agency.
	// Format: `yyyy-MM-dd HH-mm-ss z`
	// This field is supported for Visa, MasterCard, and American Express.
	//
	// Max Length: 21
	RentalDateTime string `json:"rentalDateTime,omitempty"`

	// return address
	ReturnAddress *CreateCreditParamsBodyTravelInformationAutoRentalReturnAddress `json:"returnAddress,omitempty"`

	// Date/time the auto was returned to the rental agency.
	// Format: ``yyyy-MM-dd HH-mm-ss z``
	// This field is supported for Visa, MasterCard, and American Express.
	//
	// Max Length: 21
	ReturnDateTime string `json:"returnDateTime,omitempty"`

	// Program code used to identify special circumstances, such as frequent renter or no show status for the renter.
	// Possible values:
	// - `0`: not applicable (default)
	// - `1`: frequent renter
	// - `2`: no show
	//
	// For authorizations, this field is supported only for Visa.
	//
	// For captures, this field is supported for Visa, MasterCard, and American Express.
	//
	// Code for special programs applicable to the Card Transaction or the Cardholder.
	//
	// Max Length: 2
	SpecialProgramCode string `json:"specialProgramCode,omitempty"`

	// tax details
	TaxDetails *CreateCreditParamsBodyTravelInformationAutoRentalTaxDetails `json:"taxDetails,omitempty"`

	// Indicates the time period for which the vehicle rental rate applies (e.g., daily, weekly or monthly). Daily, Weekly and Monthly are valid values.
	//
	// Max Length: 7
	TimePeriod string `json:"timePeriod,omitempty"`

	// (Towing Charges) provides the amount charged to tow the rental vehicle.
	//
	// Max Length: 4
	TowingCharge string `json:"towingCharge,omitempty"`

	// Classification of the rented auto.
	//
	// **NOTE** For VISA, this is a 2-byte optional code.
	//
	// Valid values for American Express & MasterCard:
	//
	// |American Express |MasterCard |Description|
	// |--- |--- |--- |
	// | 0001| 0001| Mini|
	// | 0002| 0002| Subcompact|
	// | 0003| 0003| Economy|
	// | 0004| 0004| Compact|
	// | 0005| 0005| Midsize|
	// | 0006| 0006| Intermediate|
	// | 0007| 0007| Standard|
	// | 0008| 0008| Fulll size|
	// | 0009| 0009| Luxury|
	// | 0010| 0010| Premium|
	// | 0011| 0011| Minivan|
	// | 0012| 0012| 12-passenger van|
	// | 0013| 0013| Moving van|
	// | 0014| 0014| 15-passenger van|
	// | 0015| 0015| Cargo van|
	// | 0016| 0016| 12-foot truck|
	// | 0017| 0017| 20-foot truck|
	// | 0018| 0018| 24-foot truck|
	// | 0019| 0019| 26-foot truck|
	// | 0020| 0020| Moped|
	// | 0021| 0021| Stretch|
	// | 0022| 0022| Regular|
	// | 0023| 0023| Unique|
	// | 0024| 0024| Exotic|
	// | 0025| 0025| Small/medium truck|
	// | 0026| 0026| Large truck|
	// | 0027| 0027| Small SUV|
	// | 0028| 0028| Medium SUV|
	// | 0029| 0029| Large SUV|
	// | 0030| 0030| Exotic SUV|
	// | 9999| 9999| Miscellaneous|
	//
	// Additional Values allowed **only** for `American Express`:
	//
	// |American Express|MasterCard|Description|
	// |--- |--- |--- |
	// | 0031| NA| Four Wheel Drive|
	// | 0032| NA| Special|
	// | 0099| NA| Taxi|
	//
	// Max Length: 4
	VehicleClass string `json:"vehicleClass,omitempty"`

	// This field contains a unique identifier assigned by the company to the vehicle.
	//
	// Max Length: 20
	VehicleIdentificationNumber string `json:"vehicleIdentificationNumber,omitempty"`

	// Make of the vehicle being rented (e.g., Chevrolet or Ford).
	//
	// Max Length: 10
	VehicleMake string `json:"vehicleMake,omitempty"`

	// Model of the vehicle being rented (e.g., Cavalier or Focus).
	//
	// Max Length: 10
	VehicleModel string `json:"vehicleModel,omitempty"`

	// Weekly Rental Amount provides the amount charged for a seven-day rental period. Field - Time Period needs to be populated with Weekly if this field is present
	//
	// Max Length: 12
	WeeklyRentalRate string `json:"weeklyRentalRate,omitempty"`
}

// Validate validates this create credit params body travel information auto rental
func (o *CreateCreditParamsBodyTravelInformationAutoRental) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAdjustedAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAdjustedAmountIndicator(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAgreementNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCommodityCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCompanyID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCustomerName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCustomerServicePhoneNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDailyRentalRate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDistanceTravelled(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDistanceUnit(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDriverAge(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExtraCharge(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExtraMileageCharge(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFuelCharges(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateGpsCharge(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateInsuranceAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLateFeeAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMaxFreeDistance(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMileageCharge(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNumberOfAdditionalDrivers(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOdometerReading(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOneWayDropOffAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOtherCharges(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateParkingViolationCharge(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePhoneCharge(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProgramCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRatePerMile(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRentalAddress(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRentalDateTime(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateReturnAddress(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateReturnDateTime(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSpecialProgramCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTimePeriod(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTowingCharge(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateVehicleClass(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateVehicleIdentificationNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateVehicleMake(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateVehicleModel(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateWeeklyRentalRate(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyTravelInformationAutoRental) validateAdjustedAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.AdjustedAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"adjustedAmount", "body", o.AdjustedAmount, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationAutoRental) validateAdjustedAmountIndicator(formats strfmt.Registry) error {
	if swag.IsZero(o.AdjustedAmountIndicator) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"adjustedAmountIndicator", "body", o.AdjustedAmountIndicator, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationAutoRental) validateAgreementNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.AgreementNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"agreementNumber", "body", o.AgreementNumber, 25); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationAutoRental) validateCommodityCode(formats strfmt.Registry) error {
	if swag.IsZero(o.CommodityCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"commodityCode", "body", o.CommodityCode, 15); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationAutoRental) validateCompanyID(formats strfmt.Registry) error {
	if swag.IsZero(o.CompanyID) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"companyId", "body", o.CompanyID, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationAutoRental) validateCustomerName(formats strfmt.Registry) error {
	if swag.IsZero(o.CustomerName) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"customerName", "body", o.CustomerName, 40); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationAutoRental) validateCustomerServicePhoneNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.CustomerServicePhoneNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"customerServicePhoneNumber", "body", o.CustomerServicePhoneNumber, 17); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationAutoRental) validateDailyRentalRate(formats strfmt.Registry) error {
	if swag.IsZero(o.DailyRentalRate) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"dailyRentalRate", "body", o.DailyRentalRate, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationAutoRental) validateDistanceTravelled(formats strfmt.Registry) error {
	if swag.IsZero(o.DistanceTravelled) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"distanceTravelled", "body", o.DistanceTravelled, 5); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationAutoRental) validateDistanceUnit(formats strfmt.Registry) error {
	if swag.IsZero(o.DistanceUnit) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"distanceUnit", "body", o.DistanceUnit, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationAutoRental) validateDriverAge(formats strfmt.Registry) error {
	if swag.IsZero(o.DriverAge) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"driverAge", "body", o.DriverAge, 3); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationAutoRental) validateExtraCharge(formats strfmt.Registry) error {
	if swag.IsZero(o.ExtraCharge) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"extraCharge", "body", o.ExtraCharge, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationAutoRental) validateExtraMileageCharge(formats strfmt.Registry) error {
	if swag.IsZero(o.ExtraMileageCharge) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"extraMileageCharge", "body", o.ExtraMileageCharge, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationAutoRental) validateFuelCharges(formats strfmt.Registry) error {
	if swag.IsZero(o.FuelCharges) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"fuelCharges", "body", o.FuelCharges, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationAutoRental) validateGpsCharge(formats strfmt.Registry) error {
	if swag.IsZero(o.GpsCharge) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"gpsCharge", "body", o.GpsCharge, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationAutoRental) validateInsuranceAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.InsuranceAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"insuranceAmount", "body", o.InsuranceAmount, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationAutoRental) validateLateFeeAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.LateFeeAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"lateFeeAmount", "body", o.LateFeeAmount, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationAutoRental) validateMaxFreeDistance(formats strfmt.Registry) error {
	if swag.IsZero(o.MaxFreeDistance) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"maxFreeDistance", "body", o.MaxFreeDistance, 4); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationAutoRental) validateMileageCharge(formats strfmt.Registry) error {
	if swag.IsZero(o.MileageCharge) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"mileageCharge", "body", o.MileageCharge, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationAutoRental) validateNumberOfAdditionalDrivers(formats strfmt.Registry) error {
	if swag.IsZero(o.NumberOfAdditionalDrivers) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"numberOfAdditionalDrivers", "body", o.NumberOfAdditionalDrivers, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationAutoRental) validateOdometerReading(formats strfmt.Registry) error {
	if swag.IsZero(o.OdometerReading) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"odometerReading", "body", o.OdometerReading, 8); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationAutoRental) validateOneWayDropOffAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.OneWayDropOffAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"oneWayDropOffAmount", "body", o.OneWayDropOffAmount, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationAutoRental) validateOtherCharges(formats strfmt.Registry) error {
	if swag.IsZero(o.OtherCharges) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"otherCharges", "body", o.OtherCharges, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationAutoRental) validateParkingViolationCharge(formats strfmt.Registry) error {
	if swag.IsZero(o.ParkingViolationCharge) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"parkingViolationCharge", "body", o.ParkingViolationCharge, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationAutoRental) validatePhoneCharge(formats strfmt.Registry) error {
	if swag.IsZero(o.PhoneCharge) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"phoneCharge", "body", o.PhoneCharge, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationAutoRental) validateProgramCode(formats strfmt.Registry) error {
	if swag.IsZero(o.ProgramCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"programCode", "body", o.ProgramCode, 2); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationAutoRental) validateRatePerMile(formats strfmt.Registry) error {
	if swag.IsZero(o.RatePerMile) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"ratePerMile", "body", o.RatePerMile, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationAutoRental) validateRentalAddress(formats strfmt.Registry) error {
	if swag.IsZero(o.RentalAddress) { // not required
		return nil
	}

	if o.RentalAddress != nil {
		if err := o.RentalAddress.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "travelInformation" + "." + "autoRental" + "." + "rentalAddress")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "travelInformation" + "." + "autoRental" + "." + "rentalAddress")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationAutoRental) validateRentalDateTime(formats strfmt.Registry) error {
	if swag.IsZero(o.RentalDateTime) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"rentalDateTime", "body", o.RentalDateTime, 21); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationAutoRental) validateReturnAddress(formats strfmt.Registry) error {
	if swag.IsZero(o.ReturnAddress) { // not required
		return nil
	}

	if o.ReturnAddress != nil {
		if err := o.ReturnAddress.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "travelInformation" + "." + "autoRental" + "." + "returnAddress")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "travelInformation" + "." + "autoRental" + "." + "returnAddress")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationAutoRental) validateReturnDateTime(formats strfmt.Registry) error {
	if swag.IsZero(o.ReturnDateTime) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"returnDateTime", "body", o.ReturnDateTime, 21); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationAutoRental) validateSpecialProgramCode(formats strfmt.Registry) error {
	if swag.IsZero(o.SpecialProgramCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"specialProgramCode", "body", o.SpecialProgramCode, 2); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationAutoRental) validateTaxDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.TaxDetails) { // not required
		return nil
	}

	if o.TaxDetails != nil {
		if err := o.TaxDetails.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "travelInformation" + "." + "autoRental" + "." + "taxDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "travelInformation" + "." + "autoRental" + "." + "taxDetails")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationAutoRental) validateTimePeriod(formats strfmt.Registry) error {
	if swag.IsZero(o.TimePeriod) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"timePeriod", "body", o.TimePeriod, 7); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationAutoRental) validateTowingCharge(formats strfmt.Registry) error {
	if swag.IsZero(o.TowingCharge) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"towingCharge", "body", o.TowingCharge, 4); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationAutoRental) validateVehicleClass(formats strfmt.Registry) error {
	if swag.IsZero(o.VehicleClass) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"vehicleClass", "body", o.VehicleClass, 4); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationAutoRental) validateVehicleIdentificationNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.VehicleIdentificationNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"vehicleIdentificationNumber", "body", o.VehicleIdentificationNumber, 20); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationAutoRental) validateVehicleMake(formats strfmt.Registry) error {
	if swag.IsZero(o.VehicleMake) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"vehicleMake", "body", o.VehicleMake, 10); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationAutoRental) validateVehicleModel(formats strfmt.Registry) error {
	if swag.IsZero(o.VehicleModel) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"vehicleModel", "body", o.VehicleModel, 10); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationAutoRental) validateWeeklyRentalRate(formats strfmt.Registry) error {
	if swag.IsZero(o.WeeklyRentalRate) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"weeklyRentalRate", "body", o.WeeklyRentalRate, 12); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this create credit params body travel information auto rental based on the context it is used
func (o *CreateCreditParamsBodyTravelInformationAutoRental) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateRentalAddress(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateReturnAddress(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateTaxDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyTravelInformationAutoRental) contextValidateRentalAddress(ctx context.Context, formats strfmt.Registry) error {

	if o.RentalAddress != nil {
		if err := o.RentalAddress.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "travelInformation" + "." + "autoRental" + "." + "rentalAddress")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "travelInformation" + "." + "autoRental" + "." + "rentalAddress")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationAutoRental) contextValidateReturnAddress(ctx context.Context, formats strfmt.Registry) error {

	if o.ReturnAddress != nil {
		if err := o.ReturnAddress.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "travelInformation" + "." + "autoRental" + "." + "returnAddress")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "travelInformation" + "." + "autoRental" + "." + "returnAddress")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationAutoRental) contextValidateTaxDetails(ctx context.Context, formats strfmt.Registry) error {

	if o.TaxDetails != nil {
		if err := o.TaxDetails.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "travelInformation" + "." + "autoRental" + "." + "taxDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "travelInformation" + "." + "autoRental" + "." + "taxDetails")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditParamsBodyTravelInformationAutoRental) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditParamsBodyTravelInformationAutoRental) UnmarshalBinary(b []byte) error {
	var res CreateCreditParamsBodyTravelInformationAutoRental
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditParamsBodyTravelInformationAutoRentalRentalAddress create credit params body travel information auto rental rental address
swagger:model CreateCreditParamsBodyTravelInformationAutoRentalRentalAddress
*/
type CreateCreditParamsBodyTravelInformationAutoRentalRentalAddress struct {

	// Address from where the vehicle was rented.
	//
	// Max Length: 13
	Address1 string `json:"address1,omitempty"`

	// Address from where the vehicle was rented.
	//
	// Max Length: 13
	Address2 string `json:"address2,omitempty"`

	// City in which the auto was rented.
	//
	// For authorizations, this field is supported for Visa, MasterCard, and American Express.
	//
	// For captures, this field is supported only for American Express.
	//
	// For all other card types, this field is ignored.
	//
	// Max Length: 25
	City string `json:"city,omitempty"`

	// Country where the auto was rented. Use the [ISO Standard Country Codes.](https://developer.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf)
	// This field is supported only for American Express.
	//
	// Max Length: 3
	Country string `json:"country,omitempty"`

	// This field contains the location where a taxi passenger was picked up or where an auto rental vehicle was picked up. In most cases, this is the rental agency's business name that appears on the storefront and/or customer receipts, commonly referred to as the DBA (Doing Business As) name. However, if the vehicle was picked up at another location (e.g., a hotel,auto dealership, repair shop, etc.), the name of that location should be used. This entry must be easily recognized by the Cardmember to avoid unnecessary inquiries. If the name is more than 38  characters, use proper and meaningful abbreviation, when possible.
	//
	// Max Length: 38
	Location string `json:"location,omitempty"`

	// The agency code, address, phone number, etc., used to identify the location where the vehicle was rented.
	//
	// Max Length: 10
	LocationID string `json:"locationId,omitempty"`

	// State in which the auto was rented. Use the [State, Province, and Territory Codes for the United States and Canada](https://developer.cybersource.com/library/documentation/sbc/quickref/states_and_provinces.pdf).
	//
	// Max Length: 3
	State string `json:"state,omitempty"`
}

// Validate validates this create credit params body travel information auto rental rental address
func (o *CreateCreditParamsBodyTravelInformationAutoRentalRentalAddress) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAddress1(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAddress2(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCity(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocationID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateState(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyTravelInformationAutoRentalRentalAddress) validateAddress1(formats strfmt.Registry) error {
	if swag.IsZero(o.Address1) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"rentalAddress"+"."+"address1", "body", o.Address1, 13); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationAutoRentalRentalAddress) validateAddress2(formats strfmt.Registry) error {
	if swag.IsZero(o.Address2) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"rentalAddress"+"."+"address2", "body", o.Address2, 13); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationAutoRentalRentalAddress) validateCity(formats strfmt.Registry) error {
	if swag.IsZero(o.City) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"rentalAddress"+"."+"city", "body", o.City, 25); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationAutoRentalRentalAddress) validateCountry(formats strfmt.Registry) error {
	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"rentalAddress"+"."+"country", "body", o.Country, 3); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationAutoRentalRentalAddress) validateLocation(formats strfmt.Registry) error {
	if swag.IsZero(o.Location) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"rentalAddress"+"."+"location", "body", o.Location, 38); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationAutoRentalRentalAddress) validateLocationID(formats strfmt.Registry) error {
	if swag.IsZero(o.LocationID) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"rentalAddress"+"."+"locationId", "body", o.LocationID, 10); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationAutoRentalRentalAddress) validateState(formats strfmt.Registry) error {
	if swag.IsZero(o.State) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"rentalAddress"+"."+"state", "body", o.State, 3); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create credit params body travel information auto rental rental address based on context it is used
func (o *CreateCreditParamsBodyTravelInformationAutoRentalRentalAddress) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditParamsBodyTravelInformationAutoRentalRentalAddress) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditParamsBodyTravelInformationAutoRentalRentalAddress) UnmarshalBinary(b []byte) error {
	var res CreateCreditParamsBodyTravelInformationAutoRentalRentalAddress
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditParamsBodyTravelInformationAutoRentalReturnAddress create credit params body travel information auto rental return address
swagger:model CreateCreditParamsBodyTravelInformationAutoRentalReturnAddress
*/
type CreateCreditParamsBodyTravelInformationAutoRentalReturnAddress struct {

	// City where the auto was returned to the rental agency.
	//
	// Max Length: 25
	City string `json:"city,omitempty"`

	// Country where the auto was returned to the rental agency. Use the [ISO Standard Country Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf).
	//
	// Max Length: 3
	Country string `json:"country,omitempty"`

	// This field contains the location where the taxi passenger was dropped off or where the auto rental vehicle was returned.
	//
	// Max Length: 38
	Location string `json:"location,omitempty"`

	// Code, address, phone number, etc. used to identify the location of the auto rental return.
	// This field is supported only for MasterCard and American Express.
	//
	// Max Length: 10
	LocationID string `json:"locationId,omitempty"`

	// State in which the auto was returned to the rental agency. Use the [State, Province, and Territory Codes for the United States and Canada](https://developer.cybersource.com/library/documentation/sbc/quickref/states_and_provinces.pdf).
	//
	// For authorizations, this field is supported for Visa, MasterCard, and American Express.
	//
	// For captures, this field is supported only for MasterCard and American Express.
	//
	// Max Length: 3
	State string `json:"state,omitempty"`
}

// Validate validates this create credit params body travel information auto rental return address
func (o *CreateCreditParamsBodyTravelInformationAutoRentalReturnAddress) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCity(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocationID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateState(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyTravelInformationAutoRentalReturnAddress) validateCity(formats strfmt.Registry) error {
	if swag.IsZero(o.City) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"returnAddress"+"."+"city", "body", o.City, 25); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationAutoRentalReturnAddress) validateCountry(formats strfmt.Registry) error {
	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"returnAddress"+"."+"country", "body", o.Country, 3); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationAutoRentalReturnAddress) validateLocation(formats strfmt.Registry) error {
	if swag.IsZero(o.Location) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"returnAddress"+"."+"location", "body", o.Location, 38); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationAutoRentalReturnAddress) validateLocationID(formats strfmt.Registry) error {
	if swag.IsZero(o.LocationID) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"returnAddress"+"."+"locationId", "body", o.LocationID, 10); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationAutoRentalReturnAddress) validateState(formats strfmt.Registry) error {
	if swag.IsZero(o.State) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"returnAddress"+"."+"state", "body", o.State, 3); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create credit params body travel information auto rental return address based on context it is used
func (o *CreateCreditParamsBodyTravelInformationAutoRentalReturnAddress) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditParamsBodyTravelInformationAutoRentalReturnAddress) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditParamsBodyTravelInformationAutoRentalReturnAddress) UnmarshalBinary(b []byte) error {
	var res CreateCreditParamsBodyTravelInformationAutoRentalReturnAddress
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditParamsBodyTravelInformationAutoRentalTaxDetails create credit params body travel information auto rental tax details
swagger:model CreateCreditParamsBodyTravelInformationAutoRentalTaxDetails
*/
type CreateCreditParamsBodyTravelInformationAutoRentalTaxDetails struct {

	// Indicates the amount of tax based on the `type` field as described in the table below:
	//
	// Max Length: 13
	Amount string `json:"amount,omitempty"`

	// Flag that indicates whether the tax amount (`travelInformation.autoRental.taxDetails.amount`) is
	// included in the request.
	//
	// Possible values:
	// - `false`: tax amount is not included in the request.
	// - `true`:  tax amount is included in the request.
	//
	Applied bool `json:"applied,omitempty"`

	// Status code for exemption from sales and use tax. This field is a pass-through, which means that
	// CyberSource does not verify the value or modify it in any way before sending it to the processor.
	//
	// Max Length: 1
	ExemptionCode string `json:"exemptionCode,omitempty"`

	// Rate of VAT or other tax for the order.
	//
	// Example 0.040 (=4%)
	//
	// Valid range: 0.01 to 0.99 (1% to 99%, with only whole percentage values accepted; values with additional
	// decimal places will be truncated)
	//
	// Max Length: 6
	Rate string `json:"rate,omitempty"`

	// Summary of all tax types
	//
	// Max Length: 12
	TaxSummary string `json:"taxSummary,omitempty"`

	// Different taxes the rental agency applies to the rental agreement such as tourist tax, airport tax, or rental tax.
	//
	// Max Length: 10
	TaxType string `json:"taxType,omitempty"`
}

// Validate validates this create credit params body travel information auto rental tax details
func (o *CreateCreditParamsBodyTravelInformationAutoRentalTaxDetails) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExemptionCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxSummary(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyTravelInformationAutoRentalTaxDetails) validateAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.Amount) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"taxDetails"+"."+"amount", "body", o.Amount, 13); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationAutoRentalTaxDetails) validateExemptionCode(formats strfmt.Registry) error {
	if swag.IsZero(o.ExemptionCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"taxDetails"+"."+"exemptionCode", "body", o.ExemptionCode, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationAutoRentalTaxDetails) validateRate(formats strfmt.Registry) error {
	if swag.IsZero(o.Rate) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"taxDetails"+"."+"rate", "body", o.Rate, 6); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationAutoRentalTaxDetails) validateTaxSummary(formats strfmt.Registry) error {
	if swag.IsZero(o.TaxSummary) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"taxDetails"+"."+"taxSummary", "body", o.TaxSummary, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationAutoRentalTaxDetails) validateTaxType(formats strfmt.Registry) error {
	if swag.IsZero(o.TaxType) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"taxDetails"+"."+"taxType", "body", o.TaxType, 10); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create credit params body travel information auto rental tax details based on context it is used
func (o *CreateCreditParamsBodyTravelInformationAutoRentalTaxDetails) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditParamsBodyTravelInformationAutoRentalTaxDetails) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditParamsBodyTravelInformationAutoRentalTaxDetails) UnmarshalBinary(b []byte) error {
	var res CreateCreditParamsBodyTravelInformationAutoRentalTaxDetails
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditParamsBodyTravelInformationLodging create credit params body travel information lodging
swagger:model CreateCreditParamsBodyTravelInformationLodging
*/
type CreateCreditParamsBodyTravelInformationLodging struct {

	// Amount of an additional coupon or discount.
	//
	// Max Length: 12
	AdditionalDiscountAmount string `json:"additionalDiscountAmount,omitempty"`

	// Adjusted amount charged in addition to the reservation amount after the stay is complete.
	//
	// Max Length: 12
	AdjustmentAmount string `json:"adjustmentAmount,omitempty"`

	// Cost of audio visual services.
	//
	// Max Length: 12
	AudioVisualCost string `json:"audioVisualCost,omitempty"`

	// Cost of banquet services.
	//
	// Max Length: 12
	BanquestCost string `json:"banquestCost,omitempty"`

	// Cost of business center services.
	//
	// Max Length: 12
	BusinessCenterCost string `json:"businessCenterCost,omitempty"`

	// Cost of the cash that was disbursed plus any associated service fees
	//
	// Max Length: 12
	CashDisbursementCost string `json:"cashDisbursementCost,omitempty"`

	// Date on which the guest checked in. In the case of a no-show or a reservation, the scheduled arrival date.
	// Format: `MMDDYY`. For best interchange rates, make sure it is a valid date.
	//
	// Max Length: 6
	CheckInDate string `json:"checkInDate,omitempty"`

	// Date on which the guest checked out.
	// Format: `MMDDYY`. For best interchange rates, make sure it is a valid date.
	//
	// Max Length: 6
	CheckOutDate string `json:"checkOutDate,omitempty"`

	// Cost of conference room services.
	//
	// Max Length: 12
	ConferenceRoomCost string `json:"conferenceRoomCost,omitempty"`

	// Code assigned to a business. You can use this code to identify corporate rates and discounts for guests.
	//
	// Max Length: 17
	CorporateClientCode string `json:"corporateClientCode,omitempty"`

	// Your toll-free customer service phone number.
	//
	// Max Length: 17
	CustomerServicePhoneNumber string `json:"customerServicePhoneNumber,omitempty"`

	// Service fee for early departure.
	//
	// Max Length: 12
	EarlyCheckOutCost string `json:"earlyCheckOutCost,omitempty"`

	// Cost for all food and beverages.
	//
	// Max Length: 12
	FoodAndBeverageCost string `json:"foodAndBeverageCost,omitempty"`

	// Cost of gift shop purchases.
	//
	// Max Length: 12
	GiftShopCost string `json:"giftShopCost,omitempty"`

	// Gratuity.
	//
	// Max Length: 12
	GratuityAmount string `json:"gratuityAmount,omitempty"`

	// Name of the guest under which the room is reserved.
	//
	// Max Length: 40
	GuestName string `json:"guestName,omitempty"`

	// Cost of health club services.
	//
	// Max Length: 12
	HealthClubCost string `json:"healthClubCost,omitempty"`

	// Cost of Internet access.
	//
	// Max Length: 12
	InternetAccessCost string `json:"internetAccessCost,omitempty"`

	// Cost of laundry services.
	//
	// Max Length: 12
	LaundryCost string `json:"laundryCost,omitempty"`

	// Cost of lounge and bar purchases.
	//
	// Max Length: 12
	LoungeBarCost string `json:"loungeBarCost,omitempty"`

	// Cost of mini-bar purchases.
	//
	// Max Length: 12
	MiniBarCost string `json:"miniBarCost,omitempty"`

	// Miscellaneous costs.
	//
	// Max Length: 12
	MiscellaneousCost string `json:"miscellaneousCost,omitempty"`

	// Cost of movies.
	//
	// Max Length: 12
	MovieCost string `json:"movieCost,omitempty"`

	// Cost of non-room purchases, such as meals and gifts.
	//
	// Max Length: 12
	NonRoomCost string `json:"nonRoomCost,omitempty"`

	// Tax on non-room purchases.
	//
	// Max Length: 12
	NonRoomTaxAmount string `json:"nonRoomTaxAmount,omitempty"`

	// Number of guests staying in the room.
	//
	// Maximum: 99
	// Minimum: 1
	NumberOfGuests int64 `json:"numberOfGuests,omitempty"`

	// Number of rooms booked by the cardholder.
	//
	// Maximum: 99
	// Minimum: 1
	NumberOfRooms int64 `json:"numberOfRooms,omitempty"`

	// Cost of telephone services.
	//
	// Max Length: 12
	PhoneCost string `json:"phoneCost,omitempty"`

	// Prepaid amount, such as a deposit.
	//
	// Max Length: 12
	PrepaidCost string `json:"prepaidCost,omitempty"`

	// Cost of restaurant purchases
	//
	// Max Length: 12
	RestaurantCost string `json:"restaurantCost,omitempty"`

	// The object containing the number of nights and the daily rate that applies for that no of nights.
	//
	Room []*CreateCreditParamsBodyTravelInformationLodgingRoomItems0 `json:"room"`

	// Type of room, such as queen, king, or two doubles.
	//
	// Max Length: 12
	RoomBedType string `json:"roomBedType,omitempty"`

	// Location of room, such as lake view or ocean view.
	//
	// Max Length: 10
	RoomLocation string `json:"roomLocation,omitempty"`

	// Type of rate, such as corporate or senior citizen.
	//
	// Max Length: 12
	RoomRateType string `json:"roomRateType,omitempty"`

	// Cost of room service.
	//
	// Max Length: 12
	RoomServiceCost string `json:"roomServiceCost,omitempty"`

	// Total tax for the room.
	//
	// Max Length: 12
	RoomTaxAmount string `json:"roomTaxAmount,omitempty"`

	// Type of tax, such as tourist or hotel.
	//
	// Max Length: 10
	RoomTaxType string `json:"roomTaxType,omitempty"`

	// Smoking preference of the guest.
	// Possible values:
	// - `Y`: smoking room
	// - `N`: non-smoking room
	//
	// Max Length: 1
	SmokingPreference string `json:"smokingPreference,omitempty"`

	// Code that identifies special circumstances.
	// Possible values:
	// - `1`: lodging (default)
	// - `2`: no show reservation
	// - `3`: advanced deposit
	//
	// Max Length: 1
	SpecialProgramCode string `json:"specialProgramCode,omitempty"`

	// Total tax amount.
	//
	// Max Length: 12
	TotalTaxAmount string `json:"totalTaxAmount,omitempty"`

	// Cost of transportation services.
	//
	// Max Length: 12
	TransportationCost string `json:"transportationCost,omitempty"`

	// Cost of valet parking services.
	//
	// Max Length: 12
	ValetParkingCost string `json:"valetParkingCost,omitempty"`
}

// Validate validates this create credit params body travel information lodging
func (o *CreateCreditParamsBodyTravelInformationLodging) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAdditionalDiscountAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAdjustmentAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAudioVisualCost(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBanquestCost(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBusinessCenterCost(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCashDisbursementCost(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCheckInDate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCheckOutDate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateConferenceRoomCost(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCorporateClientCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCustomerServicePhoneNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEarlyCheckOutCost(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFoodAndBeverageCost(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateGiftShopCost(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateGratuityAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateGuestName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateHealthClubCost(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateInternetAccessCost(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLaundryCost(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLoungeBarCost(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMiniBarCost(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMiscellaneousCost(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMovieCost(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNonRoomCost(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNonRoomTaxAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNumberOfGuests(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNumberOfRooms(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePhoneCost(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePrepaidCost(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRestaurantCost(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRoom(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRoomBedType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRoomLocation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRoomRateType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRoomServiceCost(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRoomTaxAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRoomTaxType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSmokingPreference(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSpecialProgramCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTotalTaxAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTransportationCost(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateValetParkingCost(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyTravelInformationLodging) validateAdditionalDiscountAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.AdditionalDiscountAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"lodging"+"."+"additionalDiscountAmount", "body", o.AdditionalDiscountAmount, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationLodging) validateAdjustmentAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.AdjustmentAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"lodging"+"."+"adjustmentAmount", "body", o.AdjustmentAmount, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationLodging) validateAudioVisualCost(formats strfmt.Registry) error {
	if swag.IsZero(o.AudioVisualCost) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"lodging"+"."+"audioVisualCost", "body", o.AudioVisualCost, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationLodging) validateBanquestCost(formats strfmt.Registry) error {
	if swag.IsZero(o.BanquestCost) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"lodging"+"."+"banquestCost", "body", o.BanquestCost, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationLodging) validateBusinessCenterCost(formats strfmt.Registry) error {
	if swag.IsZero(o.BusinessCenterCost) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"lodging"+"."+"businessCenterCost", "body", o.BusinessCenterCost, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationLodging) validateCashDisbursementCost(formats strfmt.Registry) error {
	if swag.IsZero(o.CashDisbursementCost) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"lodging"+"."+"cashDisbursementCost", "body", o.CashDisbursementCost, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationLodging) validateCheckInDate(formats strfmt.Registry) error {
	if swag.IsZero(o.CheckInDate) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"lodging"+"."+"checkInDate", "body", o.CheckInDate, 6); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationLodging) validateCheckOutDate(formats strfmt.Registry) error {
	if swag.IsZero(o.CheckOutDate) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"lodging"+"."+"checkOutDate", "body", o.CheckOutDate, 6); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationLodging) validateConferenceRoomCost(formats strfmt.Registry) error {
	if swag.IsZero(o.ConferenceRoomCost) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"lodging"+"."+"conferenceRoomCost", "body", o.ConferenceRoomCost, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationLodging) validateCorporateClientCode(formats strfmt.Registry) error {
	if swag.IsZero(o.CorporateClientCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"lodging"+"."+"corporateClientCode", "body", o.CorporateClientCode, 17); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationLodging) validateCustomerServicePhoneNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.CustomerServicePhoneNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"lodging"+"."+"customerServicePhoneNumber", "body", o.CustomerServicePhoneNumber, 17); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationLodging) validateEarlyCheckOutCost(formats strfmt.Registry) error {
	if swag.IsZero(o.EarlyCheckOutCost) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"lodging"+"."+"earlyCheckOutCost", "body", o.EarlyCheckOutCost, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationLodging) validateFoodAndBeverageCost(formats strfmt.Registry) error {
	if swag.IsZero(o.FoodAndBeverageCost) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"lodging"+"."+"foodAndBeverageCost", "body", o.FoodAndBeverageCost, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationLodging) validateGiftShopCost(formats strfmt.Registry) error {
	if swag.IsZero(o.GiftShopCost) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"lodging"+"."+"giftShopCost", "body", o.GiftShopCost, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationLodging) validateGratuityAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.GratuityAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"lodging"+"."+"gratuityAmount", "body", o.GratuityAmount, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationLodging) validateGuestName(formats strfmt.Registry) error {
	if swag.IsZero(o.GuestName) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"lodging"+"."+"guestName", "body", o.GuestName, 40); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationLodging) validateHealthClubCost(formats strfmt.Registry) error {
	if swag.IsZero(o.HealthClubCost) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"lodging"+"."+"healthClubCost", "body", o.HealthClubCost, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationLodging) validateInternetAccessCost(formats strfmt.Registry) error {
	if swag.IsZero(o.InternetAccessCost) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"lodging"+"."+"internetAccessCost", "body", o.InternetAccessCost, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationLodging) validateLaundryCost(formats strfmt.Registry) error {
	if swag.IsZero(o.LaundryCost) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"lodging"+"."+"laundryCost", "body", o.LaundryCost, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationLodging) validateLoungeBarCost(formats strfmt.Registry) error {
	if swag.IsZero(o.LoungeBarCost) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"lodging"+"."+"loungeBarCost", "body", o.LoungeBarCost, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationLodging) validateMiniBarCost(formats strfmt.Registry) error {
	if swag.IsZero(o.MiniBarCost) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"lodging"+"."+"miniBarCost", "body", o.MiniBarCost, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationLodging) validateMiscellaneousCost(formats strfmt.Registry) error {
	if swag.IsZero(o.MiscellaneousCost) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"lodging"+"."+"miscellaneousCost", "body", o.MiscellaneousCost, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationLodging) validateMovieCost(formats strfmt.Registry) error {
	if swag.IsZero(o.MovieCost) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"lodging"+"."+"movieCost", "body", o.MovieCost, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationLodging) validateNonRoomCost(formats strfmt.Registry) error {
	if swag.IsZero(o.NonRoomCost) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"lodging"+"."+"nonRoomCost", "body", o.NonRoomCost, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationLodging) validateNonRoomTaxAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.NonRoomTaxAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"lodging"+"."+"nonRoomTaxAmount", "body", o.NonRoomTaxAmount, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationLodging) validateNumberOfGuests(formats strfmt.Registry) error {
	if swag.IsZero(o.NumberOfGuests) { // not required
		return nil
	}

	if err := validate.MinimumInt("createCreditRequest"+"."+"travelInformation"+"."+"lodging"+"."+"numberOfGuests", "body", o.NumberOfGuests, 1, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("createCreditRequest"+"."+"travelInformation"+"."+"lodging"+"."+"numberOfGuests", "body", o.NumberOfGuests, 99, false); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationLodging) validateNumberOfRooms(formats strfmt.Registry) error {
	if swag.IsZero(o.NumberOfRooms) { // not required
		return nil
	}

	if err := validate.MinimumInt("createCreditRequest"+"."+"travelInformation"+"."+"lodging"+"."+"numberOfRooms", "body", o.NumberOfRooms, 1, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("createCreditRequest"+"."+"travelInformation"+"."+"lodging"+"."+"numberOfRooms", "body", o.NumberOfRooms, 99, false); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationLodging) validatePhoneCost(formats strfmt.Registry) error {
	if swag.IsZero(o.PhoneCost) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"lodging"+"."+"phoneCost", "body", o.PhoneCost, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationLodging) validatePrepaidCost(formats strfmt.Registry) error {
	if swag.IsZero(o.PrepaidCost) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"lodging"+"."+"prepaidCost", "body", o.PrepaidCost, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationLodging) validateRestaurantCost(formats strfmt.Registry) error {
	if swag.IsZero(o.RestaurantCost) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"lodging"+"."+"restaurantCost", "body", o.RestaurantCost, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationLodging) validateRoom(formats strfmt.Registry) error {
	if swag.IsZero(o.Room) { // not required
		return nil
	}

	for i := 0; i < len(o.Room); i++ {
		if swag.IsZero(o.Room[i]) { // not required
			continue
		}

		if o.Room[i] != nil {
			if err := o.Room[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("createCreditRequest" + "." + "travelInformation" + "." + "lodging" + "." + "room" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("createCreditRequest" + "." + "travelInformation" + "." + "lodging" + "." + "room" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationLodging) validateRoomBedType(formats strfmt.Registry) error {
	if swag.IsZero(o.RoomBedType) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"lodging"+"."+"roomBedType", "body", o.RoomBedType, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationLodging) validateRoomLocation(formats strfmt.Registry) error {
	if swag.IsZero(o.RoomLocation) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"lodging"+"."+"roomLocation", "body", o.RoomLocation, 10); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationLodging) validateRoomRateType(formats strfmt.Registry) error {
	if swag.IsZero(o.RoomRateType) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"lodging"+"."+"roomRateType", "body", o.RoomRateType, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationLodging) validateRoomServiceCost(formats strfmt.Registry) error {
	if swag.IsZero(o.RoomServiceCost) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"lodging"+"."+"roomServiceCost", "body", o.RoomServiceCost, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationLodging) validateRoomTaxAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.RoomTaxAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"lodging"+"."+"roomTaxAmount", "body", o.RoomTaxAmount, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationLodging) validateRoomTaxType(formats strfmt.Registry) error {
	if swag.IsZero(o.RoomTaxType) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"lodging"+"."+"roomTaxType", "body", o.RoomTaxType, 10); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationLodging) validateSmokingPreference(formats strfmt.Registry) error {
	if swag.IsZero(o.SmokingPreference) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"lodging"+"."+"smokingPreference", "body", o.SmokingPreference, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationLodging) validateSpecialProgramCode(formats strfmt.Registry) error {
	if swag.IsZero(o.SpecialProgramCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"lodging"+"."+"specialProgramCode", "body", o.SpecialProgramCode, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationLodging) validateTotalTaxAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.TotalTaxAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"lodging"+"."+"totalTaxAmount", "body", o.TotalTaxAmount, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationLodging) validateTransportationCost(formats strfmt.Registry) error {
	if swag.IsZero(o.TransportationCost) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"lodging"+"."+"transportationCost", "body", o.TransportationCost, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationLodging) validateValetParkingCost(formats strfmt.Registry) error {
	if swag.IsZero(o.ValetParkingCost) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"lodging"+"."+"valetParkingCost", "body", o.ValetParkingCost, 12); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this create credit params body travel information lodging based on the context it is used
func (o *CreateCreditParamsBodyTravelInformationLodging) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateRoom(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyTravelInformationLodging) contextValidateRoom(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.Room); i++ {

		if o.Room[i] != nil {
			if err := o.Room[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("createCreditRequest" + "." + "travelInformation" + "." + "lodging" + "." + "room" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("createCreditRequest" + "." + "travelInformation" + "." + "lodging" + "." + "room" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditParamsBodyTravelInformationLodging) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditParamsBodyTravelInformationLodging) UnmarshalBinary(b []byte) error {
	var res CreateCreditParamsBodyTravelInformationLodging
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditParamsBodyTravelInformationLodgingRoomItems0 create credit params body travel information lodging room items0
swagger:model CreateCreditParamsBodyTravelInformationLodgingRoomItems0
*/
type CreateCreditParamsBodyTravelInformationLodgingRoomItems0 struct {

	// Daily cost of the room.
	//
	// Max Length: 8
	DailyRate string `json:"dailyRate,omitempty"`

	// Number of nights billed at the rate specified by `travelInformation.lodging.room[].dailyRate`.
	//
	// Maximum: 9999
	// Minimum: 1
	NumberOfNights int64 `json:"numberOfNights,omitempty"`
}

// Validate validates this create credit params body travel information lodging room items0
func (o *CreateCreditParamsBodyTravelInformationLodgingRoomItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDailyRate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNumberOfNights(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyTravelInformationLodgingRoomItems0) validateDailyRate(formats strfmt.Registry) error {
	if swag.IsZero(o.DailyRate) { // not required
		return nil
	}

	if err := validate.MaxLength("dailyRate", "body", o.DailyRate, 8); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationLodgingRoomItems0) validateNumberOfNights(formats strfmt.Registry) error {
	if swag.IsZero(o.NumberOfNights) { // not required
		return nil
	}

	if err := validate.MinimumInt("numberOfNights", "body", o.NumberOfNights, 1, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("numberOfNights", "body", o.NumberOfNights, 9999, false); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create credit params body travel information lodging room items0 based on context it is used
func (o *CreateCreditParamsBodyTravelInformationLodgingRoomItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditParamsBodyTravelInformationLodgingRoomItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditParamsBodyTravelInformationLodgingRoomItems0) UnmarshalBinary(b []byte) error {
	var res CreateCreditParamsBodyTravelInformationLodgingRoomItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditParamsBodyTravelInformationTransit create credit params body travel information transit
swagger:model CreateCreditParamsBodyTravelInformationTransit
*/
type CreateCreditParamsBodyTravelInformationTransit struct {

	// airline
	Airline *CreateCreditParamsBodyTravelInformationTransitAirline `json:"airline,omitempty"`
}

// Validate validates this create credit params body travel information transit
func (o *CreateCreditParamsBodyTravelInformationTransit) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAirline(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyTravelInformationTransit) validateAirline(formats strfmt.Registry) error {
	if swag.IsZero(o.Airline) { // not required
		return nil
	}

	if o.Airline != nil {
		if err := o.Airline.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "travelInformation" + "." + "transit" + "." + "airline")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "travelInformation" + "." + "transit" + "." + "airline")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this create credit params body travel information transit based on the context it is used
func (o *CreateCreditParamsBodyTravelInformationTransit) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateAirline(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyTravelInformationTransit) contextValidateAirline(ctx context.Context, formats strfmt.Registry) error {

	if o.Airline != nil {
		if err := o.Airline.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "travelInformation" + "." + "transit" + "." + "airline")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "travelInformation" + "." + "transit" + "." + "airline")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditParamsBodyTravelInformationTransit) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditParamsBodyTravelInformationTransit) UnmarshalBinary(b []byte) error {
	var res CreateCreditParamsBodyTravelInformationTransit
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditParamsBodyTravelInformationTransitAirline create credit params body travel information transit airline
swagger:model CreateCreditParamsBodyTravelInformationTransitAirline
*/
type CreateCreditParamsBodyTravelInformationTransitAirline struct {

	// Description of the charge if the charge does not involve an airline ticket.
	// For example: Excess baggage.
	//
	// Max Length: 20
	AdditionalCharges string `json:"additionalCharges,omitempty"`

	// ancillary information
	AncillaryInformation *CreateCreditParamsBodyTravelInformationTransitAirlineAncillaryInformation `json:"ancillaryInformation,omitempty"`

	// Date of arrival for the last leg of the trip.
	// Format: `MMDDYYYY`
	// English characters only.
	// Optional request field.
	//
	// Max Length: 8
	ArrivalDate string `json:"arrivalDate,omitempty"`

	// Boarding fee.
	//
	// Max Length: 12
	BoardingFeeAmount string `json:"boardingFeeAmount,omitempty"`

	// Reference number for the airline booking.
	// Required if ticket numbers are not issued.
	//
	// Max Length: 15
	BookingReferenceNumber string `json:"bookingReferenceNumber,omitempty"`

	// Airline that generated the ticket.
	// Format: English characters only.
	// Optional request field.
	//
	// Max Length: 15
	CarrierName string `json:"carrierName,omitempty"`

	// Check digit for the ticket number. CyberSource recommends that you validate the check digit.
	// With Discover and Diners Club, a valid ticket number has these characteristics:
	// - The value is numeric.
	// - The first three digits are a valid IATA2 license plate carrier code.
	// - The last digit is a check digit or zero (0).
	// - All remaining digits are nonzero.
	//
	// Max Length: 1
	CheckDigit string `json:"checkDigit,omitempty"`

	// Total number of clearing messages associated with the authorization request.
	// Format: English characters only.
	// Optional request field.
	//
	// Max Length: 2
	ClearingCount string `json:"clearingCount,omitempty"`

	// Number that identifies the clearing message when multiple clearing messages are allowed per authorized transaction.
	// Each clearing message linked to one authorization request must include a unique clearing sequence number between 1 and the total number of clearing records.
	// Format: English characters only.
	// Optional request field.
	//
	// Max Length: 2
	ClearingSequence string `json:"clearingSequence,omitempty"`

	// Reason for the credit.
	// Possible values:
	// - `A`: Cancellation of the ancillary passenger transport purchase.
	// - `B`: Cancellation of the airline ticket and the passenger transport ancillary purchase.
	// - `C`: Cancellation of the airline ticket.
	// - `O`: Other.
	// - `P`: Partial refund of the airline ticket.
	// Format: English characters only.
	//
	// Optional request field.
	//
	// Max Length: 1
	CreditReasonIndicator string `json:"creditReasonIndicator,omitempty"`

	// Reference number or code that identifies the cardholder.
	// Format: English characters only.
	// Restricted string data type that indicates a sequence of letters, numbers, and spaces;
	// special characters are not included.
	// Optional request field.
	//
	// Max Length: 40
	CustomerCode string `json:"customerCode,omitempty"`

	// The field is not currently supported.
	//
	// Max Length: 14
	DocumentNumber string `json:"documentNumber,omitempty"`

	// The field is not currently supported.
	//
	DocumentNumberOfParts int64 `json:"documentNumberOfParts,omitempty"`

	// Airline document type code that specifies the purpose of the transaction.
	// Format: English characters only.
	// Optional request field.
	//
	// | Code | Description |
	// | --- | --- |
	// | 01 | Passenger ticket |
	// | 02 | Additional collection |
	// | 03 | Excess baggage |
	// | 04 | Miscellaneous charge order (MCO) or prepaid ticket authorization |
	// | 05 | Special service ticket |
	// | 06 | Supported refund |
	// | 07 | Unsupported refund |
	// | 08 | Lost ticket application |
	// | 09 | Tour order voucher |
	// | 10 | Ticket by mail |
	// | 11 | Undercharge adjustment |
	// | 12 | Group ticket |
	// | 13 | Exchange adjustment |
	// | 14 | SPD or air freight |
	// | 15 | In-flight adjustment |
	// | 16 | Agency passenger ticket |
	// | 17 | Agency tour order or voucher |
	// | 18 | Agency miscellaneous charge order (MCO) |
	// | 19 | Agency exchange order |
	// | 20 | Agency group ticket |
	// | 21 | Debit adjustment for duplicate refund or use |
	// | 22 | In-flight merchandise order |
	// | 23 | Catalogue merchandise order |
	// | 24 | In-flight phone charges |
	// | 25 | Frequent flyer fee or purchase |
	// | 26 | Kennel charge |
	// | 27 | Animal transportation charge |
	// | 28 | Firearms case |
	// | 29 | Upgrade charge |
	// | 30 | Credit for unused transportation |
	// | 31 | Credit for class of service adjustment |
	// | 32 | Credit for denied boarding |
	// | 33 | Credit for miscellaneous refund |
	// | 34 | Credit for lost ticket refund |
	// | 35 | Credit for exchange refund |
	// | 36 | Credit for overcharge adjustment |
	// | 37 | Credit for multiple Unused tickets |
	// | 38 | Exchange order |
	// | 39 | Self-service ticket |
	// | 41 | In-flight duty-free purchase |
	// | 42 | Senior citizen discount booklets |
	// | 43 | Club membership fee |
	// | 44 | Coupon book |
	// | 45 | In-flight charges |
	// | 46 | Tour deposit |
	// | 47 | Frequent flyer overnight delivery charge |
	// | 48 | Frequent flyer fulfillment |
	// | 49 | Small package delivery |
	// | 50 | Vendor sale |
	// | 51 | Miscellaneous taxes or fees |
	// | 52 | Travel agency fee |
	// | 60 | Vendor refund or credit |
	// | 64 | Duty free sale |
	// | 65 | Preferred seat upgrade |
	// | 66 | Cabin upgrade |
	// | 67 | Lounge or club access or day pass |
	// | 68 | Agent assisted reservation or ticketing fee |
	// | 69 | Ticket change or cancel fee |
	// | 70 | Trip insurance |
	// | 71 | Unaccompanied minor |
	// | 72 | Standby fee |
	// | 73 | Curbside baggage |
	// | 74 | In-flight medical equipment |
	// | 75 | Ticket or pass print fee |
	// | 76 | Checked sporting or special equipment |
	// | 77 | Dry ice fee |
	// | 78 | Mail or postage fee |
	// | 79 | Club membership fee or temporary trial |
	// | 80 | Frequent flyer activation or reinstatement |
	// | 81 | Gift certificate |
	// | 82 | Onboard or in-flight prepaid voucher |
	// | 83 | Optional services fee |
	// | 84 | Advance purchase for excess baggage |
	// | 85 | Advance purchase for preferred seat upgrade |
	// | 86 | Advance purchase for cabin upgrade |
	// | 87 | Advance purchase for optional services |
	// | 88 | WiFi |
	// | 89 | Packages |
	// | 90 | In-flight entertainment or internet access |
	// | 91 | Overweight bag fee |
	// | 92 | Sleep sets |
	// | 93 | Special purchase fee |
	//
	// Max Length: 1
	DocumentType string `json:"documentType,omitempty"`

	// Flag that indicates whether an electronic ticket was issued.
	// Possible values:
	// - `true`
	// - `false`
	// Optional request field.
	//
	ElectronicTicketIndicator bool `json:"electronicTicketIndicator,omitempty"`

	// Amount of the exchanged ticket.
	// Format: English characters only.
	//
	// Max Length: 12
	ExchangeTicketAmount string `json:"exchangeTicketAmount,omitempty"`

	// Fee for exchanging the ticket.
	// Format: English characters only.
	// Optional request field.
	//
	// Max Length: 12
	ExchangeTicketFeeAmount string `json:"exchangeTicketFeeAmount,omitempty"`

	// The field is not currently supported.
	//
	// Max Length: 3
	ExtendedPaymentCode string `json:"extendedPaymentCode,omitempty"`

	// Invoice date. The format is YYYYMMDD.
	// If this value is
	// included in the request, it is used in the creation of the invoice number. See "Invoice Number,"
	//
	InvoiceDate int64 `json:"invoiceDate,omitempty"`

	// Invoice number for the airline transaction.
	//
	// Max Length: 25
	InvoiceNumber string `json:"invoiceNumber,omitempty"`

	// legs
	Legs []*CreateCreditParamsBodyTravelInformationTransitAirlineLegsItems0 `json:"legs"`

	// Number of passengers for whom the ticket was issued.
	// Format: English characters only.
	// Optional request field.
	//
	NumberOfPassengers int64 `json:"numberOfPassengers,omitempty"`

	// Original ticket number when the transaction is for a replacement ticket.
	//
	// Max Length: 14
	OriginalTicketNumber string `json:"originalTicketNumber,omitempty"`

	// Name of the passenger to whom the ticket was issued.  This will always be a single passenger's name.
	// If there are more than one passengers, provide only the primary passenger's name.
	// Do not include special characters such as commas, hyphens, or apostrophes.
	// Only ASCII characters are supported.
	// Format: English characters only.
	// Optional request field.
	//
	// Max Length: 42
	PassengerName string `json:"passengerName,omitempty"`

	// Plan number based on the fare.
	// This value is provided by the airline.
	// Format: English characters only.
	// Optional request field.
	//
	// Max Length: 1
	PlanNumber string `json:"planNumber,omitempty"`

	// Airline process identifier. This value is the airlines three-digit IATA1 code
	// which is used to process extended payment airline tickets.
	//
	// Max Length: 3
	ProcessIdentifier string `json:"processIdentifier,omitempty"`

	// Type of purchase. Possible values:
	// - `EXC`: Exchange ticket
	// - `MSC`: Miscellaneous (not a ticket purchase and not a transaction related to an exchange ticket)
	// - `REF`: Refund
	// - `TKT`: Ticket
	// Format: English characters only.
	// Optional request field.
	//
	// Max Length: 3
	PurchaseType string `json:"purchaseType,omitempty"`

	// Code that specifies the computerized reservation system used to make the reservation and purchase the ticket.
	// Format: English characters only.
	// Restricted string data type that indicates a sequence of letters, numbers, and spaces;
	// special characters are not included.
	// Optional request field.
	//
	// Max Length: 4
	ReservationSystemCode string `json:"reservationSystemCode,omitempty"`

	// The field is not currently supported.
	//
	// Max Length: 32
	ReservationType string `json:"reservationType,omitempty"`

	// Text that describes the ticket limitations, such as _nonrefundable_.
	// Format: English characters only.
	// Optional request field.
	//
	// Max Length: 20
	RestrictedTicketDesciption string `json:"restrictedTicketDesciption,omitempty"`

	// Flag that indicates whether or not the ticket is restricted (nonrefundable).
	// Possible values:
	// - 0: No restriction (refundable)
	// - 1: Restricted (nonrefundable)
	// Format: English characters only.
	// Restricted string data type that indicates a sequence of letters, numbers, and spaces;
	// special characters are not included.
	// Optional request field.
	//
	RestrictedTicketIndicator int64 `json:"restrictedTicketIndicator,omitempty"`

	// Type of update.
	// Possible values:
	// - `C`: Change to the existing ticket.
	// - `N`: New ticket.
	// Format: English characters only
	// Optional request field.
	//
	// Max Length: 1
	TicketChangeIndicator string `json:"ticketChangeIndicator,omitempty"`

	// Date on which the transaction occurred.
	// Format: `YYYYMMDD`
	// Format: English characters only.
	// Optional request field.
	//
	// Max Length: 8
	TicketIssueDate string `json:"ticketIssueDate,omitempty"`

	// ticket issuer
	TicketIssuer *CreateCreditParamsBodyTravelInformationTransitAirlineTicketIssuer `json:"ticketIssuer,omitempty"`

	// Ticket number.
	// Format: English characters only.
	// Restricted string data type that indicates a sequence of letters, numbers, and spaces;
	// special characters are not included.
	// Optional request field.
	//
	// Max Length: 15
	TicketNumber string `json:"ticketNumber,omitempty"`

	// Total clearing amount for all transactions in the clearing count set.
	// This value cannot exceed `99999999999999999999` (twenty 9s).
	// Format: English characters only.
	// If this field is not set and if the total amount from the original authorization is not NULL,
	// the total clearing amount is set to the total amount from the original authorization.
	//
	// Max Length: 20
	TotalClearingAmount string `json:"totalClearingAmount,omitempty"`

	// Total fee for the ticket. This value cannot exceed `99999999999999999999` (twenty 9s).
	// Format: English characters only.
	// Optional request field.
	//
	// Max Length: 12
	TotalFeeAmount string `json:"totalFeeAmount,omitempty"`

	// Type of charge.
	// Possible values:
	// - 01: Charge is for an airline ticket
	// - 02: Charge is for an item that is not an airline ticket
	//
	TransactionType int64 `json:"transactionType,omitempty"`
}

// Validate validates this create credit params body travel information transit airline
func (o *CreateCreditParamsBodyTravelInformationTransitAirline) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAdditionalCharges(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAncillaryInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateArrivalDate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBoardingFeeAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBookingReferenceNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCarrierName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCheckDigit(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateClearingCount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateClearingSequence(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCreditReasonIndicator(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCustomerCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDocumentNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDocumentType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExchangeTicketAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExchangeTicketFeeAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExtendedPaymentCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateInvoiceNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLegs(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOriginalTicketNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePassengerName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePlanNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProcessIdentifier(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePurchaseType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateReservationSystemCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateReservationType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRestrictedTicketDesciption(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTicketChangeIndicator(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTicketIssueDate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTicketIssuer(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTicketNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTotalClearingAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTotalFeeAmount(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyTravelInformationTransitAirline) validateAdditionalCharges(formats strfmt.Registry) error {
	if swag.IsZero(o.AdditionalCharges) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"additionalCharges", "body", o.AdditionalCharges, 20); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationTransitAirline) validateAncillaryInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.AncillaryInformation) { // not required
		return nil
	}

	if o.AncillaryInformation != nil {
		if err := o.AncillaryInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "travelInformation" + "." + "transit" + "." + "airline" + "." + "ancillaryInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "travelInformation" + "." + "transit" + "." + "airline" + "." + "ancillaryInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationTransitAirline) validateArrivalDate(formats strfmt.Registry) error {
	if swag.IsZero(o.ArrivalDate) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"arrivalDate", "body", o.ArrivalDate, 8); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationTransitAirline) validateBoardingFeeAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.BoardingFeeAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"boardingFeeAmount", "body", o.BoardingFeeAmount, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationTransitAirline) validateBookingReferenceNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.BookingReferenceNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"bookingReferenceNumber", "body", o.BookingReferenceNumber, 15); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationTransitAirline) validateCarrierName(formats strfmt.Registry) error {
	if swag.IsZero(o.CarrierName) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"carrierName", "body", o.CarrierName, 15); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationTransitAirline) validateCheckDigit(formats strfmt.Registry) error {
	if swag.IsZero(o.CheckDigit) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"checkDigit", "body", o.CheckDigit, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationTransitAirline) validateClearingCount(formats strfmt.Registry) error {
	if swag.IsZero(o.ClearingCount) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"clearingCount", "body", o.ClearingCount, 2); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationTransitAirline) validateClearingSequence(formats strfmt.Registry) error {
	if swag.IsZero(o.ClearingSequence) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"clearingSequence", "body", o.ClearingSequence, 2); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationTransitAirline) validateCreditReasonIndicator(formats strfmt.Registry) error {
	if swag.IsZero(o.CreditReasonIndicator) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"creditReasonIndicator", "body", o.CreditReasonIndicator, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationTransitAirline) validateCustomerCode(formats strfmt.Registry) error {
	if swag.IsZero(o.CustomerCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"customerCode", "body", o.CustomerCode, 40); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationTransitAirline) validateDocumentNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.DocumentNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"documentNumber", "body", o.DocumentNumber, 14); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationTransitAirline) validateDocumentType(formats strfmt.Registry) error {
	if swag.IsZero(o.DocumentType) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"documentType", "body", o.DocumentType, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationTransitAirline) validateExchangeTicketAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.ExchangeTicketAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"exchangeTicketAmount", "body", o.ExchangeTicketAmount, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationTransitAirline) validateExchangeTicketFeeAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.ExchangeTicketFeeAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"exchangeTicketFeeAmount", "body", o.ExchangeTicketFeeAmount, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationTransitAirline) validateExtendedPaymentCode(formats strfmt.Registry) error {
	if swag.IsZero(o.ExtendedPaymentCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"extendedPaymentCode", "body", o.ExtendedPaymentCode, 3); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationTransitAirline) validateInvoiceNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.InvoiceNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"invoiceNumber", "body", o.InvoiceNumber, 25); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationTransitAirline) validateLegs(formats strfmt.Registry) error {
	if swag.IsZero(o.Legs) { // not required
		return nil
	}

	for i := 0; i < len(o.Legs); i++ {
		if swag.IsZero(o.Legs[i]) { // not required
			continue
		}

		if o.Legs[i] != nil {
			if err := o.Legs[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("createCreditRequest" + "." + "travelInformation" + "." + "transit" + "." + "airline" + "." + "legs" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("createCreditRequest" + "." + "travelInformation" + "." + "transit" + "." + "airline" + "." + "legs" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationTransitAirline) validateOriginalTicketNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.OriginalTicketNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"originalTicketNumber", "body", o.OriginalTicketNumber, 14); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationTransitAirline) validatePassengerName(formats strfmt.Registry) error {
	if swag.IsZero(o.PassengerName) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"passengerName", "body", o.PassengerName, 42); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationTransitAirline) validatePlanNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.PlanNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"planNumber", "body", o.PlanNumber, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationTransitAirline) validateProcessIdentifier(formats strfmt.Registry) error {
	if swag.IsZero(o.ProcessIdentifier) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"processIdentifier", "body", o.ProcessIdentifier, 3); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationTransitAirline) validatePurchaseType(formats strfmt.Registry) error {
	if swag.IsZero(o.PurchaseType) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"purchaseType", "body", o.PurchaseType, 3); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationTransitAirline) validateReservationSystemCode(formats strfmt.Registry) error {
	if swag.IsZero(o.ReservationSystemCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"reservationSystemCode", "body", o.ReservationSystemCode, 4); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationTransitAirline) validateReservationType(formats strfmt.Registry) error {
	if swag.IsZero(o.ReservationType) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"reservationType", "body", o.ReservationType, 32); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationTransitAirline) validateRestrictedTicketDesciption(formats strfmt.Registry) error {
	if swag.IsZero(o.RestrictedTicketDesciption) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"restrictedTicketDesciption", "body", o.RestrictedTicketDesciption, 20); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationTransitAirline) validateTicketChangeIndicator(formats strfmt.Registry) error {
	if swag.IsZero(o.TicketChangeIndicator) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"ticketChangeIndicator", "body", o.TicketChangeIndicator, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationTransitAirline) validateTicketIssueDate(formats strfmt.Registry) error {
	if swag.IsZero(o.TicketIssueDate) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"ticketIssueDate", "body", o.TicketIssueDate, 8); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationTransitAirline) validateTicketIssuer(formats strfmt.Registry) error {
	if swag.IsZero(o.TicketIssuer) { // not required
		return nil
	}

	if o.TicketIssuer != nil {
		if err := o.TicketIssuer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "travelInformation" + "." + "transit" + "." + "airline" + "." + "ticketIssuer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "travelInformation" + "." + "transit" + "." + "airline" + "." + "ticketIssuer")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationTransitAirline) validateTicketNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.TicketNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"ticketNumber", "body", o.TicketNumber, 15); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationTransitAirline) validateTotalClearingAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.TotalClearingAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"totalClearingAmount", "body", o.TotalClearingAmount, 20); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationTransitAirline) validateTotalFeeAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.TotalFeeAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"totalFeeAmount", "body", o.TotalFeeAmount, 12); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this create credit params body travel information transit airline based on the context it is used
func (o *CreateCreditParamsBodyTravelInformationTransitAirline) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateAncillaryInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateLegs(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateTicketIssuer(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyTravelInformationTransitAirline) contextValidateAncillaryInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.AncillaryInformation != nil {
		if err := o.AncillaryInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "travelInformation" + "." + "transit" + "." + "airline" + "." + "ancillaryInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "travelInformation" + "." + "transit" + "." + "airline" + "." + "ancillaryInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationTransitAirline) contextValidateLegs(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.Legs); i++ {

		if o.Legs[i] != nil {
			if err := o.Legs[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("createCreditRequest" + "." + "travelInformation" + "." + "transit" + "." + "airline" + "." + "legs" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("createCreditRequest" + "." + "travelInformation" + "." + "transit" + "." + "airline" + "." + "legs" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationTransitAirline) contextValidateTicketIssuer(ctx context.Context, formats strfmt.Registry) error {

	if o.TicketIssuer != nil {
		if err := o.TicketIssuer.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createCreditRequest" + "." + "travelInformation" + "." + "transit" + "." + "airline" + "." + "ticketIssuer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createCreditRequest" + "." + "travelInformation" + "." + "transit" + "." + "airline" + "." + "ticketIssuer")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditParamsBodyTravelInformationTransitAirline) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditParamsBodyTravelInformationTransitAirline) UnmarshalBinary(b []byte) error {
	var res CreateCreditParamsBodyTravelInformationTransitAirline
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditParamsBodyTravelInformationTransitAirlineAncillaryInformation create credit params body travel information transit airline ancillary information
swagger:model CreateCreditParamsBodyTravelInformationTransitAirlineAncillaryInformation
*/
type CreateCreditParamsBodyTravelInformationTransitAirlineAncillaryInformation struct {

	// Number for the airline ticket to which the ancillary purchase is connected.
	//
	// If this purchase has a connection or relationship to another purchase such as a baggage fee for a passenger transport ticket, this field must contain the ticket number for the other purchase.
	//
	// For a stand-alone purchase, the value for this field must be the same as the value for the `travelInformation.transit.airline.ancillaryInformation.ticketNumber` field.
	// **Important** This field is required in the U.S. in order for you to qualify for either the custom payment service (CPS) or the electronic interchange reimbursement fee (EIRF)
	// program.
	// Format: English characters only.
	// Optional request field for ancillary services.
	//
	// Max Length: 15
	ConnectedTicketNumber string `json:"connectedTicketNumber,omitempty"`

	// Reason for the credit.
	// Possible values:
	// - `A`: Cancellation of the ancillary passenger transport purchase.
	// - `B`: Cancellation of the airline ticket and the passenger transport ancillary purchase.
	// - `C`: Cancellation of the airline ticket.
	// - `O`: Other.
	// - `P`: Partial refund of the airline ticket.
	// Format: English characters only.
	// Optional field for ancillary services.
	//
	// Max Length: 15
	CreditReasonIndicator string `json:"creditReasonIndicator,omitempty"`

	// Name of the passenger. If the passengers name is not available, this value is the cardholders name. If neither the passengers name nor the cardholders name is available,
	// this value is a description of the ancillary purchase.
	// **Important** This field is required in the U.S. in order for you to qualify for either the custom payment service (CPS) or the electronic interchange reimbursement fee (EIRF)
	// program.
	// Format: English characters only.
	// Optional field for ancillary service.
	//
	// Max Length: 20
	PassengerName string `json:"passengerName,omitempty"`

	// service
	Service []*CreateCreditParamsBodyTravelInformationTransitAirlineAncillaryInformationServiceItems0 `json:"service"`

	// Ticket number, which consists of the carrier code, form, and serial number, without the check digit.
	// **Important** This field is required in the U.S. in order for you to qualify for either the
	// custom payment service (CPS) or the electronic interchange reimbursement fee (EIRF) program.
	// Format: English characters only.
	// Optional field for ancillary services.
	//
	// Max Length: 15
	TicketNumber string `json:"ticketNumber,omitempty"`
}

// Validate validates this create credit params body travel information transit airline ancillary information
func (o *CreateCreditParamsBodyTravelInformationTransitAirlineAncillaryInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateConnectedTicketNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCreditReasonIndicator(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePassengerName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateService(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTicketNumber(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyTravelInformationTransitAirlineAncillaryInformation) validateConnectedTicketNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.ConnectedTicketNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"ancillaryInformation"+"."+"connectedTicketNumber", "body", o.ConnectedTicketNumber, 15); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationTransitAirlineAncillaryInformation) validateCreditReasonIndicator(formats strfmt.Registry) error {
	if swag.IsZero(o.CreditReasonIndicator) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"ancillaryInformation"+"."+"creditReasonIndicator", "body", o.CreditReasonIndicator, 15); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationTransitAirlineAncillaryInformation) validatePassengerName(formats strfmt.Registry) error {
	if swag.IsZero(o.PassengerName) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"ancillaryInformation"+"."+"passengerName", "body", o.PassengerName, 20); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationTransitAirlineAncillaryInformation) validateService(formats strfmt.Registry) error {
	if swag.IsZero(o.Service) { // not required
		return nil
	}

	for i := 0; i < len(o.Service); i++ {
		if swag.IsZero(o.Service[i]) { // not required
			continue
		}

		if o.Service[i] != nil {
			if err := o.Service[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("createCreditRequest" + "." + "travelInformation" + "." + "transit" + "." + "airline" + "." + "ancillaryInformation" + "." + "service" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("createCreditRequest" + "." + "travelInformation" + "." + "transit" + "." + "airline" + "." + "ancillaryInformation" + "." + "service" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationTransitAirlineAncillaryInformation) validateTicketNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.TicketNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"ancillaryInformation"+"."+"ticketNumber", "body", o.TicketNumber, 15); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this create credit params body travel information transit airline ancillary information based on the context it is used
func (o *CreateCreditParamsBodyTravelInformationTransitAirlineAncillaryInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateService(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyTravelInformationTransitAirlineAncillaryInformation) contextValidateService(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.Service); i++ {

		if o.Service[i] != nil {
			if err := o.Service[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("createCreditRequest" + "." + "travelInformation" + "." + "transit" + "." + "airline" + "." + "ancillaryInformation" + "." + "service" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("createCreditRequest" + "." + "travelInformation" + "." + "transit" + "." + "airline" + "." + "ancillaryInformation" + "." + "service" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditParamsBodyTravelInformationTransitAirlineAncillaryInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditParamsBodyTravelInformationTransitAirlineAncillaryInformation) UnmarshalBinary(b []byte) error {
	var res CreateCreditParamsBodyTravelInformationTransitAirlineAncillaryInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditParamsBodyTravelInformationTransitAirlineAncillaryInformationServiceItems0 create credit params body travel information transit airline ancillary information service items0
swagger:model CreateCreditParamsBodyTravelInformationTransitAirlineAncillaryInformationServiceItems0
*/
type CreateCreditParamsBodyTravelInformationTransitAirlineAncillaryInformationServiceItems0 struct {

	// Category code for the ancillary service that is provided. Obtain the codes from the International
	// Air Transport Association (IATA).
	// **Note** `#` is either 0, 1, 2, or 3.
	// **Important** This field is required in the U.S. in order for you to qualify for either the custom
	// payment service (CPS) or the electronic interchange reimbursement fee (EIRF)program.
	// Format: English characters only.
	// Optional request field for ancillary services.
	//
	// Max Length: 4
	CategoryCode string `json:"categoryCode,omitempty"`

	// Subcategory code for the ancillary service category. Obtain the codes from the International
	// Air Transport Association (IATA).
	// **Note** `#` is either 0, 1, 2, or 3.
	// Format  English characters only.
	// Optional request field for ancillary services.
	//
	// Max Length: 4
	SubCategoryCode string `json:"subCategoryCode,omitempty"`
}

// Validate validates this create credit params body travel information transit airline ancillary information service items0
func (o *CreateCreditParamsBodyTravelInformationTransitAirlineAncillaryInformationServiceItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCategoryCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSubCategoryCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyTravelInformationTransitAirlineAncillaryInformationServiceItems0) validateCategoryCode(formats strfmt.Registry) error {
	if swag.IsZero(o.CategoryCode) { // not required
		return nil
	}

	if err := validate.MaxLength("categoryCode", "body", o.CategoryCode, 4); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationTransitAirlineAncillaryInformationServiceItems0) validateSubCategoryCode(formats strfmt.Registry) error {
	if swag.IsZero(o.SubCategoryCode) { // not required
		return nil
	}

	if err := validate.MaxLength("subCategoryCode", "body", o.SubCategoryCode, 4); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create credit params body travel information transit airline ancillary information service items0 based on context it is used
func (o *CreateCreditParamsBodyTravelInformationTransitAirlineAncillaryInformationServiceItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditParamsBodyTravelInformationTransitAirlineAncillaryInformationServiceItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditParamsBodyTravelInformationTransitAirlineAncillaryInformationServiceItems0) UnmarshalBinary(b []byte) error {
	var res CreateCreditParamsBodyTravelInformationTransitAirlineAncillaryInformationServiceItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditParamsBodyTravelInformationTransitAirlineLegsItems0 create credit params body travel information transit airline legs items0
swagger:model CreateCreditParamsBodyTravelInformationTransitAirlineLegsItems0
*/
type CreateCreditParamsBodyTravelInformationTransitAirlineLegsItems0 struct {

	// Time of arrival for this leg of the trip.
	// The format is military time and HHMM:
	// If not all zeros, then the hours must be `00-23` and the minutes must be `00-59`
	// Format: English characters only.
	// Optional request field for travel legs.
	//
	ArrivalTime int64 `json:"arrivalTime,omitempty"`

	// AM or PM for the arrival time for this leg of the trip.
	// Possible values:
	// - `A`: 12:00 midnight to 11:59 a.m.
	// - `P`: 12:00 noon to 11:59 p.m.
	// Format: English characters only.
	// Restricted string data type that indicates a sequence of letters, numbers, and spaces; special characters are not included.
	// Optional request field for travel legs.
	//
	// Max Length: 1
	ArrivalTimeMeridian string `json:"arrivalTimeMeridian,omitempty"`

	// IATA code for the carrier for this leg of the trip.
	// Format: English characters only.
	// Restricted string data type that indicates a sequence of letters, numbers, and spaces; special characters are not included.
	// Optional request field for travel legs.
	//
	// Max Length: 4
	CarrierCode string `json:"carrierCode,omitempty"`

	// IATA code for the class of service for this leg of the trip.
	// Format: English characters only.
	// Restricted string data type that indicates a sequence of letters, numbers, and spaces; special characters are not included.
	// Optional request field for travel legs.
	//
	// Max Length: 3
	Class string `json:"class,omitempty"`

	// Ticket that contains additional coupons for this leg of the trip on an itinerary that has more than four segments.
	// Format: English characters only.
	// Restricted string data type that indicates a sequence of letters, numbers, and spaces; special characters are not included.
	// Optional request field for travel legs.
	//
	// Max Length: 25
	ConjunctionTicket string `json:"conjunctionTicket,omitempty"`

	// Coupon number. Each leg on the ticket requires a separate coupon, and each coupon is identified by the coupon number.
	// Format: English characters only.
	// Restricted string data type that indicates a sequence of letters, numbers, and spaces; special characters are not included.
	// Optional request field for travel legs.
	//
	// Max Length: 1
	CouponNumber string `json:"couponNumber,omitempty"`

	// Amount of departure tax for this leg of the trip.
	//
	// Max Length: 12
	DepartTaxAmount string `json:"departTaxAmount,omitempty"`

	// Departure date for the first leg of the trip.
	// Format: `YYYYMMDD`.
	// Format: English characters only.
	// Optional request field for travel legs.
	//
	DepartureDate int64 `json:"departureDate,omitempty"`

	// Time of departure for this leg of the trip. The format is military time and HHMM:
	// If not all zeros, then the hours must be `00-23` and the minutes must be `00-59`.
	// Format: English characters only.
	// Optional request field for travel legs.
	//
	DepartureTime int64 `json:"departureTime,omitempty"`

	// AM or PM for the departure time.
	// Possible values:
	// - A: 12:00 midnight to 11:59 a.m.
	// - P: 12:00 noon to 11:59 p.m
	// Format: English characters only.
	// Restricted string data type that indicates a sequence of letters, numbers, and spaces; special characters are not included.
	// Optional request field for travel legs.
	//
	// Max Length: 1
	DepartureTimeMeridian string `json:"departureTimeMeridian,omitempty"`

	// IATA code for the destination airport for this leg of the trip.
	// Format: English characters only.
	// Restricted string data type that indicates a sequence of letters, numbers, and spaces; special characters are not included.
	// Optional request field for travel legs.
	//
	// Max Length: 3
	DestinationAirportCode string `json:"destinationAirportCode,omitempty"`

	// Notes or notations about endorsements and restrictions for this leg of the trip.
	// Endorsements can be notations added by the travel agency, including mandatory government-required notations such as value added tax.
	// Restrictions are limitations for the ticket based on the type of fare, such as a nonrefundable ticket or a 3-day minimum stay.
	// Format: English characters only.
	// Optional request field for travel legs.
	//
	// Max Length: 20
	EndorsementsRestrictions string `json:"endorsementsRestrictions,omitempty"`

	// New ticket number that is issued when the ticket is exchanged for this leg of the trip.
	// Restrictions are limitations for the ticket based on the type of fare, such as a nonrefundable ticket or a 3-day minimum stay.
	// Format: English characters only.
	// Optional request field for travel legs.
	//
	// Max Length: 25
	ExchangeTicketNumber string `json:"exchangeTicketNumber,omitempty"`

	// Code for the fare basis for this leg of the trip.
	// The fare basis is assigned by the carriers and indicates a particular ticket type,
	// such as business class or discounted/nonrefundable.
	// Restricted string data type that indicates a sequence of letters, numbers, and spaces; special characters are not included.
	// Format: English characters only.
	// Optional request field for travel legs.auto_rental_regular_mileage_cost
	//
	// Max Length: 15
	FareBasis string `json:"fareBasis,omitempty"`

	// Fee for this leg of the trip, such as an airport fee or country fee.
	// Format: English characters only.
	// Optional request field for travel legs.
	//
	// Max Length: 12
	FeeAmount string `json:"feeAmount,omitempty"`

	// Flight number for this leg of the trip.
	// Restrictions are limitations for the ticket based on the type of fare, such as a nonrefundable ticket or a 3-day minimum stay.
	// Format: English characters only.
	// Optional request field for travel legs.
	//
	// Max Length: 6
	FlightNumber string `json:"flightNumber,omitempty"`

	// IATA code for the originating airport for this leg of the trip.
	// Format: English characters only.
	// Restricted string data type that indicates a sequence of letters, numbers, and spaces; special characters are not included.
	// Optional request field for travel legs.
	//
	// Max Length: 5
	OriginatingAirportCode string `json:"originatingAirportCode,omitempty"`

	// Code that indicates whether a stopover is allowed on this leg of the trip. Possible values:
	// - `O` (capital letter O) (default): Stopover allowed
	// - `X` (capital letter X): Stopover not allowed
	// Format: English characters only.
	// Restricted string data type that indicates a sequence of letters, numbers, and spaces; special characters are not included.
	// Optional request field for travel legs.
	//
	StopoverIndicator int64 `json:"stopoverIndicator,omitempty"`

	// Tax for this leg of the trip.
	// Format: English characters only.
	// Optional request field for travel legs.
	//
	// Max Length: 12
	TaxAmount string `json:"taxAmount,omitempty"`

	// Total fare for this leg of the trip.
	// Format: English characters only.
	// Optional request field for travel legs.
	//
	// Max Length: 15
	TotalFareAmount string `json:"totalFareAmount,omitempty"`
}

// Validate validates this create credit params body travel information transit airline legs items0
func (o *CreateCreditParamsBodyTravelInformationTransitAirlineLegsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateArrivalTimeMeridian(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCarrierCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateClass(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateConjunctionTicket(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCouponNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDepartTaxAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDepartureTimeMeridian(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDestinationAirportCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEndorsementsRestrictions(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExchangeTicketNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFareBasis(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFeeAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFlightNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOriginatingAirportCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTotalFareAmount(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyTravelInformationTransitAirlineLegsItems0) validateArrivalTimeMeridian(formats strfmt.Registry) error {
	if swag.IsZero(o.ArrivalTimeMeridian) { // not required
		return nil
	}

	if err := validate.MaxLength("arrivalTimeMeridian", "body", o.ArrivalTimeMeridian, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationTransitAirlineLegsItems0) validateCarrierCode(formats strfmt.Registry) error {
	if swag.IsZero(o.CarrierCode) { // not required
		return nil
	}

	if err := validate.MaxLength("carrierCode", "body", o.CarrierCode, 4); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationTransitAirlineLegsItems0) validateClass(formats strfmt.Registry) error {
	if swag.IsZero(o.Class) { // not required
		return nil
	}

	if err := validate.MaxLength("class", "body", o.Class, 3); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationTransitAirlineLegsItems0) validateConjunctionTicket(formats strfmt.Registry) error {
	if swag.IsZero(o.ConjunctionTicket) { // not required
		return nil
	}

	if err := validate.MaxLength("conjunctionTicket", "body", o.ConjunctionTicket, 25); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationTransitAirlineLegsItems0) validateCouponNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.CouponNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("couponNumber", "body", o.CouponNumber, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationTransitAirlineLegsItems0) validateDepartTaxAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.DepartTaxAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("departTaxAmount", "body", o.DepartTaxAmount, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationTransitAirlineLegsItems0) validateDepartureTimeMeridian(formats strfmt.Registry) error {
	if swag.IsZero(o.DepartureTimeMeridian) { // not required
		return nil
	}

	if err := validate.MaxLength("departureTimeMeridian", "body", o.DepartureTimeMeridian, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationTransitAirlineLegsItems0) validateDestinationAirportCode(formats strfmt.Registry) error {
	if swag.IsZero(o.DestinationAirportCode) { // not required
		return nil
	}

	if err := validate.MaxLength("destinationAirportCode", "body", o.DestinationAirportCode, 3); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationTransitAirlineLegsItems0) validateEndorsementsRestrictions(formats strfmt.Registry) error {
	if swag.IsZero(o.EndorsementsRestrictions) { // not required
		return nil
	}

	if err := validate.MaxLength("endorsementsRestrictions", "body", o.EndorsementsRestrictions, 20); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationTransitAirlineLegsItems0) validateExchangeTicketNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.ExchangeTicketNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("exchangeTicketNumber", "body", o.ExchangeTicketNumber, 25); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationTransitAirlineLegsItems0) validateFareBasis(formats strfmt.Registry) error {
	if swag.IsZero(o.FareBasis) { // not required
		return nil
	}

	if err := validate.MaxLength("fareBasis", "body", o.FareBasis, 15); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationTransitAirlineLegsItems0) validateFeeAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.FeeAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("feeAmount", "body", o.FeeAmount, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationTransitAirlineLegsItems0) validateFlightNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.FlightNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("flightNumber", "body", o.FlightNumber, 6); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationTransitAirlineLegsItems0) validateOriginatingAirportCode(formats strfmt.Registry) error {
	if swag.IsZero(o.OriginatingAirportCode) { // not required
		return nil
	}

	if err := validate.MaxLength("originatingAirportCode", "body", o.OriginatingAirportCode, 5); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationTransitAirlineLegsItems0) validateTaxAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.TaxAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("taxAmount", "body", o.TaxAmount, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationTransitAirlineLegsItems0) validateTotalFareAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.TotalFareAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("totalFareAmount", "body", o.TotalFareAmount, 15); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create credit params body travel information transit airline legs items0 based on context it is used
func (o *CreateCreditParamsBodyTravelInformationTransitAirlineLegsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditParamsBodyTravelInformationTransitAirlineLegsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditParamsBodyTravelInformationTransitAirlineLegsItems0) UnmarshalBinary(b []byte) error {
	var res CreateCreditParamsBodyTravelInformationTransitAirlineLegsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreateCreditParamsBodyTravelInformationTransitAirlineTicketIssuer create credit params body travel information transit airline ticket issuer
swagger:model CreateCreditParamsBodyTravelInformationTransitAirlineTicketIssuer
*/
type CreateCreditParamsBodyTravelInformationTransitAirlineTicketIssuer struct {

	// Address of the company issuing the ticket.
	//
	// Max Length: 16
	Address string `json:"address,omitempty"`

	// State in which transaction occured.
	//
	// Max Length: 18
	AdministrativeArea string `json:"administrativeArea,omitempty"`

	// IATA2 airline code.
	// Format: English characters only.
	// Required for Mastercard; optional for all other card types.
	//
	// Max Length: 4
	Code string `json:"code,omitempty"`

	// Country in which transaction occured.
	//
	// Max Length: 18
	Country string `json:"country,omitempty"`

	// City in which the transaction occurred.
	// If the name of the city exceeds 18 characters, use meaningful abbreviations.
	// Format: English characters only.
	// Optional request field.
	//
	// Max Length: 18
	Locality string `json:"locality,omitempty"`

	// Name of the ticket issuer. If you do not include this field,
	// CyberSource uses the value for your merchant name that is in the CyberSource merchant configuration database.
	//
	// Max Length: 20
	Name string `json:"name,omitempty"`

	// Zip code of the city in which transaction occured.
	//
	// Max Length: 15
	PostalCode string `json:"postalCode,omitempty"`
}

// Validate validates this create credit params body travel information transit airline ticket issuer
func (o *CreateCreditParamsBodyTravelInformationTransitAirlineTicketIssuer) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAddress(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAdministrativeArea(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocality(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreateCreditParamsBodyTravelInformationTransitAirlineTicketIssuer) validateAddress(formats strfmt.Registry) error {
	if swag.IsZero(o.Address) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"ticketIssuer"+"."+"address", "body", o.Address, 16); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationTransitAirlineTicketIssuer) validateAdministrativeArea(formats strfmt.Registry) error {
	if swag.IsZero(o.AdministrativeArea) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"ticketIssuer"+"."+"administrativeArea", "body", o.AdministrativeArea, 18); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationTransitAirlineTicketIssuer) validateCode(formats strfmt.Registry) error {
	if swag.IsZero(o.Code) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"ticketIssuer"+"."+"code", "body", o.Code, 4); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationTransitAirlineTicketIssuer) validateCountry(formats strfmt.Registry) error {
	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"ticketIssuer"+"."+"country", "body", o.Country, 18); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationTransitAirlineTicketIssuer) validateLocality(formats strfmt.Registry) error {
	if swag.IsZero(o.Locality) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"ticketIssuer"+"."+"locality", "body", o.Locality, 18); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationTransitAirlineTicketIssuer) validateName(formats strfmt.Registry) error {
	if swag.IsZero(o.Name) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"ticketIssuer"+"."+"name", "body", o.Name, 20); err != nil {
		return err
	}

	return nil
}

func (o *CreateCreditParamsBodyTravelInformationTransitAirlineTicketIssuer) validatePostalCode(formats strfmt.Registry) error {
	if swag.IsZero(o.PostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createCreditRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"ticketIssuer"+"."+"postalCode", "body", o.PostalCode, 15); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create credit params body travel information transit airline ticket issuer based on context it is used
func (o *CreateCreditParamsBodyTravelInformationTransitAirlineTicketIssuer) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreateCreditParamsBodyTravelInformationTransitAirlineTicketIssuer) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreateCreditParamsBodyTravelInformationTransitAirlineTicketIssuer) UnmarshalBinary(b []byte) error {
	var res CreateCreditParamsBodyTravelInformationTransitAirlineTicketIssuer
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}
