// Code generated by go-swagger; DO NOT EDIT.

package payments

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"fmt"
	"io"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// IncrementAuthReader is a Reader for the IncrementAuth structure.
type IncrementAuthReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *IncrementAuthReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 201:
		result := NewIncrementAuthCreated()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	case 400:
		result := NewIncrementAuthBadRequest()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 502:
		result := NewIncrementAuthBadGateway()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	default:
		return nil, runtime.NewAPIError("response status code does not match any response statuses defined for this endpoint in the swagger spec", response, response.Code())
	}
}

// NewIncrementAuthCreated creates a IncrementAuthCreated with default headers values
func NewIncrementAuthCreated() *IncrementAuthCreated {
	return &IncrementAuthCreated{}
}

/* IncrementAuthCreated describes a response with status code 201, with default header values.

Successful response.
*/
type IncrementAuthCreated struct {
	Payload *IncrementAuthCreatedBody
}

func (o *IncrementAuthCreated) Error() string {
	return fmt.Sprintf("[PATCH /pts/v2/payments/{id}][%d] incrementAuthCreated  %+v", 201, o.Payload)
}
func (o *IncrementAuthCreated) GetPayload() *IncrementAuthCreatedBody {
	return o.Payload
}

func (o *IncrementAuthCreated) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(IncrementAuthCreatedBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewIncrementAuthBadRequest creates a IncrementAuthBadRequest with default headers values
func NewIncrementAuthBadRequest() *IncrementAuthBadRequest {
	return &IncrementAuthBadRequest{}
}

/* IncrementAuthBadRequest describes a response with status code 400, with default header values.

Invalid request.
*/
type IncrementAuthBadRequest struct {
	Payload *IncrementAuthBadRequestBody
}

func (o *IncrementAuthBadRequest) Error() string {
	return fmt.Sprintf("[PATCH /pts/v2/payments/{id}][%d] incrementAuthBadRequest  %+v", 400, o.Payload)
}
func (o *IncrementAuthBadRequest) GetPayload() *IncrementAuthBadRequestBody {
	return o.Payload
}

func (o *IncrementAuthBadRequest) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(IncrementAuthBadRequestBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewIncrementAuthBadGateway creates a IncrementAuthBadGateway with default headers values
func NewIncrementAuthBadGateway() *IncrementAuthBadGateway {
	return &IncrementAuthBadGateway{}
}

/* IncrementAuthBadGateway describes a response with status code 502, with default header values.

Unexpected system error or system timeout.
*/
type IncrementAuthBadGateway struct {
	Payload *IncrementAuthBadGatewayBody
}

func (o *IncrementAuthBadGateway) Error() string {
	return fmt.Sprintf("[PATCH /pts/v2/payments/{id}][%d] incrementAuthBadGateway  %+v", 502, o.Payload)
}
func (o *IncrementAuthBadGateway) GetPayload() *IncrementAuthBadGatewayBody {
	return o.Payload
}

func (o *IncrementAuthBadGateway) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(IncrementAuthBadGatewayBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

/*IncrementAuthBadGatewayBody ptsV2IncrementalAuthorizationPatch502Response
swagger:model IncrementAuthBadGatewayBody
*/
type IncrementAuthBadGatewayBody struct {

	// The detail message related to the status and reason listed above.
	Message string `json:"message,omitempty"`

	// The reason of the status.
	//
	// Possible values:
	//  - SYSTEM_ERROR
	//  - SERVER_TIMEOUT
	//  - SERVICE_TIMEOUT
	//
	Reason string `json:"reason,omitempty"`

	// The status of the submitted transaction.
	//
	// Possible values:
	//  - SERVER_ERROR
	//
	Status string `json:"status,omitempty"`

	// Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ`
	// **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.).
	// The `T` separates the date and the time. The `Z` indicates UTC.
	//
	// Returned by Cybersource for all services.
	//
	SubmitTimeUtc string `json:"submitTimeUtc,omitempty"`
}

// Validate validates this increment auth bad gateway body
func (o *IncrementAuthBadGatewayBody) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this increment auth bad gateway body based on context it is used
func (o *IncrementAuthBadGatewayBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *IncrementAuthBadGatewayBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *IncrementAuthBadGatewayBody) UnmarshalBinary(b []byte) error {
	var res IncrementAuthBadGatewayBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*IncrementAuthBadRequestBody ptsV2IncrementalAuthorizationPatch400Response
swagger:model IncrementAuthBadRequestBody
*/
type IncrementAuthBadRequestBody struct {

	// details
	Details []*IncrementAuthBadRequestBodyDetailsItems0 `json:"details"`

	// The detail message related to the status and reason listed above.
	Message string `json:"message,omitempty"`

	// The reason of the status.
	//
	// Possible values:
	//  - MISSING_FIELD
	//  - INVALID_DATA
	//  - DUPLICATE_REQUEST
	//  - INVALID_CARD
	//  - CARD_TYPE_NOT_ACCEPTED
	//  - INVALID_MERCHANT_CONFIGURATION
	//  - PROCESSOR_UNAVAILABLE
	//  - INVALID_PAYMENT_ID
	//
	Reason string `json:"reason,omitempty"`

	// The status of the submitted transaction.
	//
	// Possible values:
	//  - INVALID_REQUEST
	//
	Status string `json:"status,omitempty"`

	// Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ`
	// **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.).
	// The `T` separates the date and the time. The `Z` indicates UTC.
	//
	// Returned by Cybersource for all services.
	//
	SubmitTimeUtc string `json:"submitTimeUtc,omitempty"`
}

// Validate validates this increment auth bad request body
func (o *IncrementAuthBadRequestBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *IncrementAuthBadRequestBody) validateDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.Details) { // not required
		return nil
	}

	for i := 0; i < len(o.Details); i++ {
		if swag.IsZero(o.Details[i]) { // not required
			continue
		}

		if o.Details[i] != nil {
			if err := o.Details[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("incrementAuthBadRequest" + "." + "details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("incrementAuthBadRequest" + "." + "details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this increment auth bad request body based on the context it is used
func (o *IncrementAuthBadRequestBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *IncrementAuthBadRequestBody) contextValidateDetails(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.Details); i++ {

		if o.Details[i] != nil {
			if err := o.Details[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("incrementAuthBadRequest" + "." + "details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("incrementAuthBadRequest" + "." + "details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *IncrementAuthBadRequestBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *IncrementAuthBadRequestBody) UnmarshalBinary(b []byte) error {
	var res IncrementAuthBadRequestBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*IncrementAuthBadRequestBodyDetailsItems0 increment auth bad request body details items0
swagger:model IncrementAuthBadRequestBodyDetailsItems0
*/
type IncrementAuthBadRequestBodyDetailsItems0 struct {

	// This is the flattened JSON object field name/path that is either missing or invalid.
	Field string `json:"field,omitempty"`

	// Possible reasons for the error.
	//
	// Possible values:
	//  - MISSING_FIELD
	//  - INVALID_DATA
	//
	Reason string `json:"reason,omitempty"`
}

// Validate validates this increment auth bad request body details items0
func (o *IncrementAuthBadRequestBodyDetailsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this increment auth bad request body details items0 based on context it is used
func (o *IncrementAuthBadRequestBodyDetailsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *IncrementAuthBadRequestBodyDetailsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *IncrementAuthBadRequestBodyDetailsItems0) UnmarshalBinary(b []byte) error {
	var res IncrementAuthBadRequestBodyDetailsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*IncrementAuthBody increment auth body
// Example: {"clientReferenceInformation":{"code":"TC50171_3"},"merchantInformation":{"transactionLocalDateTime":20191002080000},"orderInformation":{"amountDetails":{"additionalAmount":"22.49","currency":"USD"}},"processingInformation":{"authorizationOptions":{"initiator":{"storedCredentialUsed":true}}},"travelInformation":{"duration":"4"}}
swagger:model IncrementAuthBody
*/
type IncrementAuthBody struct {

	// client reference information
	ClientReferenceInformation *IncrementAuthParamsBodyClientReferenceInformation `json:"clientReferenceInformation,omitempty"`

	// merchant information
	MerchantInformation *IncrementAuthParamsBodyMerchantInformation `json:"merchantInformation,omitempty"`

	// order information
	OrderInformation *IncrementAuthParamsBodyOrderInformation `json:"orderInformation,omitempty"`

	// processing information
	ProcessingInformation *IncrementAuthParamsBodyProcessingInformation `json:"processingInformation,omitempty"`

	// travel information
	TravelInformation *IncrementAuthParamsBodyTravelInformation `json:"travelInformation,omitempty"`
}

// Validate validates this increment auth body
func (o *IncrementAuthBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateClientReferenceInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMerchantInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOrderInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProcessingInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTravelInformation(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *IncrementAuthBody) validateClientReferenceInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ClientReferenceInformation) { // not required
		return nil
	}

	if o.ClientReferenceInformation != nil {
		if err := o.ClientReferenceInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthRequest" + "." + "clientReferenceInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthRequest" + "." + "clientReferenceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *IncrementAuthBody) validateMerchantInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.MerchantInformation) { // not required
		return nil
	}

	if o.MerchantInformation != nil {
		if err := o.MerchantInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthRequest" + "." + "merchantInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthRequest" + "." + "merchantInformation")
			}
			return err
		}
	}

	return nil
}

func (o *IncrementAuthBody) validateOrderInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.OrderInformation) { // not required
		return nil
	}

	if o.OrderInformation != nil {
		if err := o.OrderInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthRequest" + "." + "orderInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthRequest" + "." + "orderInformation")
			}
			return err
		}
	}

	return nil
}

func (o *IncrementAuthBody) validateProcessingInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ProcessingInformation) { // not required
		return nil
	}

	if o.ProcessingInformation != nil {
		if err := o.ProcessingInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthRequest" + "." + "processingInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthRequest" + "." + "processingInformation")
			}
			return err
		}
	}

	return nil
}

func (o *IncrementAuthBody) validateTravelInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.TravelInformation) { // not required
		return nil
	}

	if o.TravelInformation != nil {
		if err := o.TravelInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthRequest" + "." + "travelInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthRequest" + "." + "travelInformation")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this increment auth body based on the context it is used
func (o *IncrementAuthBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateClientReferenceInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateMerchantInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateOrderInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateProcessingInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateTravelInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *IncrementAuthBody) contextValidateClientReferenceInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ClientReferenceInformation != nil {
		if err := o.ClientReferenceInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthRequest" + "." + "clientReferenceInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthRequest" + "." + "clientReferenceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *IncrementAuthBody) contextValidateMerchantInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.MerchantInformation != nil {
		if err := o.MerchantInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthRequest" + "." + "merchantInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthRequest" + "." + "merchantInformation")
			}
			return err
		}
	}

	return nil
}

func (o *IncrementAuthBody) contextValidateOrderInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.OrderInformation != nil {
		if err := o.OrderInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthRequest" + "." + "orderInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthRequest" + "." + "orderInformation")
			}
			return err
		}
	}

	return nil
}

func (o *IncrementAuthBody) contextValidateProcessingInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ProcessingInformation != nil {
		if err := o.ProcessingInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthRequest" + "." + "processingInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthRequest" + "." + "processingInformation")
			}
			return err
		}
	}

	return nil
}

func (o *IncrementAuthBody) contextValidateTravelInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.TravelInformation != nil {
		if err := o.TravelInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthRequest" + "." + "travelInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthRequest" + "." + "travelInformation")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *IncrementAuthBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *IncrementAuthBody) UnmarshalBinary(b []byte) error {
	var res IncrementAuthBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*IncrementAuthCreatedBody ptsV2IncrementalAuthorizationPatch201Response
// Example: {"_links":{"self":{"href":"/pts/v2/payments/4963015972176007901546","method":"GET"}},"clientReferenceInformation":{"code":"TC50171_3"},"id":"4963015972176007901546","orderInformation":{"amountDetails":{"authorizedAmount":"22.49","currency":"USD"}},"processorInformation":{"approvalCode":"888888","responseCode":"100"},"reconciliationId":"39570726X3E1LBQR","status":"200","submitTimeUtc":"2017-06-01T071957Z"}
swagger:model IncrementAuthCreatedBody
*/
type IncrementAuthCreatedBody struct {

	// links
	Links *IncrementAuthCreatedBodyLinks `json:"_links,omitempty"`

	// client reference information
	ClientReferenceInformation *IncrementAuthCreatedBodyClientReferenceInformation `json:"clientReferenceInformation,omitempty"`

	// error information
	ErrorInformation *IncrementAuthCreatedBodyErrorInformation `json:"errorInformation,omitempty"`

	// An unique identification number generated by Cybersource to identify the submitted request. Returned by all services.
	// It is also appended to the endpoint of the resource.
	// On incremental authorizations, this value with be the same as the identification number returned in the original authorization response.
	//
	// Max Length: 26
	ID string `json:"id,omitempty"`

	// order information
	OrderInformation *IncrementAuthCreatedBodyOrderInformation `json:"orderInformation,omitempty"`

	// payment information
	PaymentInformation *IncrementAuthCreatedBodyPaymentInformation `json:"paymentInformation,omitempty"`

	// processor information
	ProcessorInformation *IncrementAuthCreatedBodyProcessorInformation `json:"processorInformation,omitempty"`

	// Reference number for the transaction.
	// Depending on how your Cybersource account is configured, this value could either be provided in the API request or generated by CyberSource.
	// The actual value used in the request to the processor is provided back to you by Cybersource in the response.
	//
	// Max Length: 60
	ReconciliationID string `json:"reconciliationId,omitempty"`

	// The status of the submitted transaction.
	//
	// Possible values:
	//  - AUTHORIZED
	//  - AUTHORIZED_PENDING_REVIEW
	//  - DECLINED
	//
	Status string `json:"status,omitempty"`

	// Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ`
	// **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.).
	// The `T` separates the date and the time. The `Z` indicates UTC.
	//
	// Returned by Cybersource for all services.
	//
	SubmitTimeUtc string `json:"submitTimeUtc,omitempty"`
}

// Validate validates this increment auth created body
func (o *IncrementAuthCreatedBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateClientReferenceInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateErrorInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOrderInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePaymentInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProcessorInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateReconciliationID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *IncrementAuthCreatedBody) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(o.Links) { // not required
		return nil
	}

	if o.Links != nil {
		if err := o.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthCreated" + "." + "_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthCreated" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (o *IncrementAuthCreatedBody) validateClientReferenceInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ClientReferenceInformation) { // not required
		return nil
	}

	if o.ClientReferenceInformation != nil {
		if err := o.ClientReferenceInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthCreated" + "." + "clientReferenceInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthCreated" + "." + "clientReferenceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *IncrementAuthCreatedBody) validateErrorInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ErrorInformation) { // not required
		return nil
	}

	if o.ErrorInformation != nil {
		if err := o.ErrorInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthCreated" + "." + "errorInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthCreated" + "." + "errorInformation")
			}
			return err
		}
	}

	return nil
}

func (o *IncrementAuthCreatedBody) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MaxLength("incrementAuthCreated"+"."+"id", "body", o.ID, 26); err != nil {
		return err
	}

	return nil
}

func (o *IncrementAuthCreatedBody) validateOrderInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.OrderInformation) { // not required
		return nil
	}

	if o.OrderInformation != nil {
		if err := o.OrderInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthCreated" + "." + "orderInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthCreated" + "." + "orderInformation")
			}
			return err
		}
	}

	return nil
}

func (o *IncrementAuthCreatedBody) validatePaymentInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.PaymentInformation) { // not required
		return nil
	}

	if o.PaymentInformation != nil {
		if err := o.PaymentInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthCreated" + "." + "paymentInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthCreated" + "." + "paymentInformation")
			}
			return err
		}
	}

	return nil
}

func (o *IncrementAuthCreatedBody) validateProcessorInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ProcessorInformation) { // not required
		return nil
	}

	if o.ProcessorInformation != nil {
		if err := o.ProcessorInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthCreated" + "." + "processorInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthCreated" + "." + "processorInformation")
			}
			return err
		}
	}

	return nil
}

func (o *IncrementAuthCreatedBody) validateReconciliationID(formats strfmt.Registry) error {
	if swag.IsZero(o.ReconciliationID) { // not required
		return nil
	}

	if err := validate.MaxLength("incrementAuthCreated"+"."+"reconciliationId", "body", o.ReconciliationID, 60); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this increment auth created body based on the context it is used
func (o *IncrementAuthCreatedBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateClientReferenceInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateErrorInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateOrderInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidatePaymentInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateProcessorInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *IncrementAuthCreatedBody) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if o.Links != nil {
		if err := o.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthCreated" + "." + "_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthCreated" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (o *IncrementAuthCreatedBody) contextValidateClientReferenceInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ClientReferenceInformation != nil {
		if err := o.ClientReferenceInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthCreated" + "." + "clientReferenceInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthCreated" + "." + "clientReferenceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *IncrementAuthCreatedBody) contextValidateErrorInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ErrorInformation != nil {
		if err := o.ErrorInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthCreated" + "." + "errorInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthCreated" + "." + "errorInformation")
			}
			return err
		}
	}

	return nil
}

func (o *IncrementAuthCreatedBody) contextValidateOrderInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.OrderInformation != nil {
		if err := o.OrderInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthCreated" + "." + "orderInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthCreated" + "." + "orderInformation")
			}
			return err
		}
	}

	return nil
}

func (o *IncrementAuthCreatedBody) contextValidatePaymentInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.PaymentInformation != nil {
		if err := o.PaymentInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthCreated" + "." + "paymentInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthCreated" + "." + "paymentInformation")
			}
			return err
		}
	}

	return nil
}

func (o *IncrementAuthCreatedBody) contextValidateProcessorInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ProcessorInformation != nil {
		if err := o.ProcessorInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthCreated" + "." + "processorInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthCreated" + "." + "processorInformation")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *IncrementAuthCreatedBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *IncrementAuthCreatedBody) UnmarshalBinary(b []byte) error {
	var res IncrementAuthCreatedBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*IncrementAuthCreatedBodyClientReferenceInformation increment auth created body client reference information
swagger:model IncrementAuthCreatedBodyClientReferenceInformation
*/
type IncrementAuthCreatedBodyClientReferenceInformation struct {

	// Merchant-generated order reference or tracking number. It is recommended that you send a unique value for each
	// transaction so that you can perform meaningful searches for the transaction.
	//
	// #### Used by
	// **Authorization**
	// Required field.
	//
	// #### PIN Debit
	// Requests for PIN debit reversals need to use the same merchant reference number that was used in the transaction that is being
	// reversed.
	//
	// Required field for all PIN Debit requests (purchase, credit, and reversal).
	//
	// #### FDC Nashville Global
	// Certain circumstances can cause the processor to truncate this value to 15 or 17 characters for Level II and Level III processing, which can cause a discrepancy between the value you submit and the value included in some processor reports.
	//
	// Max Length: 50
	Code string `json:"code,omitempty"`
}

// Validate validates this increment auth created body client reference information
func (o *IncrementAuthCreatedBodyClientReferenceInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *IncrementAuthCreatedBodyClientReferenceInformation) validateCode(formats strfmt.Registry) error {
	if swag.IsZero(o.Code) { // not required
		return nil
	}

	if err := validate.MaxLength("incrementAuthCreated"+"."+"clientReferenceInformation"+"."+"code", "body", o.Code, 50); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this increment auth created body client reference information based on context it is used
func (o *IncrementAuthCreatedBodyClientReferenceInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *IncrementAuthCreatedBodyClientReferenceInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *IncrementAuthCreatedBodyClientReferenceInformation) UnmarshalBinary(b []byte) error {
	var res IncrementAuthCreatedBodyClientReferenceInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*IncrementAuthCreatedBodyErrorInformation increment auth created body error information
swagger:model IncrementAuthCreatedBodyErrorInformation
*/
type IncrementAuthCreatedBodyErrorInformation struct {

	// details
	Details []*IncrementAuthCreatedBodyErrorInformationDetailsItems0 `json:"details"`

	// The detail message related to the status and reason listed above.
	Message string `json:"message,omitempty"`

	// The reason of the status.
	//
	// Possible values:
	//   - AVS_FAILED
	//   - CONTACT_PROCESSOR
	//   - EXPIRED_CARD
	//   - PROCESSOR_DECLINED
	//   - INSUFFICIENT_FUND
	//   - STOLEN_LOST_CARD
	//   - ISSUER_UNAVAILABLE
	//   - UNAUTHORIZED_CARD
	//   - CVN_NOT_MATCH
	//   - EXCEEDS_CREDIT_LIMIT
	//   - INVALID_CVN
	//   - BLACKLISTED_CUSTOMER
	//   - SUSPENDED_ACCOUNT
	//   - PAYMENT_REFUSED
	//   - CV_FAILED
	//   - INVALID_ACCOUNT
	//   - GENERAL_DECLINE
	//   - INVALID_MERCHANT_CONFIGURATION
	//   - DECISION_PROFILE_REJECT
	//   - SCORE_EXCEEDS_THRESHOLD
	//   - CONSUMER_AUTHENTICATION_REQUIRED
	//   - ALLOWABLE_PIN_RETRIES_EXCEEDED
	//   - PROCESSOR_ERROR
	//
	Reason string `json:"reason,omitempty"`
}

// Validate validates this increment auth created body error information
func (o *IncrementAuthCreatedBodyErrorInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *IncrementAuthCreatedBodyErrorInformation) validateDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.Details) { // not required
		return nil
	}

	for i := 0; i < len(o.Details); i++ {
		if swag.IsZero(o.Details[i]) { // not required
			continue
		}

		if o.Details[i] != nil {
			if err := o.Details[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("incrementAuthCreated" + "." + "errorInformation" + "." + "details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("incrementAuthCreated" + "." + "errorInformation" + "." + "details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this increment auth created body error information based on the context it is used
func (o *IncrementAuthCreatedBodyErrorInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *IncrementAuthCreatedBodyErrorInformation) contextValidateDetails(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.Details); i++ {

		if o.Details[i] != nil {
			if err := o.Details[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("incrementAuthCreated" + "." + "errorInformation" + "." + "details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("incrementAuthCreated" + "." + "errorInformation" + "." + "details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *IncrementAuthCreatedBodyErrorInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *IncrementAuthCreatedBodyErrorInformation) UnmarshalBinary(b []byte) error {
	var res IncrementAuthCreatedBodyErrorInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*IncrementAuthCreatedBodyErrorInformationDetailsItems0 increment auth created body error information details items0
swagger:model IncrementAuthCreatedBodyErrorInformationDetailsItems0
*/
type IncrementAuthCreatedBodyErrorInformationDetailsItems0 struct {

	// This is the flattened JSON object field name/path that is either missing or invalid.
	Field string `json:"field,omitempty"`

	// Possible reasons for the error.
	//
	// Possible values:
	//  - MISSING_FIELD
	//  - INVALID_DATA
	//
	Reason string `json:"reason,omitempty"`
}

// Validate validates this increment auth created body error information details items0
func (o *IncrementAuthCreatedBodyErrorInformationDetailsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this increment auth created body error information details items0 based on context it is used
func (o *IncrementAuthCreatedBodyErrorInformationDetailsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *IncrementAuthCreatedBodyErrorInformationDetailsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *IncrementAuthCreatedBodyErrorInformationDetailsItems0) UnmarshalBinary(b []byte) error {
	var res IncrementAuthCreatedBodyErrorInformationDetailsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*IncrementAuthCreatedBodyLinks increment auth created body links
swagger:model IncrementAuthCreatedBodyLinks
*/
type IncrementAuthCreatedBodyLinks struct {

	// self
	Self *IncrementAuthCreatedBodyLinksSelf `json:"self,omitempty"`
}

// Validate validates this increment auth created body links
func (o *IncrementAuthCreatedBodyLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *IncrementAuthCreatedBodyLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(o.Self) { // not required
		return nil
	}

	if o.Self != nil {
		if err := o.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthCreated" + "." + "_links" + "." + "self")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthCreated" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this increment auth created body links based on the context it is used
func (o *IncrementAuthCreatedBodyLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *IncrementAuthCreatedBodyLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if o.Self != nil {
		if err := o.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthCreated" + "." + "_links" + "." + "self")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthCreated" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *IncrementAuthCreatedBodyLinks) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *IncrementAuthCreatedBodyLinks) UnmarshalBinary(b []byte) error {
	var res IncrementAuthCreatedBodyLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*IncrementAuthCreatedBodyLinksSelf increment auth created body links self
swagger:model IncrementAuthCreatedBodyLinksSelf
*/
type IncrementAuthCreatedBodyLinksSelf struct {

	// This is the endpoint of the resource that was created by the successful request.
	Href string `json:"href,omitempty"`

	// `method` refers to the HTTP method that you can send to the `self` endpoint to retrieve details of the resource.
	Method string `json:"method,omitempty"`
}

// Validate validates this increment auth created body links self
func (o *IncrementAuthCreatedBodyLinksSelf) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this increment auth created body links self based on context it is used
func (o *IncrementAuthCreatedBodyLinksSelf) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *IncrementAuthCreatedBodyLinksSelf) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *IncrementAuthCreatedBodyLinksSelf) UnmarshalBinary(b []byte) error {
	var res IncrementAuthCreatedBodyLinksSelf
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*IncrementAuthCreatedBodyOrderInformation increment auth created body order information
swagger:model IncrementAuthCreatedBodyOrderInformation
*/
type IncrementAuthCreatedBodyOrderInformation struct {

	// amount details
	AmountDetails *IncrementAuthCreatedBodyOrderInformationAmountDetails `json:"amountDetails,omitempty"`
}

// Validate validates this increment auth created body order information
func (o *IncrementAuthCreatedBodyOrderInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAmountDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *IncrementAuthCreatedBodyOrderInformation) validateAmountDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.AmountDetails) { // not required
		return nil
	}

	if o.AmountDetails != nil {
		if err := o.AmountDetails.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthCreated" + "." + "orderInformation" + "." + "amountDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthCreated" + "." + "orderInformation" + "." + "amountDetails")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this increment auth created body order information based on the context it is used
func (o *IncrementAuthCreatedBodyOrderInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateAmountDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *IncrementAuthCreatedBodyOrderInformation) contextValidateAmountDetails(ctx context.Context, formats strfmt.Registry) error {

	if o.AmountDetails != nil {
		if err := o.AmountDetails.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthCreated" + "." + "orderInformation" + "." + "amountDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthCreated" + "." + "orderInformation" + "." + "amountDetails")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *IncrementAuthCreatedBodyOrderInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *IncrementAuthCreatedBodyOrderInformation) UnmarshalBinary(b []byte) error {
	var res IncrementAuthCreatedBodyOrderInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*IncrementAuthCreatedBodyOrderInformationAmountDetails increment auth created body order information amount details
swagger:model IncrementAuthCreatedBodyOrderInformationAmountDetails
*/
type IncrementAuthCreatedBodyOrderInformationAmountDetails struct {

	// Amount that was authorized.
	//
	// Returned by authorization service.
	//
	// #### PIN debit
	// Amount of the purchase.
	//
	// Returned by PIN debit purchase.
	//
	// #### FDMS South
	// If you accept IDR or CLP currencies, see the entry for FDMS South in Merchant Descriptors Using the SCMP API.
	//
	// Max Length: 15
	AuthorizedAmount string `json:"authorizedAmount,omitempty"`

	// Currency used for the order. Use the three-character [ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)
	//
	// #### Used by
	// **Authorization**
	// Required field.
	//
	// **Authorization Reversal**
	// For an authorization reversal (`reversalInformation`) or a capture (`processingOptions.capture` is set to `true`), you must use the same currency that you used in your payment authorization request.
	//
	// #### PIN Debit
	// Currency for the amount you requested for the PIN debit purchase. This value is returned for partial authorizations. The issuing bank can approve a partial amount if the balance on the debit card is less than the requested transaction amount. For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf).
	// Returned by PIN debit purchase.
	//
	// For PIN debit reversal requests, you must use the same currency that was used for the PIN debit purchase or PIN debit credit that you are reversing.
	// For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf).
	//
	// Required field for PIN Debit purchase and PIN Debit credit requests.
	// Optional field for PIN Debit reversal requests.
	//
	// #### GPX
	// This field is optional for reversing an authorization or credit.
	//
	// #### DCC for First Data
	// Your local currency. For details, see the `currency` field description in [Dynamic Currency Conversion For First Data Using the SCMP API](http://apps.cybersource.com/library/documentation/dev_guides/DCC_FirstData_SCMP/DCC_FirstData_SCMP_API.pdf).
	//
	// #### Tax Calculation
	// Required for international tax and value added tax only.
	// Optional for U.S. and Canadian taxes.
	// Your local currency.
	//
	// Max Length: 3
	Currency string `json:"currency,omitempty"`

	// Amount you requested for the payment or capture.
	//
	// This value is returned for partial authorizations.
	// This field is also returned on incremental authorizations will contain the aggregated amount from the original authorizations and all the incremental authorizations.
	//
	// Max Length: 15
	TotalAmount string `json:"totalAmount,omitempty"`
}

// Validate validates this increment auth created body order information amount details
func (o *IncrementAuthCreatedBodyOrderInformationAmountDetails) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAuthorizedAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCurrency(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTotalAmount(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *IncrementAuthCreatedBodyOrderInformationAmountDetails) validateAuthorizedAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.AuthorizedAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("incrementAuthCreated"+"."+"orderInformation"+"."+"amountDetails"+"."+"authorizedAmount", "body", o.AuthorizedAmount, 15); err != nil {
		return err
	}

	return nil
}

func (o *IncrementAuthCreatedBodyOrderInformationAmountDetails) validateCurrency(formats strfmt.Registry) error {
	if swag.IsZero(o.Currency) { // not required
		return nil
	}

	if err := validate.MaxLength("incrementAuthCreated"+"."+"orderInformation"+"."+"amountDetails"+"."+"currency", "body", o.Currency, 3); err != nil {
		return err
	}

	return nil
}

func (o *IncrementAuthCreatedBodyOrderInformationAmountDetails) validateTotalAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.TotalAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("incrementAuthCreated"+"."+"orderInformation"+"."+"amountDetails"+"."+"totalAmount", "body", o.TotalAmount, 15); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this increment auth created body order information amount details based on context it is used
func (o *IncrementAuthCreatedBodyOrderInformationAmountDetails) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *IncrementAuthCreatedBodyOrderInformationAmountDetails) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *IncrementAuthCreatedBodyOrderInformationAmountDetails) UnmarshalBinary(b []byte) error {
	var res IncrementAuthCreatedBodyOrderInformationAmountDetails
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*IncrementAuthCreatedBodyPaymentInformation increment auth created body payment information
swagger:model IncrementAuthCreatedBodyPaymentInformation
*/
type IncrementAuthCreatedBodyPaymentInformation struct {

	// account features
	AccountFeatures *IncrementAuthCreatedBodyPaymentInformationAccountFeatures `json:"accountFeatures,omitempty"`
}

// Validate validates this increment auth created body payment information
func (o *IncrementAuthCreatedBodyPaymentInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAccountFeatures(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *IncrementAuthCreatedBodyPaymentInformation) validateAccountFeatures(formats strfmt.Registry) error {
	if swag.IsZero(o.AccountFeatures) { // not required
		return nil
	}

	if o.AccountFeatures != nil {
		if err := o.AccountFeatures.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthCreated" + "." + "paymentInformation" + "." + "accountFeatures")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthCreated" + "." + "paymentInformation" + "." + "accountFeatures")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this increment auth created body payment information based on the context it is used
func (o *IncrementAuthCreatedBodyPaymentInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateAccountFeatures(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *IncrementAuthCreatedBodyPaymentInformation) contextValidateAccountFeatures(ctx context.Context, formats strfmt.Registry) error {

	if o.AccountFeatures != nil {
		if err := o.AccountFeatures.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthCreated" + "." + "paymentInformation" + "." + "accountFeatures")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthCreated" + "." + "paymentInformation" + "." + "accountFeatures")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *IncrementAuthCreatedBodyPaymentInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *IncrementAuthCreatedBodyPaymentInformation) UnmarshalBinary(b []byte) error {
	var res IncrementAuthCreatedBodyPaymentInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*IncrementAuthCreatedBodyPaymentInformationAccountFeatures increment auth created body payment information account features
swagger:model IncrementAuthCreatedBodyPaymentInformationAccountFeatures
*/
type IncrementAuthCreatedBodyPaymentInformationAccountFeatures struct {

	// #### GPX
	// Mastercard product ID associated with the primary account number (PAN).
	// Returned by authorization service.
	//
	// #### CyberSource through VisaNet
	// Visa or Mastercard product ID that is associated with the primary account number (PAN).
	// For descriptions of the Visa product IDs, see the Product ID table on the [Visa
	// Request & Response Codes web page.](https://developer.visa.com/guides/request_response_codes)
	//
	// Data Length: String (3)
	//
	// #### GPN
	// Visa or Mastercard product ID that is associated with the primary account number (PAN).
	// For descriptions of the Visa product IDs, see the Product ID table on the
	// [Visa Request & Response Codes web page.](https://developer.visa.com/guides/request_response_codes)
	//
	// Data Length: String (3)
	//
	// #### Worldpay VAP
	// **Important** Before using this field on Worldpay VAP,
	// you must contact CyberSource Customer Support to have
	// your account configured for this feature.
	//
	// Type of card used in the transaction. The only possible value is:
	// - `PREPAID`: Prepaid Card
	//
	// Data Length: String (7)
	//
	// #### RBS WorldPay Atlanta
	// Type of card used in the transaction. Possible values:
	// - `B`: Business Card
	// - `O`: Noncommercial Card
	// - `R`: Corporate Card
	// - `S`: Purchase Card
	// - `Blank`: Purchase card not supported
	//
	// Data Length: String (1)
	//
	// Max Length: 7
	Category string `json:"category,omitempty"`
}

// Validate validates this increment auth created body payment information account features
func (o *IncrementAuthCreatedBodyPaymentInformationAccountFeatures) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCategory(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *IncrementAuthCreatedBodyPaymentInformationAccountFeatures) validateCategory(formats strfmt.Registry) error {
	if swag.IsZero(o.Category) { // not required
		return nil
	}

	if err := validate.MaxLength("incrementAuthCreated"+"."+"paymentInformation"+"."+"accountFeatures"+"."+"category", "body", o.Category, 7); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this increment auth created body payment information account features based on context it is used
func (o *IncrementAuthCreatedBodyPaymentInformationAccountFeatures) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *IncrementAuthCreatedBodyPaymentInformationAccountFeatures) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *IncrementAuthCreatedBodyPaymentInformationAccountFeatures) UnmarshalBinary(b []byte) error {
	var res IncrementAuthCreatedBodyPaymentInformationAccountFeatures
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*IncrementAuthCreatedBodyProcessorInformation increment auth created body processor information
swagger:model IncrementAuthCreatedBodyProcessorInformation
*/
type IncrementAuthCreatedBodyProcessorInformation struct {

	// Authorization code. Returned only when the processor returns this value.
	//
	// The length of this value depends on your processor.
	//
	// Returned by authorization service.
	//
	// #### PIN debit
	// Authorization code that is returned by the processor.
	//
	// Returned by PIN debit credit.
	//
	// #### Elavon Encrypted Account Number Program
	// The returned value is OFFLINE.
	//
	// #### TSYS Acquiring Solutions
	// The returned value for a successful zero amount authorization is 000000.
	//
	// Max Length: 6
	ApprovalCode string `json:"approvalCode,omitempty"`

	// merchant advice
	MerchantAdvice *IncrementAuthCreatedBodyProcessorInformationMerchantAdvice `json:"merchantAdvice,omitempty"`

	// For most processors, this is the error message sent directly from the bank. Returned only when the processor
	// returns this value.
	//
	// **Important** Do not use this field to evaluate the result of the authorization.
	//
	// #### PIN debit
	// Response value that is returned by the processor or bank.
	// **Important** Do not use this field to evaluate the results of the transaction request.
	//
	// Returned by PIN debit credit, PIN debit purchase, and PIN debit reversal.
	//
	// #### AIBMS
	// If this value is `08`, you can accept the transaction if the customer provides you with identification.
	//
	// #### Atos
	// This value is the response code sent from Atos and it might also include the response code from the bank.
	// Format: `aa,bb` with the two values separated by a comma and where:
	// - `aa` is the two-digit error message from Atos.
	// - `bb` is the optional two-digit error message from the bank.
	//
	// #### Comercio Latino
	// This value is the status code and the error or response code received from the processor separated by a colon.
	// Format: [status code]:E[error code] or [status code]:R[response code]
	// Example `2:R06`
	//
	// #### JCN Gateway
	// Processor-defined detail error code. The associated response category code is in the `processorInformation.responseCategoryCode` field.
	// String (3)
	//
	// Max Length: 10
	ResponseCode string `json:"responseCode,omitempty"`

	// This field might contain information about a decline. This field is supported only for **CyberSource through
	// VisaNet**.
	//
	// Max Length: 255
	ResponseDetails string `json:"responseDetails,omitempty"`

	// This field is returned only for **American Express Direct** and **CyberSource through VisaNet**.
	// Returned by authorization and incremental authorization services.
	//
	// #### American Express Direct
	//
	// System trace audit number (STAN). This value identifies the transaction and is useful when investigating a
	// chargeback dispute.
	//
	// #### CyberSource through VisaNet
	//
	// System trace number that must be printed on the customers receipt.
	//
	// Max Length: 6
	SystemTraceAuditNumber string `json:"systemTraceAuditNumber,omitempty"`

	// Network transaction identifier (TID). You can use this value to identify a specific transaction when you are
	// discussing the transaction with your processor. Not all processors provide this value.
	//
	// Returned by the authorization service.
	//
	// #### PIN debit
	// Transaction identifier generated by the processor.
	//
	// Returned by PIN debit credit.
	//
	// #### GPX
	// Processor transaction ID.
	//
	// #### Cielo
	// For Cielo, this value is the non-sequential unit (NSU) and is supported for all transactions. The value is generated by Cielo or the issuing bank.
	//
	// #### Comercio Latino
	// For Comercio Latino, this value is the proof of sale or non-sequential unit (NSU) number generated by the acquirers Cielo and Rede, or the issuing bank.
	//
	// #### CyberSource through VisaNet and GPN
	// For details about this value for CyberSource through VisaNet and GPN, see "Network Transaction Identifiers" in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// #### Moneris
	// This value identifies the transaction on a host system. It contains the following information:
	// - Terminal used to process the transaction
	// - Shift during which the transaction took place
	// - Batch number
	// - Transaction number within the batch
	// You must store this value. If you give the customer a receipt, display this value on the receipt.
	//
	// **Example** For the value
	// 66012345001069003:
	// - Terminal ID = 66012345
	// - Shift number = 001
	// - Batch number = 069
	// - Transaction number = 003
	//
	// Max Length: 50
	TransactionID string `json:"transactionId,omitempty"`
}

// Validate validates this increment auth created body processor information
func (o *IncrementAuthCreatedBodyProcessorInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateApprovalCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMerchantAdvice(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateResponseCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateResponseDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSystemTraceAuditNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTransactionID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *IncrementAuthCreatedBodyProcessorInformation) validateApprovalCode(formats strfmt.Registry) error {
	if swag.IsZero(o.ApprovalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("incrementAuthCreated"+"."+"processorInformation"+"."+"approvalCode", "body", o.ApprovalCode, 6); err != nil {
		return err
	}

	return nil
}

func (o *IncrementAuthCreatedBodyProcessorInformation) validateMerchantAdvice(formats strfmt.Registry) error {
	if swag.IsZero(o.MerchantAdvice) { // not required
		return nil
	}

	if o.MerchantAdvice != nil {
		if err := o.MerchantAdvice.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthCreated" + "." + "processorInformation" + "." + "merchantAdvice")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthCreated" + "." + "processorInformation" + "." + "merchantAdvice")
			}
			return err
		}
	}

	return nil
}

func (o *IncrementAuthCreatedBodyProcessorInformation) validateResponseCode(formats strfmt.Registry) error {
	if swag.IsZero(o.ResponseCode) { // not required
		return nil
	}

	if err := validate.MaxLength("incrementAuthCreated"+"."+"processorInformation"+"."+"responseCode", "body", o.ResponseCode, 10); err != nil {
		return err
	}

	return nil
}

func (o *IncrementAuthCreatedBodyProcessorInformation) validateResponseDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.ResponseDetails) { // not required
		return nil
	}

	if err := validate.MaxLength("incrementAuthCreated"+"."+"processorInformation"+"."+"responseDetails", "body", o.ResponseDetails, 255); err != nil {
		return err
	}

	return nil
}

func (o *IncrementAuthCreatedBodyProcessorInformation) validateSystemTraceAuditNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.SystemTraceAuditNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("incrementAuthCreated"+"."+"processorInformation"+"."+"systemTraceAuditNumber", "body", o.SystemTraceAuditNumber, 6); err != nil {
		return err
	}

	return nil
}

func (o *IncrementAuthCreatedBodyProcessorInformation) validateTransactionID(formats strfmt.Registry) error {
	if swag.IsZero(o.TransactionID) { // not required
		return nil
	}

	if err := validate.MaxLength("incrementAuthCreated"+"."+"processorInformation"+"."+"transactionId", "body", o.TransactionID, 50); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this increment auth created body processor information based on the context it is used
func (o *IncrementAuthCreatedBodyProcessorInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateMerchantAdvice(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *IncrementAuthCreatedBodyProcessorInformation) contextValidateMerchantAdvice(ctx context.Context, formats strfmt.Registry) error {

	if o.MerchantAdvice != nil {
		if err := o.MerchantAdvice.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthCreated" + "." + "processorInformation" + "." + "merchantAdvice")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthCreated" + "." + "processorInformation" + "." + "merchantAdvice")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *IncrementAuthCreatedBodyProcessorInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *IncrementAuthCreatedBodyProcessorInformation) UnmarshalBinary(b []byte) error {
	var res IncrementAuthCreatedBodyProcessorInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*IncrementAuthCreatedBodyProcessorInformationMerchantAdvice increment auth created body processor information merchant advice
swagger:model IncrementAuthCreatedBodyProcessorInformationMerchantAdvice
*/
type IncrementAuthCreatedBodyProcessorInformationMerchantAdvice struct {

	// Reason the recurring payment transaction was declined. For some processors, this field is used only for
	// Mastercard. For other processors, this field is used for Visa and Mastercard. And for other processors, this
	// field is not implemented.
	//
	// Possible values:
	//
	//  - `00`: Response not provided.
	//  - `01`: New account information is available. Obtain the new information.
	//  - `02`: Try again later.
	//  - `03`: Do not try again. Obtain another type of payment from the customer.
	//  - `04`: Problem with a token or a partial shipment indicator.
	//  - `21`: Recurring payment cancellation service.
	//  - `99`: An unknown value was returned from the processor.
	//
	// For processor-specific information, see the `auth_merchant_advice_code` field in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 2
	Code string `json:"code,omitempty"`

	// Raw merchant advice code sent directly from the processor. This field is used only for Mastercard.
	//
	// #### CyberSource through VisaNet
	// The value for this field corresponds to the following data in the TC 33 capture file1:
	// - Record: CP01 TCR7
	// - Position: 96-99
	// - Field: Response Data-Merchant Advice Code
	//
	//
	// For processor-specific information, see the `auth_merchant_advice_code_raw` field in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 4
	CodeRaw string `json:"codeRaw,omitempty"`
}

// Validate validates this increment auth created body processor information merchant advice
func (o *IncrementAuthCreatedBodyProcessorInformationMerchantAdvice) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCodeRaw(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *IncrementAuthCreatedBodyProcessorInformationMerchantAdvice) validateCode(formats strfmt.Registry) error {
	if swag.IsZero(o.Code) { // not required
		return nil
	}

	if err := validate.MaxLength("incrementAuthCreated"+"."+"processorInformation"+"."+"merchantAdvice"+"."+"code", "body", o.Code, 2); err != nil {
		return err
	}

	return nil
}

func (o *IncrementAuthCreatedBodyProcessorInformationMerchantAdvice) validateCodeRaw(formats strfmt.Registry) error {
	if swag.IsZero(o.CodeRaw) { // not required
		return nil
	}

	if err := validate.MaxLength("incrementAuthCreated"+"."+"processorInformation"+"."+"merchantAdvice"+"."+"codeRaw", "body", o.CodeRaw, 4); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this increment auth created body processor information merchant advice based on context it is used
func (o *IncrementAuthCreatedBodyProcessorInformationMerchantAdvice) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *IncrementAuthCreatedBodyProcessorInformationMerchantAdvice) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *IncrementAuthCreatedBodyProcessorInformationMerchantAdvice) UnmarshalBinary(b []byte) error {
	var res IncrementAuthCreatedBodyProcessorInformationMerchantAdvice
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*IncrementAuthParamsBodyClientReferenceInformation increment auth params body client reference information
swagger:model IncrementAuthParamsBodyClientReferenceInformation
*/
type IncrementAuthParamsBodyClientReferenceInformation struct {

	// The name of the Connection Method client (such as Virtual Terminal or SOAP Toolkit API) that the merchant uses to send a transaction request to CyberSource.
	//
	ApplicationName string `json:"applicationName,omitempty"`

	// The entity that is responsible for running the transaction and submitting the processing request to CyberSource. This could be a person, a system, or a connection method.
	//
	ApplicationUser string `json:"applicationUser,omitempty"`

	// Version of the CyberSource application or integration used for a transaction.
	//
	ApplicationVersion string `json:"applicationVersion,omitempty"`

	// Merchant-generated order reference or tracking number. It is recommended that you send a unique value for each
	// transaction so that you can perform meaningful searches for the transaction.
	//
	// #### Used by
	// **Authorization**
	// Required field.
	//
	// #### PIN Debit
	// Requests for PIN debit reversals need to use the same merchant reference number that was used in the transaction that is being
	// reversed.
	//
	// Required field for all PIN Debit requests (purchase, credit, and reversal).
	//
	// #### FDC Nashville Global
	// Certain circumstances can cause the processor to truncate this value to 15 or 17 characters for Level II and Level III processing, which can cause a discrepancy between the value you submit and the value included in some processor reports.
	//
	// Max Length: 50
	Code string `json:"code,omitempty"`

	// partner
	Partner *IncrementAuthParamsBodyClientReferenceInformationPartner `json:"partner,omitempty"`
}

// Validate validates this increment auth params body client reference information
func (o *IncrementAuthParamsBodyClientReferenceInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePartner(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *IncrementAuthParamsBodyClientReferenceInformation) validateCode(formats strfmt.Registry) error {
	if swag.IsZero(o.Code) { // not required
		return nil
	}

	if err := validate.MaxLength("incrementAuthRequest"+"."+"clientReferenceInformation"+"."+"code", "body", o.Code, 50); err != nil {
		return err
	}

	return nil
}

func (o *IncrementAuthParamsBodyClientReferenceInformation) validatePartner(formats strfmt.Registry) error {
	if swag.IsZero(o.Partner) { // not required
		return nil
	}

	if o.Partner != nil {
		if err := o.Partner.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthRequest" + "." + "clientReferenceInformation" + "." + "partner")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthRequest" + "." + "clientReferenceInformation" + "." + "partner")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this increment auth params body client reference information based on the context it is used
func (o *IncrementAuthParamsBodyClientReferenceInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidatePartner(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *IncrementAuthParamsBodyClientReferenceInformation) contextValidatePartner(ctx context.Context, formats strfmt.Registry) error {

	if o.Partner != nil {
		if err := o.Partner.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthRequest" + "." + "clientReferenceInformation" + "." + "partner")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthRequest" + "." + "clientReferenceInformation" + "." + "partner")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *IncrementAuthParamsBodyClientReferenceInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *IncrementAuthParamsBodyClientReferenceInformation) UnmarshalBinary(b []byte) error {
	var res IncrementAuthParamsBodyClientReferenceInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*IncrementAuthParamsBodyClientReferenceInformationPartner increment auth params body client reference information partner
swagger:model IncrementAuthParamsBodyClientReferenceInformationPartner
*/
type IncrementAuthParamsBodyClientReferenceInformationPartner struct {

	// Identifier for the developer that helped integrate a partner solution to CyberSource.
	//
	// Send this value in all requests that are sent through the partner solutions built by that developer.
	// CyberSource assigns the ID to the developer.
	//
	// **Note** When you see a developer ID of 999 in reports, the developer ID that was submitted is incorrect.
	//
	// Max Length: 8
	DeveloperID string `json:"developerId,omitempty"`

	// Value that links the previous transaction to the current follow-on request. This value is assigned by the client
	// software that is installed on the POS terminal, which makes it available to the terminals software and to
	// CyberSource. Therefore, you can use this value to reconcile transactions between CyberSource and the terminals
	// software.
	//
	// CyberSource does not forward this value to the processor. Instead, the value is forwarded to the CyberSource
	// reporting functionality.
	//
	// This field is supported only on these processors:
	// - American Express Direct
	// - Credit Mutuel-CIC
	// - FDC Nashville Global
	// - OmniPay Direct
	// - SIX
	//
	// Optional field.
	//
	// Max Length: 32
	OriginalTransactionID string `json:"originalTransactionId,omitempty"`

	// Identifier for the partner that is integrated to CyberSource.
	//
	// Send this value in all requests that are sent through the partner solution. CyberSource assigns the ID to the partner.
	//
	// **Note** When you see a solutionId of 999 in reports, the solutionId that was submitted is incorrect.
	//
	// Max Length: 8
	SolutionID string `json:"solutionId,omitempty"`
}

// Validate validates this increment auth params body client reference information partner
func (o *IncrementAuthParamsBodyClientReferenceInformationPartner) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDeveloperID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOriginalTransactionID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSolutionID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *IncrementAuthParamsBodyClientReferenceInformationPartner) validateDeveloperID(formats strfmt.Registry) error {
	if swag.IsZero(o.DeveloperID) { // not required
		return nil
	}

	if err := validate.MaxLength("incrementAuthRequest"+"."+"clientReferenceInformation"+"."+"partner"+"."+"developerId", "body", o.DeveloperID, 8); err != nil {
		return err
	}

	return nil
}

func (o *IncrementAuthParamsBodyClientReferenceInformationPartner) validateOriginalTransactionID(formats strfmt.Registry) error {
	if swag.IsZero(o.OriginalTransactionID) { // not required
		return nil
	}

	if err := validate.MaxLength("incrementAuthRequest"+"."+"clientReferenceInformation"+"."+"partner"+"."+"originalTransactionId", "body", o.OriginalTransactionID, 32); err != nil {
		return err
	}

	return nil
}

func (o *IncrementAuthParamsBodyClientReferenceInformationPartner) validateSolutionID(formats strfmt.Registry) error {
	if swag.IsZero(o.SolutionID) { // not required
		return nil
	}

	if err := validate.MaxLength("incrementAuthRequest"+"."+"clientReferenceInformation"+"."+"partner"+"."+"solutionId", "body", o.SolutionID, 8); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this increment auth params body client reference information partner based on context it is used
func (o *IncrementAuthParamsBodyClientReferenceInformationPartner) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *IncrementAuthParamsBodyClientReferenceInformationPartner) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *IncrementAuthParamsBodyClientReferenceInformationPartner) UnmarshalBinary(b []byte) error {
	var res IncrementAuthParamsBodyClientReferenceInformationPartner
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*IncrementAuthParamsBodyMerchantInformation increment auth params body merchant information
swagger:model IncrementAuthParamsBodyMerchantInformation
*/
type IncrementAuthParamsBodyMerchantInformation struct {

	// Date and time at your physical location.
	//
	// Format: `YYYYMMDDhhmmss`, where:
	//  - `YYYY` = year
	//  - `MM` = month
	//  - `DD` = day
	//  - `hh` = hour
	//  - `mm` = minutes
	//  - `ss` = seconds
	//
	// #### Used by
	// **Authorization**
	// Required for these processors:
	// - American Express Direct                                                                                                                                                                                                                                                                                                                         - American Express Direct
	// - Credit Mutuel-CIC
	// - FDC Nashville Global
	// - SIX
	//
	// Optional for all other processors.
	//
	// Max Length: 14
	TransactionLocalDateTime string `json:"transactionLocalDateTime,omitempty"`
}

// Validate validates this increment auth params body merchant information
func (o *IncrementAuthParamsBodyMerchantInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateTransactionLocalDateTime(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *IncrementAuthParamsBodyMerchantInformation) validateTransactionLocalDateTime(formats strfmt.Registry) error {
	if swag.IsZero(o.TransactionLocalDateTime) { // not required
		return nil
	}

	if err := validate.MaxLength("incrementAuthRequest"+"."+"merchantInformation"+"."+"transactionLocalDateTime", "body", o.TransactionLocalDateTime, 14); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this increment auth params body merchant information based on context it is used
func (o *IncrementAuthParamsBodyMerchantInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *IncrementAuthParamsBodyMerchantInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *IncrementAuthParamsBodyMerchantInformation) UnmarshalBinary(b []byte) error {
	var res IncrementAuthParamsBodyMerchantInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*IncrementAuthParamsBodyOrderInformation increment auth params body order information
swagger:model IncrementAuthParamsBodyOrderInformation
*/
type IncrementAuthParamsBodyOrderInformation struct {

	// amount details
	AmountDetails *IncrementAuthParamsBodyOrderInformationAmountDetails `json:"amountDetails,omitempty"`
}

// Validate validates this increment auth params body order information
func (o *IncrementAuthParamsBodyOrderInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAmountDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *IncrementAuthParamsBodyOrderInformation) validateAmountDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.AmountDetails) { // not required
		return nil
	}

	if o.AmountDetails != nil {
		if err := o.AmountDetails.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthRequest" + "." + "orderInformation" + "." + "amountDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthRequest" + "." + "orderInformation" + "." + "amountDetails")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this increment auth params body order information based on the context it is used
func (o *IncrementAuthParamsBodyOrderInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateAmountDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *IncrementAuthParamsBodyOrderInformation) contextValidateAmountDetails(ctx context.Context, formats strfmt.Registry) error {

	if o.AmountDetails != nil {
		if err := o.AmountDetails.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthRequest" + "." + "orderInformation" + "." + "amountDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthRequest" + "." + "orderInformation" + "." + "amountDetails")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *IncrementAuthParamsBodyOrderInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *IncrementAuthParamsBodyOrderInformation) UnmarshalBinary(b []byte) error {
	var res IncrementAuthParamsBodyOrderInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*IncrementAuthParamsBodyOrderInformationAmountDetails increment auth params body order information amount details
swagger:model IncrementAuthParamsBodyOrderInformationAmountDetails
*/
type IncrementAuthParamsBodyOrderInformationAmountDetails struct {

	// Additional charges that have to be authorized against a lodging or auto-rental order.
	// This value cannot be negative. You can include a decimal point (.), but no other special characters.
	//
	// Max Length: 19
	AdditionalAmount string `json:"additionalAmount,omitempty"`

	// Currency used for the order. Use the three-character [ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)
	//
	// #### Used by
	// **Authorization**
	// Required field.
	//
	// **Authorization Reversal**
	// For an authorization reversal (`reversalInformation`) or a capture (`processingOptions.capture` is set to `true`), you must use the same currency that you used in your payment authorization request.
	//
	// #### PIN Debit
	// Currency for the amount you requested for the PIN debit purchase. This value is returned for partial authorizations. The issuing bank can approve a partial amount if the balance on the debit card is less than the requested transaction amount. For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf).
	// Returned by PIN debit purchase.
	//
	// For PIN debit reversal requests, you must use the same currency that was used for the PIN debit purchase or PIN debit credit that you are reversing.
	// For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf).
	//
	// Required field for PIN Debit purchase and PIN Debit credit requests.
	// Optional field for PIN Debit reversal requests.
	//
	// #### GPX
	// This field is optional for reversing an authorization or credit.
	//
	// #### DCC for First Data
	// Your local currency. For details, see the `currency` field description in [Dynamic Currency Conversion For First Data Using the SCMP API](http://apps.cybersource.com/library/documentation/dev_guides/DCC_FirstData_SCMP/DCC_FirstData_SCMP_API.pdf).
	//
	// #### Tax Calculation
	// Required for international tax and value added tax only.
	// Optional for U.S. and Canadian taxes.
	// Your local currency.
	//
	// Max Length: 3
	Currency string `json:"currency,omitempty"`
}

// Validate validates this increment auth params body order information amount details
func (o *IncrementAuthParamsBodyOrderInformationAmountDetails) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAdditionalAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCurrency(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *IncrementAuthParamsBodyOrderInformationAmountDetails) validateAdditionalAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.AdditionalAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("incrementAuthRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"additionalAmount", "body", o.AdditionalAmount, 19); err != nil {
		return err
	}

	return nil
}

func (o *IncrementAuthParamsBodyOrderInformationAmountDetails) validateCurrency(formats strfmt.Registry) error {
	if swag.IsZero(o.Currency) { // not required
		return nil
	}

	if err := validate.MaxLength("incrementAuthRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"currency", "body", o.Currency, 3); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this increment auth params body order information amount details based on context it is used
func (o *IncrementAuthParamsBodyOrderInformationAmountDetails) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *IncrementAuthParamsBodyOrderInformationAmountDetails) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *IncrementAuthParamsBodyOrderInformationAmountDetails) UnmarshalBinary(b []byte) error {
	var res IncrementAuthParamsBodyOrderInformationAmountDetails
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*IncrementAuthParamsBodyProcessingInformation increment auth params body processing information
swagger:model IncrementAuthParamsBodyProcessingInformation
*/
type IncrementAuthParamsBodyProcessingInformation struct {

	// authorization options
	AuthorizationOptions *IncrementAuthParamsBodyProcessingInformationAuthorizationOptions `json:"authorizationOptions,omitempty"`
}

// Validate validates this increment auth params body processing information
func (o *IncrementAuthParamsBodyProcessingInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAuthorizationOptions(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *IncrementAuthParamsBodyProcessingInformation) validateAuthorizationOptions(formats strfmt.Registry) error {
	if swag.IsZero(o.AuthorizationOptions) { // not required
		return nil
	}

	if o.AuthorizationOptions != nil {
		if err := o.AuthorizationOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthRequest" + "." + "processingInformation" + "." + "authorizationOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthRequest" + "." + "processingInformation" + "." + "authorizationOptions")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this increment auth params body processing information based on the context it is used
func (o *IncrementAuthParamsBodyProcessingInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateAuthorizationOptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *IncrementAuthParamsBodyProcessingInformation) contextValidateAuthorizationOptions(ctx context.Context, formats strfmt.Registry) error {

	if o.AuthorizationOptions != nil {
		if err := o.AuthorizationOptions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthRequest" + "." + "processingInformation" + "." + "authorizationOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthRequest" + "." + "processingInformation" + "." + "authorizationOptions")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *IncrementAuthParamsBodyProcessingInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *IncrementAuthParamsBodyProcessingInformation) UnmarshalBinary(b []byte) error {
	var res IncrementAuthParamsBodyProcessingInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*IncrementAuthParamsBodyProcessingInformationAuthorizationOptions increment auth params body processing information authorization options
swagger:model IncrementAuthParamsBodyProcessingInformationAuthorizationOptions
*/
type IncrementAuthParamsBodyProcessingInformationAuthorizationOptions struct {

	// initiator
	Initiator *IncrementAuthParamsBodyProcessingInformationAuthorizationOptionsInitiator `json:"initiator,omitempty"`
}

// Validate validates this increment auth params body processing information authorization options
func (o *IncrementAuthParamsBodyProcessingInformationAuthorizationOptions) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateInitiator(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *IncrementAuthParamsBodyProcessingInformationAuthorizationOptions) validateInitiator(formats strfmt.Registry) error {
	if swag.IsZero(o.Initiator) { // not required
		return nil
	}

	if o.Initiator != nil {
		if err := o.Initiator.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthRequest" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthRequest" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this increment auth params body processing information authorization options based on the context it is used
func (o *IncrementAuthParamsBodyProcessingInformationAuthorizationOptions) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateInitiator(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *IncrementAuthParamsBodyProcessingInformationAuthorizationOptions) contextValidateInitiator(ctx context.Context, formats strfmt.Registry) error {

	if o.Initiator != nil {
		if err := o.Initiator.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("incrementAuthRequest" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("incrementAuthRequest" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *IncrementAuthParamsBodyProcessingInformationAuthorizationOptions) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *IncrementAuthParamsBodyProcessingInformationAuthorizationOptions) UnmarshalBinary(b []byte) error {
	var res IncrementAuthParamsBodyProcessingInformationAuthorizationOptions
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*IncrementAuthParamsBodyProcessingInformationAuthorizationOptionsInitiator increment auth params body processing information authorization options initiator
swagger:model IncrementAuthParamsBodyProcessingInformationAuthorizationOptionsInitiator
*/
type IncrementAuthParamsBodyProcessingInformationAuthorizationOptionsInitiator struct {

	// Indicates to an issuing bank whether a merchant-initiated transaction came from a card that was already stored on file.
	//
	// Possible values:
	// - **true** means the merchant-initiated transaction came from a card that was already stored on file.
	// - **false**  means the merchant-initiated transaction came from a card that was not stored on file.
	//
	StoredCredentialUsed bool `json:"storedCredentialUsed,omitempty"`
}

// Validate validates this increment auth params body processing information authorization options initiator
func (o *IncrementAuthParamsBodyProcessingInformationAuthorizationOptionsInitiator) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this increment auth params body processing information authorization options initiator based on context it is used
func (o *IncrementAuthParamsBodyProcessingInformationAuthorizationOptionsInitiator) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *IncrementAuthParamsBodyProcessingInformationAuthorizationOptionsInitiator) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *IncrementAuthParamsBodyProcessingInformationAuthorizationOptionsInitiator) UnmarshalBinary(b []byte) error {
	var res IncrementAuthParamsBodyProcessingInformationAuthorizationOptionsInitiator
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*IncrementAuthParamsBodyTravelInformation increment auth params body travel information
swagger:model IncrementAuthParamsBodyTravelInformation
*/
type IncrementAuthParamsBodyTravelInformation struct {

	// Duration for which the vehicle was rented or lodge/hotel was booked.
	//
	// Max Length: 2
	Duration string `json:"duration,omitempty"`
}

// Validate validates this increment auth params body travel information
func (o *IncrementAuthParamsBodyTravelInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDuration(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *IncrementAuthParamsBodyTravelInformation) validateDuration(formats strfmt.Registry) error {
	if swag.IsZero(o.Duration) { // not required
		return nil
	}

	if err := validate.MaxLength("incrementAuthRequest"+"."+"travelInformation"+"."+"duration", "body", o.Duration, 2); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this increment auth params body travel information based on context it is used
func (o *IncrementAuthParamsBodyTravelInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *IncrementAuthParamsBodyTravelInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *IncrementAuthParamsBodyTravelInformation) UnmarshalBinary(b []byte) error {
	var res IncrementAuthParamsBodyTravelInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}
