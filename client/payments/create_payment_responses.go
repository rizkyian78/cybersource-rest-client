// Code generated by go-swagger; DO NOT EDIT.

package payments

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"fmt"
	"io"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// CreatePaymentReader is a Reader for the CreatePayment structure.
type CreatePaymentReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *CreatePaymentReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 201:
		result := NewCreatePaymentCreated()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	case 400:
		result := NewCreatePaymentBadRequest()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 502:
		result := NewCreatePaymentBadGateway()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	default:
		return nil, runtime.NewAPIError("response status code does not match any response statuses defined for this endpoint in the swagger spec", response, response.Code())
	}
}

// NewCreatePaymentCreated creates a CreatePaymentCreated with default headers values
func NewCreatePaymentCreated() *CreatePaymentCreated {
	return &CreatePaymentCreated{}
}

/* CreatePaymentCreated describes a response with status code 201, with default header values.

Successful response.
*/
type CreatePaymentCreated struct {
	Payload *CreatePaymentCreatedBody
}

func (o *CreatePaymentCreated) Error() string {
	return fmt.Sprintf("[POST /pts/v2/payments][%d] createPaymentCreated  %+v", 201, o.Payload)
}
func (o *CreatePaymentCreated) GetPayload() *CreatePaymentCreatedBody {
	return o.Payload
}

func (o *CreatePaymentCreated) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(CreatePaymentCreatedBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewCreatePaymentBadRequest creates a CreatePaymentBadRequest with default headers values
func NewCreatePaymentBadRequest() *CreatePaymentBadRequest {
	return &CreatePaymentBadRequest{}
}

/* CreatePaymentBadRequest describes a response with status code 400, with default header values.

Invalid request.
*/
type CreatePaymentBadRequest struct {
	Payload *CreatePaymentBadRequestBody
}

func (o *CreatePaymentBadRequest) Error() string {
	return fmt.Sprintf("[POST /pts/v2/payments][%d] createPaymentBadRequest  %+v", 400, o.Payload)
}
func (o *CreatePaymentBadRequest) GetPayload() *CreatePaymentBadRequestBody {
	return o.Payload
}

func (o *CreatePaymentBadRequest) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(CreatePaymentBadRequestBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewCreatePaymentBadGateway creates a CreatePaymentBadGateway with default headers values
func NewCreatePaymentBadGateway() *CreatePaymentBadGateway {
	return &CreatePaymentBadGateway{}
}

/* CreatePaymentBadGateway describes a response with status code 502, with default header values.

Unexpected system error or system timeout.
*/
type CreatePaymentBadGateway struct {
	Payload *CreatePaymentBadGatewayBody
}

func (o *CreatePaymentBadGateway) Error() string {
	return fmt.Sprintf("[POST /pts/v2/payments][%d] createPaymentBadGateway  %+v", 502, o.Payload)
}
func (o *CreatePaymentBadGateway) GetPayload() *CreatePaymentBadGatewayBody {
	return o.Payload
}

func (o *CreatePaymentBadGateway) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(CreatePaymentBadGatewayBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

/*CreatePaymentBadGatewayBody ptsV2PaymentsPost502Response
swagger:model CreatePaymentBadGatewayBody
*/
type CreatePaymentBadGatewayBody struct {

	// The detail message related to the status and reason listed above.
	Message string `json:"message,omitempty"`

	// The reason of the status.
	//
	// Possible values:
	//  - SYSTEM_ERROR
	//  - SERVER_TIMEOUT
	//  - SERVICE_TIMEOUT
	//
	Reason string `json:"reason,omitempty"`

	// The status of the submitted transaction.
	//
	// Possible values:
	//  - SERVER_ERROR
	//
	Status string `json:"status,omitempty"`

	// Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ`
	// **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.).
	// The `T` separates the date and the time. The `Z` indicates UTC.
	//
	// Returned by Cybersource for all services.
	//
	SubmitTimeUtc string `json:"submitTimeUtc,omitempty"`
}

// Validate validates this create payment bad gateway body
func (o *CreatePaymentBadGatewayBody) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this create payment bad gateway body based on context it is used
func (o *CreatePaymentBadGatewayBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentBadGatewayBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentBadGatewayBody) UnmarshalBinary(b []byte) error {
	var res CreatePaymentBadGatewayBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentBadRequestBody ptsV2PaymentsPost400Response
swagger:model CreatePaymentBadRequestBody
*/
type CreatePaymentBadRequestBody struct {

	// details
	Details []*CreatePaymentBadRequestBodyDetailsItems0 `json:"details"`

	// The detail message related to the status and reason listed above.
	Message string `json:"message,omitempty"`

	// The reason of the status.
	//
	// Possible values:
	//  - MISSING_FIELD
	//  - INVALID_DATA
	//  - DUPLICATE_REQUEST
	//  - INVALID_CARD
	//  - CARD_TYPE_NOT_ACCEPTED
	//  - INVALID_MERCHANT_CONFIGURATION
	//  - PROCESSOR_UNAVAILABLE
	//  - INVALID_AMOUNT
	//  - INVALID_CARD_TYPE
	//  - INVALID_PAYMENT_ID
	//
	Reason string `json:"reason,omitempty"`

	// The status of the submitted transaction.
	//
	// Possible values:
	//  - INVALID_REQUEST
	//
	Status string `json:"status,omitempty"`

	// Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ`
	// **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.).
	// The `T` separates the date and the time. The `Z` indicates UTC.
	//
	// Returned by Cybersource for all services.
	//
	SubmitTimeUtc string `json:"submitTimeUtc,omitempty"`
}

// Validate validates this create payment bad request body
func (o *CreatePaymentBadRequestBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentBadRequestBody) validateDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.Details) { // not required
		return nil
	}

	for i := 0; i < len(o.Details); i++ {
		if swag.IsZero(o.Details[i]) { // not required
			continue
		}

		if o.Details[i] != nil {
			if err := o.Details[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("createPaymentBadRequest" + "." + "details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("createPaymentBadRequest" + "." + "details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this create payment bad request body based on the context it is used
func (o *CreatePaymentBadRequestBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentBadRequestBody) contextValidateDetails(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.Details); i++ {

		if o.Details[i] != nil {
			if err := o.Details[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("createPaymentBadRequest" + "." + "details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("createPaymentBadRequest" + "." + "details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentBadRequestBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentBadRequestBody) UnmarshalBinary(b []byte) error {
	var res CreatePaymentBadRequestBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentBadRequestBodyDetailsItems0 create payment bad request body details items0
swagger:model CreatePaymentBadRequestBodyDetailsItems0
*/
type CreatePaymentBadRequestBodyDetailsItems0 struct {

	// This is the flattened JSON object field name/path that is either missing or invalid.
	Field string `json:"field,omitempty"`

	// Possible reasons for the error.
	//
	// Possible values:
	//  - MISSING_FIELD
	//  - INVALID_DATA
	//
	Reason string `json:"reason,omitempty"`
}

// Validate validates this create payment bad request body details items0
func (o *CreatePaymentBadRequestBodyDetailsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this create payment bad request body details items0 based on context it is used
func (o *CreatePaymentBadRequestBodyDetailsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentBadRequestBodyDetailsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentBadRequestBodyDetailsItems0) UnmarshalBinary(b []byte) error {
	var res CreatePaymentBadRequestBodyDetailsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentBody create payment body
// Example: {"clientReferenceInformation":{"code":"TC50171_3"},"orderInformation":{"amountDetails":{"currency":"USD","totalAmount":"102.21"},"billTo":{"address1":"201 S. Division St.","administrativeArea":"MI","buildingNumber":"123","country":"US","district":"MI","email":"test@cybs.com","firstName":"RTS","lastName":"VDP","locality":"Ann Arbor","phoneNumber":"999999999","postalCode":"48104-2201"}},"paymentInformation":{"card":{"expirationMonth":"12","expirationYear":"2031","number":"5555555555554444","securityCode":"123","type":"002"}}}
swagger:model CreatePaymentBody
*/
type CreatePaymentBody struct {

	// acquirer information
	AcquirerInformation *CreatePaymentParamsBodyAcquirerInformation `json:"acquirerInformation,omitempty"`

	// aggregator information
	AggregatorInformation *CreatePaymentParamsBodyAggregatorInformation `json:"aggregatorInformation,omitempty"`

	// buyer information
	BuyerInformation *CreatePaymentParamsBodyBuyerInformation `json:"buyerInformation,omitempty"`

	// client reference information
	ClientReferenceInformation *CreatePaymentParamsBodyClientReferenceInformation `json:"clientReferenceInformation,omitempty"`

	// consumer authentication information
	ConsumerAuthenticationInformation *CreatePaymentParamsBodyConsumerAuthenticationInformation `json:"consumerAuthenticationInformation,omitempty"`

	// device information
	DeviceInformation *CreatePaymentParamsBodyDeviceInformation `json:"deviceInformation,omitempty"`

	// health care information
	HealthCareInformation *CreatePaymentParamsBodyHealthCareInformation `json:"healthCareInformation,omitempty"`

	// installment information
	InstallmentInformation *CreatePaymentParamsBodyInstallmentInformation `json:"installmentInformation,omitempty"`

	// issuer information
	IssuerInformation *CreatePaymentParamsBodyIssuerInformation `json:"issuerInformation,omitempty"`

	// The object containing the custom data that the merchant defines.
	//
	MerchantDefinedInformation []*CreatePaymentParamsBodyMerchantDefinedInformationItems0 `json:"merchantDefinedInformation"`

	// merchant information
	MerchantInformation *CreatePaymentParamsBodyMerchantInformation `json:"merchantInformation,omitempty"`

	// order information
	OrderInformation *CreatePaymentParamsBodyOrderInformation `json:"orderInformation,omitempty"`

	// payment information
	PaymentInformation *CreatePaymentParamsBodyPaymentInformation `json:"paymentInformation,omitempty"`

	// point of sale information
	PointOfSaleInformation *CreatePaymentParamsBodyPointOfSaleInformation `json:"pointOfSaleInformation,omitempty"`

	// processing information
	ProcessingInformation *CreatePaymentParamsBodyProcessingInformation `json:"processingInformation,omitempty"`

	// promotion information
	PromotionInformation *CreatePaymentParamsBodyPromotionInformation `json:"promotionInformation,omitempty"`

	// recipient information
	RecipientInformation *CreatePaymentParamsBodyRecipientInformation `json:"recipientInformation,omitempty"`

	// recurring payment information
	RecurringPaymentInformation *CreatePaymentParamsBodyRecurringPaymentInformation `json:"recurringPaymentInformation,omitempty"`

	// risk information
	RiskInformation *CreatePaymentParamsBodyRiskInformation `json:"riskInformation,omitempty"`

	// token information
	TokenInformation *CreatePaymentParamsBodyTokenInformation `json:"tokenInformation,omitempty"`

	// travel information
	TravelInformation *CreatePaymentParamsBodyTravelInformation `json:"travelInformation,omitempty"`
}

// Validate validates this create payment body
func (o *CreatePaymentBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAcquirerInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAggregatorInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBuyerInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateClientReferenceInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateConsumerAuthenticationInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDeviceInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateHealthCareInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateInstallmentInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateIssuerInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMerchantDefinedInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMerchantInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOrderInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePaymentInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePointOfSaleInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProcessingInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePromotionInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRecipientInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRecurringPaymentInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRiskInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTokenInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTravelInformation(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentBody) validateAcquirerInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.AcquirerInformation) { // not required
		return nil
	}

	if o.AcquirerInformation != nil {
		if err := o.AcquirerInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "acquirerInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "acquirerInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentBody) validateAggregatorInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.AggregatorInformation) { // not required
		return nil
	}

	if o.AggregatorInformation != nil {
		if err := o.AggregatorInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "aggregatorInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "aggregatorInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentBody) validateBuyerInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.BuyerInformation) { // not required
		return nil
	}

	if o.BuyerInformation != nil {
		if err := o.BuyerInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "buyerInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "buyerInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentBody) validateClientReferenceInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ClientReferenceInformation) { // not required
		return nil
	}

	if o.ClientReferenceInformation != nil {
		if err := o.ClientReferenceInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "clientReferenceInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "clientReferenceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentBody) validateConsumerAuthenticationInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ConsumerAuthenticationInformation) { // not required
		return nil
	}

	if o.ConsumerAuthenticationInformation != nil {
		if err := o.ConsumerAuthenticationInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "consumerAuthenticationInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "consumerAuthenticationInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentBody) validateDeviceInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.DeviceInformation) { // not required
		return nil
	}

	if o.DeviceInformation != nil {
		if err := o.DeviceInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "deviceInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "deviceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentBody) validateHealthCareInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.HealthCareInformation) { // not required
		return nil
	}

	if o.HealthCareInformation != nil {
		if err := o.HealthCareInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "healthCareInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "healthCareInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentBody) validateInstallmentInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.InstallmentInformation) { // not required
		return nil
	}

	if o.InstallmentInformation != nil {
		if err := o.InstallmentInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "installmentInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "installmentInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentBody) validateIssuerInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.IssuerInformation) { // not required
		return nil
	}

	if o.IssuerInformation != nil {
		if err := o.IssuerInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "issuerInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "issuerInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentBody) validateMerchantDefinedInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.MerchantDefinedInformation) { // not required
		return nil
	}

	for i := 0; i < len(o.MerchantDefinedInformation); i++ {
		if swag.IsZero(o.MerchantDefinedInformation[i]) { // not required
			continue
		}

		if o.MerchantDefinedInformation[i] != nil {
			if err := o.MerchantDefinedInformation[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("createPaymentRequest" + "." + "merchantDefinedInformation" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("createPaymentRequest" + "." + "merchantDefinedInformation" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CreatePaymentBody) validateMerchantInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.MerchantInformation) { // not required
		return nil
	}

	if o.MerchantInformation != nil {
		if err := o.MerchantInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "merchantInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "merchantInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentBody) validateOrderInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.OrderInformation) { // not required
		return nil
	}

	if o.OrderInformation != nil {
		if err := o.OrderInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "orderInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "orderInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentBody) validatePaymentInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.PaymentInformation) { // not required
		return nil
	}

	if o.PaymentInformation != nil {
		if err := o.PaymentInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "paymentInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "paymentInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentBody) validatePointOfSaleInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.PointOfSaleInformation) { // not required
		return nil
	}

	if o.PointOfSaleInformation != nil {
		if err := o.PointOfSaleInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "pointOfSaleInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "pointOfSaleInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentBody) validateProcessingInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ProcessingInformation) { // not required
		return nil
	}

	if o.ProcessingInformation != nil {
		if err := o.ProcessingInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "processingInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "processingInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentBody) validatePromotionInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.PromotionInformation) { // not required
		return nil
	}

	if o.PromotionInformation != nil {
		if err := o.PromotionInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "promotionInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "promotionInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentBody) validateRecipientInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.RecipientInformation) { // not required
		return nil
	}

	if o.RecipientInformation != nil {
		if err := o.RecipientInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "recipientInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "recipientInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentBody) validateRecurringPaymentInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.RecurringPaymentInformation) { // not required
		return nil
	}

	if o.RecurringPaymentInformation != nil {
		if err := o.RecurringPaymentInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "recurringPaymentInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "recurringPaymentInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentBody) validateRiskInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.RiskInformation) { // not required
		return nil
	}

	if o.RiskInformation != nil {
		if err := o.RiskInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "riskInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "riskInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentBody) validateTokenInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.TokenInformation) { // not required
		return nil
	}

	if o.TokenInformation != nil {
		if err := o.TokenInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "tokenInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "tokenInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentBody) validateTravelInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.TravelInformation) { // not required
		return nil
	}

	if o.TravelInformation != nil {
		if err := o.TravelInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "travelInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "travelInformation")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this create payment body based on the context it is used
func (o *CreatePaymentBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateAcquirerInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateAggregatorInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateBuyerInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateClientReferenceInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateConsumerAuthenticationInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateDeviceInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateHealthCareInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateInstallmentInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateIssuerInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateMerchantDefinedInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateMerchantInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateOrderInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidatePaymentInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidatePointOfSaleInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateProcessingInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidatePromotionInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateRecipientInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateRecurringPaymentInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateRiskInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateTokenInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateTravelInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentBody) contextValidateAcquirerInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.AcquirerInformation != nil {
		if err := o.AcquirerInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "acquirerInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "acquirerInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentBody) contextValidateAggregatorInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.AggregatorInformation != nil {
		if err := o.AggregatorInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "aggregatorInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "aggregatorInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentBody) contextValidateBuyerInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.BuyerInformation != nil {
		if err := o.BuyerInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "buyerInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "buyerInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentBody) contextValidateClientReferenceInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ClientReferenceInformation != nil {
		if err := o.ClientReferenceInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "clientReferenceInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "clientReferenceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentBody) contextValidateConsumerAuthenticationInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ConsumerAuthenticationInformation != nil {
		if err := o.ConsumerAuthenticationInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "consumerAuthenticationInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "consumerAuthenticationInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentBody) contextValidateDeviceInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.DeviceInformation != nil {
		if err := o.DeviceInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "deviceInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "deviceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentBody) contextValidateHealthCareInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.HealthCareInformation != nil {
		if err := o.HealthCareInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "healthCareInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "healthCareInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentBody) contextValidateInstallmentInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.InstallmentInformation != nil {
		if err := o.InstallmentInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "installmentInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "installmentInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentBody) contextValidateIssuerInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.IssuerInformation != nil {
		if err := o.IssuerInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "issuerInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "issuerInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentBody) contextValidateMerchantDefinedInformation(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.MerchantDefinedInformation); i++ {

		if o.MerchantDefinedInformation[i] != nil {
			if err := o.MerchantDefinedInformation[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("createPaymentRequest" + "." + "merchantDefinedInformation" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("createPaymentRequest" + "." + "merchantDefinedInformation" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CreatePaymentBody) contextValidateMerchantInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.MerchantInformation != nil {
		if err := o.MerchantInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "merchantInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "merchantInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentBody) contextValidateOrderInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.OrderInformation != nil {
		if err := o.OrderInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "orderInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "orderInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentBody) contextValidatePaymentInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.PaymentInformation != nil {
		if err := o.PaymentInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "paymentInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "paymentInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentBody) contextValidatePointOfSaleInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.PointOfSaleInformation != nil {
		if err := o.PointOfSaleInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "pointOfSaleInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "pointOfSaleInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentBody) contextValidateProcessingInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ProcessingInformation != nil {
		if err := o.ProcessingInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "processingInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "processingInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentBody) contextValidatePromotionInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.PromotionInformation != nil {
		if err := o.PromotionInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "promotionInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "promotionInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentBody) contextValidateRecipientInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.RecipientInformation != nil {
		if err := o.RecipientInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "recipientInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "recipientInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentBody) contextValidateRecurringPaymentInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.RecurringPaymentInformation != nil {
		if err := o.RecurringPaymentInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "recurringPaymentInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "recurringPaymentInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentBody) contextValidateRiskInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.RiskInformation != nil {
		if err := o.RiskInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "riskInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "riskInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentBody) contextValidateTokenInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.TokenInformation != nil {
		if err := o.TokenInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "tokenInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "tokenInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentBody) contextValidateTravelInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.TravelInformation != nil {
		if err := o.TravelInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "travelInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "travelInformation")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentBody) UnmarshalBinary(b []byte) error {
	var res CreatePaymentBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBody ptsV2PaymentsPost201Response
// Example: {"_links":{"authReversal":{"href":"/pts/v2/payments/4963015972176007901546/reversals","method":"POST"},"capture":{"href":"/pts/v2/payments/4963015972176007901546/captures","method":"POST"},"refund":{"href":"/pts/v2/payments/4963015972176007901546/refunds","method":"POST"},"self":{"href":"/pts/v2/payments/4963015972176007901546","method":"GET"},"void":{"href":"/pts/v2/payments/4963015972176007901546/voids","method":"POST"}},"clientReferenceInformation":{"code":"TC50171_3"},"id":"4963015972176007901546","orderInformation":{"amountDetails":{"authorizedAmount":"102.21","currency":"USD"}},"processorInformation":{"approvalCode":"888888","avs":{"code":"X","codeRaw":"I1"},"cardVerification":{"resultCode":""},"responseCode":"100"},"reconciliationId":"39570726X3E1LBQR","status":"200","statusInformation":{"message":"Successful transaction.","reason":"SUCCESS"},"submitTimeUtc":"2017-06-01T071957Z"}
swagger:model CreatePaymentCreatedBody
*/
type CreatePaymentCreatedBody struct {

	// links
	Links *CreatePaymentCreatedBodyLinks `json:"_links,omitempty"`

	// buyer information
	BuyerInformation *CreatePaymentCreatedBodyBuyerInformation `json:"buyerInformation,omitempty"`

	// client reference information
	ClientReferenceInformation *CreatePaymentCreatedBodyClientReferenceInformation `json:"clientReferenceInformation,omitempty"`

	// consumer authentication information
	ConsumerAuthenticationInformation *CreatePaymentCreatedBodyConsumerAuthenticationInformation `json:"consumerAuthenticationInformation,omitempty"`

	// error information
	ErrorInformation *CreatePaymentCreatedBodyErrorInformation `json:"errorInformation,omitempty"`

	// An unique identification number generated by Cybersource to identify the submitted request. Returned by all services.
	// It is also appended to the endpoint of the resource.
	// On incremental authorizations, this value with be the same as the identification number returned in the original authorization response.
	//
	// Max Length: 26
	ID string `json:"id,omitempty"`

	// installment information
	InstallmentInformation *CreatePaymentCreatedBodyInstallmentInformation `json:"installmentInformation,omitempty"`

	// issuer information
	IssuerInformation *CreatePaymentCreatedBodyIssuerInformation `json:"issuerInformation,omitempty"`

	// order information
	OrderInformation *CreatePaymentCreatedBodyOrderInformation `json:"orderInformation,omitempty"`

	// payment account information
	PaymentAccountInformation *CreatePaymentCreatedBodyPaymentAccountInformation `json:"paymentAccountInformation,omitempty"`

	// payment information
	PaymentInformation *CreatePaymentCreatedBodyPaymentInformation `json:"paymentInformation,omitempty"`

	// point of sale information
	PointOfSaleInformation *CreatePaymentCreatedBodyPointOfSaleInformation `json:"pointOfSaleInformation,omitempty"`

	// processing information
	ProcessingInformation *CreatePaymentCreatedBodyProcessingInformation `json:"processingInformation,omitempty"`

	// processor information
	ProcessorInformation *CreatePaymentCreatedBodyProcessorInformation `json:"processorInformation,omitempty"`

	// Reference number for the transaction.
	// Depending on how your Cybersource account is configured, this value could either be provided in the API request or generated by CyberSource.
	// The actual value used in the request to the processor is provided back to you by Cybersource in the response.
	//
	// Max Length: 60
	ReconciliationID string `json:"reconciliationId,omitempty"`

	// risk information
	RiskInformation *CreatePaymentCreatedBodyRiskInformation `json:"riskInformation,omitempty"`

	// The status of the submitted transaction.
	//
	// Possible values:
	//  - AUTHORIZED
	//  - PARTIAL_AUTHORIZED
	//  - AUTHORIZED_PENDING_REVIEW
	//  - AUTHORIZED_RISK_DECLINED
	//  - PENDING_AUTHENTICATION
	//  - PENDING_REVIEW
	//  - DECLINED
	//  - INVALID_REQUEST
	//
	Status string `json:"status,omitempty"`

	// Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ`
	// **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.).
	// The `T` separates the date and the time. The `Z` indicates UTC.
	//
	// Returned by Cybersource for all services.
	//
	SubmitTimeUtc string `json:"submitTimeUtc,omitempty"`

	// token information
	TokenInformation *CreatePaymentCreatedBodyTokenInformation `json:"tokenInformation,omitempty"`
}

// Validate validates this create payment created body
func (o *CreatePaymentCreatedBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBuyerInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateClientReferenceInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateConsumerAuthenticationInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateErrorInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateInstallmentInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateIssuerInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOrderInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePaymentAccountInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePaymentInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePointOfSaleInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProcessingInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProcessorInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateReconciliationID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRiskInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTokenInformation(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBody) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(o.Links) { // not required
		return nil
	}

	if o.Links != nil {
		if err := o.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBody) validateBuyerInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.BuyerInformation) { // not required
		return nil
	}

	if o.BuyerInformation != nil {
		if err := o.BuyerInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "buyerInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "buyerInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBody) validateClientReferenceInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ClientReferenceInformation) { // not required
		return nil
	}

	if o.ClientReferenceInformation != nil {
		if err := o.ClientReferenceInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "clientReferenceInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "clientReferenceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBody) validateConsumerAuthenticationInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ConsumerAuthenticationInformation) { // not required
		return nil
	}

	if o.ConsumerAuthenticationInformation != nil {
		if err := o.ConsumerAuthenticationInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "consumerAuthenticationInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "consumerAuthenticationInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBody) validateErrorInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ErrorInformation) { // not required
		return nil
	}

	if o.ErrorInformation != nil {
		if err := o.ErrorInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "errorInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "errorInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBody) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"id", "body", o.ID, 26); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBody) validateInstallmentInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.InstallmentInformation) { // not required
		return nil
	}

	if o.InstallmentInformation != nil {
		if err := o.InstallmentInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "installmentInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "installmentInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBody) validateIssuerInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.IssuerInformation) { // not required
		return nil
	}

	if o.IssuerInformation != nil {
		if err := o.IssuerInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "issuerInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "issuerInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBody) validateOrderInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.OrderInformation) { // not required
		return nil
	}

	if o.OrderInformation != nil {
		if err := o.OrderInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "orderInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "orderInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBody) validatePaymentAccountInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.PaymentAccountInformation) { // not required
		return nil
	}

	if o.PaymentAccountInformation != nil {
		if err := o.PaymentAccountInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "paymentAccountInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "paymentAccountInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBody) validatePaymentInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.PaymentInformation) { // not required
		return nil
	}

	if o.PaymentInformation != nil {
		if err := o.PaymentInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "paymentInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "paymentInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBody) validatePointOfSaleInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.PointOfSaleInformation) { // not required
		return nil
	}

	if o.PointOfSaleInformation != nil {
		if err := o.PointOfSaleInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "pointOfSaleInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "pointOfSaleInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBody) validateProcessingInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ProcessingInformation) { // not required
		return nil
	}

	if o.ProcessingInformation != nil {
		if err := o.ProcessingInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "processingInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "processingInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBody) validateProcessorInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ProcessorInformation) { // not required
		return nil
	}

	if o.ProcessorInformation != nil {
		if err := o.ProcessorInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "processorInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "processorInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBody) validateReconciliationID(formats strfmt.Registry) error {
	if swag.IsZero(o.ReconciliationID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"reconciliationId", "body", o.ReconciliationID, 60); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBody) validateRiskInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.RiskInformation) { // not required
		return nil
	}

	if o.RiskInformation != nil {
		if err := o.RiskInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "riskInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "riskInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBody) validateTokenInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.TokenInformation) { // not required
		return nil
	}

	if o.TokenInformation != nil {
		if err := o.TokenInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "tokenInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "tokenInformation")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this create payment created body based on the context it is used
func (o *CreatePaymentCreatedBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateBuyerInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateClientReferenceInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateConsumerAuthenticationInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateErrorInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateInstallmentInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateIssuerInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateOrderInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidatePaymentAccountInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidatePaymentInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidatePointOfSaleInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateProcessingInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateProcessorInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateRiskInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateTokenInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBody) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if o.Links != nil {
		if err := o.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBody) contextValidateBuyerInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.BuyerInformation != nil {
		if err := o.BuyerInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "buyerInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "buyerInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBody) contextValidateClientReferenceInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ClientReferenceInformation != nil {
		if err := o.ClientReferenceInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "clientReferenceInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "clientReferenceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBody) contextValidateConsumerAuthenticationInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ConsumerAuthenticationInformation != nil {
		if err := o.ConsumerAuthenticationInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "consumerAuthenticationInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "consumerAuthenticationInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBody) contextValidateErrorInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ErrorInformation != nil {
		if err := o.ErrorInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "errorInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "errorInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBody) contextValidateInstallmentInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.InstallmentInformation != nil {
		if err := o.InstallmentInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "installmentInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "installmentInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBody) contextValidateIssuerInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.IssuerInformation != nil {
		if err := o.IssuerInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "issuerInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "issuerInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBody) contextValidateOrderInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.OrderInformation != nil {
		if err := o.OrderInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "orderInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "orderInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBody) contextValidatePaymentAccountInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.PaymentAccountInformation != nil {
		if err := o.PaymentAccountInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "paymentAccountInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "paymentAccountInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBody) contextValidatePaymentInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.PaymentInformation != nil {
		if err := o.PaymentInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "paymentInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "paymentInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBody) contextValidatePointOfSaleInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.PointOfSaleInformation != nil {
		if err := o.PointOfSaleInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "pointOfSaleInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "pointOfSaleInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBody) contextValidateProcessingInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ProcessingInformation != nil {
		if err := o.ProcessingInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "processingInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "processingInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBody) contextValidateProcessorInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ProcessorInformation != nil {
		if err := o.ProcessorInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "processorInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "processorInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBody) contextValidateRiskInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.RiskInformation != nil {
		if err := o.RiskInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "riskInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "riskInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBody) contextValidateTokenInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.TokenInformation != nil {
		if err := o.TokenInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "tokenInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "tokenInformation")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBody) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyBuyerInformation create payment created body buyer information
swagger:model CreatePaymentCreatedBodyBuyerInformation
*/
type CreatePaymentCreatedBodyBuyerInformation struct {

	// Recipients date of birth. **Format**: `YYYYMMDD`.
	//
	// This field is a `pass-through`, which means that CyberSource ensures that the value is eight numeric characters
	// but otherwise does not verify the value or modify it in any way before sending it to the processor. If the field
	// is not required for the transaction, CyberSource does not forward it to the processor.
	//
	// For more details, see `recipient_date_of_birth` field description in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// Max Length: 8
	DateOfBirth string `json:"dateOfBirth,omitempty"`

	// Your identifier for the customer.
	//
	// When a subscription or customer profile is being created, the maximum length for this field for most processors is 30. Otherwise, the maximum length is 100.
	//
	// #### Comercio Latino
	// For recurring payments in Mexico, the value is the customers contract number.
	// Note Before you request the authorization, you must inform the issuer of the customer contract numbers that will be used for recurring transactions.
	//
	// #### Worldpay VAP
	// For a follow-on credit with Worldpay VAP, CyberSource checks the following locations, in the order
	// given, for a customer account ID value and uses the first value it finds:
	// 1. `customer_account_id` value in the follow-on credit request
	// 2. Customer account ID value that was used for the capture that is being credited
	// 3. Customer account ID value that was used for the original authorization
	// If a customer account ID value cannot be found in any of these locations, then no value is used.
	//
	// For processor-specific information, see the `customer_account_id` field description in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 100
	MerchantCustomerID string `json:"merchantCustomerId,omitempty"`

	// personal identification
	PersonalIdentification []*CreatePaymentCreatedBodyBuyerInformationPersonalIdentificationItems0 `json:"personalIdentification"`

	// The description for this field is not available.
	TaxID string `json:"taxId,omitempty"`

	// Customers government-assigned tax identification number.
	//
	// #### Tax Calculation
	// Optional for international and value added taxes only. Not applicable to U.S. and Canadian taxes.
	//
	// For processor-specific information, see the purchaser_vat_registration_number field in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 20
	VatRegistrationNumber string `json:"vatRegistrationNumber,omitempty"`
}

// Validate validates this create payment created body buyer information
func (o *CreatePaymentCreatedBodyBuyerInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDateOfBirth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMerchantCustomerID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePersonalIdentification(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateVatRegistrationNumber(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyBuyerInformation) validateDateOfBirth(formats strfmt.Registry) error {
	if swag.IsZero(o.DateOfBirth) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"buyerInformation"+"."+"dateOfBirth", "body", o.DateOfBirth, 8); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyBuyerInformation) validateMerchantCustomerID(formats strfmt.Registry) error {
	if swag.IsZero(o.MerchantCustomerID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"buyerInformation"+"."+"merchantCustomerId", "body", o.MerchantCustomerID, 100); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyBuyerInformation) validatePersonalIdentification(formats strfmt.Registry) error {
	if swag.IsZero(o.PersonalIdentification) { // not required
		return nil
	}

	for i := 0; i < len(o.PersonalIdentification); i++ {
		if swag.IsZero(o.PersonalIdentification[i]) { // not required
			continue
		}

		if o.PersonalIdentification[i] != nil {
			if err := o.PersonalIdentification[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("createPaymentCreated" + "." + "buyerInformation" + "." + "personalIdentification" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("createPaymentCreated" + "." + "buyerInformation" + "." + "personalIdentification" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CreatePaymentCreatedBodyBuyerInformation) validateVatRegistrationNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.VatRegistrationNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"buyerInformation"+"."+"vatRegistrationNumber", "body", o.VatRegistrationNumber, 20); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this create payment created body buyer information based on the context it is used
func (o *CreatePaymentCreatedBodyBuyerInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidatePersonalIdentification(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyBuyerInformation) contextValidatePersonalIdentification(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.PersonalIdentification); i++ {

		if o.PersonalIdentification[i] != nil {
			if err := o.PersonalIdentification[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("createPaymentCreated" + "." + "buyerInformation" + "." + "personalIdentification" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("createPaymentCreated" + "." + "buyerInformation" + "." + "personalIdentification" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyBuyerInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyBuyerInformation) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyBuyerInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyBuyerInformationPersonalIdentificationItems0 create payment created body buyer information personal identification items0
swagger:model CreatePaymentCreatedBodyBuyerInformationPersonalIdentificationItems0
*/
type CreatePaymentCreatedBodyBuyerInformationPersonalIdentificationItems0 struct {

	// The value of the identification type. This field is supported only on the following processors.
	//
	// #### ComercioLatino
	// Set this field to the Cadastro de Pessoas Fisicas (CPF).
	//
	// #### CyberSource Latin American Processing
	// Supported for Redecard in Brazil. Set this field to the Cadastro de Pessoas Fisicas (CPF), which is required for AVS for Redecard in Brazil.
	// **Note** CyberSource Latin American Processing is the name of a specific processing connection that CyberSource supports. In the CyberSource API documentation, CyberSource Latin American Processing does not refer to the general topic of processing in Latin America. The information in this field description is for the specific processing connection called CyberSource Latin American Processing. It is not for any other Latin American processors that CyberSource supports.
	//
	// For processor-specific information, see the `personal_id` field in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// If `type = PASSPORT`, this is the cardholder's passport number.
	// Recommended for Discover ProtectBuy.
	//
	// Max Length: 26
	ID string `json:"id,omitempty"`

	// The government agency that issued the driver's license or passport.
	//
	// If **type**` = DRIVER_LICENSE`, this is the State or province where the customers drivers license was issued.
	//
	// If **type**` = PASSPORT`, this is the Issuing country for the cardholders passport. Recommended for Discover ProtectBuy.
	//
	// Use the two-character [State, Province, and Territory Codes for the United States and Canada](https://developer.cybersource.com/library/documentation/sbc/quickref/states_and_provinces.pdf).
	//
	// #### TeleCheck
	// Contact your TeleCheck representative to find out whether this field is required or optional.
	//
	// #### All Other Processors
	// Not used.
	//
	// For details about the country that issued the passport, see `customer_passport_country` field description in [CyberSource Payer Authentication Using the SCMP API]
	// (https://apps.cybersource.com/library/documentation/dev_guides/Payer_Authentication_SCMP_API/html/)
	//
	// For details about the state or province that issued the passport, see `driver_license_state` field description in [Electronic Check Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/EChecks_SCMP_API/html/)
	//
	IssuedBy string `json:"issuedBy,omitempty"`

	// The type of the identification.
	//
	// Possible values:
	//   - `NATIONAL`
	//   - `CPF`
	//   - `CPNJ`
	//   - `CURP`
	//   - `SSN`
	//   - `DRIVER_LICENSE`
	//   - `PASSPORT_NUMBER`
	//   - `PERSONAL_ID`
	//   - `TAX_ID`
	//
	// This field is supported only on the following processors.
	//
	// #### ComercioLatino
	// Set this field to the Cadastro de Pessoas Fisicas (CPF).
	//
	// #### CyberSource Latin American Processing
	// Supported for Redecard in Brazil. Set this field to the Cadastro de Pessoas Fisicas (CPF), which is required for AVS for Redecard in Brazil.
	// **Note** CyberSource Latin American Processing is the name of a specific processing connection that CyberSource supports. In the CyberSource API documentation, CyberSource Latin American Processing does not refer to the general topic of processing in Latin America. The information in this field description is for the specific processing connection called CyberSource Latin American Processing. It is not for any other Latin American processors that CyberSource supports.
	//
	// For processor-specific information, see the `personal_id` field in [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	Type string `json:"type,omitempty"`

	// Verification results received from Issuer or Card Network for verification transactions. Response Only Field.
	//
	VerificationResults string `json:"verificationResults,omitempty"`
}

// Validate validates this create payment created body buyer information personal identification items0
func (o *CreatePaymentCreatedBodyBuyerInformationPersonalIdentificationItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyBuyerInformationPersonalIdentificationItems0) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MaxLength("id", "body", o.ID, 26); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment created body buyer information personal identification items0 based on context it is used
func (o *CreatePaymentCreatedBodyBuyerInformationPersonalIdentificationItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyBuyerInformationPersonalIdentificationItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyBuyerInformationPersonalIdentificationItems0) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyBuyerInformationPersonalIdentificationItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyClientReferenceInformation create payment created body client reference information
swagger:model CreatePaymentCreatedBodyClientReferenceInformation
*/
type CreatePaymentCreatedBodyClientReferenceInformation struct {

	// Merchant-generated order reference or tracking number. It is recommended that you send a unique value for each
	// transaction so that you can perform meaningful searches for the transaction.
	//
	// #### Used by
	// **Authorization**
	// Required field.
	//
	// #### PIN Debit
	// Requests for PIN debit reversals need to use the same merchant reference number that was used in the transaction that is being
	// reversed.
	//
	// Required field for all PIN Debit requests (purchase, credit, and reversal).
	//
	// #### FDC Nashville Global
	// Certain circumstances can cause the processor to truncate this value to 15 or 17 characters for Level II and Level III processing, which can cause a discrepancy between the value you submit and the value included in some processor reports.
	//
	// Max Length: 50
	Code string `json:"code,omitempty"`

	// Merchant ID that was used to create the subscription or customer profile for which the service was requested.
	//
	// If your CyberSource account is enabled for Recurring Billing, this field is returned only if you are using
	// subscription sharing and if your merchant ID is in the same merchant ID pool as the owner merchant ID.
	//
	// If your CyberSource account is enabled for Payment Tokenization, this field is returned only if you are using
	// profile sharing and if your merchant ID is in the same merchant ID pool as the owner merchant ID.
	//
	OwnerMerchantID string `json:"ownerMerchantId,omitempty"`

	// Date and time at your physical location.
	//
	// Format: `YYYYMMDDhhmmss`, where YYYY = year, MM = month, DD = day, hh = hour, mm = minutes ss = seconds
	//
	// #### PIN Debit
	// Optional field for PIN Debit purchase and credit requests.
	//
	// Max Length: 14
	SubmitLocalDateTime string `json:"submitLocalDateTime,omitempty"`
}

// Validate validates this create payment created body client reference information
func (o *CreatePaymentCreatedBodyClientReferenceInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSubmitLocalDateTime(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyClientReferenceInformation) validateCode(formats strfmt.Registry) error {
	if swag.IsZero(o.Code) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"clientReferenceInformation"+"."+"code", "body", o.Code, 50); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyClientReferenceInformation) validateSubmitLocalDateTime(formats strfmt.Registry) error {
	if swag.IsZero(o.SubmitLocalDateTime) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"clientReferenceInformation"+"."+"submitLocalDateTime", "body", o.SubmitLocalDateTime, 14); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment created body client reference information based on context it is used
func (o *CreatePaymentCreatedBodyClientReferenceInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyClientReferenceInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyClientReferenceInformation) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyClientReferenceInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyConsumerAuthenticationInformation create payment created body consumer authentication information
swagger:model CreatePaymentCreatedBodyConsumerAuthenticationInformation
*/
type CreatePaymentCreatedBodyConsumerAuthenticationInformation struct {

	// JSON Web Token (JWT) used to authenticate the consumer with the authentication provider, such as, CardinalCommerce or Rupay.
	// Note - Max Length of this field is 2048 characters.
	//
	AccessToken string `json:"accessToken,omitempty"`

	// Identifies the UI Type the ACS will use to complete the challenge. **NOTE**: Only available for App transactions using the Cardinal Mobile SDK.
	//
	AcsRenderingType string `json:"acsRenderingType,omitempty"`

	// Unique transaction identifier assigned by the ACS to identify a single transaction.
	//
	// Max Length: 36
	AcsTransactionID string `json:"acsTransactionId,omitempty"`

	// URL for the card-issuing banks authentication form that you receive when the card is enrolled.
	// The value can be very large.
	//
	// Max Length: 2048
	AcsURL string `json:"acsUrl,omitempty"`

	// Indicates what displays to the customer during the authentication process.
	// This field can contain one of these values:
	// - `ADS`: (Card not enrolled) customer prompted to activate the card during the checkout process.
	// - `ATTEMPTS`: (Attempts processing) Processing briefly displays before the checkout process is completed.
	// - `ENROLLED`: (Card enrolled) the card issuers authentication window displays.
	// - `UNKNOWN`: Card enrollment status cannot be determined.
	// - `NOREDIRECT`: (Card not enrolled, authentication unavailable, or error occurred) nothing displays to the customer.
	//
	// The following values can be returned if you are using rules-based payer authentication.
	// - `RIBA`: The card-issuing bank supports risk-based authentication, but whether the cardholder is likely
	// to be challenged cannot be determined.
	// - `RIBA_PASS`: The card-issuing bank supports risk-based authentication and it is likely that the
	// cardholder will not be challenged to provide credentials, also known as _silent authentication_.
	//
	// For details about possible values, see `pa_enroll_authentication_path` field description and "Rules-Based Payer Authentication"
	// in [CyberSource Payer Authentication Using the SCMP API.]
	// (https://apps.cybersource.com/library/documentation/dev_guides/Payer_Authentication_SCMP_API/html/)
	//
	AuthenticationPath string `json:"authenticationPath,omitempty"`

	// Raw authentication data that comes from the cardissuing bank. Primary authentication field that
	// indicates if authentication was successful and if liability shift occurred. You should examine first the
	// result of this field. This field contains one of these values:
	// - `-1`: Invalid PARes.
	// - `0`: Successful validation.
	// - `1`: Cardholder is not participating, but the attempt to authenticate was recorded.
	// - `6`: Issuer unable to perform authentication.
	// - `9`: Cardholder did not complete authentication.
	//
	AuthenticationResult string `json:"authenticationResult,omitempty"`

	// Message that explains the authenticationResult reply field.
	//
	AuthenticationStatusMsg string `json:"authenticationStatusMsg,omitempty"`

	// Payer authentication transaction identifier passed to link the check
	// enrollment and validate authentication messages.
	//
	// Max Length: 20
	AuthenticationTransactionID string `json:"authenticationTransactionId,omitempty"`

	// The Base64 encoded JSON Payload of CB specific Authorization Values returned in the challenge Flow
	//
	AuthorizationPayload string `json:"authorizationPayload,omitempty"`

	// Text provided by the ACS/Issuer to Cardholder during a Frictionless or Decoupled transaction.The Issuer can provide information to Cardholder.
	// For example, Additional authentication is needed for this transaction, please contact (Issuer Name) at xxx-xxx-xxxx..
	// The Issuing Bank can optionally support this value.
	//
	// Max Length: 128
	CardholderMessage string `json:"cardholderMessage,omitempty"`

	// Unique identifier generated by the card-issuing bank for Visa, American Express, JCB, Diners Club, and
	// Discover transactions after the customer is authenticated. The value is in base64. When you
	// request the card authorization service, CyberSource automatically converts the value, not the field name,
	// to the format required by your payment processor.
	//
	// Max Length: 255
	Cavv string `json:"cavv,omitempty"`

	// Field that is returned only when the CAVV is generated, which occurs when paresStatus
	// contains the values Y (successful authentication) or A (attempted authentication). If
	// you use the ATOS processor, send the value of this field in the `cavv_algorithm` request field of the
	// authorization service. This field contains one of these values:
	// - `2`: Visa, American Express, JCB, Diners Club, and Discover
	// - `3`: Mastercard
	//
	// Max Length: 1
	CavvAlgorithm string `json:"cavvAlgorithm,omitempty"`

	// An indicator as to why the transaction was canceled.
	// Possible Values:
	//
	// - `01`: Cardholder selected Cancel.
	// - `02`: Reserved for future EMVCo use (values invalid until defined by EMVCo).
	// - `03`: Transaction Timed OutDecoupled Authentication
	// - `04`: Transaction timed out at ACSother timeouts
	// - `05`: Transaction Timed out at ACS - First CReq not received by ACS
	// - `06`: Transaction Error
	// - `07`: Unknown
	// - `08`: Transaction Timed Out at SDK
	//
	// Max Length: 2
	ChallengeCancelCode string `json:"challengeCancelCode,omitempty"`

	// Indicates whether a challenge is required in order to complete authentication.
	// **Note** Regional mandates might determine that a challenge is required.
	//
	// Possible values:
	// - `Y`: Challenge required
	// - `N`: Challenge not required
	// **Note**  Used by the Hybrid integration.
	//
	// Max Length: 1
	ChallengeRequired string `json:"challengeRequired,omitempty"`

	// Indicates whether the 3DS Requestor requests the ACS to utilize Decoupled Authentication and agrees to utilize Decoupled Authentication if the ACS confirms its use.
	//
	// Possible Values:
	//
	// Y - Decoupled Authentication is supported and preferred if challenge is necessary
	//
	// N - Do not use Decoupled Authentication
	//
	// **Default Value**: N
	//
	// Max Length: 1
	DecoupledAuthenticationIndicator string `json:"decoupledAuthenticationIndicator,omitempty"`

	// The directory server error code indicating a problem with this transaction. Note - Max Length of this field is typically 3 characters.
	//
	DirectoryServerErrorCode string `json:"directoryServerErrorCode,omitempty"`

	// Directory server text and additional detail about the error for this transaction.
	//
	// Max Length: 4096
	DirectoryServerErrorDescription string `json:"directoryServerErrorDescription,omitempty"`

	// The Directory Server Transaction ID is generated by the Mastercard Directory Server during the authentication transaction and passed back to the merchant with the authentication results.
	// For Cybersource Through Visanet Gateway:
	// The value for this field corresponds to the following data in the TC 33 capture file3: Record: CP01 TCR7, Position: 114-149, Field: MC AVV VerificationDirectory Server Transaction ID
	//
	// Max Length: 36
	DirectoryServerTransactionID string `json:"directoryServerTransactionId,omitempty"`

	// Note This field applies only to non-U.S-issued cards.
	//
	// For enroll, Numeric electronic commerce indicator (ECI) returned only for Visa, American Express, JCB,
	// Diners Club, and Discover transactions when the card is not enrolled. For more information, see
	// "Interpreting the Reply," page 22.
	//
	// If you are not using the CyberSource payment services, you must send this value to your payment
	// processor in the subsequent request for card authorization. This field contains one of these values:
	// - `06`: The card can be enrolled. Liability shift.
	// - `07`: The card cannot be enrolled. No liability shift.
	//
	// For validate, Numeric electronic commerce indicator (ECI) returned only for Visa, American Express, JCB,
	// Diners Club, and Discover transactions. The field is absent when authentication fails.
	// You must send this value to your payment processor in the subsequent request for card authorization.
	// This field contains one of these values:
	// - `05`: Successful authentication
	// - `06`: Authentication attempted
	// - `07`: Failed authentication (No response from the merchant because of a problem.)
	//
	Eci string `json:"eci,omitempty"`

	// ECI value that can be returned for Visa, Mastercard, American Express, JCB, Diners Club, and Discover.
	// The field is absent when authentication fails. If your payment processor is Streamline, you must pass the
	// value of this field instead of the value of `eci` or `ucafCollectionIndicator`.
	//
	// This field can contain one of these values:
	// - `01`: Authentication attempted (Mastercard)
	// - `02`: Successful authentication (Mastercard)
	// - `05`: Successful authentication (Visa, American Express, JCB, Diners Club, and Discover)
	// - `06`: Authentication attempted (Visa, American Express, JCB, Diners Club, and Discover)
	//
	EciRaw string `json:"eciRaw,omitempty"`

	// Commerce indicator for cards not enrolled. This field contains one of these values:
	// - `internet`: Card not enrolled, or card type not supported by payer authentication. No liability shift.
	// - `js_attempted`: Card not enrolled, but attempt to authenticate is recorded. Liability shift.
	// - `js_failure`: J/Secure directory service is not available. No liability shift.
	// - `spa`: Mastercard card not enrolled in the SecureCode program. No liability shift.
	// - `vbv_attempted`: Card not enrolled, but attempt to authenticate is recorded. Liability shift.
	// - `vbv_failure`: For payment processor Barclays, Streamline, AIBMS, or FDC Germany, you receive
	// this result if Visas directory service is not available. No liability shift.
	//
	// Max Length: 255
	EcommerceIndicator string `json:"ecommerceIndicator,omitempty"`

	// This field describes the type of 3DS transaction flow that took place.  It can be one of three possible flows;
	// CH - Challenge
	// FR - Frictionless
	// FD - Frictionless with delegation, (challenge not generated by the issuer but by the scheme on behalf of the issuer).
	//
	// Max Length: 2
	EffectiveAuthenticationType string `json:"effectiveAuthenticationType,omitempty"`

	// Indicator used to differentiate Internet transactions from other types. The authentication failed if this field
	// is not returned. For Visa, if your payment processor is Streamline, Barclays, AIBMS, or FDC Germany,
	// you receive the value vbv_failure instead of internet when eci is 07.
	// The value of this field is passed automatically to the authorization service if you request the services
	// together. This field contains one of these values:
	// - `aesk`: American Express SafeKey authentication verified successfully.
	// - `aesk_attempted`: Card not enrolled in American Express SafeKey, but the attempt to authenticate was recorded.
	// - `dipb`: Discover ProtectBuy authentication verified successfully.
	// - `dipb_attempted`: Card not enrolled in Discover ProtectBuy, but the attempt to authenticate was recorded.
	// - `internet`: Authentication was not verified successfully.
	// - `js`: J/Secure authentication verified successfully.
	// - `js_attempted`: Card not enrolled in J/Secure, but the attempt to authenticate was recorded.
	// - `moto`: Mail or telephone order.
	// - `pb_attempted`: Card not enrolled in Diners Club ProtectBuy, but the attempt to authenticate was recorded.
	// - `recurring`: Recurring transaction.
	// - `spa`: Mastercard Identity Check authentication verified successfully.
	// - `spa_failure`: Mastercard Identity Check failed authentication.
	// - `vbv`: Visa Secure authentication verified successfully.
	// - `vbv_attempted`: Card not enrolled in Visa Secure, but the attempt to authenticate was recorded.
	// - `vbv_failure`: Visa Secure authentication unavailable.
	//
	Indicator string `json:"indicator,omitempty"`

	// Indicates the number of authentication cycles attempted by the cardholder and is tracked by the Issuing Banks ACS.Example: if customer gets the challenge window and enter in their one time password and hit submit then that interaction counter should just be 1.
	// When customer gets the challenge window and the bank asks if they want to have the one time password  sent to their phone or their email and they have to choose before going to the next screen to enter in their one time password then this interaction count would be 2.
	// One for the selection of how they want the one time password delivered and another with them actually entering in the one time password and hitting the submit button.
	//
	// Max Length: 2
	InteractionCounter string `json:"interactionCounter,omitempty"`

	// ivr
	Ivr *CreatePaymentCreatedBodyConsumerAuthenticationInformationIvr `json:"ivr,omitempty"`

	// The global score calculated by the CB scoring platform and returned to merchants.
	//
	// Max Length: 2
	NetworkScore string `json:"networkScore,omitempty"`

	// Payer authentication request (PAReq) message that you need to forward to the ACS.
	// The value can be very large. The value is in base64.
	//
	Pareq string `json:"pareq,omitempty"`

	// Raw result of the authentication check. If you are configured for Asia, Middle East, and Africa Gateway
	// Processing, you need to send the value of this field in your authorization request. This field can contain
	// one of these values:
	// - `A`: Proof of authentication attempt was generated.
	// - `N`: Customer failed or canceled authentication. Transaction denied.
	// - `U`: Authentication not completed regardless of the reason.
	// - `Y`: Customer was successfully authenticated.
	//
	ParesStatus string `json:"paresStatus,omitempty"`

	// Date and time of the enrollment check combined with the VEReq and VERes elements. If you ever need
	// to show proof of enrollment checking, you may need to parse the string for the information required by the
	// payment card company. The value can be very large. For details about possible values, see the `pa_enroll_proofxml` field description in
	// [CyberSource Payer Authentication Using the SCMP API.]
	// (https://apps.cybersource.com/library/documentation/dev_guides/Payer_Authentication_SCMP_API/html/)
	// - For cards issued in the U.S. or Canada, Visa may require this data for specific merchant category codes.
	// - For cards not issued in the U.S. or Canada, your bank may require this data as proof of enrollment
	// checking for any payer authentication transaction that you re-present because of a chargeback.
	//
	ProofXML string `json:"proofXml,omitempty"`

	// Encrypted version of the card number used in the payer authentication request message.
	//
	ProxyPan string `json:"proxyPan,omitempty"`

	// SDK unique transaction identifier that is generated on each new transaction.
	//
	// Max Length: 36
	SdkTransactionID string `json:"sdkTransactionId,omitempty"`

	// Provides additional information as to why the PAResStatus has a specific value.
	//
	// Max Length: 2
	SignedParesStatusReason string `json:"signedParesStatusReason,omitempty"`

	// This field contains the 3D Secure version that was used to process the transaction. For example, 1.0.2 or 2.0.0.
	//
	SpecificationVersion string `json:"specificationVersion,omitempty"`

	// The fully qualified URL that the merchant uses to post a form to the cardholder in order to complete the Consumer Authentication transaction for the Cardinal Cruise API integration.
	//
	// Max Length: 2048
	StepUpURL string `json:"stepUpUrl,omitempty"`

	// strong authentication
	StrongAuthentication *CreatePaymentCreatedBodyConsumerAuthenticationInformationStrongAuthentication `json:"strongAuthentication,omitempty"`

	// Unique transaction identifier assigned by the 3DS Server to identify a single transaction.
	//
	// Max Length: 36
	ThreeDSServerTransactionID string `json:"threeDSServerTransactionId,omitempty"`

	// AAV is a unique identifier generated by the card-issuing bank for Mastercard Identity Check
	// transactions after the customer is authenticated. The value is in base64.
	// Include the data in the card authorization request.
	//
	UcafAuthenticationData string `json:"ucafAuthenticationData,omitempty"`

	// For enroll, Returned only for Mastercard transactions. Indicates that authentication is not required because the
	// customer is not enrolled. Add the value of this field to the authorization field ucaf_collection_indicator.
	// This field can contain these values: 0, 1.
	//
	// For validate, Numeric electronic commerce indicator (ECI) returned only for Mastercard Identity Check
	// transactions. The field is absent when authentication fails. You must send this value to your payment
	// processor in the request for card authorization. This field contain one of these values:
	// - `0`: Authentication data not collected, and customer authentication was not completed.
	// - `1`: Authentication data not collected because customer authentication was not completed.
	// - `2`: Authentication data collected because customer completed authentication.
	//
	UcafCollectionIndicator string `json:"ucafCollectionIndicator,omitempty"`

	// Result of the enrollment check. This field can contain one of these values:
	// - `Y`: Card enrolled or can be enrolled; you must authenticate. Liability shift.
	// - `N`: Card not enrolled; proceed with authorization. Liability shift.
	// - `U`: Unable to authenticate regardless of the reason. No liability shift.
	//
	// **Note** This field only applies to the Asia, Middle East, and Africa Gateway. If you are configured for
	// this processor, you must send the value of this field in your authorization request.
	//
	// The following value can be returned if you are using rules-based Payer Authentication:
	// - `B`: Indicates that authentication was bypassed.
	//
	// For details, see `pa_enroll_veres_enrolled` field description in [CyberSource Payer Authentication Using the SCMP API.]
	// (https://apps.cybersource.com/library/documentation/dev_guides/Payer_Authentication_SCMP_API/html/)
	//
	VeresEnrolled string `json:"veresEnrolled,omitempty"`

	// Enables the communication of trusted beneficiary/whitelist status between the ACS, the DS and the 3DS Requestor.
	//
	// Possible Values:
	//
	// Y - 3DS Requestor is whitelisted by cardholder
	//
	// N - 3DS Requestor is not whitelisted by cardholder
	//
	// Max Length: 1
	WhiteListStatus string `json:"whiteListStatus,omitempty"`

	// This data element will be populated by the system setting Whitelist Status. Possible Values: 01 - 3DS/ Server/ 02  DS/03 - ACS
	//
	// Max Length: 2
	WhiteListStatusSource string `json:"whiteListStatusSource,omitempty"`

	// Transaction identifier generated by CyberSource for successful enrollment or validation checks.
	// Use this value, which is in base64, to match an outgoing PAReq with an incoming PARes.
	// CyberSource forwards the XID with the card authorization service to these payment processors in these cases:
	// - Barclays
	// - Streamline (when the **ecommerceIndicator**`=spa`)
	//
	Xid string `json:"xid,omitempty"`
}

// Validate validates this create payment created body consumer authentication information
func (o *CreatePaymentCreatedBodyConsumerAuthenticationInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAcsTransactionID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAcsURL(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAuthenticationTransactionID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCardholderMessage(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCavv(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCavvAlgorithm(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateChallengeCancelCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateChallengeRequired(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDecoupledAuthenticationIndicator(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDirectoryServerErrorDescription(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDirectoryServerTransactionID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEcommerceIndicator(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEffectiveAuthenticationType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateInteractionCounter(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateIvr(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNetworkScore(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSdkTransactionID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSignedParesStatusReason(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateStepUpURL(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateStrongAuthentication(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateThreeDSServerTransactionID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateWhiteListStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateWhiteListStatusSource(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyConsumerAuthenticationInformation) validateAcsTransactionID(formats strfmt.Registry) error {
	if swag.IsZero(o.AcsTransactionID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"consumerAuthenticationInformation"+"."+"acsTransactionId", "body", o.AcsTransactionID, 36); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyConsumerAuthenticationInformation) validateAcsURL(formats strfmt.Registry) error {
	if swag.IsZero(o.AcsURL) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"consumerAuthenticationInformation"+"."+"acsUrl", "body", o.AcsURL, 2048); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyConsumerAuthenticationInformation) validateAuthenticationTransactionID(formats strfmt.Registry) error {
	if swag.IsZero(o.AuthenticationTransactionID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"consumerAuthenticationInformation"+"."+"authenticationTransactionId", "body", o.AuthenticationTransactionID, 20); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyConsumerAuthenticationInformation) validateCardholderMessage(formats strfmt.Registry) error {
	if swag.IsZero(o.CardholderMessage) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"consumerAuthenticationInformation"+"."+"cardholderMessage", "body", o.CardholderMessage, 128); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyConsumerAuthenticationInformation) validateCavv(formats strfmt.Registry) error {
	if swag.IsZero(o.Cavv) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"consumerAuthenticationInformation"+"."+"cavv", "body", o.Cavv, 255); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyConsumerAuthenticationInformation) validateCavvAlgorithm(formats strfmt.Registry) error {
	if swag.IsZero(o.CavvAlgorithm) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"consumerAuthenticationInformation"+"."+"cavvAlgorithm", "body", o.CavvAlgorithm, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyConsumerAuthenticationInformation) validateChallengeCancelCode(formats strfmt.Registry) error {
	if swag.IsZero(o.ChallengeCancelCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"consumerAuthenticationInformation"+"."+"challengeCancelCode", "body", o.ChallengeCancelCode, 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyConsumerAuthenticationInformation) validateChallengeRequired(formats strfmt.Registry) error {
	if swag.IsZero(o.ChallengeRequired) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"consumerAuthenticationInformation"+"."+"challengeRequired", "body", o.ChallengeRequired, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyConsumerAuthenticationInformation) validateDecoupledAuthenticationIndicator(formats strfmt.Registry) error {
	if swag.IsZero(o.DecoupledAuthenticationIndicator) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"consumerAuthenticationInformation"+"."+"decoupledAuthenticationIndicator", "body", o.DecoupledAuthenticationIndicator, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyConsumerAuthenticationInformation) validateDirectoryServerErrorDescription(formats strfmt.Registry) error {
	if swag.IsZero(o.DirectoryServerErrorDescription) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"consumerAuthenticationInformation"+"."+"directoryServerErrorDescription", "body", o.DirectoryServerErrorDescription, 4096); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyConsumerAuthenticationInformation) validateDirectoryServerTransactionID(formats strfmt.Registry) error {
	if swag.IsZero(o.DirectoryServerTransactionID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"consumerAuthenticationInformation"+"."+"directoryServerTransactionId", "body", o.DirectoryServerTransactionID, 36); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyConsumerAuthenticationInformation) validateEcommerceIndicator(formats strfmt.Registry) error {
	if swag.IsZero(o.EcommerceIndicator) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"consumerAuthenticationInformation"+"."+"ecommerceIndicator", "body", o.EcommerceIndicator, 255); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyConsumerAuthenticationInformation) validateEffectiveAuthenticationType(formats strfmt.Registry) error {
	if swag.IsZero(o.EffectiveAuthenticationType) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"consumerAuthenticationInformation"+"."+"effectiveAuthenticationType", "body", o.EffectiveAuthenticationType, 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyConsumerAuthenticationInformation) validateInteractionCounter(formats strfmt.Registry) error {
	if swag.IsZero(o.InteractionCounter) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"consumerAuthenticationInformation"+"."+"interactionCounter", "body", o.InteractionCounter, 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyConsumerAuthenticationInformation) validateIvr(formats strfmt.Registry) error {
	if swag.IsZero(o.Ivr) { // not required
		return nil
	}

	if o.Ivr != nil {
		if err := o.Ivr.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "consumerAuthenticationInformation" + "." + "ivr")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "consumerAuthenticationInformation" + "." + "ivr")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyConsumerAuthenticationInformation) validateNetworkScore(formats strfmt.Registry) error {
	if swag.IsZero(o.NetworkScore) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"consumerAuthenticationInformation"+"."+"networkScore", "body", o.NetworkScore, 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyConsumerAuthenticationInformation) validateSdkTransactionID(formats strfmt.Registry) error {
	if swag.IsZero(o.SdkTransactionID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"consumerAuthenticationInformation"+"."+"sdkTransactionId", "body", o.SdkTransactionID, 36); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyConsumerAuthenticationInformation) validateSignedParesStatusReason(formats strfmt.Registry) error {
	if swag.IsZero(o.SignedParesStatusReason) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"consumerAuthenticationInformation"+"."+"signedParesStatusReason", "body", o.SignedParesStatusReason, 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyConsumerAuthenticationInformation) validateStepUpURL(formats strfmt.Registry) error {
	if swag.IsZero(o.StepUpURL) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"consumerAuthenticationInformation"+"."+"stepUpUrl", "body", o.StepUpURL, 2048); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyConsumerAuthenticationInformation) validateStrongAuthentication(formats strfmt.Registry) error {
	if swag.IsZero(o.StrongAuthentication) { // not required
		return nil
	}

	if o.StrongAuthentication != nil {
		if err := o.StrongAuthentication.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "consumerAuthenticationInformation" + "." + "strongAuthentication")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "consumerAuthenticationInformation" + "." + "strongAuthentication")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyConsumerAuthenticationInformation) validateThreeDSServerTransactionID(formats strfmt.Registry) error {
	if swag.IsZero(o.ThreeDSServerTransactionID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"consumerAuthenticationInformation"+"."+"threeDSServerTransactionId", "body", o.ThreeDSServerTransactionID, 36); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyConsumerAuthenticationInformation) validateWhiteListStatus(formats strfmt.Registry) error {
	if swag.IsZero(o.WhiteListStatus) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"consumerAuthenticationInformation"+"."+"whiteListStatus", "body", o.WhiteListStatus, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyConsumerAuthenticationInformation) validateWhiteListStatusSource(formats strfmt.Registry) error {
	if swag.IsZero(o.WhiteListStatusSource) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"consumerAuthenticationInformation"+"."+"whiteListStatusSource", "body", o.WhiteListStatusSource, 2); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this create payment created body consumer authentication information based on the context it is used
func (o *CreatePaymentCreatedBodyConsumerAuthenticationInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateIvr(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateStrongAuthentication(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyConsumerAuthenticationInformation) contextValidateIvr(ctx context.Context, formats strfmt.Registry) error {

	if o.Ivr != nil {
		if err := o.Ivr.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "consumerAuthenticationInformation" + "." + "ivr")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "consumerAuthenticationInformation" + "." + "ivr")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyConsumerAuthenticationInformation) contextValidateStrongAuthentication(ctx context.Context, formats strfmt.Registry) error {

	if o.StrongAuthentication != nil {
		if err := o.StrongAuthentication.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "consumerAuthenticationInformation" + "." + "strongAuthentication")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "consumerAuthenticationInformation" + "." + "strongAuthentication")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyConsumerAuthenticationInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyConsumerAuthenticationInformation) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyConsumerAuthenticationInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyConsumerAuthenticationInformationIvr create payment created body consumer authentication information ivr
swagger:model CreatePaymentCreatedBodyConsumerAuthenticationInformationIvr
*/
type CreatePaymentCreatedBodyConsumerAuthenticationInformationIvr struct {

	// Flag to indicate if a valid IVR transaction was detected.
	//
	EnabledMessage bool `json:"enabledMessage,omitempty"`

	// Encryption key to be used in the event the ACS requires encryption of the credential field.
	//
	// Max Length: 16
	EncryptionKey string `json:"encryptionKey,omitempty"`

	// Flag to indicate if the ACS requires the credential to be encrypted.
	//
	EncryptionMandatory bool `json:"encryptionMandatory,omitempty"`

	// An indicator from the ACS to inform the type of encryption that should be used in the event the ACS requires encryption of the credential field.
	//
	// Max Length: 20
	EncryptionType string `json:"encryptionType,omitempty"`

	// An ACS Provided label that can be presented to the Consumer. Recommended use with an application.
	//
	// Max Length: 20
	Label string `json:"label,omitempty"`

	// An ACS provided string that can be presented to the Consumer. Recommended use with an application.
	//
	// Max Length: 80
	Prompt string `json:"prompt,omitempty"`

	// An ACS provided message that can provide additional information or details.
	//
	// Max Length: 80
	StatusMessage string `json:"statusMessage,omitempty"`
}

// Validate validates this create payment created body consumer authentication information ivr
func (o *CreatePaymentCreatedBodyConsumerAuthenticationInformationIvr) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateEncryptionKey(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEncryptionType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLabel(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePrompt(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateStatusMessage(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyConsumerAuthenticationInformationIvr) validateEncryptionKey(formats strfmt.Registry) error {
	if swag.IsZero(o.EncryptionKey) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"consumerAuthenticationInformation"+"."+"ivr"+"."+"encryptionKey", "body", o.EncryptionKey, 16); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyConsumerAuthenticationInformationIvr) validateEncryptionType(formats strfmt.Registry) error {
	if swag.IsZero(o.EncryptionType) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"consumerAuthenticationInformation"+"."+"ivr"+"."+"encryptionType", "body", o.EncryptionType, 20); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyConsumerAuthenticationInformationIvr) validateLabel(formats strfmt.Registry) error {
	if swag.IsZero(o.Label) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"consumerAuthenticationInformation"+"."+"ivr"+"."+"label", "body", o.Label, 20); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyConsumerAuthenticationInformationIvr) validatePrompt(formats strfmt.Registry) error {
	if swag.IsZero(o.Prompt) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"consumerAuthenticationInformation"+"."+"ivr"+"."+"prompt", "body", o.Prompt, 80); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyConsumerAuthenticationInformationIvr) validateStatusMessage(formats strfmt.Registry) error {
	if swag.IsZero(o.StatusMessage) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"consumerAuthenticationInformation"+"."+"ivr"+"."+"statusMessage", "body", o.StatusMessage, 80); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment created body consumer authentication information ivr based on context it is used
func (o *CreatePaymentCreatedBodyConsumerAuthenticationInformationIvr) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyConsumerAuthenticationInformationIvr) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyConsumerAuthenticationInformationIvr) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyConsumerAuthenticationInformationIvr
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyConsumerAuthenticationInformationStrongAuthentication create payment created body consumer authentication information strong authentication
swagger:model CreatePaymentCreatedBodyConsumerAuthenticationInformationStrongAuthentication
*/
type CreatePaymentCreatedBodyConsumerAuthenticationInformationStrongAuthentication struct {

	// issuer information
	IssuerInformation *CreatePaymentCreatedBodyConsumerAuthenticationInformationStrongAuthenticationIssuerInformation `json:"issuerInformation,omitempty"`
}

// Validate validates this create payment created body consumer authentication information strong authentication
func (o *CreatePaymentCreatedBodyConsumerAuthenticationInformationStrongAuthentication) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateIssuerInformation(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyConsumerAuthenticationInformationStrongAuthentication) validateIssuerInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.IssuerInformation) { // not required
		return nil
	}

	if o.IssuerInformation != nil {
		if err := o.IssuerInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "consumerAuthenticationInformation" + "." + "strongAuthentication" + "." + "issuerInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "consumerAuthenticationInformation" + "." + "strongAuthentication" + "." + "issuerInformation")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this create payment created body consumer authentication information strong authentication based on the context it is used
func (o *CreatePaymentCreatedBodyConsumerAuthenticationInformationStrongAuthentication) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateIssuerInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyConsumerAuthenticationInformationStrongAuthentication) contextValidateIssuerInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.IssuerInformation != nil {
		if err := o.IssuerInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "consumerAuthenticationInformation" + "." + "strongAuthentication" + "." + "issuerInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "consumerAuthenticationInformation" + "." + "strongAuthentication" + "." + "issuerInformation")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyConsumerAuthenticationInformationStrongAuthentication) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyConsumerAuthenticationInformationStrongAuthentication) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyConsumerAuthenticationInformationStrongAuthentication
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyConsumerAuthenticationInformationStrongAuthenticationIssuerInformation create payment created body consumer authentication information strong authentication issuer information
swagger:model CreatePaymentCreatedBodyConsumerAuthenticationInformationStrongAuthenticationIssuerInformation
*/
type CreatePaymentCreatedBodyConsumerAuthenticationInformationStrongAuthenticationIssuerInformation struct {

	// Possible values: Visa Platform Connect
	// - `8401` Merchant not participating in Visa Trusted Listing Program.
	// - `8402` Issuer not participating in Visa Trusted Listing Program.
	// - `8403` Cardholder has not trusted the merchant (supplied by Visa Net).
	// - `8404` Indeterminate or invalid issuer response.
	// - `8473` Cardholder has not trusted the merchant (issuer-supplied).
	// - `8474` Did not meet the exemption criteria (issuer-supplied).
	//
	// Upto 20 Values may be received in a transaction.
	//
	// Max Length: 80
	RiskAnalysisExemptionResult string `json:"riskAnalysisExemptionResult,omitempty"`

	// Possible values: Visa Platform Connect
	// - `2` Trusted merchant exemption validated/honored.
	// - `3` Trusted merchant exemption failed validation/not honored.
	//
	// Max Length: 4
	TrustedMerchantExemptionResult string `json:"trustedMerchantExemptionResult,omitempty"`
}

// Validate validates this create payment created body consumer authentication information strong authentication issuer information
func (o *CreatePaymentCreatedBodyConsumerAuthenticationInformationStrongAuthenticationIssuerInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateRiskAnalysisExemptionResult(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTrustedMerchantExemptionResult(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyConsumerAuthenticationInformationStrongAuthenticationIssuerInformation) validateRiskAnalysisExemptionResult(formats strfmt.Registry) error {
	if swag.IsZero(o.RiskAnalysisExemptionResult) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"consumerAuthenticationInformation"+"."+"strongAuthentication"+"."+"issuerInformation"+"."+"riskAnalysisExemptionResult", "body", o.RiskAnalysisExemptionResult, 80); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyConsumerAuthenticationInformationStrongAuthenticationIssuerInformation) validateTrustedMerchantExemptionResult(formats strfmt.Registry) error {
	if swag.IsZero(o.TrustedMerchantExemptionResult) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"consumerAuthenticationInformation"+"."+"strongAuthentication"+"."+"issuerInformation"+"."+"trustedMerchantExemptionResult", "body", o.TrustedMerchantExemptionResult, 4); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment created body consumer authentication information strong authentication issuer information based on context it is used
func (o *CreatePaymentCreatedBodyConsumerAuthenticationInformationStrongAuthenticationIssuerInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyConsumerAuthenticationInformationStrongAuthenticationIssuerInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyConsumerAuthenticationInformationStrongAuthenticationIssuerInformation) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyConsumerAuthenticationInformationStrongAuthenticationIssuerInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyErrorInformation create payment created body error information
swagger:model CreatePaymentCreatedBodyErrorInformation
*/
type CreatePaymentCreatedBodyErrorInformation struct {

	// details
	Details []*CreatePaymentCreatedBodyErrorInformationDetailsItems0 `json:"details"`

	// The detail message related to the status and reason listed above.
	Message string `json:"message,omitempty"`

	// The reason of the status.
	//
	// Possible values:
	//  - AVS_FAILED
	//  - CONTACT_PROCESSOR
	//  - EXPIRED_CARD
	//  - PROCESSOR_DECLINED
	//  - INSUFFICIENT_FUND
	//  - STOLEN_LOST_CARD
	//  - ISSUER_UNAVAILABLE
	//  - UNAUTHORIZED_CARD
	//  - CVN_NOT_MATCH
	//  - EXCEEDS_CREDIT_LIMIT
	//  - INVALID_CVN
	//  - DECLINED_CHECK
	//  - BLACKLISTED_CUSTOMER
	//  - SUSPENDED_ACCOUNT
	//  - PAYMENT_REFUSED
	//  - CV_FAILED
	//  - INVALID_ACCOUNT
	//  - GENERAL_DECLINE
	//  - INVALID_MERCHANT_CONFIGURATION
	//  - DECISION_PROFILE_REJECT
	//  - SCORE_EXCEEDS_THRESHOLD
	//  - PENDING_AUTHENTICATION
	//  - ACH_VERIFICATION_FAILED
	//  - DECISION_PROFILE_REVIEW
	//  - CONSUMER_AUTHENTICATION_REQUIRED
	//  - CONSUMER_AUTHENTICATION_FAILED
	//  - ALLOWABLE_PIN_RETRIES_EXCEEDED
	//  - PROCESSOR_ERROR
	//
	Reason string `json:"reason,omitempty"`
}

// Validate validates this create payment created body error information
func (o *CreatePaymentCreatedBodyErrorInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyErrorInformation) validateDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.Details) { // not required
		return nil
	}

	for i := 0; i < len(o.Details); i++ {
		if swag.IsZero(o.Details[i]) { // not required
			continue
		}

		if o.Details[i] != nil {
			if err := o.Details[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("createPaymentCreated" + "." + "errorInformation" + "." + "details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("createPaymentCreated" + "." + "errorInformation" + "." + "details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this create payment created body error information based on the context it is used
func (o *CreatePaymentCreatedBodyErrorInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyErrorInformation) contextValidateDetails(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.Details); i++ {

		if o.Details[i] != nil {
			if err := o.Details[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("createPaymentCreated" + "." + "errorInformation" + "." + "details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("createPaymentCreated" + "." + "errorInformation" + "." + "details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyErrorInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyErrorInformation) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyErrorInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyErrorInformationDetailsItems0 create payment created body error information details items0
swagger:model CreatePaymentCreatedBodyErrorInformationDetailsItems0
*/
type CreatePaymentCreatedBodyErrorInformationDetailsItems0 struct {

	// This is the flattened JSON object field name/path that is either missing or invalid.
	Field string `json:"field,omitempty"`

	// Possible reasons for the error.
	//
	// Possible values:
	//  - MISSING_FIELD
	//  - INVALID_DATA
	//
	Reason string `json:"reason,omitempty"`
}

// Validate validates this create payment created body error information details items0
func (o *CreatePaymentCreatedBodyErrorInformationDetailsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this create payment created body error information details items0 based on context it is used
func (o *CreatePaymentCreatedBodyErrorInformationDetailsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyErrorInformationDetailsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyErrorInformationDetailsItems0) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyErrorInformationDetailsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyInstallmentInformation create payment created body installment information
swagger:model CreatePaymentCreatedBodyInstallmentInformation
*/
type CreatePaymentCreatedBodyInstallmentInformation struct {

	// Additional costs charged by the issuer to fund the installment payments.
	//
	// This field is included in the authorization reply for the Crediario eligibility request when the issuer approves
	// the cardholder's request for Crediario installment payments in Brazil.
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file1:
	// - Record: CP01 TCR9
	// - Position: 128-139
	// - Field: Total Other Costs
	//
	// Max Length: 12
	AdditionalCosts string `json:"additionalCosts,omitempty"`

	// Additional costs divided by the amount funded.
	//
	// For example:
	// - A value of 1.0 specifies 1%.
	// - A value of 4.0 specifies 4%.
	//
	// This field is included in the authorization reply for the Crediario eligibility request when the issuer approves
	// the cardholder's request for Crediario installment payments in Brazil.
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file1:
	// - Record: CP01 TCR9
	// - Position: 140-143
	// - Field: Percent of Total Other Costs
	//
	// Max Length: 4
	AdditionalCostsPercentage string `json:"additionalCostsPercentage,omitempty"`

	// Amount for the current installment payment.
	//
	// This field is supported only for CyberSource through VisaNet.
	//
	// For details, see `installment_amount` field description in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// Max Length: 12
	Amount string `json:"amount,omitempty"`

	// Amount funded.
	//
	// This field is included in the authorization reply for the Crediario eligibility request when the issuer approves
	// the cardholder's request for Crediario installment payments in Brazil.
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file1:
	// - Record: CP01 TCR9
	// - Position: 48-59
	// - Field: Total Amount Funded
	//
	// Max Length: 12
	AmountFunded string `json:"amountFunded,omitempty"`

	// Amount requested divided by the amount funded.
	//
	// For example:
	// - A value of 90.0 specifies 90%.
	// - A value of 93.7 specifies 93.7%.
	//
	// This field is included in the authorization reply for the Crediario eligibility request when the issuer approves
	// the cardholder's request for Crediario installment payments in Brazil.
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file1:
	// - Record: CP01 TCR9
	// - Position: 60-63
	// - Field: Percent of Amount Requested
	//
	// Max Length: 4
	AmountRequestedPercentage string `json:"amountRequestedPercentage,omitempty"`

	// Annual cost of financing the installment payments.
	//
	// This field is included in the authorization reply for the Crediario eligibility request when the issuer approves
	// the cardholder's request for Crediario installment payments in Brazil.
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file1:
	// - Record: CP01 TCR9
	// - Position: 158-164
	// - Field: Annual Total Cost of Financing
	//
	// Max Length: 7
	AnnualFinancingCost string `json:"annualFinancingCost,omitempty"`

	// Annual interest rate.
	//
	// For example:
	// - A value of 1.0 specifies 1%.
	// - A value of 4.0 specifies 4%.
	//
	// This field is included in the authorization reply for the Crediario eligibility request when the issuer approves
	// the cardholder's request for Crediario installment payments in Brazil.
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file1:
	// - Record: CP01 TCR9
	// - Position: 151-157
	// - Field: Annual Interest Rate
	//
	// Max Length: 7
	AnnualInterestRate string `json:"annualInterestRate,omitempty"`

	// Expenses charged by the issuer to fund the installment payments.
	//
	// This field is included in the authorization reply for the Crediario eligibility request when the issuer approves
	// the cardholder's request for Crediario installment payments in Brazil.
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file1:
	// - Record: CP01 TCR9
	// - Position: 64-75
	// - Field: Total Expenses
	//
	// Max Length: 12
	Expenses string `json:"expenses,omitempty"`

	// Expenses divided by the amount funded.
	//
	// For example:
	// - A value of 1.0 specifies 1%.
	// - A value of 4.0 specifies 4%.
	//
	// This field is included in the authorization reply for the Crediario eligibility request when the issuer approves
	// the cardholder's request for Crediario installment payments in Brazil.
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file1:
	// - Record: CP01 TCR9
	// - Position: 76-79
	// - Field: Percent of Total Expenses
	//
	// Max Length: 4
	ExpensesPercentage string `json:"expensesPercentage,omitempty"`

	// Fees charged by the issuer to fund the installment payments.
	//
	// This field is included in the authorization reply for the Crediario eligibility request when the issuer approves
	// the cardholder's request for Crediario installment payments in Brazil.
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file1:
	// - Record: CP01 TCR9
	// - Position: 80-91
	// - Field: Total Fees
	//
	// Max Length: 12
	Fees string `json:"fees,omitempty"`

	// Fees divided by the amount funded.
	//
	// For example:
	// - A value of 1.0 specifies 1%.
	// - A value of 4.0 specifies 4%.
	//
	// This field is included in the authorization reply for the Crediario eligibility request when the issuer approves
	// the cardholder's request for Crediario installment payments in Brazil.
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// This field is supported only for Crediario installment payments in Brazil on CyberSource through VisaNet.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file1:
	// - Record: CP01 TCR9
	// - Position: 92-95
	// - Field: Percent of Total Fees
	//
	// Max Length: 4
	FeesPercentage string `json:"feesPercentage,omitempty"`

	// Amount of the first installment payment. The issuer provides this value when the first installment payment is successful.
	// This field is supported for Mastercard installment payments on CyberSource through VisaNet in all countries except Brazil,Croatia, Georgia, and Greece.
	// The value for this field corresponds to the following data in the TC 33 capture file:
	// - Record: CP01 TCR5
	// - Position: 23-34
	// - Field: Amount of Each Installment
	//
	// Max Length: 13
	FirstInstallmentAmount string `json:"firstInstallmentAmount,omitempty"`

	// Date of the first installment payment. Format: YYMMDD. When you do not include this field, CyberSource sends a string of six zeros (000000) to the processor.
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// This field is supported only for Crediario installment payments in Brazil on CyberSource through VisaNet.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file:
	// - Record: CP01 TCR9
	// - Position: 42-47
	// - Field: Date of First Installment
	//
	// Max Length: 6
	FirstInstallmentDate string `json:"firstInstallmentDate,omitempty"`

	// Frequency of the installment payments. When you do not include this field in a request for a
	// Crediario installment payment, CyberSource sends a space character to the processor.
	//
	// For details, see `installment_frequency` field description in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// This field is supported only for CyberSource through VisaNet. Possible values:
	// - `B`: Biweekly
	// - `M`: Monthly
	// - `W`: Weekly
	//
	// For Crediario installment payments, the value for this field corresponds to the following data in the TC 33 capture file5:
	// - Record: CP01 TCR9
	// - Position: 41
	// - Field: Installment Frequency
	//
	// For details, see "Installment Payments" in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// Max Length: 1
	Frequency string `json:"frequency,omitempty"`

	// Insurance charged by the issuer to fund the installment payments.
	//
	// This field is included in the authorization reply for the Crediario eligibility request when the issuer approves
	// the cardholder's request for Crediario installment payments in Brazil.
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file1:
	// - Record: CP01 TCR9
	// - Position: 112-123
	// - Field: Total Insurance
	//
	// Max Length: 12
	Insurance string `json:"insurance,omitempty"`

	// Insurance costs divided by the amount funded.
	//
	// For example:
	// - A value of 1.0 specifies 1%.
	// - A value of 4.0 specifies 4%.
	//
	// This field is included in the authorization reply for the Crediario eligibility request when the issuer approves
	// the cardholder's request for Crediario installment payments in Brazil.
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file1:
	// - Record: CP01 TCR9
	// - Position: 124-127
	// - Field: Percent Of Total Insurance
	//
	// Max Length: 4
	InsurancePercentage string `json:"insurancePercentage,omitempty"`

	// Invoice information that you want to provide to the issuer. This value is similar to a tracking number and is
	// the same for all installment payments for one purchase.
	//
	// This field is supported only for installment payments with Mastercard on CyberSource through VisaNet in Brazil.
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// The value for this field corresponds to the following data in the TC 33 capture file5:
	// - Record: CP07 TCR4
	// - Position: 51-70
	// - Field: Purchase Identification
	//
	// Max Length: 20
	InvoiceData string `json:"invoiceData,omitempty"`

	// Maximum number of installments offered by the issuer for this purchase. The issuer provides this value when the first installment payment is successful.
	// This field is supported for installment payments with Mastercard on CyberSource through VisaNet in all countries except Brazil, Croatia, Georgia, and Greece.
	// The value for this field corresponds to the following data in the TC 33 capture file1:
	// - Record: CP01 TCR5
	// - Position: 77-78
	// - Field: Mastercard Maximum Number Of Installments
	//
	MaximumTotalCount string `json:"maximumTotalCount,omitempty"`

	// "Minimum number of installments offered by the issuer for this purchase. The issuer provides this value when the first installment payment is successful.
	// This field is supported for installment payments with Mastercard on CyberSource through VisaNet in all countries except Brazil, Croatia, Georgia, and Greece.
	// The value for this field corresponds to the following data in the TC 33 capture file:
	// - Record: CP01 TCR5
	// - Position: 75-76
	// - Field: Mastercard Minimum Number Of Installments
	//
	MinimumTotalCount string `json:"minimumTotalCount,omitempty"`

	// Monthly interest rate.
	//
	// For example:
	// - A value of 1.0 specifies 1%.
	// - A value of 4.0 specifies 4%.
	//
	// This field is included in the authorization reply for the Crediario eligibility request when the issuer approves
	// the cardholder's request for Crediario installment payments in Brazil.
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file1:
	// - Record: CP01 TCR9
	// - Position: 144-150
	// - Field: Monthly Interest Rate
	//
	// Max Length: 7
	MonthlyInterestRate string `json:"monthlyInterestRate,omitempty"`

	// #### American Express Direct, Cielo, and CyberSource Latin American Processing
	// Flag that indicates the type of funding for the installment plan associated with the payment.
	//
	// Possible values:
	// - `1`: Merchant-funded installment plan
	// - `2`: Issuer-funded installment plan
	// If you do not include this field in the request, CyberSource uses the value in your CyberSource account.
	//
	// To change the value in your CyberSource account, contact CyberSource Customer Service.
	// For details, see `installment_plan_type` field description in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// #### CyberSource through VisaNet and American Express
	// Defined code that indicates the type of installment plan for this transaction.
	//
	// Contact American Express for:
	// - Information about the kinds of installment plans that American Express provides
	// - Values for this field
	//
	// For installment payments with American Express in Brazil, the value for this field corresponds to the following data in the TC 33 capture file*:
	// - Record: CP07 TCR3
	// - Position: 5-6
	// - Field: Plan Type
	//
	// * The TC 33 Capture file contains information about the purchases and refunds that a merchant submits to CyberSource. CyberSource through VisaNet creates the TC 33 Capture file at the end of the day and sends it to the merchants acquirer, who uses this information to facilitate end-of-day clearing processing with payment card companies.
	//
	// #### CyberSource through VisaNet with Visa or Mastercard
	// Flag indicating the type of funding for the installment plan associated with the payment.
	// Possible values:
	// - 1 or 01: Merchant-funded installment plan
	// - 2 or 02: Issuer-funded installment plan
	// - 43: Crediario installment planonly with Visa in Brazil
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// For installment payments with Visa in Brazil, the value for this field corresponds to the following data in the TC 33 capture file5:
	// - Record: CP07 TCR1
	// - Position: 5-6
	// - Field: Installment Type
	//
	// For all other kinds of installment payments, the value for this field corresponds to the following data in the TC 33 capture file5:
	// - Record: CP01 TCR5
	// - Position: 39-40
	// - Field: Installment Plan Type (Issuer or Merchant)
	//
	// Max Length: 1
	PlanType string `json:"planType,omitempty"`

	// Installment number when making payments in installments. Used along with `totalCount` to track which payment is being processed.
	//
	// For example, the second of 5 payments would be passed to CyberSource as `sequence` = 2 and `totalCount` = 5.
	//
	// For details, see "Installment Payments" in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// #### Chase Paymentech Solutions and FDC Compass
	// This field is optional because this value is required in the merchant descriptors.
	// For details, see "Chase Paymentech Solutions Merchant Descriptors" and "FDC Compass Merchant Descriptors" in the [Merchant Descriptors Using the SCMP API]
	// (https://apps.cybersource.com/library/documentation/dev_guides/Merchant_Descriptors_SCMP_API/html/)
	//
	// #### CyberSource through VisaNet
	// When you do not include this field in a request for a Crediario installment payment, CyberSource sends a value of 0 to the processor.
	//
	// For Crediario installment payments, the value for this field corresponds to the following data in the TC 33 capture file*:
	// - Record: CP01 TCR9
	// - Position: 38-40
	// - Field: Installment Payment Number
	//
	// * The TC 33 Capture file contains information about the purchases and refunds that a merchant submits to CyberSource. CyberSource through VisaNet creates the TC 33 Capture file at the end of the day and sends it to the merchants acquirer, who uses this information to facilitate end-of-day clearing processing with payment card companies.
	//
	// Maximum: 99
	Sequence int64 `json:"sequence,omitempty"`

	// Taxes collected by the issuer to fund the installment payments.
	//
	// This field is included in the authorization reply for the Crediario eligibility request when the issuer approves
	// the cardholder's request for Crediario installment payments in Brazil.
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file1:
	// - Record: CP01 TCR9
	// - Position: 96-107
	// - Field: Total Taxes
	//
	// Max Length: 12
	Taxes string `json:"taxes,omitempty"`

	// Taxes divided by the amount funded.
	//
	// For example:
	// - A value of 1.0 specifies 1%.
	// - A value of 4.0 specifies 4%.
	//
	// This field is included in the authorization reply for the Crediario eligibility request when the issuer approves
	// the cardholder's request for Crediario installment payments in Brazil.
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file1:
	// - Record: CP01 TCR9
	// - Position: 108-111
	// - Field: Percent of Total Taxes
	//
	// Max Length: 4
	TaxesPercentage string `json:"taxesPercentage,omitempty"`

	// Total amount of the loan that is being paid in installments. This field is supported only for CyberSource
	// through VisaNet.
	//
	// For details, see "Installment Payments" in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// Max Length: 12
	TotalAmount string `json:"totalAmount,omitempty"`

	// Total number of installments when making payments in installments.
	//
	// For details, see "Installment Payments" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// #### Chase Paymentech Solutions and FDC Compass
	// This field is optional because this value is required in the merchant descriptors.
	//
	// For details, see "Chase Paymentech Solutions Merchant Descriptors" and "FDC Compass Merchant Descriptors" in the [Merchant Descriptors Using the SCMP API.]
	// (https://apps.cybersource.com/library/documentation/dev_guides/Merchant_Descriptors_SCMP_API/html/)
	//
	// #### American Express Direct, Cielo, and Comercio Latino
	// This value is the total number of installments you approved.
	//
	// #### CyberSource Latin American Processing in Brazil
	// This value is the total number of installments that you approved. The default is 1.
	//
	// #### All Other Processors
	// This value is used along with _sequence_ to track which payment is being processed.
	//
	// For example, the second of 5 payments would be passed to CyberSource as _sequence_ = 2 and _totalCount_ = 5.
	//
	// #### CyberSource through VisaNet
	// For Crediario installment payments, the value for this field corresponds to the following data in the TC 33 capture file*:
	// - Record: CP01 TCR9
	// - Position: 23-25
	// - Field: Number of Installments
	//
	// For installment payments with American Express in Brazil, the value for this field corresponds to the following data in the TC 33 capture file*:
	// - Record: CP07 TCR3
	// - Position: 7-8
	// - Field: Number of Installments
	//
	// For installment payments with Visa in Brazil, the value for this field corresponds to the following data in the TC 33 capture file*:
	// - Record: CP07 TCR1
	// - Position: 7-8
	// - Field: Number of Installments
	//
	// For all other kinds of installment payments, the value for this field corresponds to the following data in the TC 33 capture file*:
	// - Record: CP01 TCR5
	// - Position: 20-22
	// - Field: Installment Total Count
	//
	// **Note** The TC 33 Capture file contains information about the purchases and refunds that a merchant submits to CyberSource. CyberSource through VisaNet creates the TC 33 Capture file at the end of the day and sends it to the merchants acquirer, who uses this information to facilitate end-of-day clearing processing with payment card companies.
	//
	// Maximum: 99
	TotalCount int64 `json:"totalCount,omitempty"`
}

// Validate validates this create payment created body installment information
func (o *CreatePaymentCreatedBodyInstallmentInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAdditionalCosts(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAdditionalCostsPercentage(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAmountFunded(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAmountRequestedPercentage(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAnnualFinancingCost(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAnnualInterestRate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpenses(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpensesPercentage(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFees(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFeesPercentage(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFirstInstallmentAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFirstInstallmentDate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFrequency(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateInsurance(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateInsurancePercentage(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateInvoiceData(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMonthlyInterestRate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePlanType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSequence(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxes(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxesPercentage(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTotalAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTotalCount(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyInstallmentInformation) validateAdditionalCosts(formats strfmt.Registry) error {
	if swag.IsZero(o.AdditionalCosts) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"installmentInformation"+"."+"additionalCosts", "body", o.AdditionalCosts, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyInstallmentInformation) validateAdditionalCostsPercentage(formats strfmt.Registry) error {
	if swag.IsZero(o.AdditionalCostsPercentage) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"installmentInformation"+"."+"additionalCostsPercentage", "body", o.AdditionalCostsPercentage, 4); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyInstallmentInformation) validateAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.Amount) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"installmentInformation"+"."+"amount", "body", o.Amount, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyInstallmentInformation) validateAmountFunded(formats strfmt.Registry) error {
	if swag.IsZero(o.AmountFunded) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"installmentInformation"+"."+"amountFunded", "body", o.AmountFunded, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyInstallmentInformation) validateAmountRequestedPercentage(formats strfmt.Registry) error {
	if swag.IsZero(o.AmountRequestedPercentage) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"installmentInformation"+"."+"amountRequestedPercentage", "body", o.AmountRequestedPercentage, 4); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyInstallmentInformation) validateAnnualFinancingCost(formats strfmt.Registry) error {
	if swag.IsZero(o.AnnualFinancingCost) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"installmentInformation"+"."+"annualFinancingCost", "body", o.AnnualFinancingCost, 7); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyInstallmentInformation) validateAnnualInterestRate(formats strfmt.Registry) error {
	if swag.IsZero(o.AnnualInterestRate) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"installmentInformation"+"."+"annualInterestRate", "body", o.AnnualInterestRate, 7); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyInstallmentInformation) validateExpenses(formats strfmt.Registry) error {
	if swag.IsZero(o.Expenses) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"installmentInformation"+"."+"expenses", "body", o.Expenses, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyInstallmentInformation) validateExpensesPercentage(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpensesPercentage) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"installmentInformation"+"."+"expensesPercentage", "body", o.ExpensesPercentage, 4); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyInstallmentInformation) validateFees(formats strfmt.Registry) error {
	if swag.IsZero(o.Fees) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"installmentInformation"+"."+"fees", "body", o.Fees, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyInstallmentInformation) validateFeesPercentage(formats strfmt.Registry) error {
	if swag.IsZero(o.FeesPercentage) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"installmentInformation"+"."+"feesPercentage", "body", o.FeesPercentage, 4); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyInstallmentInformation) validateFirstInstallmentAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.FirstInstallmentAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"installmentInformation"+"."+"firstInstallmentAmount", "body", o.FirstInstallmentAmount, 13); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyInstallmentInformation) validateFirstInstallmentDate(formats strfmt.Registry) error {
	if swag.IsZero(o.FirstInstallmentDate) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"installmentInformation"+"."+"firstInstallmentDate", "body", o.FirstInstallmentDate, 6); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyInstallmentInformation) validateFrequency(formats strfmt.Registry) error {
	if swag.IsZero(o.Frequency) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"installmentInformation"+"."+"frequency", "body", o.Frequency, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyInstallmentInformation) validateInsurance(formats strfmt.Registry) error {
	if swag.IsZero(o.Insurance) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"installmentInformation"+"."+"insurance", "body", o.Insurance, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyInstallmentInformation) validateInsurancePercentage(formats strfmt.Registry) error {
	if swag.IsZero(o.InsurancePercentage) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"installmentInformation"+"."+"insurancePercentage", "body", o.InsurancePercentage, 4); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyInstallmentInformation) validateInvoiceData(formats strfmt.Registry) error {
	if swag.IsZero(o.InvoiceData) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"installmentInformation"+"."+"invoiceData", "body", o.InvoiceData, 20); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyInstallmentInformation) validateMonthlyInterestRate(formats strfmt.Registry) error {
	if swag.IsZero(o.MonthlyInterestRate) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"installmentInformation"+"."+"monthlyInterestRate", "body", o.MonthlyInterestRate, 7); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyInstallmentInformation) validatePlanType(formats strfmt.Registry) error {
	if swag.IsZero(o.PlanType) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"installmentInformation"+"."+"planType", "body", o.PlanType, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyInstallmentInformation) validateSequence(formats strfmt.Registry) error {
	if swag.IsZero(o.Sequence) { // not required
		return nil
	}

	if err := validate.MaximumInt("createPaymentCreated"+"."+"installmentInformation"+"."+"sequence", "body", o.Sequence, 99, false); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyInstallmentInformation) validateTaxes(formats strfmt.Registry) error {
	if swag.IsZero(o.Taxes) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"installmentInformation"+"."+"taxes", "body", o.Taxes, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyInstallmentInformation) validateTaxesPercentage(formats strfmt.Registry) error {
	if swag.IsZero(o.TaxesPercentage) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"installmentInformation"+"."+"taxesPercentage", "body", o.TaxesPercentage, 4); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyInstallmentInformation) validateTotalAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.TotalAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"installmentInformation"+"."+"totalAmount", "body", o.TotalAmount, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyInstallmentInformation) validateTotalCount(formats strfmt.Registry) error {
	if swag.IsZero(o.TotalCount) { // not required
		return nil
	}

	if err := validate.MaximumInt("createPaymentCreated"+"."+"installmentInformation"+"."+"totalCount", "body", o.TotalCount, 99, false); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment created body installment information based on context it is used
func (o *CreatePaymentCreatedBodyInstallmentInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyInstallmentInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyInstallmentInformation) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyInstallmentInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyIssuerInformation create payment created body issuer information
swagger:model CreatePaymentCreatedBodyIssuerInformation
*/
type CreatePaymentCreatedBodyIssuerInformation struct {

	// Country in which the card was issued. This information enables you to determine whether the card was issued
	// domestically or internationally. Use the two-character [ISO Standard Country Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf).
	//
	// This field is supported for Visa, Mastercard, Discover, Diners Club, JCB, and Maestro (International) on Chase
	// Paymentech Solutions.
	//
	// For details, see `auth_card_issuer_country` field description in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// Max Length: 3
	Country string `json:"country,omitempty"`

	// Data defined by the issuer.
	//
	// This national use field contains two subfields for information unique to the processing of Visa transactions by members in Japan.
	// This subfield contains the Katakana text to be printed on the receipt.
	// For details, see `jpo_issuer_message` field description in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// Max Length: 140
	CountrySpecificDiscretionaryData string `json:"countrySpecificDiscretionaryData,omitempty"`

	// Data defined by the issuer.
	//
	// The value for this reply field will probably be the same as the value that you submitted in the authorization request, but it is possible for the processor, issuer, or acquirer to modify the value.
	//
	// This field is supported only for Visa transactions on **CyberSource through VisaNet**.
	//
	// For details, see `issuer_additional_data` field description in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// Max Length: 255
	DiscretionaryData string `json:"discretionaryData,omitempty"`

	// Additional authorization code that must be printed on the receipt when returned by the processor.
	//
	// This value is generated by the processor and is returned only for a successful transaction.
	//
	// This reply field is supported only for these processors:
	// - FDC Nashville Global
	// - SIX
	//
	// Max Length: 6
	ResponseCode string `json:"responseCode,omitempty"`
}

// Validate validates this create payment created body issuer information
func (o *CreatePaymentCreatedBodyIssuerInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountrySpecificDiscretionaryData(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDiscretionaryData(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateResponseCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyIssuerInformation) validateCountry(formats strfmt.Registry) error {
	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"issuerInformation"+"."+"country", "body", o.Country, 3); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyIssuerInformation) validateCountrySpecificDiscretionaryData(formats strfmt.Registry) error {
	if swag.IsZero(o.CountrySpecificDiscretionaryData) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"issuerInformation"+"."+"countrySpecificDiscretionaryData", "body", o.CountrySpecificDiscretionaryData, 140); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyIssuerInformation) validateDiscretionaryData(formats strfmt.Registry) error {
	if swag.IsZero(o.DiscretionaryData) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"issuerInformation"+"."+"discretionaryData", "body", o.DiscretionaryData, 255); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyIssuerInformation) validateResponseCode(formats strfmt.Registry) error {
	if swag.IsZero(o.ResponseCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"issuerInformation"+"."+"responseCode", "body", o.ResponseCode, 6); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment created body issuer information based on context it is used
func (o *CreatePaymentCreatedBodyIssuerInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyIssuerInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyIssuerInformation) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyIssuerInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyLinks create payment created body links
swagger:model CreatePaymentCreatedBodyLinks
*/
type CreatePaymentCreatedBodyLinks struct {

	// capture
	Capture *CreatePaymentCreatedBodyLinksCapture `json:"capture,omitempty"`

	// customer
	Customer *CreatePaymentCreatedBodyLinksCustomer `json:"customer,omitempty"`

	// instrument identifier
	InstrumentIdentifier *CreatePaymentCreatedBodyLinksInstrumentIdentifier `json:"instrumentIdentifier,omitempty"`

	// payment instrument
	PaymentInstrument *CreatePaymentCreatedBodyLinksPaymentInstrument `json:"paymentInstrument,omitempty"`

	// reversal
	Reversal *CreatePaymentCreatedBodyLinksReversal `json:"reversal,omitempty"`

	// self
	Self *CreatePaymentCreatedBodyLinksSelf `json:"self,omitempty"`

	// shipping address
	ShippingAddress *CreatePaymentCreatedBodyLinksShippingAddress `json:"shippingAddress,omitempty"`
}

// Validate validates this create payment created body links
func (o *CreatePaymentCreatedBodyLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCapture(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCustomer(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateInstrumentIdentifier(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePaymentInstrument(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateReversal(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateShippingAddress(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyLinks) validateCapture(formats strfmt.Registry) error {
	if swag.IsZero(o.Capture) { // not required
		return nil
	}

	if o.Capture != nil {
		if err := o.Capture.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "_links" + "." + "capture")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "_links" + "." + "capture")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyLinks) validateCustomer(formats strfmt.Registry) error {
	if swag.IsZero(o.Customer) { // not required
		return nil
	}

	if o.Customer != nil {
		if err := o.Customer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "_links" + "." + "customer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "_links" + "." + "customer")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyLinks) validateInstrumentIdentifier(formats strfmt.Registry) error {
	if swag.IsZero(o.InstrumentIdentifier) { // not required
		return nil
	}

	if o.InstrumentIdentifier != nil {
		if err := o.InstrumentIdentifier.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "_links" + "." + "instrumentIdentifier")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "_links" + "." + "instrumentIdentifier")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyLinks) validatePaymentInstrument(formats strfmt.Registry) error {
	if swag.IsZero(o.PaymentInstrument) { // not required
		return nil
	}

	if o.PaymentInstrument != nil {
		if err := o.PaymentInstrument.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "_links" + "." + "paymentInstrument")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "_links" + "." + "paymentInstrument")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyLinks) validateReversal(formats strfmt.Registry) error {
	if swag.IsZero(o.Reversal) { // not required
		return nil
	}

	if o.Reversal != nil {
		if err := o.Reversal.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "_links" + "." + "reversal")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "_links" + "." + "reversal")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(o.Self) { // not required
		return nil
	}

	if o.Self != nil {
		if err := o.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "_links" + "." + "self")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyLinks) validateShippingAddress(formats strfmt.Registry) error {
	if swag.IsZero(o.ShippingAddress) { // not required
		return nil
	}

	if o.ShippingAddress != nil {
		if err := o.ShippingAddress.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "_links" + "." + "shippingAddress")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "_links" + "." + "shippingAddress")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this create payment created body links based on the context it is used
func (o *CreatePaymentCreatedBodyLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateCapture(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateCustomer(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateInstrumentIdentifier(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidatePaymentInstrument(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateReversal(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateShippingAddress(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyLinks) contextValidateCapture(ctx context.Context, formats strfmt.Registry) error {

	if o.Capture != nil {
		if err := o.Capture.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "_links" + "." + "capture")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "_links" + "." + "capture")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyLinks) contextValidateCustomer(ctx context.Context, formats strfmt.Registry) error {

	if o.Customer != nil {
		if err := o.Customer.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "_links" + "." + "customer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "_links" + "." + "customer")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyLinks) contextValidateInstrumentIdentifier(ctx context.Context, formats strfmt.Registry) error {

	if o.InstrumentIdentifier != nil {
		if err := o.InstrumentIdentifier.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "_links" + "." + "instrumentIdentifier")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "_links" + "." + "instrumentIdentifier")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyLinks) contextValidatePaymentInstrument(ctx context.Context, formats strfmt.Registry) error {

	if o.PaymentInstrument != nil {
		if err := o.PaymentInstrument.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "_links" + "." + "paymentInstrument")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "_links" + "." + "paymentInstrument")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyLinks) contextValidateReversal(ctx context.Context, formats strfmt.Registry) error {

	if o.Reversal != nil {
		if err := o.Reversal.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "_links" + "." + "reversal")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "_links" + "." + "reversal")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if o.Self != nil {
		if err := o.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "_links" + "." + "self")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyLinks) contextValidateShippingAddress(ctx context.Context, formats strfmt.Registry) error {

	if o.ShippingAddress != nil {
		if err := o.ShippingAddress.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "_links" + "." + "shippingAddress")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "_links" + "." + "shippingAddress")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyLinks) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyLinks) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyLinksCapture create payment created body links capture
swagger:model CreatePaymentCreatedBodyLinksCapture
*/
type CreatePaymentCreatedBodyLinksCapture struct {

	// This is the endpoint of the resource that was created by the successful request.
	Href string `json:"href,omitempty"`

	// `method` refers to the HTTP method that you can send to the `self` endpoint to retrieve details of the resource.
	Method string `json:"method,omitempty"`
}

// Validate validates this create payment created body links capture
func (o *CreatePaymentCreatedBodyLinksCapture) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this create payment created body links capture based on context it is used
func (o *CreatePaymentCreatedBodyLinksCapture) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyLinksCapture) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyLinksCapture) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyLinksCapture
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyLinksCustomer create payment created body links customer
swagger:model CreatePaymentCreatedBodyLinksCustomer
*/
type CreatePaymentCreatedBodyLinksCustomer struct {

	// This is the endpoint of the resource that was created by the successful request.
	Href string `json:"href,omitempty"`

	// `method` refers to the HTTP method that you can send to the `self` endpoint to retrieve details of the resource.
	Method string `json:"method,omitempty"`
}

// Validate validates this create payment created body links customer
func (o *CreatePaymentCreatedBodyLinksCustomer) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this create payment created body links customer based on context it is used
func (o *CreatePaymentCreatedBodyLinksCustomer) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyLinksCustomer) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyLinksCustomer) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyLinksCustomer
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyLinksInstrumentIdentifier create payment created body links instrument identifier
swagger:model CreatePaymentCreatedBodyLinksInstrumentIdentifier
*/
type CreatePaymentCreatedBodyLinksInstrumentIdentifier struct {

	// This is the endpoint of the resource that was created by the successful request.
	Href string `json:"href,omitempty"`

	// `method` refers to the HTTP method that you can send to the `self` endpoint to retrieve details of the resource.
	Method string `json:"method,omitempty"`
}

// Validate validates this create payment created body links instrument identifier
func (o *CreatePaymentCreatedBodyLinksInstrumentIdentifier) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this create payment created body links instrument identifier based on context it is used
func (o *CreatePaymentCreatedBodyLinksInstrumentIdentifier) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyLinksInstrumentIdentifier) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyLinksInstrumentIdentifier) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyLinksInstrumentIdentifier
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyLinksPaymentInstrument create payment created body links payment instrument
swagger:model CreatePaymentCreatedBodyLinksPaymentInstrument
*/
type CreatePaymentCreatedBodyLinksPaymentInstrument struct {

	// This is the endpoint of the resource that was created by the successful request.
	Href string `json:"href,omitempty"`

	// `method` refers to the HTTP method that you can send to the `self` endpoint to retrieve details of the resource.
	Method string `json:"method,omitempty"`
}

// Validate validates this create payment created body links payment instrument
func (o *CreatePaymentCreatedBodyLinksPaymentInstrument) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this create payment created body links payment instrument based on context it is used
func (o *CreatePaymentCreatedBodyLinksPaymentInstrument) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyLinksPaymentInstrument) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyLinksPaymentInstrument) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyLinksPaymentInstrument
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyLinksReversal create payment created body links reversal
swagger:model CreatePaymentCreatedBodyLinksReversal
*/
type CreatePaymentCreatedBodyLinksReversal struct {

	// This is the endpoint of the resource that was created by the successful request.
	Href string `json:"href,omitempty"`

	// `method` refers to the HTTP method that you can send to the `self` endpoint to retrieve details of the resource.
	Method string `json:"method,omitempty"`
}

// Validate validates this create payment created body links reversal
func (o *CreatePaymentCreatedBodyLinksReversal) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this create payment created body links reversal based on context it is used
func (o *CreatePaymentCreatedBodyLinksReversal) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyLinksReversal) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyLinksReversal) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyLinksReversal
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyLinksSelf create payment created body links self
swagger:model CreatePaymentCreatedBodyLinksSelf
*/
type CreatePaymentCreatedBodyLinksSelf struct {

	// This is the endpoint of the resource that was created by the successful request.
	Href string `json:"href,omitempty"`

	// `method` refers to the HTTP method that you can send to the `self` endpoint to retrieve details of the resource.
	Method string `json:"method,omitempty"`
}

// Validate validates this create payment created body links self
func (o *CreatePaymentCreatedBodyLinksSelf) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this create payment created body links self based on context it is used
func (o *CreatePaymentCreatedBodyLinksSelf) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyLinksSelf) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyLinksSelf) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyLinksSelf
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyLinksShippingAddress create payment created body links shipping address
swagger:model CreatePaymentCreatedBodyLinksShippingAddress
*/
type CreatePaymentCreatedBodyLinksShippingAddress struct {

	// This is the endpoint of the resource that was created by the successful request.
	Href string `json:"href,omitempty"`

	// `method` refers to the HTTP method that you can send to the `self` endpoint to retrieve details of the resource.
	Method string `json:"method,omitempty"`
}

// Validate validates this create payment created body links shipping address
func (o *CreatePaymentCreatedBodyLinksShippingAddress) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this create payment created body links shipping address based on context it is used
func (o *CreatePaymentCreatedBodyLinksShippingAddress) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyLinksShippingAddress) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyLinksShippingAddress) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyLinksShippingAddress
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyOrderInformation create payment created body order information
swagger:model CreatePaymentCreatedBodyOrderInformation
*/
type CreatePaymentCreatedBodyOrderInformation struct {

	// amount details
	AmountDetails *CreatePaymentCreatedBodyOrderInformationAmountDetails `json:"amountDetails,omitempty"`

	// invoice details
	InvoiceDetails *CreatePaymentCreatedBodyOrderInformationInvoiceDetails `json:"invoiceDetails,omitempty"`

	// reward points details
	RewardPointsDetails *CreatePaymentCreatedBodyOrderInformationRewardPointsDetails `json:"rewardPointsDetails,omitempty"`
}

// Validate validates this create payment created body order information
func (o *CreatePaymentCreatedBodyOrderInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAmountDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateInvoiceDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRewardPointsDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyOrderInformation) validateAmountDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.AmountDetails) { // not required
		return nil
	}

	if o.AmountDetails != nil {
		if err := o.AmountDetails.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "orderInformation" + "." + "amountDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "orderInformation" + "." + "amountDetails")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyOrderInformation) validateInvoiceDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.InvoiceDetails) { // not required
		return nil
	}

	if o.InvoiceDetails != nil {
		if err := o.InvoiceDetails.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "orderInformation" + "." + "invoiceDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "orderInformation" + "." + "invoiceDetails")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyOrderInformation) validateRewardPointsDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.RewardPointsDetails) { // not required
		return nil
	}

	if o.RewardPointsDetails != nil {
		if err := o.RewardPointsDetails.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "orderInformation" + "." + "rewardPointsDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "orderInformation" + "." + "rewardPointsDetails")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this create payment created body order information based on the context it is used
func (o *CreatePaymentCreatedBodyOrderInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateAmountDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateInvoiceDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateRewardPointsDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyOrderInformation) contextValidateAmountDetails(ctx context.Context, formats strfmt.Registry) error {

	if o.AmountDetails != nil {
		if err := o.AmountDetails.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "orderInformation" + "." + "amountDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "orderInformation" + "." + "amountDetails")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyOrderInformation) contextValidateInvoiceDetails(ctx context.Context, formats strfmt.Registry) error {

	if o.InvoiceDetails != nil {
		if err := o.InvoiceDetails.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "orderInformation" + "." + "invoiceDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "orderInformation" + "." + "invoiceDetails")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyOrderInformation) contextValidateRewardPointsDetails(ctx context.Context, formats strfmt.Registry) error {

	if o.RewardPointsDetails != nil {
		if err := o.RewardPointsDetails.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "orderInformation" + "." + "rewardPointsDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "orderInformation" + "." + "rewardPointsDetails")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyOrderInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyOrderInformation) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyOrderInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyOrderInformationAmountDetails create payment created body order information amount details
swagger:model CreatePaymentCreatedBodyOrderInformationAmountDetails
*/
type CreatePaymentCreatedBodyOrderInformationAmountDetails struct {

	// Amount that was authorized.
	//
	// Returned by authorization service.
	//
	// #### PIN debit
	// Amount of the purchase.
	//
	// Returned by PIN debit purchase.
	//
	// #### FDMS South
	// If you accept IDR or CLP currencies, see the entry for FDMS South in Merchant Descriptors Using the SCMP API.
	//
	// Max Length: 15
	AuthorizedAmount string `json:"authorizedAmount,omitempty"`

	// Currency used for the order. Use the three-character [ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)
	//
	// #### Used by
	// **Authorization**
	// Required field.
	//
	// **Authorization Reversal**
	// For an authorization reversal (`reversalInformation`) or a capture (`processingOptions.capture` is set to `true`), you must use the same currency that you used in your payment authorization request.
	//
	// #### PIN Debit
	// Currency for the amount you requested for the PIN debit purchase. This value is returned for partial authorizations. The issuing bank can approve a partial amount if the balance on the debit card is less than the requested transaction amount. For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf).
	// Returned by PIN debit purchase.
	//
	// For PIN debit reversal requests, you must use the same currency that was used for the PIN debit purchase or PIN debit credit that you are reversing.
	// For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf).
	//
	// Required field for PIN Debit purchase and PIN Debit credit requests.
	// Optional field for PIN Debit reversal requests.
	//
	// #### GPX
	// This field is optional for reversing an authorization or credit.
	//
	// #### DCC for First Data
	// Your local currency. For details, see the `currency` field description in [Dynamic Currency Conversion For First Data Using the SCMP API](http://apps.cybersource.com/library/documentation/dev_guides/DCC_FirstData_SCMP/DCC_FirstData_SCMP_API.pdf).
	//
	// #### Tax Calculation
	// Required for international tax and value added tax only.
	// Optional for U.S. and Canadian taxes.
	// Your local currency.
	//
	// Max Length: 3
	Currency string `json:"currency,omitempty"`

	// Amount you requested for the payment or capture.
	//
	// This value is returned for partial authorizations.
	// This field is also returned on incremental authorizations will contain the aggregated amount from the original authorizations and all the incremental authorizations.
	//
	// Max Length: 15
	TotalAmount string `json:"totalAmount,omitempty"`
}

// Validate validates this create payment created body order information amount details
func (o *CreatePaymentCreatedBodyOrderInformationAmountDetails) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAuthorizedAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCurrency(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTotalAmount(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyOrderInformationAmountDetails) validateAuthorizedAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.AuthorizedAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"orderInformation"+"."+"amountDetails"+"."+"authorizedAmount", "body", o.AuthorizedAmount, 15); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyOrderInformationAmountDetails) validateCurrency(formats strfmt.Registry) error {
	if swag.IsZero(o.Currency) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"orderInformation"+"."+"amountDetails"+"."+"currency", "body", o.Currency, 3); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyOrderInformationAmountDetails) validateTotalAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.TotalAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"orderInformation"+"."+"amountDetails"+"."+"totalAmount", "body", o.TotalAmount, 15); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment created body order information amount details based on context it is used
func (o *CreatePaymentCreatedBodyOrderInformationAmountDetails) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyOrderInformationAmountDetails) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyOrderInformationAmountDetails) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyOrderInformationAmountDetails
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyOrderInformationInvoiceDetails create payment created body order information invoice details
swagger:model CreatePaymentCreatedBodyOrderInformationInvoiceDetails
*/
type CreatePaymentCreatedBodyOrderInformationInvoiceDetails struct {

	// Indicates whether CyberSource sent the Level III information to the processor. The possible values are:
	//
	// If your account is not enabled for Level III data or if you did not include the purchasing level field in your
	// request, CyberSource does not include the Level III data in the request sent to the processor.
	//
	// Possible values:
	// - **true**
	// - **false**
	//
	Level3TransmissionStatus bool `json:"level3TransmissionStatus,omitempty"`

	// Transaction identifier that is generated. You have the option of printing the sales slip number on the receipt.
	// This field is supported only on Cybersource through Visanet and JCN gateway.
	//
	// Optional field.
	//
	// #### Card Present processing message
	// If you included this field in the request, the returned value is the value that you sent in the request.
	// If you did not include this field in the request, the system generated this value for you.
	//
	// The difference between this reply field and the `processorInformation.systemTraceAuditNumber` field is that the
	// system generates the system trace audit number (STAN), and you must print the receipt number on the receipt;
	// whereas you can generate the sales slip number, and you can choose to print the sales slip number on the receipt.
	//
	// Maximum: 99999
	SalesSlipNumber int64 `json:"salesSlipNumber,omitempty"`
}

// Validate validates this create payment created body order information invoice details
func (o *CreatePaymentCreatedBodyOrderInformationInvoiceDetails) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateSalesSlipNumber(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyOrderInformationInvoiceDetails) validateSalesSlipNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.SalesSlipNumber) { // not required
		return nil
	}

	if err := validate.MaximumInt("createPaymentCreated"+"."+"orderInformation"+"."+"invoiceDetails"+"."+"salesSlipNumber", "body", o.SalesSlipNumber, 99999, false); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment created body order information invoice details based on context it is used
func (o *CreatePaymentCreatedBodyOrderInformationInvoiceDetails) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyOrderInformationInvoiceDetails) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyOrderInformationInvoiceDetails) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyOrderInformationInvoiceDetails
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyOrderInformationRewardPointsDetails create payment created body order information reward points details
swagger:model CreatePaymentCreatedBodyOrderInformationRewardPointsDetails
*/
type CreatePaymentCreatedBodyOrderInformationRewardPointsDetails struct {

	// Loyalty Points remaining total balance after redemption.
	// For Example: Points, such as 20.00
	//
	// Max Length: 10
	PointsAfterRedemption string `json:"pointsAfterRedemption,omitempty"`

	// Loyalty points total balance before redemption.
	// For Example: Points, such as 100
	//
	// Max Length: 10
	PointsBeforeRedemption string `json:"pointsBeforeRedemption,omitempty"`

	// Number of loyalty points that were redeemed.
	// For Example: Points, such as 100
	//
	// Max Length: 10
	PointsRedeemed string `json:"pointsRedeemed,omitempty"`

	// The value of the remaining loyalty points after redumption in the default currency. Max characters is 12 excluding the "." symbol
	// For Example: Points, such as 20.00
	//
	// Max Length: 12
	PointsValueAfterRedemption string `json:"pointsValueAfterRedemption,omitempty"`

	// The total value of loyalty points before redemption in the default currency. Max characters is 12 excluding the "." symbol
	// For Example: Points, such as 20.00
	//
	// Max Length: 12
	PointsValueBeforeRedemption string `json:"pointsValueBeforeRedemption,omitempty"`

	// The value of the loyalty points that were redeemed in the default currency. Max characters is 12 excluding the "." symbol
	// For Example: Points, such as 100.00
	//
	// Max Length: 12
	PointsValueRedeemed string `json:"pointsValueRedeemed,omitempty"`
}

// Validate validates this create payment created body order information reward points details
func (o *CreatePaymentCreatedBodyOrderInformationRewardPointsDetails) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validatePointsAfterRedemption(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePointsBeforeRedemption(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePointsRedeemed(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePointsValueAfterRedemption(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePointsValueBeforeRedemption(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePointsValueRedeemed(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyOrderInformationRewardPointsDetails) validatePointsAfterRedemption(formats strfmt.Registry) error {
	if swag.IsZero(o.PointsAfterRedemption) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"orderInformation"+"."+"rewardPointsDetails"+"."+"pointsAfterRedemption", "body", o.PointsAfterRedemption, 10); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyOrderInformationRewardPointsDetails) validatePointsBeforeRedemption(formats strfmt.Registry) error {
	if swag.IsZero(o.PointsBeforeRedemption) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"orderInformation"+"."+"rewardPointsDetails"+"."+"pointsBeforeRedemption", "body", o.PointsBeforeRedemption, 10); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyOrderInformationRewardPointsDetails) validatePointsRedeemed(formats strfmt.Registry) error {
	if swag.IsZero(o.PointsRedeemed) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"orderInformation"+"."+"rewardPointsDetails"+"."+"pointsRedeemed", "body", o.PointsRedeemed, 10); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyOrderInformationRewardPointsDetails) validatePointsValueAfterRedemption(formats strfmt.Registry) error {
	if swag.IsZero(o.PointsValueAfterRedemption) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"orderInformation"+"."+"rewardPointsDetails"+"."+"pointsValueAfterRedemption", "body", o.PointsValueAfterRedemption, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyOrderInformationRewardPointsDetails) validatePointsValueBeforeRedemption(formats strfmt.Registry) error {
	if swag.IsZero(o.PointsValueBeforeRedemption) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"orderInformation"+"."+"rewardPointsDetails"+"."+"pointsValueBeforeRedemption", "body", o.PointsValueBeforeRedemption, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyOrderInformationRewardPointsDetails) validatePointsValueRedeemed(formats strfmt.Registry) error {
	if swag.IsZero(o.PointsValueRedeemed) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"orderInformation"+"."+"rewardPointsDetails"+"."+"pointsValueRedeemed", "body", o.PointsValueRedeemed, 12); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment created body order information reward points details based on context it is used
func (o *CreatePaymentCreatedBodyOrderInformationRewardPointsDetails) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyOrderInformationRewardPointsDetails) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyOrderInformationRewardPointsDetails) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyOrderInformationRewardPointsDetails
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyPaymentAccountInformation create payment created body payment account information
swagger:model CreatePaymentCreatedBodyPaymentAccountInformation
*/
type CreatePaymentCreatedBodyPaymentAccountInformation struct {

	// card
	Card *CreatePaymentCreatedBodyPaymentAccountInformationCard `json:"card,omitempty"`
}

// Validate validates this create payment created body payment account information
func (o *CreatePaymentCreatedBodyPaymentAccountInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCard(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyPaymentAccountInformation) validateCard(formats strfmt.Registry) error {
	if swag.IsZero(o.Card) { // not required
		return nil
	}

	if o.Card != nil {
		if err := o.Card.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "paymentAccountInformation" + "." + "card")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "paymentAccountInformation" + "." + "card")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this create payment created body payment account information based on the context it is used
func (o *CreatePaymentCreatedBodyPaymentAccountInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateCard(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyPaymentAccountInformation) contextValidateCard(ctx context.Context, formats strfmt.Registry) error {

	if o.Card != nil {
		if err := o.Card.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "paymentAccountInformation" + "." + "card")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "paymentAccountInformation" + "." + "card")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyPaymentAccountInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyPaymentAccountInformation) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyPaymentAccountInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyPaymentAccountInformationCard create payment created body payment account information card
swagger:model CreatePaymentCreatedBodyPaymentAccountInformationCard
*/
type CreatePaymentCreatedBodyPaymentAccountInformationCard struct {

	// Two-digit month in which the payment card expires.
	//
	// Format: `MM`.
	//
	// Valid values: `01` through `12`. Leading 0 is required.
	//
	// #### Barclays and Streamline
	// For Maestro (UK Domestic) and Maestro (International) cards on Barclays and Streamline, this must be a valid value
	// (`01` through `12`) but is not required to be a valid expiration date. In other words, an expiration date that is
	// in the past does not cause CyberSource to reject your request. However, an invalid expiration date might cause
	// the issuer to reject your request.
	//
	// #### Encoded Account Numbers
	// For encoded account numbers (_type_=039), if there is no expiration date on the card, use `12`.
	//
	// #### FDMS Nashville
	// Required field.
	//
	// #### All other processors
	// Required if `pointOfSaleInformation.entryMode=keyed`. However, this field is optional if your account is configured
	// for relaxed requirements for address data and expiration date. **Important** It is your responsibility to determine
	// whether a field is required for the transaction you are requesting.
	//
	// #### Google Pay transactions
	// For PAN-based Google Pay transactions, this field is returned in the API response.
	//
	// Max Length: 2
	ExpirationMonth string `json:"expirationMonth,omitempty"`

	// Four-digit year in which the payment card expires.
	//
	// Format: `YYYY`.
	//
	// #### Barclays and Streamline
	// For Maestro (UK Domestic) and Maestro (International) cards on Barclays and Streamline, this must be a valid value (`1900` through `3000`) but is not required to be a valid expiration date. In other words, an expiration date that is in the past does not cause CyberSource to reject your request. However, an invalid expiration date might cause the issuer to reject your request.
	//
	// #### Encoded Account Numbers
	// For encoded account numbers (**_type_**`=039`), if there is no expiration date on the card, use `2021`.
	//
	// #### FDMS Nashville
	// Required field.
	//
	// #### FDC Nashville Global and FDMS South
	// You can send in 2 digits or 4 digits. If you send in 2 digits, they must be the last 2 digits of the year.
	//
	// #### All other processors
	// Required if `pointOfSaleInformation.entryMode=keyed`. However, this field is optional if your account is configured
	// for relaxed requirements for address data and expiration date. **Important** It is your responsibility to determine
	// whether a field is required for the transaction you are requesting.
	//
	// #### Google Pay transactions
	// For PAN-based Google Pay transactions, this field is returned in the API response.
	//
	// Max Length: 4
	ExpirationYear string `json:"expirationYear,omitempty"`

	// Bank Identification Number (BIN). This is the initial four to six numbers on a credit card account number.
	//
	// #### Google Pay transactions
	// For PAN-based Google Pay transactions, this field is returned in the API response.
	//
	// Max Length: 6
	Prefix string `json:"prefix,omitempty"`

	// Last four digits of the cardholders account number. This field is included in the reply message when the client software
	// that is installed on the POS terminal uses the token management service (TMS) to retrieve tokenized payment details.
	//
	// You must contact customer support to have your account enabled to receive these fields in the credit reply message.
	//
	// #### Google Pay transactions
	// For PAN-based Google Pay transactions, this field is returned in the API response.
	//
	// #### PIN debit
	// This field is returned only for tokenized transactions. You can use this value on the receipt that you give to the cardholder.
	//
	// Returned by PIN debit credit and PIN debit purchase.
	//
	// This field is supported only by the following processors:
	// - American Express Direct
	// - Credit Mutuel-CIC
	// - FDC Nashville Global
	// - OmniPay Direct
	// - SIX
	//
	Suffix string `json:"suffix,omitempty"`

	// Three-digit value that indicates the card type.
	//
	// **IMPORTANT** It is strongly recommended that you include the card type field in request messages even if it is
	// optional for your processor and card type. Omitting the card type can cause the transaction to be processed with the wrong card type.
	//
	// Possible values:
	// - `001`: Visa. For card-present transactions on all processors except SIX, the Visa Electron card type is processed the same way that the Visa debit card is processed. Use card type value `001` for Visa Electron.
	// - `002`: Mastercard, Eurocard[^1], which is a European regional brand of Mastercard.
	// - `003`: American Express
	// - `004`: Discover
	// - `005`: Diners Club
	// - `006`: Carte Blanche[^1]
	// - `007`: JCB[^1]
	// - `014`: Enroute[^1]
	// - `021`: JAL[^1]
	// - `024`: Maestro (UK Domestic)[^1]
	// - `031`: Delta[^1]: Use this value only for Ingenico ePayments. For other processors, use `001` for all Visa card types.
	// - `033`: Visa Electron[^1]. Use this value only for Ingenico ePayments and SIX. For other processors, use `001` for all Visa card types.
	// - `034`: Dankort[^1]
	// - `036`: Cartes Bancaires[^1,4]
	// - `037`: Carta Si[^1]
	// - `039`: Encoded account number[^1]
	// - `040`: UATP[^1]
	// - `042`: Maestro (International)[^1]
	// - `050`: Hipercard[^2,3]
	// - `051`: Aura
	// - `054`: Elo[^3]
	// - `062`: China UnionPay
	//
	// [^1]: For this card type, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in your request for an authorization or a stand-alone credit.
	// [^2]: For this card type on Cielo 3.0, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in a request for an authorization or a stand-alone credit. This card type is not supported on Cielo 1.5.
	// [^3]: For this card type on Getnet and Rede, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in a request for an authorization or a stand-alone credit.
	// [^4]: For this card type, you must include the `paymentInformation.card.type` in your request for any payer authentication services.
	//
	// #### Used by
	// **Authorization**
	// Required for Carte Blanche and JCB.
	// Optional for all other card types.
	//
	// #### Card Present reply
	// This field is included in the reply message when the client software that is installed on the POS terminal uses
	// the token management service (TMS) to retrieve tokenized payment details. You must contact customer support to
	// have your account enabled to receive these fields in the credit reply message.
	//
	// Returned by the Credit service.
	//
	// This reply field is only supported by the following processors:
	// - American Express Direct
	// - Credit Mutuel-CIC
	// - FDC Nashville Global
	// - OmniPay Direct
	// - SIX
	//
	// #### Google Pay transactions
	// For PAN-based Google Pay transactions, this field is returned in the API response.
	//
	// #### GPX
	// This field only supports transactions from the following card types:
	// - Visa
	// - Mastercard
	// - AMEX
	// - Discover
	// - Diners
	// - JCB
	// - Union Pay International
	//
	Type string `json:"type,omitempty"`
}

// Validate validates this create payment created body payment account information card
func (o *CreatePaymentCreatedBodyPaymentAccountInformationCard) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateExpirationMonth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpirationYear(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePrefix(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyPaymentAccountInformationCard) validateExpirationMonth(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationMonth) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"paymentAccountInformation"+"."+"card"+"."+"expirationMonth", "body", o.ExpirationMonth, 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPaymentAccountInformationCard) validateExpirationYear(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationYear) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"paymentAccountInformation"+"."+"card"+"."+"expirationYear", "body", o.ExpirationYear, 4); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPaymentAccountInformationCard) validatePrefix(formats strfmt.Registry) error {
	if swag.IsZero(o.Prefix) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"paymentAccountInformation"+"."+"card"+"."+"prefix", "body", o.Prefix, 6); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment created body payment account information card based on context it is used
func (o *CreatePaymentCreatedBodyPaymentAccountInformationCard) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyPaymentAccountInformationCard) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyPaymentAccountInformationCard) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyPaymentAccountInformationCard
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyPaymentInformation create payment created body payment information
swagger:model CreatePaymentCreatedBodyPaymentInformation
*/
type CreatePaymentCreatedBodyPaymentInformation struct {

	// account features
	AccountFeatures *CreatePaymentCreatedBodyPaymentInformationAccountFeatures `json:"accountFeatures,omitempty"`

	// Type of payment card account. This field can refer to a credit card, debit card, or prepaid card
	// account type.
	//
	// For all possible values, see the `score_card_account_type` field description in the _Decision Manager Using the SCMP API Developer Guide_ on the [CyberSource Business Center.](https://ebc2.cybersource.com/ebc2/) Click **Decision Manager** > **Documentation** > **Guides** > _Decision Manager Using the SCMP API Developer Guide_ (PDF link).
	//
	// Max Length: 255
	AccountType string `json:"accountType,omitempty"`

	// bank
	Bank *CreatePaymentCreatedBodyPaymentInformationBank `json:"bank,omitempty"`

	// Credit card BIN (the first six digits of the credit card).Derived either from the `cc_bin` request field
	// or from the first six characters of the `customer_cc_num` field.
	//
	// For all possible values, see the `score_cc_bin` field description in the _Decision Manager Using the SCMP API Developer Guide_ on the [CyberSource Business Center.](https://ebc2.cybersource.com/ebc2/) Click **Decision Manager** > **Documentation** > **Guides** > _Decision Manager Using the SCMP API Developer Guide_ (PDF link).
	//
	// Max Length: 255
	Bin string `json:"bin,omitempty"`

	// Country (two-digit country code) associated with the BIN of the customers card used for the payment.
	// Returned if the information is available. Use this field for additional information when reviewing orders.
	// This information is also displayed in the details page of the CyberSource Business Center.
	//
	// For all possible values, see the `bin_country` field description in the _Decision Manager Using the SCMP API Developer Guide_ on the [CyberSource Business Center.](https://ebc2.cybersource.com/ebc2/) Click **Decision Manager** > **Documentation** > **Guides** > _Decision Manager Using the SCMP API Developer Guide_ (PDF link).
	//
	// Max Length: 255
	BinCountry string `json:"binCountry,omitempty"`

	// card
	Card *CreatePaymentCreatedBodyPaymentInformationCard `json:"card,omitempty"`

	// customer
	Customer *CreatePaymentCreatedBodyPaymentInformationCustomer `json:"customer,omitempty"`

	// instrument identifier
	InstrumentIdentifier *CreatePaymentCreatedBodyPaymentInformationInstrumentIdentifier `json:"instrumentIdentifier,omitempty"`

	// Name of the bank or entity that issued the card account.
	//
	// For all possible values, see the `score_card_issuer` field description in the _Decision Manager Using the SCMP API Developer Guide_ on the [CyberSource Business Center.](https://ebc2.cybersource.com/ebc2/) Click **Decision Manager** > **Documentation** > **Guides** > _Decision Manager Using the SCMP API Developer Guide_ (PDF link).
	//
	// Max Length: 255
	Issuer string `json:"issuer,omitempty"`

	// payment instrument
	PaymentInstrument *CreatePaymentCreatedBodyPaymentInformationPaymentInstrument `json:"paymentInstrument,omitempty"`

	// Subtype of card account. This field can contain one of the following values:
	// - Maestro International
	// - Maestro UK Domestic
	// - MasterCard Credit
	// - MasterCard Debit
	// - Visa Credit
	// - Visa Debit
	// - Visa Electron
	//
	// **Note** Additional values may be present.
	//
	// For all possible values, see the `score_card_scheme` field description in the _Decision Manager Using the SCMP API Developer Guide_ on the [CyberSource Business Center.](https://ebc2.cybersource.com/ebc2/) Click **Decision Manager** > **Documentation** > **Guides** > _Decision Manager Using the SCMP API Developer Guide_ (PDF link).
	//
	// Max Length: 255
	Scheme string `json:"scheme,omitempty"`

	// shipping address
	ShippingAddress *CreatePaymentCreatedBodyPaymentInformationShippingAddress `json:"shippingAddress,omitempty"`

	// tokenized card
	TokenizedCard *CreatePaymentCreatedBodyPaymentInformationTokenizedCard `json:"tokenizedCard,omitempty"`
}

// Validate validates this create payment created body payment information
func (o *CreatePaymentCreatedBodyPaymentInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAccountFeatures(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAccountType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBank(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBin(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBinCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCard(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCustomer(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateInstrumentIdentifier(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateIssuer(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePaymentInstrument(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateScheme(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateShippingAddress(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTokenizedCard(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformation) validateAccountFeatures(formats strfmt.Registry) error {
	if swag.IsZero(o.AccountFeatures) { // not required
		return nil
	}

	if o.AccountFeatures != nil {
		if err := o.AccountFeatures.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "paymentInformation" + "." + "accountFeatures")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "paymentInformation" + "." + "accountFeatures")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformation) validateAccountType(formats strfmt.Registry) error {
	if swag.IsZero(o.AccountType) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"paymentInformation"+"."+"accountType", "body", o.AccountType, 255); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformation) validateBank(formats strfmt.Registry) error {
	if swag.IsZero(o.Bank) { // not required
		return nil
	}

	if o.Bank != nil {
		if err := o.Bank.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "paymentInformation" + "." + "bank")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "paymentInformation" + "." + "bank")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformation) validateBin(formats strfmt.Registry) error {
	if swag.IsZero(o.Bin) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"paymentInformation"+"."+"bin", "body", o.Bin, 255); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformation) validateBinCountry(formats strfmt.Registry) error {
	if swag.IsZero(o.BinCountry) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"paymentInformation"+"."+"binCountry", "body", o.BinCountry, 255); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformation) validateCard(formats strfmt.Registry) error {
	if swag.IsZero(o.Card) { // not required
		return nil
	}

	if o.Card != nil {
		if err := o.Card.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "paymentInformation" + "." + "card")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "paymentInformation" + "." + "card")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformation) validateCustomer(formats strfmt.Registry) error {
	if swag.IsZero(o.Customer) { // not required
		return nil
	}

	if o.Customer != nil {
		if err := o.Customer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "paymentInformation" + "." + "customer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "paymentInformation" + "." + "customer")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformation) validateInstrumentIdentifier(formats strfmt.Registry) error {
	if swag.IsZero(o.InstrumentIdentifier) { // not required
		return nil
	}

	if o.InstrumentIdentifier != nil {
		if err := o.InstrumentIdentifier.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "paymentInformation" + "." + "instrumentIdentifier")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "paymentInformation" + "." + "instrumentIdentifier")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformation) validateIssuer(formats strfmt.Registry) error {
	if swag.IsZero(o.Issuer) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"paymentInformation"+"."+"issuer", "body", o.Issuer, 255); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformation) validatePaymentInstrument(formats strfmt.Registry) error {
	if swag.IsZero(o.PaymentInstrument) { // not required
		return nil
	}

	if o.PaymentInstrument != nil {
		if err := o.PaymentInstrument.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "paymentInformation" + "." + "paymentInstrument")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "paymentInformation" + "." + "paymentInstrument")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformation) validateScheme(formats strfmt.Registry) error {
	if swag.IsZero(o.Scheme) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"paymentInformation"+"."+"scheme", "body", o.Scheme, 255); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformation) validateShippingAddress(formats strfmt.Registry) error {
	if swag.IsZero(o.ShippingAddress) { // not required
		return nil
	}

	if o.ShippingAddress != nil {
		if err := o.ShippingAddress.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "paymentInformation" + "." + "shippingAddress")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "paymentInformation" + "." + "shippingAddress")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformation) validateTokenizedCard(formats strfmt.Registry) error {
	if swag.IsZero(o.TokenizedCard) { // not required
		return nil
	}

	if o.TokenizedCard != nil {
		if err := o.TokenizedCard.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "paymentInformation" + "." + "tokenizedCard")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "paymentInformation" + "." + "tokenizedCard")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this create payment created body payment information based on the context it is used
func (o *CreatePaymentCreatedBodyPaymentInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateAccountFeatures(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateBank(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateCard(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateCustomer(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateInstrumentIdentifier(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidatePaymentInstrument(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateShippingAddress(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateTokenizedCard(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformation) contextValidateAccountFeatures(ctx context.Context, formats strfmt.Registry) error {

	if o.AccountFeatures != nil {
		if err := o.AccountFeatures.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "paymentInformation" + "." + "accountFeatures")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "paymentInformation" + "." + "accountFeatures")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformation) contextValidateBank(ctx context.Context, formats strfmt.Registry) error {

	if o.Bank != nil {
		if err := o.Bank.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "paymentInformation" + "." + "bank")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "paymentInformation" + "." + "bank")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformation) contextValidateCard(ctx context.Context, formats strfmt.Registry) error {

	if o.Card != nil {
		if err := o.Card.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "paymentInformation" + "." + "card")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "paymentInformation" + "." + "card")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformation) contextValidateCustomer(ctx context.Context, formats strfmt.Registry) error {

	if o.Customer != nil {
		if err := o.Customer.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "paymentInformation" + "." + "customer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "paymentInformation" + "." + "customer")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformation) contextValidateInstrumentIdentifier(ctx context.Context, formats strfmt.Registry) error {

	if o.InstrumentIdentifier != nil {
		if err := o.InstrumentIdentifier.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "paymentInformation" + "." + "instrumentIdentifier")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "paymentInformation" + "." + "instrumentIdentifier")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformation) contextValidatePaymentInstrument(ctx context.Context, formats strfmt.Registry) error {

	if o.PaymentInstrument != nil {
		if err := o.PaymentInstrument.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "paymentInformation" + "." + "paymentInstrument")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "paymentInformation" + "." + "paymentInstrument")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformation) contextValidateShippingAddress(ctx context.Context, formats strfmt.Registry) error {

	if o.ShippingAddress != nil {
		if err := o.ShippingAddress.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "paymentInformation" + "." + "shippingAddress")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "paymentInformation" + "." + "shippingAddress")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformation) contextValidateTokenizedCard(ctx context.Context, formats strfmt.Registry) error {

	if o.TokenizedCard != nil {
		if err := o.TokenizedCard.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "paymentInformation" + "." + "tokenizedCard")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "paymentInformation" + "." + "tokenizedCard")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyPaymentInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyPaymentInformation) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyPaymentInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyPaymentInformationAccountFeatures create payment created body payment information account features
swagger:model CreatePaymentCreatedBodyPaymentInformationAccountFeatures
*/
type CreatePaymentCreatedBodyPaymentInformationAccountFeatures struct {

	// Possible values:
	// - `N`: Nonregulated
	// - `R`: Regulated
	//
	// Returned by PIN debit credit or PIN debit purchase.
	//
	// **Note** This field is returned only for CyberSource through VisaNet.
	//
	// Max Length: 1
	AccountStatus string `json:"accountStatus,omitempty"`

	// Type of account. This value is returned only if you requested a balance inquiry. Possible values:
	//
	//  - `00`: Not applicable or not specified
	//  - `10`: Savings account
	//  - `20`: Checking account
	//  - `30`: Credit card account
	//  - `40`: Universal account
	//
	// #### PIN debit
	// Type of account. This value is returned only if you requested a balance inquiry.
	//
	// Possible values:
	// - `00`: Not applicable or not specified
	// - `10`: Savings account
	// - `20`: Checking account
	// - `40`: Universal account
	// - `96`: Cash benefits account
	// - `98`: Food stamp account
	//
	// Returned by PIN debit purchase.
	//
	// Max Length: 2
	AccountType string `json:"accountType,omitempty"`

	// **Chase Paymentech Solutions**
	//
	// Indicates whether a customer has high credit limits. This information enables you to market high cost items to
	// these customers and to understand the kinds of cards that high income customers are using.
	//
	// This field is supported for Visa, Mastercard, Discover, and Diners Club. Possible values:
	//
	//  - `Y`: Yes
	//  - `N`: No
	//  - `X`: Not applicable / Unknown
	//
	// #### Litle
	//
	// Flag that indicates that a Visa cardholder or Mastercard cardholder is in one of the affluent categories.
	// Possible values:
	//
	//  - `AFFLUENT`: High income customer with high spending pattern (>100k USD annual income and >40k USD annual
	//    card usage).
	//  - `MASS AFFLUENT`: High income customer (>100k USD annual income).
	//
	//  Maximum length is 13.
	//
	// #### Chase Paymentech Solutions
	//  Maximum length is 1.
	//
	// Max Length: 13
	AffluenceIndicator string `json:"affluenceIndicator,omitempty"`

	// Remaining balance on the account.
	//
	// Returned by authorization service.
	//
	// #### PIN debit
	// Remaining balance on the prepaid card.
	//
	// Returned by PIN debit purchase.
	//
	// Max Length: 12
	BalanceAmount string `json:"balanceAmount,omitempty"`

	// Type of amount. This value is returned only if you requested a balance inquiry. The issuer determines the value
	// that is returned. Possible values for deposit accounts:
	//
	//  - `01`: Current ledger (posted) balance.
	//  - `02`: Current available balance, which is typically the ledger balance less outstanding authorizations.
	//
	// Some depository institutions also include pending deposits and the credit or overdraft line associated with the
	// account. Possible values for credit card accounts:
	//
	//  - `01`: Credit amount remaining for customer (open to buy).
	//  - `02`: Credit limit.
	//
	// Max Length: 2
	BalanceAmountType string `json:"balanceAmountType,omitempty"`

	// Sign for the remaining balance on the account. Returned only when the processor returns this value. Possible values:
	//
	// Possible values:
	// - `Positive`
	// - `Negative`
	//
	// #### PIN debit
	// Sign for the remaining balance on the prepaid card. Returned only when the processor returns this value.
	//
	// Returned by PIN debit purchase.
	//
	// Max Length: 8
	BalanceSign string `json:"balanceSign,omitempty"`

	// This is an array of multiple balances information an issuer can return for a given card.
	Balances []*CreatePaymentCreatedBodyPaymentInformationAccountFeaturesBalancesItems0 `json:"balances"`

	// #### GPX
	// Mastercard product ID associated with the primary account number (PAN).
	// Returned by authorization service.
	//
	// #### CyberSource through VisaNet
	// Visa or Mastercard product ID that is associated with the primary account number (PAN).
	// For descriptions of the Visa product IDs, see the Product ID table on the [Visa
	// Request & Response Codes web page.](https://developer.visa.com/guides/request_response_codes)
	//
	// Data Length: String (3)
	//
	// #### GPN
	// Visa or Mastercard product ID that is associated with the primary account number (PAN).
	// For descriptions of the Visa product IDs, see the Product ID table on the
	// [Visa Request & Response Codes web page.](https://developer.visa.com/guides/request_response_codes)
	//
	// Data Length: String (3)
	//
	// #### Worldpay VAP
	// **Important** Before using this field on Worldpay VAP,
	// you must contact CyberSource Customer Support to have
	// your account configured for this feature.
	//
	// Type of card used in the transaction. The only possible value is:
	// - `PREPAID`: Prepaid Card
	//
	// Data Length: String (7)
	//
	// #### RBS WorldPay Atlanta
	// Type of card used in the transaction. Possible values:
	// - `B`: Business Card
	// - `O`: Noncommercial Card
	// - `R`: Corporate Card
	// - `S`: Purchase Card
	// - `Blank`: Purchase card not supported
	//
	// Data Length: String (1)
	//
	// Max Length: 7
	Category string `json:"category,omitempty"`

	// Indicates whether the card is a commercial card, which enables you to include Level II data in your transaction
	// requests. This field is supported for Visa and Mastercard on **Chase Paymentech Solutions**. Possible values:
	//
	//  - `Y`: Yes
	//  - `N`: No
	//  - `X`: Not applicable / Unknown
	//
	// Max Length: 1
	Commercial string `json:"commercial,omitempty"`

	// Currency of the remaining balance on the account. For the possible values, see the [ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)
	//
	// Returned by authorization service.
	//
	// #### PIN debit
	// Currency of the remaining balance on the prepaid card.
	//
	// Returned by PIN debit purchase.
	//
	// Max Length: 5
	Currency string `json:"currency,omitempty"`

	// Type of commercial card. This field is supported only for CyberSource through VisaNet. Possible values:
	//
	//  - `B`: Business card
	//  - `R`: Corporate card
	//  - `S`: Purchasing card
	//  - `0`: Noncommercial card
	//
	// Returned by authorization service.
	//
	// Max Length: 1
	Group string `json:"group,omitempty"`

	// Indicates whether the card is a healthcare card. This field is supported for Visa and Mastercard on **Chase
	// Paymentech Solutions**. Possible values:
	//
	//  - `Y`: Yes
	//  - `N`: No
	//  - `X`: Not applicable / Unknown
	//
	// Max Length: 1
	HealthCare string `json:"healthCare,omitempty"`

	// Indicates whether the card is eligible for Level III interchange fees, which enables you to include Level III
	// data in your transaction requests. This field is supported for Visa and Mastercard on **Chase Paymentech
	// Solutions**. Possible values:
	//
	//  - `Y`: Yes
	//  - `N`: No
	//  - `X`: Not applicable / Unknown
	//
	// Max Length: 1
	Level3Eligible string `json:"level3Eligible,omitempty"`

	// Indicates whether the card is a payroll card. This field is supported for Visa, Discover, Diners Club, and JCB
	// on **Chase Paymentech Solutions**. Possible values:
	//
	//  - `Y`: Yes
	//  - `N`: No
	//  - `X`: Not applicable / Unknown
	//
	// Max Length: 1
	Payroll string `json:"payroll,omitempty"`

	// Indicates whether the card is a PINless debit card. This field is supported for Visa and Mastercard on **Chase
	// Paymentech Solutions**. Possible values:
	//
	//  - `Y`: Yes
	//  - `N`: No
	//  - `X`: Not applicable / Unknown
	//
	// Max Length: 1
	PinlessDebit string `json:"pinlessDebit,omitempty"`

	// Indicates whether the card is a prepaid card. This information enables you to determine when a gift card or
	// prepaid card is presented for use when establishing a new recurring, installment, or deferred billing
	// relationship.
	//
	// This field is supported for Visa, Mastercard, Discover, Diners Club, and JCB on Chase Paymentech Solutions.
	// Possible values:
	//
	//  - `Y`: Yes
	//  - `N`: No
	//  - `X`: Not applicable / Unknown
	//
	// Max Length: 1
	Prepaid string `json:"prepaid,omitempty"`

	// Indicates whether the card is regulated according to the Durbin Amendment. If the card is regulated, the card
	// issuer is subject to price caps and interchange rules. This field is supported for Visa, Mastercard, Discover,
	// Diners Club, and JCB on Chase Paymentech Solutions. Possible values:
	//
	//  - `Y`: Yes
	//  - `N`: No
	//  - `X`: Not applicable / Unknown
	//
	// Max Length: 1
	Regulated string `json:"regulated,omitempty"`

	// Indicates whether the card is a signature debit card.
	//
	// This information enables you to alter the way an order is processed. For example, you might not want to reauthorize a transaction for a signature debit card, or you might
	// want to perform reversals promptly for a signature debit card. This field is supported for Visa, Mastercard, and
	// Maestro (International) on Chase Paymentech Solutions. Possible values:
	//
	//  - `Y`: Yes
	//  - `N`: No
	//  - `X`: Not applicable / Unknown
	//
	// Max Length: 1
	SignatureDebit string `json:"signatureDebit,omitempty"`
}

// Validate validates this create payment created body payment information account features
func (o *CreatePaymentCreatedBodyPaymentInformationAccountFeatures) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAccountStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAccountType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAffluenceIndicator(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBalanceAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBalanceAmountType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBalanceSign(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBalances(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCategory(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCommercial(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCurrency(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateGroup(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateHealthCare(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLevel3Eligible(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePayroll(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePinlessDebit(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePrepaid(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRegulated(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSignatureDebit(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformationAccountFeatures) validateAccountStatus(formats strfmt.Registry) error {
	if swag.IsZero(o.AccountStatus) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"paymentInformation"+"."+"accountFeatures"+"."+"accountStatus", "body", o.AccountStatus, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformationAccountFeatures) validateAccountType(formats strfmt.Registry) error {
	if swag.IsZero(o.AccountType) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"paymentInformation"+"."+"accountFeatures"+"."+"accountType", "body", o.AccountType, 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformationAccountFeatures) validateAffluenceIndicator(formats strfmt.Registry) error {
	if swag.IsZero(o.AffluenceIndicator) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"paymentInformation"+"."+"accountFeatures"+"."+"affluenceIndicator", "body", o.AffluenceIndicator, 13); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformationAccountFeatures) validateBalanceAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.BalanceAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"paymentInformation"+"."+"accountFeatures"+"."+"balanceAmount", "body", o.BalanceAmount, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformationAccountFeatures) validateBalanceAmountType(formats strfmt.Registry) error {
	if swag.IsZero(o.BalanceAmountType) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"paymentInformation"+"."+"accountFeatures"+"."+"balanceAmountType", "body", o.BalanceAmountType, 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformationAccountFeatures) validateBalanceSign(formats strfmt.Registry) error {
	if swag.IsZero(o.BalanceSign) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"paymentInformation"+"."+"accountFeatures"+"."+"balanceSign", "body", o.BalanceSign, 8); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformationAccountFeatures) validateBalances(formats strfmt.Registry) error {
	if swag.IsZero(o.Balances) { // not required
		return nil
	}

	for i := 0; i < len(o.Balances); i++ {
		if swag.IsZero(o.Balances[i]) { // not required
			continue
		}

		if o.Balances[i] != nil {
			if err := o.Balances[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("createPaymentCreated" + "." + "paymentInformation" + "." + "accountFeatures" + "." + "balances" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("createPaymentCreated" + "." + "paymentInformation" + "." + "accountFeatures" + "." + "balances" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformationAccountFeatures) validateCategory(formats strfmt.Registry) error {
	if swag.IsZero(o.Category) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"paymentInformation"+"."+"accountFeatures"+"."+"category", "body", o.Category, 7); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformationAccountFeatures) validateCommercial(formats strfmt.Registry) error {
	if swag.IsZero(o.Commercial) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"paymentInformation"+"."+"accountFeatures"+"."+"commercial", "body", o.Commercial, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformationAccountFeatures) validateCurrency(formats strfmt.Registry) error {
	if swag.IsZero(o.Currency) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"paymentInformation"+"."+"accountFeatures"+"."+"currency", "body", o.Currency, 5); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformationAccountFeatures) validateGroup(formats strfmt.Registry) error {
	if swag.IsZero(o.Group) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"paymentInformation"+"."+"accountFeatures"+"."+"group", "body", o.Group, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformationAccountFeatures) validateHealthCare(formats strfmt.Registry) error {
	if swag.IsZero(o.HealthCare) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"paymentInformation"+"."+"accountFeatures"+"."+"healthCare", "body", o.HealthCare, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformationAccountFeatures) validateLevel3Eligible(formats strfmt.Registry) error {
	if swag.IsZero(o.Level3Eligible) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"paymentInformation"+"."+"accountFeatures"+"."+"level3Eligible", "body", o.Level3Eligible, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformationAccountFeatures) validatePayroll(formats strfmt.Registry) error {
	if swag.IsZero(o.Payroll) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"paymentInformation"+"."+"accountFeatures"+"."+"payroll", "body", o.Payroll, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformationAccountFeatures) validatePinlessDebit(formats strfmt.Registry) error {
	if swag.IsZero(o.PinlessDebit) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"paymentInformation"+"."+"accountFeatures"+"."+"pinlessDebit", "body", o.PinlessDebit, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformationAccountFeatures) validatePrepaid(formats strfmt.Registry) error {
	if swag.IsZero(o.Prepaid) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"paymentInformation"+"."+"accountFeatures"+"."+"prepaid", "body", o.Prepaid, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformationAccountFeatures) validateRegulated(formats strfmt.Registry) error {
	if swag.IsZero(o.Regulated) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"paymentInformation"+"."+"accountFeatures"+"."+"regulated", "body", o.Regulated, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformationAccountFeatures) validateSignatureDebit(formats strfmt.Registry) error {
	if swag.IsZero(o.SignatureDebit) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"paymentInformation"+"."+"accountFeatures"+"."+"signatureDebit", "body", o.SignatureDebit, 1); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this create payment created body payment information account features based on the context it is used
func (o *CreatePaymentCreatedBodyPaymentInformationAccountFeatures) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateBalances(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformationAccountFeatures) contextValidateBalances(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.Balances); i++ {

		if o.Balances[i] != nil {
			if err := o.Balances[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("createPaymentCreated" + "." + "paymentInformation" + "." + "accountFeatures" + "." + "balances" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("createPaymentCreated" + "." + "paymentInformation" + "." + "accountFeatures" + "." + "balances" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyPaymentInformationAccountFeatures) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyPaymentInformationAccountFeatures) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyPaymentInformationAccountFeatures
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyPaymentInformationAccountFeaturesBalancesItems0 create payment created body payment information account features balances items0
swagger:model CreatePaymentCreatedBodyPaymentInformationAccountFeaturesBalancesItems0
*/
type CreatePaymentCreatedBodyPaymentInformationAccountFeaturesBalancesItems0 struct {

	// Type of account.
	//
	// This value is returned only if you request a balance inquiry.
	//
	// Possible values:
	//
	//  - `00`: Not applicable or not specified
	//  - `10`: Savings account
	//  - `20`: Checking account
	//  - `30`: Credit card account
	//  - `40`: Universal account
	//
	// Balance Account Types returned on EBT Debit card transactions:
	//
	//  - `96`: Cash Benefits Account (PIN Debit Gateway EBT only)
	//  - `98`: Food Stamp Account (PIN Debit Gateway EBT only)
	//
	// Max Length: 2
	AccountType string `json:"accountType,omitempty"`

	// Remaining balance on the account. If the processor returns the sign, positive or negative, this sign is prefixed
	// to the amount value as (+/-).
	//
	// Max Length: 13
	Amount string `json:"amount,omitempty"`

	// Type of amount. This value is returned only if you request a balance inquiry. The issuer determines the value
	// that is returned.
	//
	// Possible values for deposit accounts:
	//
	//  - `01`: Current ledger (posted) balance.
	//  - `02`: Current available balance, which is typically the ledger balance minus outstanding authorizations. Some
	//  depository institutions also include pending deposits and the credit or overdraft line associated with the account.
	//
	// Possible values for credit card accounts:
	//
	//  - `01`: Credit amount remaining for customer (open to buy).
	//  - `02`: Credit limit.
	//
	// Max Length: 2
	AmountType string `json:"amountType,omitempty"`

	// Currency of the remaining balance on the account.
	//
	// Max Length: 3
	Currency string `json:"currency,omitempty"`
}

// Validate validates this create payment created body payment information account features balances items0
func (o *CreatePaymentCreatedBodyPaymentInformationAccountFeaturesBalancesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAccountType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAmountType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCurrency(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformationAccountFeaturesBalancesItems0) validateAccountType(formats strfmt.Registry) error {
	if swag.IsZero(o.AccountType) { // not required
		return nil
	}

	if err := validate.MaxLength("accountType", "body", o.AccountType, 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformationAccountFeaturesBalancesItems0) validateAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.Amount) { // not required
		return nil
	}

	if err := validate.MaxLength("amount", "body", o.Amount, 13); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformationAccountFeaturesBalancesItems0) validateAmountType(formats strfmt.Registry) error {
	if swag.IsZero(o.AmountType) { // not required
		return nil
	}

	if err := validate.MaxLength("amountType", "body", o.AmountType, 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformationAccountFeaturesBalancesItems0) validateCurrency(formats strfmt.Registry) error {
	if swag.IsZero(o.Currency) { // not required
		return nil
	}

	if err := validate.MaxLength("currency", "body", o.Currency, 3); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment created body payment information account features balances items0 based on context it is used
func (o *CreatePaymentCreatedBodyPaymentInformationAccountFeaturesBalancesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyPaymentInformationAccountFeaturesBalancesItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyPaymentInformationAccountFeaturesBalancesItems0) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyPaymentInformationAccountFeaturesBalancesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyPaymentInformationBank create payment created body payment information bank
swagger:model CreatePaymentCreatedBodyPaymentInformationBank
*/
type CreatePaymentCreatedBodyPaymentInformationBank struct {

	// account
	Account *CreatePaymentCreatedBodyPaymentInformationBankAccount `json:"account,omitempty"`

	// Corrected account number from the ACH verification service.
	//
	// For details, see `ecp_debit_corrected_routing_number` or `ecp_credit_corrected_routing_number` reply field descriptions in the [Electronic Check Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/EChecks_SCMP_API/html/)
	//
	// Max Length: 9
	CorrectedRoutingNumber string `json:"correctedRoutingNumber,omitempty"`
}

// Validate validates this create payment created body payment information bank
func (o *CreatePaymentCreatedBodyPaymentInformationBank) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAccount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCorrectedRoutingNumber(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformationBank) validateAccount(formats strfmt.Registry) error {
	if swag.IsZero(o.Account) { // not required
		return nil
	}

	if o.Account != nil {
		if err := o.Account.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "paymentInformation" + "." + "bank" + "." + "account")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "paymentInformation" + "." + "bank" + "." + "account")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformationBank) validateCorrectedRoutingNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.CorrectedRoutingNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"paymentInformation"+"."+"bank"+"."+"correctedRoutingNumber", "body", o.CorrectedRoutingNumber, 9); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this create payment created body payment information bank based on the context it is used
func (o *CreatePaymentCreatedBodyPaymentInformationBank) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateAccount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformationBank) contextValidateAccount(ctx context.Context, formats strfmt.Registry) error {

	if o.Account != nil {
		if err := o.Account.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "paymentInformation" + "." + "bank" + "." + "account")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "paymentInformation" + "." + "bank" + "." + "account")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyPaymentInformationBank) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyPaymentInformationBank) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyPaymentInformationBank
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyPaymentInformationBankAccount create payment created body payment information bank account
swagger:model CreatePaymentCreatedBodyPaymentInformationBankAccount
*/
type CreatePaymentCreatedBodyPaymentInformationBankAccount struct {

	// Corrected account number from the ACH verification service.
	//
	// For details, see `ecp_debit_corrected_account_number` or `ecp_credit_corrected_account_number` field descriptions in [Electronic Check Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/EChecks_SCMP_API/html/)
	//
	// Max Length: 17
	CorrectedAccountNumber string `json:"correctedAccountNumber,omitempty"`
}

// Validate validates this create payment created body payment information bank account
func (o *CreatePaymentCreatedBodyPaymentInformationBankAccount) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCorrectedAccountNumber(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformationBankAccount) validateCorrectedAccountNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.CorrectedAccountNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"paymentInformation"+"."+"bank"+"."+"account"+"."+"correctedAccountNumber", "body", o.CorrectedAccountNumber, 17); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment created body payment information bank account based on context it is used
func (o *CreatePaymentCreatedBodyPaymentInformationBankAccount) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyPaymentInformationBankAccount) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyPaymentInformationBankAccount) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyPaymentInformationBankAccount
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyPaymentInformationCard create payment created body payment information card
swagger:model CreatePaymentCreatedBodyPaymentInformationCard
*/
type CreatePaymentCreatedBodyPaymentInformationCard struct {

	// Two-digit month in which the payment card expires.
	//
	// Format: `MM`.
	//
	// Valid values: `01` through `12`. Leading 0 is required.
	//
	// #### Barclays and Streamline
	// For Maestro (UK Domestic) and Maestro (International) cards on Barclays and Streamline, this must be a valid value
	// (`01` through `12`) but is not required to be a valid expiration date. In other words, an expiration date that is
	// in the past does not cause CyberSource to reject your request. However, an invalid expiration date might cause
	// the issuer to reject your request.
	//
	// #### Encoded Account Numbers
	// For encoded account numbers (_type_=039), if there is no expiration date on the card, use `12`.
	//
	// #### FDMS Nashville
	// Required field.
	//
	// #### All other processors
	// Required if `pointOfSaleInformation.entryMode=keyed`. However, this field is optional if your account is configured
	// for relaxed requirements for address data and expiration date. **Important** It is your responsibility to determine
	// whether a field is required for the transaction you are requesting.
	//
	// #### Google Pay transactions
	// For PAN-based Google Pay transactions, this field is returned in the API response.
	//
	// Max Length: 2
	ExpirationMonth string `json:"expirationMonth,omitempty"`

	// Four-digit year in which the payment card expires.
	//
	// Format: `YYYY`.
	//
	// #### Barclays and Streamline
	// For Maestro (UK Domestic) and Maestro (International) cards on Barclays and Streamline, this must be a valid value (`1900` through `3000`) but is not required to be a valid expiration date. In other words, an expiration date that is in the past does not cause CyberSource to reject your request. However, an invalid expiration date might cause the issuer to reject your request.
	//
	// #### Encoded Account Numbers
	// For encoded account numbers (**_type_**`=039`), if there is no expiration date on the card, use `2021`.
	//
	// #### FDMS Nashville
	// Required field.
	//
	// #### FDC Nashville Global and FDMS South
	// You can send in 2 digits or 4 digits. If you send in 2 digits, they must be the last 2 digits of the year.
	//
	// #### All other processors
	// Required if `pointOfSaleInformation.entryMode=keyed`. However, this field is optional if your account is configured
	// for relaxed requirements for address data and expiration date. **Important** It is your responsibility to determine
	// whether a field is required for the transaction you are requesting.
	//
	// #### Google Pay transactions
	// For PAN-based Google Pay transactions, this field is returned in the API response.
	//
	// Max Length: 4
	ExpirationYear string `json:"expirationYear,omitempty"`

	// Bank Identification Number (BIN). This is the initial four to six numbers on a credit card account number.
	//
	// #### Google Pay transactions
	// For PAN-based Google Pay transactions, this field is returned in the API response.
	//
	// Max Length: 6
	Prefix string `json:"prefix,omitempty"`

	// Last four digits of the cardholders account number. This field is included in the reply message when the client software
	// that is installed on the POS terminal uses the token management service (TMS) to retrieve tokenized payment details.
	//
	// You must contact customer support to have your account enabled to receive these fields in the credit reply message.
	//
	// #### Google Pay transactions
	// For PAN-based Google Pay transactions, this field is returned in the API response.
	//
	// #### PIN debit
	// This field is returned only for tokenized transactions. You can use this value on the receipt that you give to the cardholder.
	//
	// Returned by PIN debit credit and PIN debit purchase.
	//
	// This field is supported only by the following processors:
	// - American Express Direct
	// - Credit Mutuel-CIC
	// - FDC Nashville Global
	// - OmniPay Direct
	// - SIX
	//
	Suffix string `json:"suffix,omitempty"`

	// Three-digit value that indicates the card type.
	//
	// **IMPORTANT** It is strongly recommended that you include the card type field in request messages even if it is
	// optional for your processor and card type. Omitting the card type can cause the transaction to be processed with the wrong card type.
	//
	// Possible values:
	// - `001`: Visa. For card-present transactions on all processors except SIX, the Visa Electron card type is processed the same way that the Visa debit card is processed. Use card type value `001` for Visa Electron.
	// - `002`: Mastercard, Eurocard[^1], which is a European regional brand of Mastercard.
	// - `003`: American Express
	// - `004`: Discover
	// - `005`: Diners Club
	// - `006`: Carte Blanche[^1]
	// - `007`: JCB[^1]
	// - `014`: Enroute[^1]
	// - `021`: JAL[^1]
	// - `024`: Maestro (UK Domestic)[^1]
	// - `031`: Delta[^1]: Use this value only for Ingenico ePayments. For other processors, use `001` for all Visa card types.
	// - `033`: Visa Electron[^1]. Use this value only for Ingenico ePayments and SIX. For other processors, use `001` for all Visa card types.
	// - `034`: Dankort[^1]
	// - `036`: Cartes Bancaires[^1,4]
	// - `037`: Carta Si[^1]
	// - `039`: Encoded account number[^1]
	// - `040`: UATP[^1]
	// - `042`: Maestro (International)[^1]
	// - `050`: Hipercard[^2,3]
	// - `051`: Aura
	// - `054`: Elo[^3]
	// - `062`: China UnionPay
	//
	// [^1]: For this card type, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in your request for an authorization or a stand-alone credit.
	// [^2]: For this card type on Cielo 3.0, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in a request for an authorization or a stand-alone credit. This card type is not supported on Cielo 1.5.
	// [^3]: For this card type on Getnet and Rede, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in a request for an authorization or a stand-alone credit.
	// [^4]: For this card type, you must include the `paymentInformation.card.type` in your request for any payer authentication services.
	//
	// #### Used by
	// **Authorization**
	// Required for Carte Blanche and JCB.
	// Optional for all other card types.
	//
	// #### Card Present reply
	// This field is included in the reply message when the client software that is installed on the POS terminal uses
	// the token management service (TMS) to retrieve tokenized payment details. You must contact customer support to
	// have your account enabled to receive these fields in the credit reply message.
	//
	// Returned by the Credit service.
	//
	// This reply field is only supported by the following processors:
	// - American Express Direct
	// - Credit Mutuel-CIC
	// - FDC Nashville Global
	// - OmniPay Direct
	// - SIX
	//
	// #### Google Pay transactions
	// For PAN-based Google Pay transactions, this field is returned in the API response.
	//
	// #### GPX
	// This field only supports transactions from the following card types:
	// - Visa
	// - Mastercard
	// - AMEX
	// - Discover
	// - Diners
	// - JCB
	// - Union Pay International
	//
	Type string `json:"type,omitempty"`
}

// Validate validates this create payment created body payment information card
func (o *CreatePaymentCreatedBodyPaymentInformationCard) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateExpirationMonth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpirationYear(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePrefix(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformationCard) validateExpirationMonth(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationMonth) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"paymentInformation"+"."+"card"+"."+"expirationMonth", "body", o.ExpirationMonth, 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformationCard) validateExpirationYear(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationYear) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"paymentInformation"+"."+"card"+"."+"expirationYear", "body", o.ExpirationYear, 4); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformationCard) validatePrefix(formats strfmt.Registry) error {
	if swag.IsZero(o.Prefix) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"paymentInformation"+"."+"card"+"."+"prefix", "body", o.Prefix, 6); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment created body payment information card based on context it is used
func (o *CreatePaymentCreatedBodyPaymentInformationCard) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyPaymentInformationCard) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyPaymentInformationCard) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyPaymentInformationCard
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyPaymentInformationCustomer create payment created body payment information customer
swagger:model CreatePaymentCreatedBodyPaymentInformationCustomer
*/
type CreatePaymentCreatedBodyPaymentInformationCustomer struct {

	// Unique identifier for the customer's card and billing information.
	//
	// When you use Payment Tokenization or Recurring Billing and you include this value in
	// your request, many of the fields that are normally required for an authorization or credit
	// become optional.
	//
	// **NOTE** When you use Payment Tokenization or Recurring Billing, the value for the Customer ID is actually the Cybersource payment token for a customer. This token stores information such as the consumers card number so it can be applied towards bill payments, recurring payments, or one-time payments. By using this token in a payment API request, the merchant doesn't need to pass in data such as the card number or expiration date in the request itself.
	//
	// For details, see the `subscription_id` field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	CustomerID string `json:"customerId,omitempty"`

	// Unique identifier for the Customer token used in the transaction.
	// When you include this value in your request, many of the fields that are normally required for an authorization or credit
	// become optional.
	//
	// Max Length: 32
	// Min Length: 1
	ID string `json:"id,omitempty"`
}

// Validate validates this create payment created body payment information customer
func (o *CreatePaymentCreatedBodyPaymentInformationCustomer) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformationCustomer) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MinLength("createPaymentCreated"+"."+"paymentInformation"+"."+"customer"+"."+"id", "body", o.ID, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"paymentInformation"+"."+"customer"+"."+"id", "body", o.ID, 32); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment created body payment information customer based on context it is used
func (o *CreatePaymentCreatedBodyPaymentInformationCustomer) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyPaymentInformationCustomer) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyPaymentInformationCustomer) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyPaymentInformationCustomer
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyPaymentInformationInstrumentIdentifier create payment created body payment information instrument identifier
swagger:model CreatePaymentCreatedBodyPaymentInformationInstrumentIdentifier
*/
type CreatePaymentCreatedBodyPaymentInformationInstrumentIdentifier struct {

	// Unique identifier for the Instrument Identifier token used in the transaction.
	// When you include this value in your request, many of the fields that can be supplied for an authorization or credit
	// become optional.
	//
	// Max Length: 32
	// Min Length: 12
	ID string `json:"id,omitempty"`

	// Issuers state for the card number.
	// Valid values:
	// - ACTIVE
	// - CLOSED : The account has been closed.
	//
	State string `json:"state,omitempty"`
}

// Validate validates this create payment created body payment information instrument identifier
func (o *CreatePaymentCreatedBodyPaymentInformationInstrumentIdentifier) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformationInstrumentIdentifier) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MinLength("createPaymentCreated"+"."+"paymentInformation"+"."+"instrumentIdentifier"+"."+"id", "body", o.ID, 12); err != nil {
		return err
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"paymentInformation"+"."+"instrumentIdentifier"+"."+"id", "body", o.ID, 32); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment created body payment information instrument identifier based on context it is used
func (o *CreatePaymentCreatedBodyPaymentInformationInstrumentIdentifier) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyPaymentInformationInstrumentIdentifier) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyPaymentInformationInstrumentIdentifier) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyPaymentInformationInstrumentIdentifier
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyPaymentInformationPaymentInstrument create payment created body payment information payment instrument
swagger:model CreatePaymentCreatedBodyPaymentInformationPaymentInstrument
*/
type CreatePaymentCreatedBodyPaymentInformationPaymentInstrument struct {

	// Unique identifier for the Payment Instrument token used in the transaction.
	// When you include this value in your request, many of the fields that are normally required for an authorization or credit
	// become optional.
	//
	// Max Length: 32
	// Min Length: 1
	ID string `json:"id,omitempty"`
}

// Validate validates this create payment created body payment information payment instrument
func (o *CreatePaymentCreatedBodyPaymentInformationPaymentInstrument) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformationPaymentInstrument) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MinLength("createPaymentCreated"+"."+"paymentInformation"+"."+"paymentInstrument"+"."+"id", "body", o.ID, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"paymentInformation"+"."+"paymentInstrument"+"."+"id", "body", o.ID, 32); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment created body payment information payment instrument based on context it is used
func (o *CreatePaymentCreatedBodyPaymentInformationPaymentInstrument) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyPaymentInformationPaymentInstrument) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyPaymentInformationPaymentInstrument) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyPaymentInformationPaymentInstrument
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyPaymentInformationShippingAddress create payment created body payment information shipping address
swagger:model CreatePaymentCreatedBodyPaymentInformationShippingAddress
*/
type CreatePaymentCreatedBodyPaymentInformationShippingAddress struct {

	// Unique identifier for the Customers Shipping Address token used in the transaction.
	// When you include this value in your request, many of the shipping fields that can be supplied for an authorization or credit
	// become optional.
	//
	// Max Length: 32
	// Min Length: 1
	ID string `json:"id,omitempty"`
}

// Validate validates this create payment created body payment information shipping address
func (o *CreatePaymentCreatedBodyPaymentInformationShippingAddress) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformationShippingAddress) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MinLength("createPaymentCreated"+"."+"paymentInformation"+"."+"shippingAddress"+"."+"id", "body", o.ID, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"paymentInformation"+"."+"shippingAddress"+"."+"id", "body", o.ID, 32); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment created body payment information shipping address based on context it is used
func (o *CreatePaymentCreatedBodyPaymentInformationShippingAddress) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyPaymentInformationShippingAddress) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyPaymentInformationShippingAddress) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyPaymentInformationShippingAddress
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyPaymentInformationTokenizedCard create payment created body payment information tokenized card
swagger:model CreatePaymentCreatedBodyPaymentInformationTokenizedCard
*/
type CreatePaymentCreatedBodyPaymentInformationTokenizedCard struct {

	// Confidence level of the tokenization. This value is assigned by the token service provider.
	//
	// **Note** This field is supported only for **CyberSource through VisaNet** and **FDC Nashville Global**.
	//
	// Returned by PIN debit credit or PIN debit purchase.
	//
	// Max Length: 2
	AssuranceLevel string `json:"assuranceLevel,omitempty"`

	// One of two possible meanings:
	// - The two-digit month in which a token expires.
	// - The two-digit month in which a card expires.
	// Format: `MM`
	// Possible values: `01` through `12`
	//
	// **NOTE** The meaning of this field is dependent on the payment processor that is returning the value in an authorization reply. Please see the processor-specific details below.
	//
	// #### Barclays and Streamline
	// For Maestro (UK Domestic) and Maestro (International) cards on Barclays and Streamline, this must be a valid value (`01` through `12`) but is not required to be a valid expiration date. In other words, an expiration date that is in the past does not cause CyberSource to reject your request. However, an invalid expiration date might cause the issuer to reject your request.
	//
	// #### Encoded Account Numbers
	// For encoded account numbers (`card_type=039`), if there is no expiration date on the card, use `12`.\
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// #### Samsung Pay and Apple Pay
	// Month in which the token expires. CyberSource includes this field in the reply message when it decrypts the payment blob for the tokenized transaction.
	//
	// For processor-specific information, see the `customer_cc_expmo` field in [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 2
	ExpirationMonth string `json:"expirationMonth,omitempty"`

	// One of two possible meanings:
	// - The four-digit year in which a token expires.
	// - The four-digit year in which a card expires.
	// Format: `YYYY`
	// Possible values: `1900` through `3000`
	// Data type: Non-negative integer
	//
	// **NOTE** The meaning of this field is dependent on the payment processor that is returning the value in an authorization reply. Please see the processor-specific details below.
	//
	// #### Barclays and Streamline
	// For Maestro (UK Domestic) and Maestro (International) cards on Barclays and Streamline, this must be a valid value (1900 through
	// 3000) but is not required to be a valid expiration date. In other words, an expiration date that is in the past does not cause CyberSource to reject your request. However, an invalid expiration date might cause the issuer to reject your request.
	//
	// #### Encoded Account Numbers
	// For encoded account numbers (`card_ type=039`), if there is no expiration date on the card, use `2021`.
	//
	// #### FDC Nashville Global and FDMS South
	// You can send in 2 digits or 4 digits. When you send in 2 digits, they must be the last 2 digits of
	// the year.
	//
	// #### Samsung Pay and Apple Pay
	// Year in which the token expires. CyberSource includes this field in the reply message when it decrypts the payment blob for the tokenized transaction.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction
	// you are requesting.
	//
	// For processor-specific information, see the `customer_cc_expyr` or `token_expiration_year` field in [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 4
	ExpirationYear string `json:"expirationYear,omitempty"`

	// First six digits of token. CyberSource includes this field in the reply message when it decrypts the payment
	// blob for the tokenized transaction.
	//
	// For details, see `token_prefix` field description in [Google Pay Using the SCMP API.]
	// (https://apps.cybersource.com/library/documentation/dev_guides/Google_Pay_SCMP_API/html/)
	//
	// Max Length: 6
	Prefix string `json:"prefix,omitempty"`

	// Value that identifies your business and indicates that the cardholders account number is tokenized. This value
	// is assigned by the token service provider and is unique within the token service providers database.
	//
	// **Note** This field is supported only for **CyberSource through VisaNet** and **FDC Nashville Global**.
	//
	// #### PIN debit
	// Optional field for PIN debit credit or PIN debit purchase transactions that use payment network tokens; otherwise, not used.
	//
	// Max Length: 11
	RequestorID string `json:"requestorId,omitempty"`

	// Last four digits of token. CyberSource includes this field in the reply message when it decrypts the payment
	// blob for the tokenized transaction.
	//
	// For details, see `token_suffix` field description in [Google Pay Using the SCMP API.]
	// (https://apps.cybersource.com/library/documentation/dev_guides/Google_Pay_SCMP_API/html/)
	//
	// Max Length: 4
	Suffix string `json:"suffix,omitempty"`

	// Three-digit value that indicates the card type.
	//
	// **IMPORTANT** It is strongly recommended that you include the card type field in request messages even if it is
	// optional for your processor and card type. Omitting the card type can cause the transaction to be processed with the wrong card type.
	//
	// Possible values:
	// - `001`: Visa. For card-present transactions on all processors except SIX, the Visa Electron card type is processed the same way that the Visa debit card is processed. Use card type value `001` for Visa Electron.
	// - `002`: Mastercard, Eurocard[^1], which is a European regional brand of Mastercard.
	// - `003`: American Express
	// - `004`: Discover
	// - `005`: Diners Club
	// - `006`: Carte Blanche[^1]
	// - `007`: JCB[^1]
	// - `014`: Enroute[^1]
	// - `021`: JAL[^1]
	// - `024`: Maestro (UK Domestic)[^1]
	// - `031`: Delta[^1]: Use this value only for Ingenico ePayments. For other processors, use `001` for all Visa card types.
	// - `033`: Visa Electron[^1]. Use this value only for Ingenico ePayments and SIX. For other processors, use `001` for all Visa card types.
	// - `034`: Dankort[^1]
	// - `036`: Cartes Bancaires[^1,4]
	// - `037`: Carta Si[^1]
	// - `039`: Encoded account number[^1]
	// - `040`: UATP[^1]
	// - `042`: Maestro (International)[^1]
	// - `050`: Hipercard[^2,3]
	// - `051`: Aura
	// - `054`: Elo[^3]
	// - `062`: China UnionPay
	//
	// [^1]: For this card type, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in your request for an authorization or a stand-alone credit.
	// [^2]: For this card type on Cielo 3.0, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in a request for an authorization or a stand-alone credit. This card type is not supported on Cielo 1.5.
	// [^3]: For this card type on Getnet and Rede, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in a request for an authorization or a stand-alone credit.
	// [^4]: For this card type, you must include the `paymentInformation.card.type` in your request for any payer authentication services.
	//
	// #### Used by
	// **Authorization**
	// Required for Carte Blanche and JCB.
	// Optional for all other card types.
	//
	// #### Card Present reply
	// This field is included in the reply message when the client software that is installed on the POS terminal uses
	// the token management service (TMS) to retrieve tokenized payment details. You must contact customer support to
	// have your account enabled to receive these fields in the credit reply message.
	//
	// Returned by the Credit service.
	//
	// This reply field is only supported by the following processors:
	// - American Express Direct
	// - Credit Mutuel-CIC
	// - FDC Nashville Global
	// - OmniPay Direct
	// - SIX
	//
	// #### Google Pay transactions
	// For PAN-based Google Pay transactions, this field is returned in the API response.
	//
	// #### GPX
	// This field only supports transactions from the following card types:
	// - Visa
	// - Mastercard
	// - AMEX
	// - Discover
	// - Diners
	// - JCB
	// - Union Pay International
	//
	Type string `json:"type,omitempty"`
}

// Validate validates this create payment created body payment information tokenized card
func (o *CreatePaymentCreatedBodyPaymentInformationTokenizedCard) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAssuranceLevel(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpirationMonth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpirationYear(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePrefix(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRequestorID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSuffix(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformationTokenizedCard) validateAssuranceLevel(formats strfmt.Registry) error {
	if swag.IsZero(o.AssuranceLevel) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"paymentInformation"+"."+"tokenizedCard"+"."+"assuranceLevel", "body", o.AssuranceLevel, 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformationTokenizedCard) validateExpirationMonth(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationMonth) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"paymentInformation"+"."+"tokenizedCard"+"."+"expirationMonth", "body", o.ExpirationMonth, 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformationTokenizedCard) validateExpirationYear(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationYear) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"paymentInformation"+"."+"tokenizedCard"+"."+"expirationYear", "body", o.ExpirationYear, 4); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformationTokenizedCard) validatePrefix(formats strfmt.Registry) error {
	if swag.IsZero(o.Prefix) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"paymentInformation"+"."+"tokenizedCard"+"."+"prefix", "body", o.Prefix, 6); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformationTokenizedCard) validateRequestorID(formats strfmt.Registry) error {
	if swag.IsZero(o.RequestorID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"paymentInformation"+"."+"tokenizedCard"+"."+"requestorId", "body", o.RequestorID, 11); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformationTokenizedCard) validateSuffix(formats strfmt.Registry) error {
	if swag.IsZero(o.Suffix) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"paymentInformation"+"."+"tokenizedCard"+"."+"suffix", "body", o.Suffix, 4); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment created body payment information tokenized card based on context it is used
func (o *CreatePaymentCreatedBodyPaymentInformationTokenizedCard) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyPaymentInformationTokenizedCard) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyPaymentInformationTokenizedCard) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyPaymentInformationTokenizedCard
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyPointOfSaleInformation create payment created body point of sale information
swagger:model CreatePaymentCreatedBodyPointOfSaleInformation
*/
type CreatePaymentCreatedBodyPointOfSaleInformation struct {

	// Point-of-sale details for the transaction. This value is returned only for **American Express Direct**.
	// CyberSource generates this value, which consists of a series of codes that identify terminal capability,
	// security data, and specific conditions present at the time the transaction occurred. To comply with the CAPN
	// requirements, this value must be included in all subsequent follow-on requests, such as captures and follow-on
	// credits.
	//
	// When you perform authorizations, captures, and credits through CyberSource, CyberSource passes this value from
	// the authorization service to the subsequent services for you. However, when you perform authorizations through
	// CyberSource and perform subsequent services through other financial institutions, you must ensure that your
	// requests for captures and credits include this value.
	//
	// For details, see `auth_pos_data` field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// Max Length: 15
	AmexCapnData string `json:"amexCapnData,omitempty"`

	// emv
	Emv *CreatePaymentCreatedBodyPointOfSaleInformationEmv `json:"emv,omitempty"`

	// Identifier for the terminal at your retail location. You can define this value yourself, but consult the processor for requirements.
	//
	// #### CyberSource through VisaNet
	// A list of all possible values is stored in your CyberSource account. If terminal ID validation is enabled for
	// your CyberSource account, the value you send for this field is validated against the list each time you include
	// the field in a request. To enable or disable terminal ID validation, contact CyberSource Customer Support.
	//
	// When you do not include this field in a request, CyberSource uses the default value that is defined in your CyberSource account.
	//
	// #### FDC Nashville Global
	// To have your account configured to support this field, contact CyberSource Customer Support. This value must be a value that FDC Nashville Global issued to you.
	//
	// #### For Payouts
	// This field is applicable for CyberSource through VisaNet.
	//
	// #### GPX
	// Identifier for the terminal at your retail location. A list of all possible values is stored in your account.
	// If terminal ID validation is enabled for your account, the value you send for this field is validated against
	// the list each time you include the field in a request. To enable or disable terminal ID validation, contact
	// customer support.
	//
	// When you do not include this field in a request, the default value that is defined in your account is used.
	//
	// Optional for authorizations.
	//
	// #### Used by
	// **Authorization**
	// Optional for the following processors. When you do not include this field in a request, the default value that is
	// defined in your account is used.
	//   - American Express Direct
	//   - Credit Mutuel-CIC
	//   - FDC Nashville Global
	//   - SIX
	// - Chase Paymentech Solutions: Optional field. If you include this field in your request, you must also include `pointOfSaleInformation.catLevel`.
	// - FDMS Nashville: The default value that is defined in your account is used.
	// - GPX
	// - OmniPay Direct: Optional field.
	//
	// For the following processors, this field is not used.
	// - GPN
	// - JCN Gateway
	// - RBS WorldPay Atlanta
	// - TSYS Acquiring Solutions
	// - Worldpay VAP
	//
	// #### Card Present reply
	// Terminal identifier assigned by the acquirer. This value must be printed on the receipt.
	//
	// Max Length: 8
	TerminalID string `json:"terminalId,omitempty"`
}

// Validate validates this create payment created body point of sale information
func (o *CreatePaymentCreatedBodyPointOfSaleInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAmexCapnData(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEmv(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTerminalID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyPointOfSaleInformation) validateAmexCapnData(formats strfmt.Registry) error {
	if swag.IsZero(o.AmexCapnData) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"pointOfSaleInformation"+"."+"amexCapnData", "body", o.AmexCapnData, 15); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPointOfSaleInformation) validateEmv(formats strfmt.Registry) error {
	if swag.IsZero(o.Emv) { // not required
		return nil
	}

	if o.Emv != nil {
		if err := o.Emv.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "pointOfSaleInformation" + "." + "emv")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "pointOfSaleInformation" + "." + "emv")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPointOfSaleInformation) validateTerminalID(formats strfmt.Registry) error {
	if swag.IsZero(o.TerminalID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"pointOfSaleInformation"+"."+"terminalId", "body", o.TerminalID, 8); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this create payment created body point of sale information based on the context it is used
func (o *CreatePaymentCreatedBodyPointOfSaleInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateEmv(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyPointOfSaleInformation) contextValidateEmv(ctx context.Context, formats strfmt.Registry) error {

	if o.Emv != nil {
		if err := o.Emv.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "pointOfSaleInformation" + "." + "emv")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "pointOfSaleInformation" + "." + "emv")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyPointOfSaleInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyPointOfSaleInformation) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyPointOfSaleInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyPointOfSaleInformationEmv create payment created body point of sale information emv
swagger:model CreatePaymentCreatedBodyPointOfSaleInformationEmv
*/
type CreatePaymentCreatedBodyPointOfSaleInformationEmv struct {

	// Cryptogram validation results returned by the entity or service specified in `chipValidationType`.
	//
	// Possible values:
	// - `A`: Application cryptogram is valid, but the application transaction counter (ATC) is outside allowed range. (A large jump in ATC values may indicate data copying or other fraud.)
	// - `C`: Chip validation was completed successfully.
	// - `E`: Application cryptogram is valid but the ATC indicates possible replay fraud.
	// - `F`: Format error in the chip data.
	// - `G`: Application cryptogram is valid but is not a valid authorization request cryptogram (ARQC).
	// - `I`: Application cryptogram is invalid.
	// - `T`: Application cryptogram is valid but terminal verification results (TVR) or card verification results (CVR) are invalid.
	// - `U`: Application cryptogram could not be validated because of a technical error.
	//
	// This field is returned only for NFC payment network tokenization transactions with MasterCard.
	//
	// **Note** No CyberSource through VisaNet acquirers support EMV at this time.
	//
	// Max Length: 1
	ChipValidationResult string `json:"chipValidationResult,omitempty"`

	// Entity or service that provided the validation results returned in `chipValidationResult`.
	//
	// Possible values:
	//  - `02`: MasterCard on-behalf pre-validation service (The MasterCard authorization platform validated the M/Chip cryptogram before the authorization request reached the issuer.)
	//  - `03`: MasterCard on-behalf stand-in service (The MasterCard authorization platform validated the M/Chip cryptogram because the issuer was not available.)
	//  - `50`: Issuer
	//  - `90`: Chip fall-back transaction downgrade process (The chip could not be read.)
	//
	// This field is returned only for NFC payment network tokenization transactions with MasterCard.
	//
	// **Note** No CyberSource through VisaNet acquirers support EMV at this time.
	//
	// Max Length: 2
	ChipValidationType string `json:"chipValidationType,omitempty"`

	// EMV data that is transmitted from the chip card to the issuer, and from the issuer to the chip card. The EMV
	// data is in the tag-length-value format and includes chip card tags, terminal tags, and transaction detail tags.
	//
	// For information about the individual tags, see the Application Specification section in the EMV 4.3 Specifications: http://emvco.com
	//
	// **Note** Card present information about EMV applies only to credit card processing and PIN debit processing.
	// All other card present information applies only to credit card processing. PIN debit processing is available only
	// on FDC Nashville Global.
	//
	// **Important** The following tags contain sensitive information and **must not** be included in this field:
	//
	//  - `56`: Track 1 equivalent data
	//  - `57`: Track 2 equivalent data
	//  - `5A`: Application PAN
	//  - `5F20`: Cardholder name
	//  - `5F24`: Application expiration date (This sensitivity has been relaxed for Credit Mutuel-CIC, American Express Direct, FDC Nashville Global, First Data Merchant Solutions, and SIX)
	//  - `99`: Transaction PIN
	//  - `9F0B`: Cardholder name (extended)
	//  - `9F1F`: Track 1 discretionary data
	//  - `9F20`: Track 2 discretionary data
	//
	// For captures, this field is required for contact EMV transactions. Otherwise, it is optional.
	//
	// For credits, this field is required for contact EMV stand-alone credits and contactless EMV stand-alone credits.
	// Otherwise, it is optional.
	//
	// **Important** For contact EMV captures, contact EMV stand-alone credits, and contactless EMV stand-alone credits,
	// you must include the following tags in this field. For all other types of EMV transactions, the following tags
	// are optional.
	//
	//  - `95`: Terminal verification results
	//  - `9F10`: Issuer application data
	//  - `9F26`: Application cryptogram
	//
	//
	// #### CyberSource through VisaNet
	// - In Japan: 199 bytes
	// - In other countries: String (252)
	//
	// #### GPX
	// This field only supports transactions from the following card types:
	// - Visa
	// - Mastercard
	// - AMEX
	// - Discover
	// - Diners
	// - JCB
	// - Union Pay International
	//
	// #### JCN Gateway
	// The following tags must be included:
	// - `4F`: Application identifier
	// - `84`: Dedicated file name
	//
	// Data length: 199 bytes
	//
	// #### All other processors:
	// String (999)
	//
	// #### Used by
	// Authorization: Optional
	// Authorization Reversal: Optional
	// Credit: Optional
	// PIN Debit processing (purchase, credit and reversal): Optional
	//
	// Max Length: 1998
	Tags string `json:"tags,omitempty"`
}

// Validate validates this create payment created body point of sale information emv
func (o *CreatePaymentCreatedBodyPointOfSaleInformationEmv) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateChipValidationResult(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateChipValidationType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTags(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyPointOfSaleInformationEmv) validateChipValidationResult(formats strfmt.Registry) error {
	if swag.IsZero(o.ChipValidationResult) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"pointOfSaleInformation"+"."+"emv"+"."+"chipValidationResult", "body", o.ChipValidationResult, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPointOfSaleInformationEmv) validateChipValidationType(formats strfmt.Registry) error {
	if swag.IsZero(o.ChipValidationType) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"pointOfSaleInformation"+"."+"emv"+"."+"chipValidationType", "body", o.ChipValidationType, 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPointOfSaleInformationEmv) validateTags(formats strfmt.Registry) error {
	if swag.IsZero(o.Tags) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"pointOfSaleInformation"+"."+"emv"+"."+"tags", "body", o.Tags, 1998); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment created body point of sale information emv based on context it is used
func (o *CreatePaymentCreatedBodyPointOfSaleInformationEmv) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyPointOfSaleInformationEmv) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyPointOfSaleInformationEmv) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyPointOfSaleInformationEmv
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyProcessingInformation create payment created body processing information
swagger:model CreatePaymentCreatedBodyProcessingInformation
*/
type CreatePaymentCreatedBodyProcessingInformation struct {

	// bank transfer options
	BankTransferOptions *CreatePaymentCreatedBodyProcessingInformationBankTransferOptions `json:"bankTransferOptions,omitempty"`

	// The possible values for the reply field are:
	// - `true` : the airline data was included in the request to the processor.
	// - `false` : the airline data was not included in the request to the processor.
	//
	// Returned by authorization, capture, or credit services.
	//
	EnhancedDataEnabled bool `json:"enhancedDataEnabled,omitempty"`

	// Type of digital payment solution for the transaction. Possible Values:
	//
	//  - `visacheckout`: Visa Checkout. This value is required for Visa Checkout transactions. For details, see `payment_solution` field description in [Visa Checkout Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/VCO_SCMP_API/html/)
	//  - `001`: Apple Pay.
	//  - `004`: Cybersource In-App Solution.
	//  - `005`: Masterpass. This value is required for Masterpass transactions on OmniPay Direct. For details, see "Masterpass" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//  - `006`: Android Pay.
	//  - `007`: Chase Pay.
	//  - `008`: Samsung Pay.
	//  - `012`: Google Pay.
	//  - `013`: Cybersource P2PE Decryption
	//  - `014`: Mastercard credential on file (COF) payment network token. Returned in authorizations that use a payment network token associated with a TMS token.
	//  - `015`: Visa credential on file (COF) payment network token. Returned in authorizations that use a payment network token associated with a TMS token.
	//  - `027`: Click to Pay.
	//
	// Max Length: 12
	PaymentSolution string `json:"paymentSolution,omitempty"`
}

// Validate validates this create payment created body processing information
func (o *CreatePaymentCreatedBodyProcessingInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateBankTransferOptions(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePaymentSolution(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyProcessingInformation) validateBankTransferOptions(formats strfmt.Registry) error {
	if swag.IsZero(o.BankTransferOptions) { // not required
		return nil
	}

	if o.BankTransferOptions != nil {
		if err := o.BankTransferOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "processingInformation" + "." + "bankTransferOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "processingInformation" + "." + "bankTransferOptions")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessingInformation) validatePaymentSolution(formats strfmt.Registry) error {
	if swag.IsZero(o.PaymentSolution) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processingInformation"+"."+"paymentSolution", "body", o.PaymentSolution, 12); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this create payment created body processing information based on the context it is used
func (o *CreatePaymentCreatedBodyProcessingInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateBankTransferOptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyProcessingInformation) contextValidateBankTransferOptions(ctx context.Context, formats strfmt.Registry) error {

	if o.BankTransferOptions != nil {
		if err := o.BankTransferOptions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "processingInformation" + "." + "bankTransferOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "processingInformation" + "." + "bankTransferOptions")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyProcessingInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyProcessingInformation) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyProcessingInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyProcessingInformationBankTransferOptions create payment created body processing information bank transfer options
swagger:model CreatePaymentCreatedBodyProcessingInformationBankTransferOptions
*/
type CreatePaymentCreatedBodyProcessingInformationBankTransferOptions struct {

	// Level of fraud screening.
	//
	// Possible values:
	// - `1`: Validation  default if the field has not already been configured for your merchant ID
	// - `2`: Verification
	//
	// For a description of this feature and a list of supported processors, see "Verification and Validation" in the [Electronic Check Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/EChecks_SCMP_API/html/).
	//
	// Max Length: 1
	FraudScreeningLevel string `json:"fraudScreeningLevel,omitempty"`

	// Method used for settlement.
	//
	// Possible values:
	// - `A`: Automated Clearing House (default for credits and for transactions using Canadian dollars)
	// - `F`: Facsimile draft (U.S. dollars only)
	// - `B`: Best possible (U.S. dollars only) (default if the field has not already been configured for your
	// merchant ID)
	//
	// For details, see `ecp_settlement_method` field description for credit cars and `ecp_debit_settlement_method` for debit cards in the [Electronic Check Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/EChecks_SCMP_API/html/)
	//
	// Max Length: 1
	SettlementMethod string `json:"settlementMethod,omitempty"`
}

// Validate validates this create payment created body processing information bank transfer options
func (o *CreatePaymentCreatedBodyProcessingInformationBankTransferOptions) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateFraudScreeningLevel(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSettlementMethod(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyProcessingInformationBankTransferOptions) validateFraudScreeningLevel(formats strfmt.Registry) error {
	if swag.IsZero(o.FraudScreeningLevel) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processingInformation"+"."+"bankTransferOptions"+"."+"fraudScreeningLevel", "body", o.FraudScreeningLevel, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessingInformationBankTransferOptions) validateSettlementMethod(formats strfmt.Registry) error {
	if swag.IsZero(o.SettlementMethod) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processingInformation"+"."+"bankTransferOptions"+"."+"settlementMethod", "body", o.SettlementMethod, 1); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment created body processing information bank transfer options based on context it is used
func (o *CreatePaymentCreatedBodyProcessingInformationBankTransferOptions) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyProcessingInformationBankTransferOptions) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyProcessingInformationBankTransferOptions) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyProcessingInformationBankTransferOptions
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyProcessorInformation create payment created body processor information
swagger:model CreatePaymentCreatedBodyProcessorInformation
*/
type CreatePaymentCreatedBodyProcessorInformation struct {

	// ach verification
	AchVerification *CreatePaymentCreatedBodyProcessorInformationAchVerification `json:"achVerification,omitempty"`

	// Referral response number for a verbal authorization with FDMS Nashville when using an American Express card.
	// Give this number to American Express when you call them for the verbal authorization.
	//
	// Max Length: 6
	AmexVerbalAuthReferenceNumber string `json:"amexVerbalAuthReferenceNumber,omitempty"`

	// Authorization code. Returned only when the processor returns this value.
	//
	// The length of this value depends on your processor.
	//
	// Returned by authorization service.
	//
	// #### PIN debit
	// Authorization code that is returned by the processor.
	//
	// Returned by PIN debit credit.
	//
	// #### Elavon Encrypted Account Number Program
	// The returned value is OFFLINE.
	//
	// #### TSYS Acquiring Solutions
	// The returned value for a successful zero amount authorization is 000000.
	//
	// Max Length: 6
	ApprovalCode string `json:"approvalCode,omitempty"`

	// Flag that specifies the purpose of the authorization.
	//
	// Possible values:
	//  - `0`: Preauthorization
	//  - `1`: Final authorization
	//
	// Max Length: 1
	AuthIndicator string `json:"authIndicator,omitempty"`

	// avs
	Avs *CreatePaymentCreatedBodyProcessorInformationAvs `json:"avs,omitempty"`

	// The Scheme reference data is a variable length data element up to a maximum of 56 characters. It may be sent by the acquirer in the
	// authorisation response message, and by the terminal (unchanged) in subsequent authorisation request messages associated with the same
	// transaction.
	// This field is used by Streamline and HSBC UK only, at present.
	//
	// Max Length: 56
	CardReferenceData string `json:"cardReferenceData,omitempty"`

	// card verification
	CardVerification *CreatePaymentCreatedBodyProcessorInformationCardVerification `json:"cardVerification,omitempty"`

	// consumer authentication response
	ConsumerAuthenticationResponse *CreatePaymentCreatedBodyProcessorInformationConsumerAuthenticationResponse `json:"consumerAuthenticationResponse,omitempty"`

	// customer
	Customer *CreatePaymentCreatedBodyProcessorInformationCustomer `json:"customer,omitempty"`

	// electronic verification results
	ElectronicVerificationResults *CreatePaymentCreatedBodyProcessorInformationElectronicVerificationResults `json:"electronicVerificationResults,omitempty"`

	// Name of the Japanese acquirer that processed the transaction. Returned only for JCN Gateway.
	// Please contact the CyberSource Japan Support Group for more information.
	//
	// Max Length: 32
	ForwardedAcquirerCode string `json:"forwardedAcquirerCode,omitempty"`

	// Type of authentication for which the transaction qualifies as determined by the Mastercard authentication
	// service, which confirms the identity of the cardholder. Mastercard provides this value to CyberSource.
	//
	// Possible values:
	//
	//  - `1`: Transaction qualifies for Mastercard authentication type 1.
	//  - `2`: Transaction qualifies for Mastercard authentication type 2.
	//
	// #### CyberSource through VisaNet
	// The value for this field corresponds to the following data in the TC 33 capture file:
	// - Record: CP01 TCR6
	// - Position: 132
	// - Field: Mastercard Member Defined service.
	// **Note** This field is returned only for CyberSource through VisaNet.
	//
	// Max Length: 1
	MasterCardAuthenticationType string `json:"masterCardAuthenticationType,omitempty"`

	// Mastercard service that was used for the transaction. Mastercard provides this value to CyberSource.
	//
	// Possible value:
	//  - 53: Mastercard card-on-file token service
	//
	// #### CyberSource through VisaNet
	// The value for this field corresponds to the following data in the TC 33 capture file:
	// - Record: CP01 TCR6
	// - Position: 133-134
	// - Field: Mastercard Merchant on-behalf service.
	// **Note** This field is returned only for CyberSource through VisaNet.
	//
	// Max Length: 2
	MasterCardServiceCode string `json:"masterCardServiceCode,omitempty"`

	// Result of the Mastercard card-on-file token service. Mastercard provides this value to CyberSource.
	//
	// Possible values:
	//
	//  - `C`: Service completed successfully.
	//  - `F`: One of the following:
	//    - Incorrect Mastercard POS entry mode. The Mastercard POS entry mode should be 81 for an authorization or
	//      authorization reversal.
	//    - Incorrect Mastercard POS entry mode. The Mastercard POS entry mode should be 01 for a tokenized request.
	//    - Token requestor ID is missing or formatted incorrectly.
	//  - `I`: One of the following:
	//    - Invalid token requestor ID.
	//    - Suspended or deactivated token.
	//    - Invalid token (not in mapping table).
	//  - `T`: Invalid combination of token requestor ID and token.
	//  - `U`: Expired token.
	//  - `W`: Primary account number (PAN) listed in electronic warning bulletin.
	//
	// **Note** This field is returned only for **CyberSource through VisaNet**.
	//
	// Max Length: 1
	MasterCardServiceReplyCode string `json:"masterCardServiceReplyCode,omitempty"`

	// merchant advice
	MerchantAdvice *CreatePaymentCreatedBodyProcessorInformationMerchantAdvice `json:"merchantAdvice,omitempty"`

	// Identifier that was assigned to you by your acquirer. This value must be printed on the receipt.
	//
	// #### Returned by
	// Authorizations and Credits.
	//
	// This reply field is only supported by merchants who have installed client software on their POS terminals and
	// use these processors:
	// - American Express Direct
	// - Credit Mutuel-CIC
	// - FDC Nashville Global
	// - OmniPay Direct
	// - SIX
	//
	// Max Length: 15
	MerchantNumber string `json:"merchantNumber,omitempty"`

	// Name of the Processor.
	//
	// Max Length: 30
	Name string `json:"name,omitempty"`

	// Same value as `processorInformation.transactionId`
	NetworkTransactionID string `json:"networkTransactionId,omitempty"`

	// Visa-generated reference number that identifies a card-present transaction for which you provided one of the
	// following:
	//
	//  - Visa primary account number (PAN)
	//  - Visa-generated token for a PAN
	//
	// This reference number serves as a link to the cardholder account and to all transactions for that account.
	// This reply field is returned only for CyberSource through VisaNet.
	//
	// **Note** On CyberSource through VisaNet, the value for this field corresponds to the following data in the TC 33 capture file:
	// - Record: CP01 TCR8
	// - Position: 79-110
	// - Field: Payment Account Reference
	//
	// The TC 33 Capture file contains information about the purchases and refunds that a merchant submits to CyberSource.
	// CyberSource through VisaNet creates the TC 33 Capture file at the end of the day and sends it to the merchants acquirer,
	// who uses this information to facilitate end-of-day clearing processing with payment networks.
	//
	// Max Length: 32
	PaymentAccountReferenceNumber string `json:"paymentAccountReferenceNumber,omitempty"`

	// Processor-defined response category code. The associated detail error code is in the `processorInformation.responseCode` or `issuerInformation.responseCode`
	// field of the service you requested.
	//
	// This field is supported only for:
	//
	//  - Japanese issuers
	//  - Domestic transactions in Japan
	//  - Comercio Latinoprocessor transaction ID required for troubleshooting
	//
	// #### Maximum length for processors
	//
	//  - Comercio Latino: 36
	//  - All other processors: 3
	//
	// Max Length: 36
	ResponseCategoryCode string `json:"responseCategoryCode,omitempty"`

	// For most processors, this is the error message sent directly from the bank. Returned only when the processor
	// returns this value.
	//
	// **Important** Do not use this field to evaluate the result of the authorization.
	//
	// #### PIN debit
	// Response value that is returned by the processor or bank.
	// **Important** Do not use this field to evaluate the results of the transaction request.
	//
	// Returned by PIN debit credit, PIN debit purchase, and PIN debit reversal.
	//
	// #### AIBMS
	// If this value is `08`, you can accept the transaction if the customer provides you with identification.
	//
	// #### Atos
	// This value is the response code sent from Atos and it might also include the response code from the bank.
	// Format: `aa,bb` with the two values separated by a comma and where:
	// - `aa` is the two-digit error message from Atos.
	// - `bb` is the optional two-digit error message from the bank.
	//
	// #### Comercio Latino
	// This value is the status code and the error or response code received from the processor separated by a colon.
	// Format: [status code]:E[error code] or [status code]:R[response code]
	// Example `2:R06`
	//
	// #### JCN Gateway
	// Processor-defined detail error code. The associated response category code is in the `processorInformation.responseCategoryCode` field.
	// String (3)
	//
	// Max Length: 10
	ResponseCode string `json:"responseCode,omitempty"`

	// Used by Visa only and contains the response source/reason code that identifies the source of the response decision.
	//
	// Max Length: 1
	ResponseCodeSource string `json:"responseCodeSource,omitempty"`

	// This field might contain information about a decline. This field is supported only for **CyberSource through
	// VisaNet**.
	//
	// Max Length: 255
	ResponseDetails string `json:"responseDetails,omitempty"`

	// #### Ingenico ePayments
	// Unique number that CyberSource generates to identify the transaction. You can use this value to identify transactions in the Ingenico ePayments Collections Report, which provides settlement information. Contact customer support for information about the report.
	//
	// ### CyberSource through VisaNet
	// Retrieval request number.
	//
	// Max Length: 20
	RetrievalReferenceNumber string `json:"retrievalReferenceNumber,omitempty"`

	// routing
	Routing *CreatePaymentCreatedBodyProcessorInformationRouting `json:"routing,omitempty"`

	// This field is returned only for **American Express Direct** and **CyberSource through VisaNet**.
	// Returned by authorization and incremental authorization services.
	//
	// #### American Express Direct
	//
	// System trace audit number (STAN). This value identifies the transaction and is useful when investigating a
	// chargeback dispute.
	//
	// #### CyberSource through VisaNet
	//
	// System trace number that must be printed on the customers receipt.
	//
	// Max Length: 6
	SystemTraceAuditNumber string `json:"systemTraceAuditNumber,omitempty"`

	// Network transaction identifier (TID). You can use this value to identify a specific transaction when you are
	// discussing the transaction with your processor. Not all processors provide this value.
	//
	// Returned by the authorization service.
	//
	// #### PIN debit
	// Transaction identifier generated by the processor.
	//
	// Returned by PIN debit credit.
	//
	// #### GPX
	// Processor transaction ID.
	//
	// #### Cielo
	// For Cielo, this value is the non-sequential unit (NSU) and is supported for all transactions. The value is generated by Cielo or the issuing bank.
	//
	// #### Comercio Latino
	// For Comercio Latino, this value is the proof of sale or non-sequential unit (NSU) number generated by the acquirers Cielo and Rede, or the issuing bank.
	//
	// #### CyberSource through VisaNet and GPN
	// For details about this value for CyberSource through VisaNet and GPN, see "Network Transaction Identifiers" in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// #### Moneris
	// This value identifies the transaction on a host system. It contains the following information:
	// - Terminal used to process the transaction
	// - Shift during which the transaction took place
	// - Batch number
	// - Transaction number within the batch
	// You must store this value. If you give the customer a receipt, display this value on the receipt.
	//
	// **Example** For the value
	// 66012345001069003:
	// - Terminal ID = 66012345
	// - Shift number = 001
	// - Batch number = 069
	// - Transaction number = 003
	//
	// Max Length: 50
	TransactionID string `json:"transactionId,omitempty"`

	// Transaction integrity classification provided by Mastercard. This value specifies Mastercards evaluation of
	// the transactions safety and security. This field is returned only for **CyberSource through VisaNet**.
	//
	// For card-present transactions, possible values:
	//
	//  - `A1`: EMV or token in a secure, trusted environment
	//  - `B1`: EMV or chip equivalent
	//  - `C1`: Magnetic stripe
	//  - `E1`: Key entered
	//  - `U0`: Unclassified
	//
	// For card-not-present transactions, possible values:
	//
	//  - `A2`: Digital transactions
	//  - `B2`: Authenticated checkout
	//  - `C2`: Transaction validation
	//  - `D2`: Enhanced data
	//  - `E2`: Generic messaging
	//  - `U0`: Unclassified
	//
	// For information about these values, contact Mastercard or your acquirer.
	//
	// #### CyberSource through VisaNet
	//
	// The value for this field corresponds to the following data in the TC 33 capture file,<sup>1</sup>:
	// - Record: CP01 TCR6
	// - Position: 136-137
	// - Field: Mastercard Transaction Integrity Classification
	//
	// <sup>1</sup> The TC 33 Capture file contains information about the purchases and refunds that a merchant submits to CyberSource.
	// CyberSource through VisaNet creates the TC 33 Capture file at the end of the day and sends it to the merchants acquirer, who uses
	// this information to facilitate end-of-day clearing processing with payment networks.
	//
	// Max Length: 2
	TransactionIntegrityCode string `json:"transactionIntegrityCode,omitempty"`
}

// Validate validates this create payment created body processor information
func (o *CreatePaymentCreatedBodyProcessorInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAchVerification(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAmexVerbalAuthReferenceNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateApprovalCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAuthIndicator(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAvs(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCardReferenceData(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCardVerification(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateConsumerAuthenticationResponse(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCustomer(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateElectronicVerificationResults(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateForwardedAcquirerCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMasterCardAuthenticationType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMasterCardServiceCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMasterCardServiceReplyCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMerchantAdvice(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMerchantNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePaymentAccountReferenceNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateResponseCategoryCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateResponseCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateResponseCodeSource(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateResponseDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRetrievalReferenceNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRouting(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSystemTraceAuditNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTransactionID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTransactionIntegrityCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformation) validateAchVerification(formats strfmt.Registry) error {
	if swag.IsZero(o.AchVerification) { // not required
		return nil
	}

	if o.AchVerification != nil {
		if err := o.AchVerification.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "processorInformation" + "." + "achVerification")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "processorInformation" + "." + "achVerification")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformation) validateAmexVerbalAuthReferenceNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.AmexVerbalAuthReferenceNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"amexVerbalAuthReferenceNumber", "body", o.AmexVerbalAuthReferenceNumber, 6); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformation) validateApprovalCode(formats strfmt.Registry) error {
	if swag.IsZero(o.ApprovalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"approvalCode", "body", o.ApprovalCode, 6); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformation) validateAuthIndicator(formats strfmt.Registry) error {
	if swag.IsZero(o.AuthIndicator) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"authIndicator", "body", o.AuthIndicator, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformation) validateAvs(formats strfmt.Registry) error {
	if swag.IsZero(o.Avs) { // not required
		return nil
	}

	if o.Avs != nil {
		if err := o.Avs.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "processorInformation" + "." + "avs")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "processorInformation" + "." + "avs")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformation) validateCardReferenceData(formats strfmt.Registry) error {
	if swag.IsZero(o.CardReferenceData) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"cardReferenceData", "body", o.CardReferenceData, 56); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformation) validateCardVerification(formats strfmt.Registry) error {
	if swag.IsZero(o.CardVerification) { // not required
		return nil
	}

	if o.CardVerification != nil {
		if err := o.CardVerification.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "processorInformation" + "." + "cardVerification")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "processorInformation" + "." + "cardVerification")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformation) validateConsumerAuthenticationResponse(formats strfmt.Registry) error {
	if swag.IsZero(o.ConsumerAuthenticationResponse) { // not required
		return nil
	}

	if o.ConsumerAuthenticationResponse != nil {
		if err := o.ConsumerAuthenticationResponse.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "processorInformation" + "." + "consumerAuthenticationResponse")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "processorInformation" + "." + "consumerAuthenticationResponse")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformation) validateCustomer(formats strfmt.Registry) error {
	if swag.IsZero(o.Customer) { // not required
		return nil
	}

	if o.Customer != nil {
		if err := o.Customer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "processorInformation" + "." + "customer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "processorInformation" + "." + "customer")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformation) validateElectronicVerificationResults(formats strfmt.Registry) error {
	if swag.IsZero(o.ElectronicVerificationResults) { // not required
		return nil
	}

	if o.ElectronicVerificationResults != nil {
		if err := o.ElectronicVerificationResults.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "processorInformation" + "." + "electronicVerificationResults")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "processorInformation" + "." + "electronicVerificationResults")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformation) validateForwardedAcquirerCode(formats strfmt.Registry) error {
	if swag.IsZero(o.ForwardedAcquirerCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"forwardedAcquirerCode", "body", o.ForwardedAcquirerCode, 32); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformation) validateMasterCardAuthenticationType(formats strfmt.Registry) error {
	if swag.IsZero(o.MasterCardAuthenticationType) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"masterCardAuthenticationType", "body", o.MasterCardAuthenticationType, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformation) validateMasterCardServiceCode(formats strfmt.Registry) error {
	if swag.IsZero(o.MasterCardServiceCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"masterCardServiceCode", "body", o.MasterCardServiceCode, 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformation) validateMasterCardServiceReplyCode(formats strfmt.Registry) error {
	if swag.IsZero(o.MasterCardServiceReplyCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"masterCardServiceReplyCode", "body", o.MasterCardServiceReplyCode, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformation) validateMerchantAdvice(formats strfmt.Registry) error {
	if swag.IsZero(o.MerchantAdvice) { // not required
		return nil
	}

	if o.MerchantAdvice != nil {
		if err := o.MerchantAdvice.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "processorInformation" + "." + "merchantAdvice")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "processorInformation" + "." + "merchantAdvice")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformation) validateMerchantNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.MerchantNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"merchantNumber", "body", o.MerchantNumber, 15); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformation) validateName(formats strfmt.Registry) error {
	if swag.IsZero(o.Name) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"name", "body", o.Name, 30); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformation) validatePaymentAccountReferenceNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.PaymentAccountReferenceNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"paymentAccountReferenceNumber", "body", o.PaymentAccountReferenceNumber, 32); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformation) validateResponseCategoryCode(formats strfmt.Registry) error {
	if swag.IsZero(o.ResponseCategoryCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"responseCategoryCode", "body", o.ResponseCategoryCode, 36); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformation) validateResponseCode(formats strfmt.Registry) error {
	if swag.IsZero(o.ResponseCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"responseCode", "body", o.ResponseCode, 10); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformation) validateResponseCodeSource(formats strfmt.Registry) error {
	if swag.IsZero(o.ResponseCodeSource) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"responseCodeSource", "body", o.ResponseCodeSource, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformation) validateResponseDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.ResponseDetails) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"responseDetails", "body", o.ResponseDetails, 255); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformation) validateRetrievalReferenceNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.RetrievalReferenceNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"retrievalReferenceNumber", "body", o.RetrievalReferenceNumber, 20); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformation) validateRouting(formats strfmt.Registry) error {
	if swag.IsZero(o.Routing) { // not required
		return nil
	}

	if o.Routing != nil {
		if err := o.Routing.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "processorInformation" + "." + "routing")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "processorInformation" + "." + "routing")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformation) validateSystemTraceAuditNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.SystemTraceAuditNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"systemTraceAuditNumber", "body", o.SystemTraceAuditNumber, 6); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformation) validateTransactionID(formats strfmt.Registry) error {
	if swag.IsZero(o.TransactionID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"transactionId", "body", o.TransactionID, 50); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformation) validateTransactionIntegrityCode(formats strfmt.Registry) error {
	if swag.IsZero(o.TransactionIntegrityCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"transactionIntegrityCode", "body", o.TransactionIntegrityCode, 2); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this create payment created body processor information based on the context it is used
func (o *CreatePaymentCreatedBodyProcessorInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateAchVerification(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateAvs(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateCardVerification(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateConsumerAuthenticationResponse(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateCustomer(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateElectronicVerificationResults(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateMerchantAdvice(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateRouting(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformation) contextValidateAchVerification(ctx context.Context, formats strfmt.Registry) error {

	if o.AchVerification != nil {
		if err := o.AchVerification.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "processorInformation" + "." + "achVerification")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "processorInformation" + "." + "achVerification")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformation) contextValidateAvs(ctx context.Context, formats strfmt.Registry) error {

	if o.Avs != nil {
		if err := o.Avs.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "processorInformation" + "." + "avs")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "processorInformation" + "." + "avs")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformation) contextValidateCardVerification(ctx context.Context, formats strfmt.Registry) error {

	if o.CardVerification != nil {
		if err := o.CardVerification.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "processorInformation" + "." + "cardVerification")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "processorInformation" + "." + "cardVerification")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformation) contextValidateConsumerAuthenticationResponse(ctx context.Context, formats strfmt.Registry) error {

	if o.ConsumerAuthenticationResponse != nil {
		if err := o.ConsumerAuthenticationResponse.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "processorInformation" + "." + "consumerAuthenticationResponse")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "processorInformation" + "." + "consumerAuthenticationResponse")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformation) contextValidateCustomer(ctx context.Context, formats strfmt.Registry) error {

	if o.Customer != nil {
		if err := o.Customer.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "processorInformation" + "." + "customer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "processorInformation" + "." + "customer")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformation) contextValidateElectronicVerificationResults(ctx context.Context, formats strfmt.Registry) error {

	if o.ElectronicVerificationResults != nil {
		if err := o.ElectronicVerificationResults.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "processorInformation" + "." + "electronicVerificationResults")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "processorInformation" + "." + "electronicVerificationResults")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformation) contextValidateMerchantAdvice(ctx context.Context, formats strfmt.Registry) error {

	if o.MerchantAdvice != nil {
		if err := o.MerchantAdvice.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "processorInformation" + "." + "merchantAdvice")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "processorInformation" + "." + "merchantAdvice")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformation) contextValidateRouting(ctx context.Context, formats strfmt.Registry) error {

	if o.Routing != nil {
		if err := o.Routing.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "processorInformation" + "." + "routing")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "processorInformation" + "." + "routing")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyProcessorInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyProcessorInformation) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyProcessorInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyProcessorInformationAchVerification create payment created body processor information ach verification
swagger:model CreatePaymentCreatedBodyProcessorInformationAchVerification
*/
type CreatePaymentCreatedBodyProcessorInformationAchVerification struct {

	// Results from the ACH verification service.
	// For details about this service and the possible values for the results, see "ACH Verification" and "Verification Codes" in the [Electronic Check Services Using the SCMP API](https://apps.cybersource.com/library/documentation/dev_guides/EChecks_SCMP_API/html/).
	//
	// Max Length: 2
	ResultCode string `json:"resultCode,omitempty"`

	// Raw results from the ACH verification service.
	// For details about this service and the possible values for the raw results, see "ACH Verification" and "Verification Codes" in the [Electronic Check Services Using the SCMP API](https://apps.cybersource.com/library/documentation/dev_guides/EChecks_SCMP_API/html/).
	//
	// Max Length: 10
	ResultCodeRaw string `json:"resultCodeRaw,omitempty"`
}

// Validate validates this create payment created body processor information ach verification
func (o *CreatePaymentCreatedBodyProcessorInformationAchVerification) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateResultCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateResultCodeRaw(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformationAchVerification) validateResultCode(formats strfmt.Registry) error {
	if swag.IsZero(o.ResultCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"achVerification"+"."+"resultCode", "body", o.ResultCode, 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformationAchVerification) validateResultCodeRaw(formats strfmt.Registry) error {
	if swag.IsZero(o.ResultCodeRaw) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"achVerification"+"."+"resultCodeRaw", "body", o.ResultCodeRaw, 10); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment created body processor information ach verification based on context it is used
func (o *CreatePaymentCreatedBodyProcessorInformationAchVerification) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyProcessorInformationAchVerification) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyProcessorInformationAchVerification) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyProcessorInformationAchVerification
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyProcessorInformationAvs create payment created body processor information avs
swagger:model CreatePaymentCreatedBodyProcessorInformationAvs
*/
type CreatePaymentCreatedBodyProcessorInformationAvs struct {

	// AVS result code.
	//
	// Returned by authorization service.
	//
	// Max Length: 1
	Code string `json:"code,omitempty"`

	// AVS result code sent directly from the processor. Returned only when the processor returns this value.
	// **Important** Do not use this field to evaluate the result of AVS. Use for debugging purposes only.
	//
	// Returned by authorization service.
	//
	// Max Length: 10
	CodeRaw string `json:"codeRaw,omitempty"`
}

// Validate validates this create payment created body processor information avs
func (o *CreatePaymentCreatedBodyProcessorInformationAvs) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCodeRaw(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformationAvs) validateCode(formats strfmt.Registry) error {
	if swag.IsZero(o.Code) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"avs"+"."+"code", "body", o.Code, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformationAvs) validateCodeRaw(formats strfmt.Registry) error {
	if swag.IsZero(o.CodeRaw) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"avs"+"."+"codeRaw", "body", o.CodeRaw, 10); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment created body processor information avs based on context it is used
func (o *CreatePaymentCreatedBodyProcessorInformationAvs) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyProcessorInformationAvs) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyProcessorInformationAvs) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyProcessorInformationAvs
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyProcessorInformationCardVerification create payment created body processor information card verification
swagger:model CreatePaymentCreatedBodyProcessorInformationCardVerification
*/
type CreatePaymentCreatedBodyProcessorInformationCardVerification struct {

	// CVN result code.
	//
	// For details, see the `auth_cv_result` reply field description in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// Max Length: 1
	ResultCode string `json:"resultCode,omitempty"`

	// CVN result code sent directly from the processor. Returned only when the processor returns this value.
	//
	// **Important** Do not use this field to evaluate the result of card verification. Use for debugging purposes only.
	//
	// Max Length: 10
	ResultCodeRaw string `json:"resultCodeRaw,omitempty"`
}

// Validate validates this create payment created body processor information card verification
func (o *CreatePaymentCreatedBodyProcessorInformationCardVerification) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateResultCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateResultCodeRaw(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformationCardVerification) validateResultCode(formats strfmt.Registry) error {
	if swag.IsZero(o.ResultCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"cardVerification"+"."+"resultCode", "body", o.ResultCode, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformationCardVerification) validateResultCodeRaw(formats strfmt.Registry) error {
	if swag.IsZero(o.ResultCodeRaw) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"cardVerification"+"."+"resultCodeRaw", "body", o.ResultCodeRaw, 10); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment created body processor information card verification based on context it is used
func (o *CreatePaymentCreatedBodyProcessorInformationCardVerification) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyProcessorInformationCardVerification) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyProcessorInformationCardVerification) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyProcessorInformationCardVerification
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyProcessorInformationConsumerAuthenticationResponse create payment created body processor information consumer authentication response
swagger:model CreatePaymentCreatedBodyProcessorInformationConsumerAuthenticationResponse
*/
type CreatePaymentCreatedBodyProcessorInformationConsumerAuthenticationResponse struct {

	// Mapped response code for Visa Secure and American Express SafeKey.
	//
	// Max Length: 3
	Code string `json:"code,omitempty"`

	// Raw response code sent directly from the processor for Visa Secure and American Express SafeKey:
	//
	// Max Length: 3
	CodeRaw string `json:"codeRaw,omitempty"`
}

// Validate validates this create payment created body processor information consumer authentication response
func (o *CreatePaymentCreatedBodyProcessorInformationConsumerAuthenticationResponse) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCodeRaw(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformationConsumerAuthenticationResponse) validateCode(formats strfmt.Registry) error {
	if swag.IsZero(o.Code) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"consumerAuthenticationResponse"+"."+"code", "body", o.Code, 3); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformationConsumerAuthenticationResponse) validateCodeRaw(formats strfmt.Registry) error {
	if swag.IsZero(o.CodeRaw) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"consumerAuthenticationResponse"+"."+"codeRaw", "body", o.CodeRaw, 3); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment created body processor information consumer authentication response based on context it is used
func (o *CreatePaymentCreatedBodyProcessorInformationConsumerAuthenticationResponse) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyProcessorInformationConsumerAuthenticationResponse) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyProcessorInformationConsumerAuthenticationResponse) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyProcessorInformationConsumerAuthenticationResponse
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyProcessorInformationCustomer create payment created body processor information customer
swagger:model CreatePaymentCreatedBodyProcessorInformationCustomer
*/
type CreatePaymentCreatedBodyProcessorInformationCustomer struct {

	// Personal identifier result. This field is supported only for Redecard in Brazil for CyberSource Latin
	// American Processing. If you included `buyerInformation.personalIdentification[].ID` in the request, this
	// value indicates whether or not `buyerInformation.personalIdentification[].ID` matched a value in a record
	// on file. Returned only when the personal ID result is returned by the processor.
	//
	// Possible values:
	//
	//  - `Y`: Match
	//  - `N`: No match
	//  - `K`: Not supported
	//  - `U`: Unknown
	//  - `Z`: No response returned
	// **Note** CyberSource Latin American Processing is the name of a specific processing connection that CyberSource supports. In the CyberSource API documentation, CyberSource Latin American Processing does not refer to the general topic of processing in Latin America.The information in this field description is for the specific processing
	// connection called CyberSource Latin American Processing. It is not for any other Latin American processors that CyberSource supports.
	//
	// Max Length: 1
	PersonalIDResult string `json:"personalIdResult,omitempty"`
}

// Validate validates this create payment created body processor information customer
func (o *CreatePaymentCreatedBodyProcessorInformationCustomer) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validatePersonalIDResult(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformationCustomer) validatePersonalIDResult(formats strfmt.Registry) error {
	if swag.IsZero(o.PersonalIDResult) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"customer"+"."+"personalIdResult", "body", o.PersonalIDResult, 1); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment created body processor information customer based on context it is used
func (o *CreatePaymentCreatedBodyProcessorInformationCustomer) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyProcessorInformationCustomer) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyProcessorInformationCustomer) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyProcessorInformationCustomer
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyProcessorInformationElectronicVerificationResults create payment created body processor information electronic verification results
swagger:model CreatePaymentCreatedBodyProcessorInformationElectronicVerificationResults
*/
type CreatePaymentCreatedBodyProcessorInformationElectronicVerificationResults struct {

	// Mapped Electronic Verification response code for the customers name.
	//
	// For details, see `auth_ev_name` field description in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// Max Length: 1
	Code string `json:"code,omitempty"`

	// Raw Electronic Verification response code from the processor for the customers last name
	// Max Length: 1
	CodeRaw string `json:"codeRaw,omitempty"`

	// Mapped Electronic Verification response code for the customers email address.
	//
	// For details, see `auth_ev_email` field description in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// Max Length: 1
	Email string `json:"email,omitempty"`

	// Raw Electronic Verification response code from the processor for the customers email address.
	// Max Length: 1
	EmailRaw string `json:"emailRaw,omitempty"`

	// Mapped Electronic Verification response code for the customers name.
	//
	// Max Length: 30
	Name string `json:"name,omitempty"`

	// Raw Electronic Verification response code from the processor for the customers name.
	//
	// Max Length: 30
	NameRaw string `json:"nameRaw,omitempty"`

	// Mapped Electronic Verification response code for the customers phone number.
	//
	// For details, see `auth_ev_phone_number` field description in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// Max Length: 1
	PhoneNumber string `json:"phoneNumber,omitempty"`

	// Raw Electronic Verification response code from the processor for the customers phone number.
	// Max Length: 1
	PhoneNumberRaw string `json:"phoneNumberRaw,omitempty"`

	// Mapped Electronic Verification response code for the customers postal code.
	//
	// For details, see `auth_ev_postal_code` field description in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// Max Length: 1
	PostalCode string `json:"postalCode,omitempty"`

	// Raw Electronic Verification response code from the processor for the customers postal code.
	// Max Length: 1
	PostalCodeRaw string `json:"postalCodeRaw,omitempty"`

	// Mapped Electronic Verification response code for the customers street address.
	//
	// For details, see `auth_ev_street` field description in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// Max Length: 1
	Street string `json:"street,omitempty"`

	// Raw Electronic Verification response code from the processor for the customers street address.
	// Max Length: 1
	StreetRaw string `json:"streetRaw,omitempty"`
}

// Validate validates this create payment created body processor information electronic verification results
func (o *CreatePaymentCreatedBodyProcessorInformationElectronicVerificationResults) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCodeRaw(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEmail(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEmailRaw(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNameRaw(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePhoneNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePhoneNumberRaw(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePostalCodeRaw(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateStreet(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateStreetRaw(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformationElectronicVerificationResults) validateCode(formats strfmt.Registry) error {
	if swag.IsZero(o.Code) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"electronicVerificationResults"+"."+"code", "body", o.Code, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformationElectronicVerificationResults) validateCodeRaw(formats strfmt.Registry) error {
	if swag.IsZero(o.CodeRaw) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"electronicVerificationResults"+"."+"codeRaw", "body", o.CodeRaw, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformationElectronicVerificationResults) validateEmail(formats strfmt.Registry) error {
	if swag.IsZero(o.Email) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"electronicVerificationResults"+"."+"email", "body", o.Email, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformationElectronicVerificationResults) validateEmailRaw(formats strfmt.Registry) error {
	if swag.IsZero(o.EmailRaw) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"electronicVerificationResults"+"."+"emailRaw", "body", o.EmailRaw, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformationElectronicVerificationResults) validateName(formats strfmt.Registry) error {
	if swag.IsZero(o.Name) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"electronicVerificationResults"+"."+"name", "body", o.Name, 30); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformationElectronicVerificationResults) validateNameRaw(formats strfmt.Registry) error {
	if swag.IsZero(o.NameRaw) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"electronicVerificationResults"+"."+"nameRaw", "body", o.NameRaw, 30); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformationElectronicVerificationResults) validatePhoneNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.PhoneNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"electronicVerificationResults"+"."+"phoneNumber", "body", o.PhoneNumber, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformationElectronicVerificationResults) validatePhoneNumberRaw(formats strfmt.Registry) error {
	if swag.IsZero(o.PhoneNumberRaw) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"electronicVerificationResults"+"."+"phoneNumberRaw", "body", o.PhoneNumberRaw, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformationElectronicVerificationResults) validatePostalCode(formats strfmt.Registry) error {
	if swag.IsZero(o.PostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"electronicVerificationResults"+"."+"postalCode", "body", o.PostalCode, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformationElectronicVerificationResults) validatePostalCodeRaw(formats strfmt.Registry) error {
	if swag.IsZero(o.PostalCodeRaw) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"electronicVerificationResults"+"."+"postalCodeRaw", "body", o.PostalCodeRaw, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformationElectronicVerificationResults) validateStreet(formats strfmt.Registry) error {
	if swag.IsZero(o.Street) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"electronicVerificationResults"+"."+"street", "body", o.Street, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformationElectronicVerificationResults) validateStreetRaw(formats strfmt.Registry) error {
	if swag.IsZero(o.StreetRaw) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"electronicVerificationResults"+"."+"streetRaw", "body", o.StreetRaw, 1); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment created body processor information electronic verification results based on context it is used
func (o *CreatePaymentCreatedBodyProcessorInformationElectronicVerificationResults) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyProcessorInformationElectronicVerificationResults) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyProcessorInformationElectronicVerificationResults) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyProcessorInformationElectronicVerificationResults
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyProcessorInformationMerchantAdvice create payment created body processor information merchant advice
swagger:model CreatePaymentCreatedBodyProcessorInformationMerchantAdvice
*/
type CreatePaymentCreatedBodyProcessorInformationMerchantAdvice struct {

	// Reason the recurring payment transaction was declined. For some processors, this field is used only for
	// Mastercard. For other processors, this field is used for Visa and Mastercard. And for other processors, this
	// field is not implemented.
	//
	// Possible values:
	//
	//  - `00`: Response not provided.
	//  - `01`: New account information is available. Obtain the new information.
	//  - `02`: Try again later.
	//  - `03`: Do not try again. Obtain another type of payment from the customer.
	//  - `04`: Problem with a token or a partial shipment indicator.
	//  - `21`: Recurring payment cancellation service.
	//  - `99`: An unknown value was returned from the processor.
	//
	// For processor-specific information, see the `auth_merchant_advice_code` field in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 2
	Code string `json:"code,omitempty"`

	// Raw merchant advice code sent directly from the processor. This field is used only for Mastercard.
	//
	// #### CyberSource through VisaNet
	// The value for this field corresponds to the following data in the TC 33 capture file1:
	// - Record: CP01 TCR7
	// - Position: 96-99
	// - Field: Response Data-Merchant Advice Code
	//
	//
	// For processor-specific information, see the `auth_merchant_advice_code_raw` field in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 4
	CodeRaw string `json:"codeRaw,omitempty"`
}

// Validate validates this create payment created body processor information merchant advice
func (o *CreatePaymentCreatedBodyProcessorInformationMerchantAdvice) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCodeRaw(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformationMerchantAdvice) validateCode(formats strfmt.Registry) error {
	if swag.IsZero(o.Code) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"merchantAdvice"+"."+"code", "body", o.Code, 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformationMerchantAdvice) validateCodeRaw(formats strfmt.Registry) error {
	if swag.IsZero(o.CodeRaw) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"merchantAdvice"+"."+"codeRaw", "body", o.CodeRaw, 4); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment created body processor information merchant advice based on context it is used
func (o *CreatePaymentCreatedBodyProcessorInformationMerchantAdvice) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyProcessorInformationMerchantAdvice) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyProcessorInformationMerchantAdvice) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyProcessorInformationMerchantAdvice
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyProcessorInformationRouting create payment created body processor information routing
swagger:model CreatePaymentCreatedBodyProcessorInformationRouting
*/
type CreatePaymentCreatedBodyProcessorInformationRouting struct {

	// Indicates whether you need to obtain the cardholder's signature.
	//
	// Possible values:
	// - `Y`: You need to obtain the cardholder's signature.
	// - `N`: You do not need to obtain the cardholder's signature.
	//
	// Max Length: 1
	CustomerSignatureRequired string `json:"customerSignatureRequired,omitempty"`

	// PIN Debit Services:
	// Contains the ID of the debit network to which the transaction was routed.
	//
	// | Code | Network |
	// | --- | --- |
	// | 0000 | Priority Routing or Generic File Update |
	// | 0002 | Visa programs, Private Label and non-Visa Authorization Gateway Services |
	// | 0003 | Interlink |
	// | 0004 | Plus |
	// | 0008 | Star |
	// | 0009 | Pulse|
	// | 0010 | Star |
	// | 0011 | Star |
	// | 0012 | Star (primary network ID) |
	// | 0013 | AFFN |
	// | 0015 | Star |
	// | 0016 | Maestro |
	// | 0017 | Pulse (primary network ID) |
	// | 0018 | NYCE (primary network ID) |
	// | 0019 | Pulse |
	// | 0020 | Accel |
	// | 0023 | NETS |
	// | 0024 | CU24 |
	// | 0025 | Alaska Option |
	// | 0027 | NYCE |
	// | 0028 | Shazam |
	// | 0029 | EBT POS |
	//
	// FDC Nashville Global authorization service:
	//
	// Indicates whether the transaction was routed to a credit network, a debit network, or the STAR signature debit
	// network.
	// - `C`: Credit network
	// - `D`: Debit network (without signature)
	// - `S`: STAR signature debit network
	//
	// Max Length: 4
	Network string `json:"network,omitempty"`

	// Name of the network to which the transaction was routed.
	//
	// Max Length: 10
	NetworkName string `json:"networkName,omitempty"`
}

// Validate validates this create payment created body processor information routing
func (o *CreatePaymentCreatedBodyProcessorInformationRouting) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCustomerSignatureRequired(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNetwork(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNetworkName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformationRouting) validateCustomerSignatureRequired(formats strfmt.Registry) error {
	if swag.IsZero(o.CustomerSignatureRequired) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"routing"+"."+"customerSignatureRequired", "body", o.CustomerSignatureRequired, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformationRouting) validateNetwork(formats strfmt.Registry) error {
	if swag.IsZero(o.Network) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"routing"+"."+"network", "body", o.Network, 4); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformationRouting) validateNetworkName(formats strfmt.Registry) error {
	if swag.IsZero(o.NetworkName) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"routing"+"."+"networkName", "body", o.NetworkName, 10); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment created body processor information routing based on context it is used
func (o *CreatePaymentCreatedBodyProcessorInformationRouting) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyProcessorInformationRouting) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyProcessorInformationRouting) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyProcessorInformationRouting
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyRiskInformation Contains the result of risk assessment.
swagger:model CreatePaymentCreatedBodyRiskInformation
*/
type CreatePaymentCreatedBodyRiskInformation struct {

	// You receive this field only if you subscribe to the Enhanced Case Management service. The priority level ranges from 1 (highest) to 5 (lowest); the default value is 3. If you do not assign a priority to your rules or to your profiles, the default value is given to the order.
	//
	// For all possible values, see the `decision_case_priority` field description in the _Decision Manager Using the SCMP API Developer Guide_ on the [CyberSource Business Center.](https://ebc2.cybersource.com/ebc2/) Click **Decision Manager** > **Documentation** > **Guides** > _Decision Manager Using the SCMP API Developer Guide_ (PDF link).
	//
	CasePriority string `json:"casePriority,omitempty"`

	// info codes
	InfoCodes *CreatePaymentCreatedBodyRiskInformationInfoCodes `json:"infoCodes,omitempty"`

	// ip address
	IPAddress *CreatePaymentCreatedBodyRiskInformationIPAddress `json:"ipAddress,omitempty"`

	// The customer's local time (`hh:mm:ss`), which is calculated from the transaction request time and the
	// customer's billing address.
	//
	// For details, see the `score_time_local` field description in the _Decision Manager Using the SCMP API Developer Guide_ on the [CyberSource Business Center.](https://ebc2.cybersource.com/ebc2/)
	//
	// Max Length: 255
	LocalTime string `json:"localTime,omitempty"`

	// profile
	Profile *CreatePaymentCreatedBodyRiskInformationProfile `json:"profile,omitempty"`

	// providers
	Providers *CreatePaymentCreatedBodyRiskInformationProviders `json:"providers,omitempty"`

	// rules
	Rules []*CreatePaymentCreatedBodyRiskInformationRulesItems0 `json:"rules"`

	// score
	Score *CreatePaymentCreatedBodyRiskInformationScore `json:"score,omitempty"`

	// travel
	Travel *CreatePaymentCreatedBodyRiskInformationTravel `json:"travel,omitempty"`

	// velocity
	Velocity *CreatePaymentCreatedBodyRiskInformationVelocity `json:"velocity,omitempty"`
}

// Validate validates this create payment created body risk information
func (o *CreatePaymentCreatedBodyRiskInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateInfoCodes(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateIPAddress(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocalTime(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProfile(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProviders(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRules(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateScore(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTravel(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateVelocity(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyRiskInformation) validateInfoCodes(formats strfmt.Registry) error {
	if swag.IsZero(o.InfoCodes) { // not required
		return nil
	}

	if o.InfoCodes != nil {
		if err := o.InfoCodes.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "riskInformation" + "." + "infoCodes")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "riskInformation" + "." + "infoCodes")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyRiskInformation) validateIPAddress(formats strfmt.Registry) error {
	if swag.IsZero(o.IPAddress) { // not required
		return nil
	}

	if o.IPAddress != nil {
		if err := o.IPAddress.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "riskInformation" + "." + "ipAddress")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "riskInformation" + "." + "ipAddress")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyRiskInformation) validateLocalTime(formats strfmt.Registry) error {
	if swag.IsZero(o.LocalTime) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"riskInformation"+"."+"localTime", "body", o.LocalTime, 255); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyRiskInformation) validateProfile(formats strfmt.Registry) error {
	if swag.IsZero(o.Profile) { // not required
		return nil
	}

	if o.Profile != nil {
		if err := o.Profile.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "riskInformation" + "." + "profile")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "riskInformation" + "." + "profile")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyRiskInformation) validateProviders(formats strfmt.Registry) error {
	if swag.IsZero(o.Providers) { // not required
		return nil
	}

	if o.Providers != nil {
		if err := o.Providers.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "riskInformation" + "." + "providers")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "riskInformation" + "." + "providers")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyRiskInformation) validateRules(formats strfmt.Registry) error {
	if swag.IsZero(o.Rules) { // not required
		return nil
	}

	for i := 0; i < len(o.Rules); i++ {
		if swag.IsZero(o.Rules[i]) { // not required
			continue
		}

		if o.Rules[i] != nil {
			if err := o.Rules[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("createPaymentCreated" + "." + "riskInformation" + "." + "rules" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("createPaymentCreated" + "." + "riskInformation" + "." + "rules" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CreatePaymentCreatedBodyRiskInformation) validateScore(formats strfmt.Registry) error {
	if swag.IsZero(o.Score) { // not required
		return nil
	}

	if o.Score != nil {
		if err := o.Score.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "riskInformation" + "." + "score")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "riskInformation" + "." + "score")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyRiskInformation) validateTravel(formats strfmt.Registry) error {
	if swag.IsZero(o.Travel) { // not required
		return nil
	}

	if o.Travel != nil {
		if err := o.Travel.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "riskInformation" + "." + "travel")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "riskInformation" + "." + "travel")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyRiskInformation) validateVelocity(formats strfmt.Registry) error {
	if swag.IsZero(o.Velocity) { // not required
		return nil
	}

	if o.Velocity != nil {
		if err := o.Velocity.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "riskInformation" + "." + "velocity")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "riskInformation" + "." + "velocity")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this create payment created body risk information based on the context it is used
func (o *CreatePaymentCreatedBodyRiskInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateInfoCodes(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateIPAddress(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateProfile(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateProviders(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateRules(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateScore(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateTravel(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateVelocity(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyRiskInformation) contextValidateInfoCodes(ctx context.Context, formats strfmt.Registry) error {

	if o.InfoCodes != nil {
		if err := o.InfoCodes.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "riskInformation" + "." + "infoCodes")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "riskInformation" + "." + "infoCodes")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyRiskInformation) contextValidateIPAddress(ctx context.Context, formats strfmt.Registry) error {

	if o.IPAddress != nil {
		if err := o.IPAddress.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "riskInformation" + "." + "ipAddress")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "riskInformation" + "." + "ipAddress")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyRiskInformation) contextValidateProfile(ctx context.Context, formats strfmt.Registry) error {

	if o.Profile != nil {
		if err := o.Profile.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "riskInformation" + "." + "profile")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "riskInformation" + "." + "profile")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyRiskInformation) contextValidateProviders(ctx context.Context, formats strfmt.Registry) error {

	if o.Providers != nil {
		if err := o.Providers.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "riskInformation" + "." + "providers")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "riskInformation" + "." + "providers")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyRiskInformation) contextValidateRules(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.Rules); i++ {

		if o.Rules[i] != nil {
			if err := o.Rules[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("createPaymentCreated" + "." + "riskInformation" + "." + "rules" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("createPaymentCreated" + "." + "riskInformation" + "." + "rules" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CreatePaymentCreatedBodyRiskInformation) contextValidateScore(ctx context.Context, formats strfmt.Registry) error {

	if o.Score != nil {
		if err := o.Score.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "riskInformation" + "." + "score")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "riskInformation" + "." + "score")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyRiskInformation) contextValidateTravel(ctx context.Context, formats strfmt.Registry) error {

	if o.Travel != nil {
		if err := o.Travel.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "riskInformation" + "." + "travel")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "riskInformation" + "." + "travel")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyRiskInformation) contextValidateVelocity(ctx context.Context, formats strfmt.Registry) error {

	if o.Velocity != nil {
		if err := o.Velocity.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "riskInformation" + "." + "velocity")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "riskInformation" + "." + "velocity")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyRiskInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyRiskInformation) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyRiskInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyRiskInformationIPAddress Contains detailed response information about the customer's IP address.
swagger:model CreatePaymentCreatedBodyRiskInformationIPAddress
*/
type CreatePaymentCreatedBodyRiskInformationIPAddress struct {

	// Name of the state decoded from the IP address used directly or indirectly by the customer to send the order.
	//
	// For all possible values, see the `score_ip_state` field description in the _Decision Manager Using the SCMP API Developer Guide_ on the [CyberSource Business Center.](https://ebc2.cybersource.com/ebc2/) Click **Decision Manager** > **Documentation** > **Guides** > _Decision Manager Using the SCMP API Developer Guide_ (PDF link).
	//
	// Max Length: 255
	AdministrativeArea string `json:"administrativeArea,omitempty"`

	// Indicates whether the transaction IP address is associated with a known anonymous proxy.
	//
	// For all possible values, see the `score_ip_anonymizer_status` field description in the _Decision Manager Using the SCMP API Developer Guide_ on the [CyberSource Business Center.](https://ebc2.cybersource.com/ebc2/) Click **Decision Manager** > **Documentation** > **Guides** > _Decision Manager Using the SCMP API Developer Guide_ (PDF link).
	//
	// Max Length: 255
	AnonymizerStatus string `json:"anonymizerStatus,omitempty"`

	// Provides the name of the organization that owns the ASN. The carrier is responsible for the traffic carried on the network or set of networks designated as an Autonomous System (AS) and identified by the ASN.
	// While there are more than 27,000 active ASNs, there are fewer carriers, because a single carrier often manages several ASNs.
	//
	// Max Length: 255
	Carrier string `json:"carrier,omitempty"`

	// Name of the country decoded from the IP address used directly or indirectly by the customer to send the order.
	//
	// For all possible values, see the `score_ip_country` field description in the _Decision Manager Using the SCMP API Developer Guide_ on the [CyberSource Business Center.](https://ebc2.cybersource.com/ebc2/) Click **Decision Manager** > **Documentation** > **Guides** > _Decision Manager Using the SCMP API Developer Guide_ (PDF link).
	//
	// Max Length: 255
	Country string `json:"country,omitempty"`

	// Name of the city decoded from the IP address used directly or indirectly by the customer to send the order.
	//
	// For all possible values, see the `score_ip_city` field description in the _Decision Manager Using the SCMP API Developer Guide_ on the [CyberSource Business Center.](https://ebc2.cybersource.com/ebc2/) Click **Decision Manager** > **Documentation** > **Guides** > _Decision Manager Using the SCMP API Developer Guide_ (PDF link).
	//
	// Max Length: 255
	Locality string `json:"locality,omitempty"`

	// The Registering Organization is the entity responsible for the actions and content associated with a given block of IP addresses. This is in contrast to the carrier, which is responsible for the routing of traffic for network blocks. Registering Organizations include many types of entities, including corporate, government, or educational entities, and ISPs managing the allocation and use of network blocks.
	//
	// Max Length: 255
	Organization string `json:"organization,omitempty"`

	// Routing method decoded from the IP address used directly or indirectly by the customer to send the order.
	//
	// For all possible values, see the `score_ip_routing_method` field description in the _Decision Manager Using the SCMP API Developer Guide_ on the [CyberSource Business Center.](https://ebc2.cybersource.com/ebc2/) Click **Decision Manager** > **Documentation** > **Guides** > _Decision Manager Using the SCMP API Developer Guide_ (PDF link).
	//
	// Max Length: 255
	RoutingMethod string `json:"routingMethod,omitempty"`
}

// Validate validates this create payment created body risk information IP address
func (o *CreatePaymentCreatedBodyRiskInformationIPAddress) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAdministrativeArea(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAnonymizerStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCarrier(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocality(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOrganization(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRoutingMethod(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyRiskInformationIPAddress) validateAdministrativeArea(formats strfmt.Registry) error {
	if swag.IsZero(o.AdministrativeArea) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"riskInformation"+"."+"ipAddress"+"."+"administrativeArea", "body", o.AdministrativeArea, 255); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyRiskInformationIPAddress) validateAnonymizerStatus(formats strfmt.Registry) error {
	if swag.IsZero(o.AnonymizerStatus) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"riskInformation"+"."+"ipAddress"+"."+"anonymizerStatus", "body", o.AnonymizerStatus, 255); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyRiskInformationIPAddress) validateCarrier(formats strfmt.Registry) error {
	if swag.IsZero(o.Carrier) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"riskInformation"+"."+"ipAddress"+"."+"carrier", "body", o.Carrier, 255); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyRiskInformationIPAddress) validateCountry(formats strfmt.Registry) error {
	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"riskInformation"+"."+"ipAddress"+"."+"country", "body", o.Country, 255); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyRiskInformationIPAddress) validateLocality(formats strfmt.Registry) error {
	if swag.IsZero(o.Locality) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"riskInformation"+"."+"ipAddress"+"."+"locality", "body", o.Locality, 255); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyRiskInformationIPAddress) validateOrganization(formats strfmt.Registry) error {
	if swag.IsZero(o.Organization) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"riskInformation"+"."+"ipAddress"+"."+"organization", "body", o.Organization, 255); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyRiskInformationIPAddress) validateRoutingMethod(formats strfmt.Registry) error {
	if swag.IsZero(o.RoutingMethod) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"riskInformation"+"."+"ipAddress"+"."+"routingMethod", "body", o.RoutingMethod, 255); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment created body risk information IP address based on context it is used
func (o *CreatePaymentCreatedBodyRiskInformationIPAddress) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyRiskInformationIPAddress) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyRiskInformationIPAddress) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyRiskInformationIPAddress
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyRiskInformationInfoCodes create payment created body risk information info codes
swagger:model CreatePaymentCreatedBodyRiskInformationInfoCodes
*/
type CreatePaymentCreatedBodyRiskInformationInfoCodes struct {

	// Indicates a mismatch between the customers billing and shipping addresses.
	//
	Address []string `json:"address"`

	// Indicates that customer information is associated with transactions that are either on the negative or
	// the positive list.
	//
	CustomerList []string `json:"customerList"`

	// Indicates the device behavior information code(s) returned from device fingerprinting.
	//
	DeviceBehavior []string `json:"deviceBehavior"`

	// Indicates that the customer has a high purchase frequency.
	//
	GlobalVelocity []string `json:"globalVelocity"`

	// Indicates excessive identity changes. The threshold is variable depending on the identity elements being
	// compared.
	//
	IdentityChange []string `json:"identityChange"`

	// Indicates a problem with the customers email address, IP address, or billing address.
	//
	Internet []string `json:"internet"`

	// Indicates a problem with the customers phone number.
	//
	Phone []string `json:"phone"`

	// Indicates that the customer provided potentially suspicious information.
	//
	Suspicious []string `json:"suspicious"`

	// List of information codes triggered by the order. These information codes were generated when you created
	// the order and product velocity rules and are returned so that you can associate them with the rules.
	//
	Velocity []string `json:"velocity"`
}

// Validate validates this create payment created body risk information info codes
func (o *CreatePaymentCreatedBodyRiskInformationInfoCodes) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this create payment created body risk information info codes based on context it is used
func (o *CreatePaymentCreatedBodyRiskInformationInfoCodes) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyRiskInformationInfoCodes) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyRiskInformationInfoCodes) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyRiskInformationInfoCodes
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyRiskInformationProfile create payment created body risk information profile
swagger:model CreatePaymentCreatedBodyRiskInformationProfile
*/
type CreatePaymentCreatedBodyRiskInformationProfile struct {

	// Name of the queue where orders that are not automatically accepted are sent.
	//
	// Max Length: 255
	DesinationQueue string `json:"desinationQueue,omitempty"`

	// Name of the active profile chosen by the profile selector. If no profile selector exists,
	// the default active profile is chosen.
	//
	// **Note** By default, your default profile is the active profile, or the Profile Selector chooses the active profile. Use this field
	// only if you want to specify the name of a different profile. The passed-in profile will then become the active profile.
	//
	// Max Length: 30
	Name string `json:"name,omitempty"`

	// Name of the profile selector rule that chooses the profile to use for the
	// transaction. If no profile selector exists, the value is Default Active Profile.
	//
	// Max Length: 255
	SelectorRule string `json:"selectorRule,omitempty"`
}

// Validate validates this create payment created body risk information profile
func (o *CreatePaymentCreatedBodyRiskInformationProfile) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDesinationQueue(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSelectorRule(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyRiskInformationProfile) validateDesinationQueue(formats strfmt.Registry) error {
	if swag.IsZero(o.DesinationQueue) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"riskInformation"+"."+"profile"+"."+"desinationQueue", "body", o.DesinationQueue, 255); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyRiskInformationProfile) validateName(formats strfmt.Registry) error {
	if swag.IsZero(o.Name) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"riskInformation"+"."+"profile"+"."+"name", "body", o.Name, 30); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyRiskInformationProfile) validateSelectorRule(formats strfmt.Registry) error {
	if swag.IsZero(o.SelectorRule) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"riskInformation"+"."+"profile"+"."+"selectorRule", "body", o.SelectorRule, 255); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment created body risk information profile based on context it is used
func (o *CreatePaymentCreatedBodyRiskInformationProfile) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyRiskInformationProfile) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyRiskInformationProfile) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyRiskInformationProfile
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyRiskInformationProviders create payment created body risk information providers
swagger:model CreatePaymentCreatedBodyRiskInformationProviders
*/
type CreatePaymentCreatedBodyRiskInformationProviders struct {

	// provider name
	ProviderName []*CreatePaymentCreatedBodyRiskInformationProvidersProviderNameItems0 `json:"providerName"`
}

// Validate validates this create payment created body risk information providers
func (o *CreatePaymentCreatedBodyRiskInformationProviders) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateProviderName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyRiskInformationProviders) validateProviderName(formats strfmt.Registry) error {
	if swag.IsZero(o.ProviderName) { // not required
		return nil
	}

	for i := 0; i < len(o.ProviderName); i++ {
		if swag.IsZero(o.ProviderName[i]) { // not required
			continue
		}

		if o.ProviderName[i] != nil {
			if err := o.ProviderName[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("createPaymentCreated" + "." + "riskInformation" + "." + "providers" + "." + "providerName" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("createPaymentCreated" + "." + "riskInformation" + "." + "providers" + "." + "providerName" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this create payment created body risk information providers based on the context it is used
func (o *CreatePaymentCreatedBodyRiskInformationProviders) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateProviderName(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyRiskInformationProviders) contextValidateProviderName(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.ProviderName); i++ {

		if o.ProviderName[i] != nil {
			if err := o.ProviderName[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("createPaymentCreated" + "." + "riskInformation" + "." + "providers" + "." + "providerName" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("createPaymentCreated" + "." + "riskInformation" + "." + "providers" + "." + "providerName" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyRiskInformationProviders) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyRiskInformationProviders) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyRiskInformationProviders
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyRiskInformationProvidersProviderNameItems0 Name of the 3rd party provider, for example, Emailage.
//
// For all possible values, see the `decision_provider_#_name` field description in the _Decision Manager Using the SCMP API Developer Guide_ on the [CyberSource Business Center.](https://ebc2.cybersource.com/ebc2/) Click **Decision Manager** > **Documentation** > **Guides** > _Decision Manager Using the SCMP API Developer Guide_ (PDF link).
//
swagger:model CreatePaymentCreatedBodyRiskInformationProvidersProviderNameItems0
*/
type CreatePaymentCreatedBodyRiskInformationProvidersProviderNameItems0 struct {

	// field name
	FieldName []string `json:"fieldName"`

	// field value
	FieldValue []string `json:"fieldValue"`
}

// Validate validates this create payment created body risk information providers provider name items0
func (o *CreatePaymentCreatedBodyRiskInformationProvidersProviderNameItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this create payment created body risk information providers provider name items0 based on context it is used
func (o *CreatePaymentCreatedBodyRiskInformationProvidersProviderNameItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyRiskInformationProvidersProviderNameItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyRiskInformationProvidersProviderNameItems0) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyRiskInformationProvidersProviderNameItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyRiskInformationRulesItems0 create payment created body risk information rules items0
swagger:model CreatePaymentCreatedBodyRiskInformationRulesItems0
*/
type CreatePaymentCreatedBodyRiskInformationRulesItems0 struct {

	// Summarizes the result for the rule according to the setting that you chose in the Profile Editor.
	// This field can contain one of the following values:
	// - `IGNORE`
	// - `REVIEW`
	// - `REJECT`
	// - `ACCEPT`
	//
	// Max Length: 255
	Decision string `json:"decision,omitempty"`

	// Description of the rule as it appears in the Profile Editor.
	// Max Length: 255
	Name string `json:"name,omitempty"`
}

// Validate validates this create payment created body risk information rules items0
func (o *CreatePaymentCreatedBodyRiskInformationRulesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDecision(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyRiskInformationRulesItems0) validateDecision(formats strfmt.Registry) error {
	if swag.IsZero(o.Decision) { // not required
		return nil
	}

	if err := validate.MaxLength("decision", "body", o.Decision, 255); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyRiskInformationRulesItems0) validateName(formats strfmt.Registry) error {
	if swag.IsZero(o.Name) { // not required
		return nil
	}

	if err := validate.MaxLength("name", "body", o.Name, 255); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment created body risk information rules items0 based on context it is used
func (o *CreatePaymentCreatedBodyRiskInformationRulesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyRiskInformationRulesItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyRiskInformationRulesItems0) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyRiskInformationRulesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyRiskInformationScore create payment created body risk information score
swagger:model CreatePaymentCreatedBodyRiskInformationScore
*/
type CreatePaymentCreatedBodyRiskInformationScore struct {

	// factor codes
	FactorCodes []string `json:"factorCodes"`

	// Name of the score model used for the transaction. If you did not include a custom model in your request,
	// this field contains the name of CyberSources default model.
	//
	// For all possible values, see the `score_model_used` field description in the _Decision Manager Using the SCMP API Developer Guide_ on the [CyberSource Business Center.](https://ebc2.cybersource.com/ebc2/) Click **Decision Manager** > **Documentation** > **Guides** > _Decision Manager Using the SCMP API Developer Guide_ (PDF link).
	//
	// Max Length: 255
	ModelUsed string `json:"modelUsed,omitempty"`

	// Total score calculated for this order. The value cannot be negative.
	//
	// For all possible values, see the `score_score_result` field description in the _Decision Manager Using the SCMP API Developer Guide_ on the [CyberSource Business Center.](https://ebc2.cybersource.com/ebc2/) Click **Decision Manager** > **Documentation** > **Guides** > _Decision Manager Using the SCMP API Developer Guide_ (PDF link).
	//
	// Max Length: 255
	Result string `json:"result,omitempty"`
}

// Validate validates this create payment created body risk information score
func (o *CreatePaymentCreatedBodyRiskInformationScore) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateModelUsed(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateResult(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyRiskInformationScore) validateModelUsed(formats strfmt.Registry) error {
	if swag.IsZero(o.ModelUsed) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"riskInformation"+"."+"score"+"."+"modelUsed", "body", o.ModelUsed, 255); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyRiskInformationScore) validateResult(formats strfmt.Registry) error {
	if swag.IsZero(o.Result) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"riskInformation"+"."+"score"+"."+"result", "body", o.Result, 255); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment created body risk information score based on context it is used
func (o *CreatePaymentCreatedBodyRiskInformationScore) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyRiskInformationScore) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyRiskInformationScore) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyRiskInformationScore
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyRiskInformationTravel create payment created body risk information travel
swagger:model CreatePaymentCreatedBodyRiskInformationTravel
*/
type CreatePaymentCreatedBodyRiskInformationTravel struct {

	// actual final destination
	ActualFinalDestination *CreatePaymentCreatedBodyRiskInformationTravelActualFinalDestination `json:"actualFinalDestination,omitempty"`

	// first departure
	FirstDeparture *CreatePaymentCreatedBodyRiskInformationTravelFirstDeparture `json:"firstDeparture,omitempty"`

	// first destination
	FirstDestination *CreatePaymentCreatedBodyRiskInformationTravelFirstDestination `json:"firstDestination,omitempty"`

	// last destination
	LastDestination *CreatePaymentCreatedBodyRiskInformationTravelLastDestination `json:"lastDestination,omitempty"`
}

// Validate validates this create payment created body risk information travel
func (o *CreatePaymentCreatedBodyRiskInformationTravel) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateActualFinalDestination(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFirstDeparture(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFirstDestination(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLastDestination(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyRiskInformationTravel) validateActualFinalDestination(formats strfmt.Registry) error {
	if swag.IsZero(o.ActualFinalDestination) { // not required
		return nil
	}

	if o.ActualFinalDestination != nil {
		if err := o.ActualFinalDestination.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "riskInformation" + "." + "travel" + "." + "actualFinalDestination")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "riskInformation" + "." + "travel" + "." + "actualFinalDestination")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyRiskInformationTravel) validateFirstDeparture(formats strfmt.Registry) error {
	if swag.IsZero(o.FirstDeparture) { // not required
		return nil
	}

	if o.FirstDeparture != nil {
		if err := o.FirstDeparture.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "riskInformation" + "." + "travel" + "." + "firstDeparture")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "riskInformation" + "." + "travel" + "." + "firstDeparture")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyRiskInformationTravel) validateFirstDestination(formats strfmt.Registry) error {
	if swag.IsZero(o.FirstDestination) { // not required
		return nil
	}

	if o.FirstDestination != nil {
		if err := o.FirstDestination.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "riskInformation" + "." + "travel" + "." + "firstDestination")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "riskInformation" + "." + "travel" + "." + "firstDestination")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyRiskInformationTravel) validateLastDestination(formats strfmt.Registry) error {
	if swag.IsZero(o.LastDestination) { // not required
		return nil
	}

	if o.LastDestination != nil {
		if err := o.LastDestination.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "riskInformation" + "." + "travel" + "." + "lastDestination")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "riskInformation" + "." + "travel" + "." + "lastDestination")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this create payment created body risk information travel based on the context it is used
func (o *CreatePaymentCreatedBodyRiskInformationTravel) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateActualFinalDestination(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateFirstDeparture(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateFirstDestination(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateLastDestination(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyRiskInformationTravel) contextValidateActualFinalDestination(ctx context.Context, formats strfmt.Registry) error {

	if o.ActualFinalDestination != nil {
		if err := o.ActualFinalDestination.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "riskInformation" + "." + "travel" + "." + "actualFinalDestination")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "riskInformation" + "." + "travel" + "." + "actualFinalDestination")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyRiskInformationTravel) contextValidateFirstDeparture(ctx context.Context, formats strfmt.Registry) error {

	if o.FirstDeparture != nil {
		if err := o.FirstDeparture.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "riskInformation" + "." + "travel" + "." + "firstDeparture")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "riskInformation" + "." + "travel" + "." + "firstDeparture")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyRiskInformationTravel) contextValidateFirstDestination(ctx context.Context, formats strfmt.Registry) error {

	if o.FirstDestination != nil {
		if err := o.FirstDestination.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "riskInformation" + "." + "travel" + "." + "firstDestination")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "riskInformation" + "." + "travel" + "." + "firstDestination")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyRiskInformationTravel) contextValidateLastDestination(ctx context.Context, formats strfmt.Registry) error {

	if o.LastDestination != nil {
		if err := o.LastDestination.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "riskInformation" + "." + "travel" + "." + "lastDestination")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "riskInformation" + "." + "travel" + "." + "lastDestination")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyRiskInformationTravel) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyRiskInformationTravel) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyRiskInformationTravel
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyRiskInformationTravelActualFinalDestination create payment created body risk information travel actual final destination
swagger:model CreatePaymentCreatedBodyRiskInformationTravelActualFinalDestination
*/
type CreatePaymentCreatedBodyRiskInformationTravelActualFinalDestination struct {

	// Country of actual final destination on the route.
	// Max Length: 90
	Country string `json:"country,omitempty"`

	// Latitude of actual final destination on the route.
	// Max Length: 10
	Latitude string `json:"latitude,omitempty"`

	// City of actual final destination on the route.
	// Max Length: 90
	Locality string `json:"locality,omitempty"`

	// Longitude of actual final destination on the route.
	// Max Length: 10
	Longitude string `json:"longitude,omitempty"`
}

// Validate validates this create payment created body risk information travel actual final destination
func (o *CreatePaymentCreatedBodyRiskInformationTravelActualFinalDestination) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLatitude(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocality(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLongitude(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyRiskInformationTravelActualFinalDestination) validateCountry(formats strfmt.Registry) error {
	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"riskInformation"+"."+"travel"+"."+"actualFinalDestination"+"."+"country", "body", o.Country, 90); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyRiskInformationTravelActualFinalDestination) validateLatitude(formats strfmt.Registry) error {
	if swag.IsZero(o.Latitude) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"riskInformation"+"."+"travel"+"."+"actualFinalDestination"+"."+"latitude", "body", o.Latitude, 10); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyRiskInformationTravelActualFinalDestination) validateLocality(formats strfmt.Registry) error {
	if swag.IsZero(o.Locality) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"riskInformation"+"."+"travel"+"."+"actualFinalDestination"+"."+"locality", "body", o.Locality, 90); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyRiskInformationTravelActualFinalDestination) validateLongitude(formats strfmt.Registry) error {
	if swag.IsZero(o.Longitude) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"riskInformation"+"."+"travel"+"."+"actualFinalDestination"+"."+"longitude", "body", o.Longitude, 10); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment created body risk information travel actual final destination based on context it is used
func (o *CreatePaymentCreatedBodyRiskInformationTravelActualFinalDestination) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyRiskInformationTravelActualFinalDestination) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyRiskInformationTravelActualFinalDestination) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyRiskInformationTravelActualFinalDestination
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyRiskInformationTravelFirstDeparture create payment created body risk information travel first departure
swagger:model CreatePaymentCreatedBodyRiskInformationTravelFirstDeparture
*/
type CreatePaymentCreatedBodyRiskInformationTravelFirstDeparture struct {

	// Country of first departure on the route.
	// Max Length: 90
	Country string `json:"country,omitempty"`

	// Latitude of first departure on the route.
	// Max Length: 10
	Latitude string `json:"latitude,omitempty"`

	// City of first departure on the route.
	// Max Length: 90
	Locality string `json:"locality,omitempty"`

	// Longitude of first departure on the route.
	// Max Length: 10
	Longitude string `json:"longitude,omitempty"`
}

// Validate validates this create payment created body risk information travel first departure
func (o *CreatePaymentCreatedBodyRiskInformationTravelFirstDeparture) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLatitude(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocality(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLongitude(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyRiskInformationTravelFirstDeparture) validateCountry(formats strfmt.Registry) error {
	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"riskInformation"+"."+"travel"+"."+"firstDeparture"+"."+"country", "body", o.Country, 90); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyRiskInformationTravelFirstDeparture) validateLatitude(formats strfmt.Registry) error {
	if swag.IsZero(o.Latitude) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"riskInformation"+"."+"travel"+"."+"firstDeparture"+"."+"latitude", "body", o.Latitude, 10); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyRiskInformationTravelFirstDeparture) validateLocality(formats strfmt.Registry) error {
	if swag.IsZero(o.Locality) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"riskInformation"+"."+"travel"+"."+"firstDeparture"+"."+"locality", "body", o.Locality, 90); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyRiskInformationTravelFirstDeparture) validateLongitude(formats strfmt.Registry) error {
	if swag.IsZero(o.Longitude) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"riskInformation"+"."+"travel"+"."+"firstDeparture"+"."+"longitude", "body", o.Longitude, 10); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment created body risk information travel first departure based on context it is used
func (o *CreatePaymentCreatedBodyRiskInformationTravelFirstDeparture) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyRiskInformationTravelFirstDeparture) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyRiskInformationTravelFirstDeparture) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyRiskInformationTravelFirstDeparture
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyRiskInformationTravelFirstDestination create payment created body risk information travel first destination
swagger:model CreatePaymentCreatedBodyRiskInformationTravelFirstDestination
*/
type CreatePaymentCreatedBodyRiskInformationTravelFirstDestination struct {

	// Country of first destination on the route.
	// Max Length: 90
	Country string `json:"country,omitempty"`

	// Latitude of first destination on the route.
	// Max Length: 10
	Latitude string `json:"latitude,omitempty"`

	// City of first destination on the route.
	// Max Length: 90
	Locality string `json:"locality,omitempty"`

	// Longitude of first destination on the route.
	// Max Length: 10
	Longitude string `json:"longitude,omitempty"`
}

// Validate validates this create payment created body risk information travel first destination
func (o *CreatePaymentCreatedBodyRiskInformationTravelFirstDestination) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLatitude(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocality(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLongitude(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyRiskInformationTravelFirstDestination) validateCountry(formats strfmt.Registry) error {
	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"riskInformation"+"."+"travel"+"."+"firstDestination"+"."+"country", "body", o.Country, 90); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyRiskInformationTravelFirstDestination) validateLatitude(formats strfmt.Registry) error {
	if swag.IsZero(o.Latitude) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"riskInformation"+"."+"travel"+"."+"firstDestination"+"."+"latitude", "body", o.Latitude, 10); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyRiskInformationTravelFirstDestination) validateLocality(formats strfmt.Registry) error {
	if swag.IsZero(o.Locality) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"riskInformation"+"."+"travel"+"."+"firstDestination"+"."+"locality", "body", o.Locality, 90); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyRiskInformationTravelFirstDestination) validateLongitude(formats strfmt.Registry) error {
	if swag.IsZero(o.Longitude) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"riskInformation"+"."+"travel"+"."+"firstDestination"+"."+"longitude", "body", o.Longitude, 10); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment created body risk information travel first destination based on context it is used
func (o *CreatePaymentCreatedBodyRiskInformationTravelFirstDestination) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyRiskInformationTravelFirstDestination) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyRiskInformationTravelFirstDestination) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyRiskInformationTravelFirstDestination
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyRiskInformationTravelLastDestination create payment created body risk information travel last destination
swagger:model CreatePaymentCreatedBodyRiskInformationTravelLastDestination
*/
type CreatePaymentCreatedBodyRiskInformationTravelLastDestination struct {

	// Country of last destination on the route.
	// Max Length: 90
	Country string `json:"country,omitempty"`

	// Latitude of last destination on the route.
	// Max Length: 10
	Latitude string `json:"latitude,omitempty"`

	// City of last destination on the route.
	// Max Length: 90
	Locality string `json:"locality,omitempty"`

	// Longitude of last destination on the route.
	// Max Length: 10
	Longitude string `json:"longitude,omitempty"`
}

// Validate validates this create payment created body risk information travel last destination
func (o *CreatePaymentCreatedBodyRiskInformationTravelLastDestination) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLatitude(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocality(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLongitude(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyRiskInformationTravelLastDestination) validateCountry(formats strfmt.Registry) error {
	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"riskInformation"+"."+"travel"+"."+"lastDestination"+"."+"country", "body", o.Country, 90); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyRiskInformationTravelLastDestination) validateLatitude(formats strfmt.Registry) error {
	if swag.IsZero(o.Latitude) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"riskInformation"+"."+"travel"+"."+"lastDestination"+"."+"latitude", "body", o.Latitude, 10); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyRiskInformationTravelLastDestination) validateLocality(formats strfmt.Registry) error {
	if swag.IsZero(o.Locality) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"riskInformation"+"."+"travel"+"."+"lastDestination"+"."+"locality", "body", o.Locality, 90); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyRiskInformationTravelLastDestination) validateLongitude(formats strfmt.Registry) error {
	if swag.IsZero(o.Longitude) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"riskInformation"+"."+"travel"+"."+"lastDestination"+"."+"longitude", "body", o.Longitude, 10); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment created body risk information travel last destination based on context it is used
func (o *CreatePaymentCreatedBodyRiskInformationTravelLastDestination) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyRiskInformationTravelLastDestination) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyRiskInformationTravelLastDestination) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyRiskInformationTravelLastDestination
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyRiskInformationVelocity create payment created body risk information velocity
swagger:model CreatePaymentCreatedBodyRiskInformationVelocity
*/
type CreatePaymentCreatedBodyRiskInformationVelocity struct {

	// address
	Address []string `json:"address"`

	// List of information codes triggered by the order. These information codes were generated when you created the order and product velocity rules and are returned so that you can associate them with the rules.
	//
	// Returned by scoring service.
	//
	Morphing []*CreatePaymentCreatedBodyRiskInformationVelocityMorphingItems0 `json:"morphing"`
}

// Validate validates this create payment created body risk information velocity
func (o *CreatePaymentCreatedBodyRiskInformationVelocity) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAddress(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMorphing(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyRiskInformationVelocity) validateAddress(formats strfmt.Registry) error {
	if swag.IsZero(o.Address) { // not required
		return nil
	}

	for i := 0; i < len(o.Address); i++ {

		if err := validate.MaxLength("createPaymentCreated"+"."+"riskInformation"+"."+"velocity"+"."+"address"+"."+strconv.Itoa(i), "body", o.Address[i], 255); err != nil {
			return err
		}

	}

	return nil
}

func (o *CreatePaymentCreatedBodyRiskInformationVelocity) validateMorphing(formats strfmt.Registry) error {
	if swag.IsZero(o.Morphing) { // not required
		return nil
	}

	for i := 0; i < len(o.Morphing); i++ {
		if swag.IsZero(o.Morphing[i]) { // not required
			continue
		}

		if o.Morphing[i] != nil {
			if err := o.Morphing[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("createPaymentCreated" + "." + "riskInformation" + "." + "velocity" + "." + "morphing" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("createPaymentCreated" + "." + "riskInformation" + "." + "velocity" + "." + "morphing" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this create payment created body risk information velocity based on the context it is used
func (o *CreatePaymentCreatedBodyRiskInformationVelocity) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateMorphing(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyRiskInformationVelocity) contextValidateMorphing(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.Morphing); i++ {

		if o.Morphing[i] != nil {
			if err := o.Morphing[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("createPaymentCreated" + "." + "riskInformation" + "." + "velocity" + "." + "morphing" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("createPaymentCreated" + "." + "riskInformation" + "." + "velocity" + "." + "morphing" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyRiskInformationVelocity) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyRiskInformationVelocity) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyRiskInformationVelocity
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyRiskInformationVelocityMorphingItems0 create payment created body risk information velocity morphing items0
swagger:model CreatePaymentCreatedBodyRiskInformationVelocityMorphingItems0
*/
type CreatePaymentCreatedBodyRiskInformationVelocityMorphingItems0 struct {

	// Morphing count specified by the number #.
	//
	// **Note** The count is not returned for the initial transaction.
	//
	Count int64 `json:"count,omitempty"`

	// Field name of the morphing element. specified by the setting that you chose in the
	// Velocity Editor.
	//
	// For all possible values, see the `decisionReply_morphingElement_#_fieldName` field description in the _Decision Manager Using the SCMP API Developer Guide_ on the [CyberSource Business Center.](https://ebc2.cybersource.com/ebc2/) Click **Decision Manager** > **Documentation** > **Guides** > _Decision Manager Using the SCMP API Developer Guide_ (PDF link).
	//
	// Max Length: 255
	FieldName string `json:"fieldName,omitempty"`

	// Identifier that CyberSource assigned to the velocity rule specified by the number #.
	//
	// For all possible values, see the `decision_velocity_morphing_#_info_code` field description in the _Decision Manager Using the SCMP API Developer Guide_ on the [CyberSource Business Center.](https://ebc2.cybersource.com/ebc2/) Click **Decision Manager** >
	//
	// Max Length: 255
	InformationCode string `json:"informationCode,omitempty"`
}

// Validate validates this create payment created body risk information velocity morphing items0
func (o *CreatePaymentCreatedBodyRiskInformationVelocityMorphingItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateFieldName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateInformationCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyRiskInformationVelocityMorphingItems0) validateFieldName(formats strfmt.Registry) error {
	if swag.IsZero(o.FieldName) { // not required
		return nil
	}

	if err := validate.MaxLength("fieldName", "body", o.FieldName, 255); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyRiskInformationVelocityMorphingItems0) validateInformationCode(formats strfmt.Registry) error {
	if swag.IsZero(o.InformationCode) { // not required
		return nil
	}

	if err := validate.MaxLength("informationCode", "body", o.InformationCode, 255); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment created body risk information velocity morphing items0 based on context it is used
func (o *CreatePaymentCreatedBodyRiskInformationVelocityMorphingItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyRiskInformationVelocityMorphingItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyRiskInformationVelocityMorphingItems0) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyRiskInformationVelocityMorphingItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyTokenInformation create payment created body token information
swagger:model CreatePaymentCreatedBodyTokenInformation
*/
type CreatePaymentCreatedBodyTokenInformation struct {

	// customer
	Customer *CreatePaymentCreatedBodyTokenInformationCustomer `json:"customer,omitempty"`

	// instrument identifier
	InstrumentIdentifier *CreatePaymentCreatedBodyTokenInformationInstrumentIdentifier `json:"instrumentIdentifier,omitempty"`

	// A value of true means the card number or bank account used to create an Instrument Identifier was new and did not already exist in the token vault.
	// A value of false means the card number or bank account used to create an Instrument Identifier already existed in the token vault.
	//
	InstrumentidentifierNew bool `json:"instrumentidentifierNew,omitempty"`

	// payment instrument
	PaymentInstrument *CreatePaymentCreatedBodyTokenInformationPaymentInstrument `json:"paymentInstrument,omitempty"`

	// shipping address
	ShippingAddress *CreatePaymentCreatedBodyTokenInformationShippingAddress `json:"shippingAddress,omitempty"`
}

// Validate validates this create payment created body token information
func (o *CreatePaymentCreatedBodyTokenInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCustomer(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateInstrumentIdentifier(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePaymentInstrument(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateShippingAddress(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyTokenInformation) validateCustomer(formats strfmt.Registry) error {
	if swag.IsZero(o.Customer) { // not required
		return nil
	}

	if o.Customer != nil {
		if err := o.Customer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "tokenInformation" + "." + "customer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "tokenInformation" + "." + "customer")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyTokenInformation) validateInstrumentIdentifier(formats strfmt.Registry) error {
	if swag.IsZero(o.InstrumentIdentifier) { // not required
		return nil
	}

	if o.InstrumentIdentifier != nil {
		if err := o.InstrumentIdentifier.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "tokenInformation" + "." + "instrumentIdentifier")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "tokenInformation" + "." + "instrumentIdentifier")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyTokenInformation) validatePaymentInstrument(formats strfmt.Registry) error {
	if swag.IsZero(o.PaymentInstrument) { // not required
		return nil
	}

	if o.PaymentInstrument != nil {
		if err := o.PaymentInstrument.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "tokenInformation" + "." + "paymentInstrument")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "tokenInformation" + "." + "paymentInstrument")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyTokenInformation) validateShippingAddress(formats strfmt.Registry) error {
	if swag.IsZero(o.ShippingAddress) { // not required
		return nil
	}

	if o.ShippingAddress != nil {
		if err := o.ShippingAddress.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "tokenInformation" + "." + "shippingAddress")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "tokenInformation" + "." + "shippingAddress")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this create payment created body token information based on the context it is used
func (o *CreatePaymentCreatedBodyTokenInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateCustomer(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateInstrumentIdentifier(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidatePaymentInstrument(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateShippingAddress(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyTokenInformation) contextValidateCustomer(ctx context.Context, formats strfmt.Registry) error {

	if o.Customer != nil {
		if err := o.Customer.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "tokenInformation" + "." + "customer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "tokenInformation" + "." + "customer")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyTokenInformation) contextValidateInstrumentIdentifier(ctx context.Context, formats strfmt.Registry) error {

	if o.InstrumentIdentifier != nil {
		if err := o.InstrumentIdentifier.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "tokenInformation" + "." + "instrumentIdentifier")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "tokenInformation" + "." + "instrumentIdentifier")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyTokenInformation) contextValidatePaymentInstrument(ctx context.Context, formats strfmt.Registry) error {

	if o.PaymentInstrument != nil {
		if err := o.PaymentInstrument.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "tokenInformation" + "." + "paymentInstrument")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "tokenInformation" + "." + "paymentInstrument")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyTokenInformation) contextValidateShippingAddress(ctx context.Context, formats strfmt.Registry) error {

	if o.ShippingAddress != nil {
		if err := o.ShippingAddress.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "tokenInformation" + "." + "shippingAddress")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentCreated" + "." + "tokenInformation" + "." + "shippingAddress")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyTokenInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyTokenInformation) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyTokenInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyTokenInformationCustomer create payment created body token information customer
swagger:model CreatePaymentCreatedBodyTokenInformationCustomer
*/
type CreatePaymentCreatedBodyTokenInformationCustomer struct {

	// Unique identifier for the Customer token that was created as part of a bundled TOKEN_CREATE action.
	//
	// Max Length: 32
	// Min Length: 1
	ID string `json:"id,omitempty"`
}

// Validate validates this create payment created body token information customer
func (o *CreatePaymentCreatedBodyTokenInformationCustomer) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyTokenInformationCustomer) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MinLength("createPaymentCreated"+"."+"tokenInformation"+"."+"customer"+"."+"id", "body", o.ID, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"tokenInformation"+"."+"customer"+"."+"id", "body", o.ID, 32); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment created body token information customer based on context it is used
func (o *CreatePaymentCreatedBodyTokenInformationCustomer) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyTokenInformationCustomer) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyTokenInformationCustomer) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyTokenInformationCustomer
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyTokenInformationInstrumentIdentifier create payment created body token information instrument identifier
swagger:model CreatePaymentCreatedBodyTokenInformationInstrumentIdentifier
*/
type CreatePaymentCreatedBodyTokenInformationInstrumentIdentifier struct {

	// Unique identifier for the Instrument Identifier token that was created as part of a bundled TOKEN_CREATE action.
	//
	// Max Length: 32
	// Min Length: 12
	ID string `json:"id,omitempty"`

	// Issuers state for the card number.
	// Valid values:
	// - ACTIVE
	// - CLOSED : The account has been closed.
	//
	State string `json:"state,omitempty"`
}

// Validate validates this create payment created body token information instrument identifier
func (o *CreatePaymentCreatedBodyTokenInformationInstrumentIdentifier) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyTokenInformationInstrumentIdentifier) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MinLength("createPaymentCreated"+"."+"tokenInformation"+"."+"instrumentIdentifier"+"."+"id", "body", o.ID, 12); err != nil {
		return err
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"tokenInformation"+"."+"instrumentIdentifier"+"."+"id", "body", o.ID, 32); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment created body token information instrument identifier based on context it is used
func (o *CreatePaymentCreatedBodyTokenInformationInstrumentIdentifier) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyTokenInformationInstrumentIdentifier) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyTokenInformationInstrumentIdentifier) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyTokenInformationInstrumentIdentifier
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyTokenInformationPaymentInstrument create payment created body token information payment instrument
swagger:model CreatePaymentCreatedBodyTokenInformationPaymentInstrument
*/
type CreatePaymentCreatedBodyTokenInformationPaymentInstrument struct {

	// Unique identifier for the Payment Instrument token that was created as part of a bundled TOKEN_CREATE action.
	//
	// Max Length: 32
	// Min Length: 1
	ID string `json:"id,omitempty"`
}

// Validate validates this create payment created body token information payment instrument
func (o *CreatePaymentCreatedBodyTokenInformationPaymentInstrument) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyTokenInformationPaymentInstrument) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MinLength("createPaymentCreated"+"."+"tokenInformation"+"."+"paymentInstrument"+"."+"id", "body", o.ID, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"tokenInformation"+"."+"paymentInstrument"+"."+"id", "body", o.ID, 32); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment created body token information payment instrument based on context it is used
func (o *CreatePaymentCreatedBodyTokenInformationPaymentInstrument) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyTokenInformationPaymentInstrument) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyTokenInformationPaymentInstrument) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyTokenInformationPaymentInstrument
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyTokenInformationShippingAddress create payment created body token information shipping address
swagger:model CreatePaymentCreatedBodyTokenInformationShippingAddress
*/
type CreatePaymentCreatedBodyTokenInformationShippingAddress struct {

	// Unique identifier for the Customers Shipping Address token that was created as part of a bundled TOKEN_CREATE action.
	//
	// Max Length: 32
	// Min Length: 1
	ID string `json:"id,omitempty"`
}

// Validate validates this create payment created body token information shipping address
func (o *CreatePaymentCreatedBodyTokenInformationShippingAddress) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyTokenInformationShippingAddress) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MinLength("createPaymentCreated"+"."+"tokenInformation"+"."+"shippingAddress"+"."+"id", "body", o.ID, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"tokenInformation"+"."+"shippingAddress"+"."+"id", "body", o.ID, 32); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment created body token information shipping address based on context it is used
func (o *CreatePaymentCreatedBodyTokenInformationShippingAddress) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyTokenInformationShippingAddress) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyTokenInformationShippingAddress) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyTokenInformationShippingAddress
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyAcquirerInformation create payment params body acquirer information
swagger:model CreatePaymentParamsBodyAcquirerInformation
*/
type CreatePaymentParamsBodyAcquirerInformation struct {

	// Acquirer bank ID number that  corresponds to a certificate that Cybersource already has.This ID has this format. 4XXXXX for Visa and 5XXXXX for Mastercard.
	//
	// Max Length: 11
	AcquirerBin string `json:"acquirerBin,omitempty"`

	// Issuers need to be aware of the Acquirer's Country Code when the Acquirer country differs from the Merchant country and the Acquirer is in the EEA (European Economic Area).
	//
	// Max Length: 2
	Country string `json:"country,omitempty"`

	// Username for the visa directory server that is created when your acquirer sets up your account. This ID might be the same as your merchant ID. the username can be 15 or 23 characters.
	//
	// Max Length: 15
	MerchantID string `json:"merchantId,omitempty"`

	// Registered password for the Visa directory server.
	//
	// Max Length: 8
	Password string `json:"password,omitempty"`
}

// Validate validates this create payment params body acquirer information
func (o *CreatePaymentParamsBodyAcquirerInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAcquirerBin(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMerchantID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePassword(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyAcquirerInformation) validateAcquirerBin(formats strfmt.Registry) error {
	if swag.IsZero(o.AcquirerBin) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"acquirerInformation"+"."+"acquirerBin", "body", o.AcquirerBin, 11); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyAcquirerInformation) validateCountry(formats strfmt.Registry) error {
	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"acquirerInformation"+"."+"country", "body", o.Country, 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyAcquirerInformation) validateMerchantID(formats strfmt.Registry) error {
	if swag.IsZero(o.MerchantID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"acquirerInformation"+"."+"merchantId", "body", o.MerchantID, 15); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyAcquirerInformation) validatePassword(formats strfmt.Registry) error {
	if swag.IsZero(o.Password) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"acquirerInformation"+"."+"password", "body", o.Password, 8); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment params body acquirer information based on context it is used
func (o *CreatePaymentParamsBodyAcquirerInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyAcquirerInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyAcquirerInformation) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyAcquirerInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyAggregatorInformation create payment params body aggregator information
swagger:model CreatePaymentParamsBodyAggregatorInformation
*/
type CreatePaymentParamsBodyAggregatorInformation struct {

	// Value that identifies you as a payment aggregator. Get this value from the
	// processor.
	//
	// #### CyberSource through VisaNet
	// The value for this field corresponds to the following data in the TC 33 capture file5:
	// - Record: CP01 TCR6
	// - Position: 95-105
	// - Field: MasterCard Payment Facilitator ID
	//
	// **FDC Compass**\
	// This value must consist of uppercase characters.
	//
	// For processor-specific information, see the `aggregator_id` field in [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 20
	AggregatorID string `json:"aggregatorId,omitempty"`

	// Your payment aggregator business name.
	//
	// **American Express Direct**\
	// The maximum length of the aggregator name depends on the length of the sub-merchant name. The combined length for both values must not exceed 36 characters.\
	//
	// #### CyberSource through VisaNet
	// With American Express, the maximum length of the aggregator name depends on the length of the sub-merchant name. The combined length for both values must not exceed 36 characters. The value for this field does not map to the TC 33 capture file5.
	//
	// **FDC Compass**\
	// This value must consist of uppercase characters.
	//
	// For processor-specific information, see the aggregator_name field in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 37
	Name string `json:"name,omitempty"`

	// sub merchant
	SubMerchant *CreatePaymentParamsBodyAggregatorInformationSubMerchant `json:"subMerchant,omitempty"`
}

// Validate validates this create payment params body aggregator information
func (o *CreatePaymentParamsBodyAggregatorInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAggregatorID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSubMerchant(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyAggregatorInformation) validateAggregatorID(formats strfmt.Registry) error {
	if swag.IsZero(o.AggregatorID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"aggregatorInformation"+"."+"aggregatorId", "body", o.AggregatorID, 20); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyAggregatorInformation) validateName(formats strfmt.Registry) error {
	if swag.IsZero(o.Name) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"aggregatorInformation"+"."+"name", "body", o.Name, 37); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyAggregatorInformation) validateSubMerchant(formats strfmt.Registry) error {
	if swag.IsZero(o.SubMerchant) { // not required
		return nil
	}

	if o.SubMerchant != nil {
		if err := o.SubMerchant.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "aggregatorInformation" + "." + "subMerchant")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "aggregatorInformation" + "." + "subMerchant")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this create payment params body aggregator information based on the context it is used
func (o *CreatePaymentParamsBodyAggregatorInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateSubMerchant(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyAggregatorInformation) contextValidateSubMerchant(ctx context.Context, formats strfmt.Registry) error {

	if o.SubMerchant != nil {
		if err := o.SubMerchant.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "aggregatorInformation" + "." + "subMerchant")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "aggregatorInformation" + "." + "subMerchant")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyAggregatorInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyAggregatorInformation) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyAggregatorInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyAggregatorInformationSubMerchant create payment params body aggregator information sub merchant
swagger:model CreatePaymentParamsBodyAggregatorInformationSubMerchant
*/
type CreatePaymentParamsBodyAggregatorInformationSubMerchant struct {

	// First line of the sub-merchants street address.
	//
	// For processor-specific details, see `submerchant_street` field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// #### CyberSource through VisaNet
	// The value for this field does not map to the TC 33 capture file5.
	//
	// #### FDC Compass
	// This value must consist of uppercase characters.
	//
	// Max Length: 38
	Address1 string `json:"address1,omitempty"`

	// Sub-merchants state or province.
	//
	// For possible values and also aggregator support, see `submerchant_state` request field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// #### CyberSource through VisaNet
	// The value for this field does not map to the TC 33 capture file5.
	//
	// #### FDC Compass
	// This value must consist of uppercase characters.
	//
	// Max Length: 3
	AdministrativeArea string `json:"administrativeArea,omitempty"`

	// Unique identifier assigned by the payment card company to the sub-merchant.
	// Max Length: 15
	CardAcceptorID string `json:"cardAcceptorId,omitempty"`

	// Sub-merchants country. Use the [ISO Standard Country Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf).
	//
	// #### CyberSource through VisaNet
	// The value for this field does not map to the TC 33 capture file.
	//
	// #### FDC Compass
	// This value must consist of uppercase characters.
	//
	// For details, see the `submerchant_country` request-level field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// Max Length: 3
	Country string `json:"country,omitempty"`

	// Sub-merchants email address.
	//
	// **Maximum length for processors**
	//
	//  - American Express Direct: 40
	//  - CyberSource through VisaNet: 40
	//  - FDC Compass: 40
	//  - FDC Nashville Global: 19
	//
	// #### CyberSource through VisaNet
	// With American Express, the value for this field corresponds to the following data in the TC 33 capture file:
	// - Record: CP01 TCRB
	// - Position: 25-64
	// - Field: American Express Seller E-mail Address
	//
	// **Note** The TC 33 Capture file contains information about the purchases and refunds that a merchant submits to CyberSource. CyberSource through VisaNet creates the TC 33 Capture file at the end of the day and sends it to the merchants acquirer, who uses this information to facilitate end-of-day clearing processing with payment card companies.
	//
	// Max Length: 40
	Email string `json:"email,omitempty"`

	// The ID you assigned to your sub-merchant.
	// CyberSource through VisaNet: For American Express transaction, the value for this field corresponds to the following data in the TC 33 capture file:
	// - Record: CP01 TCRB
	// - Position: 65-84
	// - Field: American Express Seller ID
	// For  Mastercard transactions, the value for this field corresponds to the following data in the TC 33 capture file:
	// - Record: CP01 TCR6
	// - Position: 117-131
	// - Field: Mastercard Sub-Merchant ID
	// FDC Compass: This value must consist of uppercase characters.
	//
	// American Express Direct: String (20)
	// CyberSource through VisaNet with American Express: String (20)
	// CyberSource through VisaNet with Mastercard: String (15)
	// FDC Compass: String (20)
	// FDC Nashville Global: String (14)
	//
	// Max Length: 20
	ID string `json:"id,omitempty"`

	// Sub-merchants city.
	//
	// For processor-specific details, see `submerchant_city` request field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// #### CyberSource through VisaNet
	// The value for this field does not map to the TC 33 capture file5.
	//
	// #### FDC Compass
	// This value must consist of uppercase characters.
	//
	// Max Length: 21
	Locality string `json:"locality,omitempty"`

	// Sub-merchants business name.
	//
	// #### American Express Direct
	// The maximum length of the sub-merchant name depends on the length of the aggregator name. The combined length for both values must not exceed 36 characters.
	//
	// #### CyberSource through VisaNet
	// With American Express, the maximum length of the sub-merchant name depends on the length of the aggregator name. The combined length for both values must not exceed 36 characters. The value for this field does not map to the TC 33 capture file5.
	//
	// #### FDC Compass
	// This value must consist of uppercase characters.
	//
	// #### FDC Nashville Global
	// With Mastercard, the maximum length of the sub-merchant name depends on the length of the aggregator name:
	// - If aggregator name length is 1 through 3, maximum sub-merchant name length is 21.
	// - If aggregator name length is 4 through 7, maximum sub-merchant name length is 17.
	// - If aggregator name length is 8 through 12, maximum sub-merchant name length is 12.
	//
	// Max Length: 37
	Name string `json:"name,omitempty"`

	// Sub-merchants telephone number.
	//
	// **Maximum length for procesors**
	//
	//  - American Express Direct: 20
	//  - CyberSource through VisaNet: 20
	//  - FDC Compass: 13
	//  - FDC Nashville Global: 10
	//
	// #### CyberSource through VisaNet
	// With American Express, the value for this field corresponds to the following data in the TC 33 capture file5:
	// - Record: CP01 TCRB
	// - Position: 5-24
	// - Field: American Express Seller Telephone Number
	//
	// **FDC Compass**\
	// This value must consist of uppercase characters. Use one of these recommended formats:\
	// `NNN-NNN-NNNN`\
	// `NNN-AAAAAAA`
	//
	// Max Length: 20
	PhoneNumber string `json:"phoneNumber,omitempty"`

	// Partial postal code for the sub-merchants address.
	//
	// For processor-specific details, see `submerchant_postal_code` request field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// #### CyberSource through VisaNet
	// The value for this field does not map to the TC 33 capture file5.
	//
	// #### FDC Compass
	// This value must consist of uppercase characters.
	//
	// Max Length: 15
	PostalCode string `json:"postalCode,omitempty"`

	// Sub-merchants region.
	//
	// **Example**\
	// `NE` indicates that the sub-merchant is in the northeast region.
	//
	// For processor-specific details, see `submerchant_region` request field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// Max Length: 3
	Region string `json:"region,omitempty"`
}

// Validate validates this create payment params body aggregator information sub merchant
func (o *CreatePaymentParamsBodyAggregatorInformationSubMerchant) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAddress1(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAdministrativeArea(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCardAcceptorID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEmail(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocality(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePhoneNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRegion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyAggregatorInformationSubMerchant) validateAddress1(formats strfmt.Registry) error {
	if swag.IsZero(o.Address1) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"aggregatorInformation"+"."+"subMerchant"+"."+"address1", "body", o.Address1, 38); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyAggregatorInformationSubMerchant) validateAdministrativeArea(formats strfmt.Registry) error {
	if swag.IsZero(o.AdministrativeArea) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"aggregatorInformation"+"."+"subMerchant"+"."+"administrativeArea", "body", o.AdministrativeArea, 3); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyAggregatorInformationSubMerchant) validateCardAcceptorID(formats strfmt.Registry) error {
	if swag.IsZero(o.CardAcceptorID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"aggregatorInformation"+"."+"subMerchant"+"."+"cardAcceptorId", "body", o.CardAcceptorID, 15); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyAggregatorInformationSubMerchant) validateCountry(formats strfmt.Registry) error {
	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"aggregatorInformation"+"."+"subMerchant"+"."+"country", "body", o.Country, 3); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyAggregatorInformationSubMerchant) validateEmail(formats strfmt.Registry) error {
	if swag.IsZero(o.Email) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"aggregatorInformation"+"."+"subMerchant"+"."+"email", "body", o.Email, 40); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyAggregatorInformationSubMerchant) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"aggregatorInformation"+"."+"subMerchant"+"."+"id", "body", o.ID, 20); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyAggregatorInformationSubMerchant) validateLocality(formats strfmt.Registry) error {
	if swag.IsZero(o.Locality) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"aggregatorInformation"+"."+"subMerchant"+"."+"locality", "body", o.Locality, 21); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyAggregatorInformationSubMerchant) validateName(formats strfmt.Registry) error {
	if swag.IsZero(o.Name) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"aggregatorInformation"+"."+"subMerchant"+"."+"name", "body", o.Name, 37); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyAggregatorInformationSubMerchant) validatePhoneNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.PhoneNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"aggregatorInformation"+"."+"subMerchant"+"."+"phoneNumber", "body", o.PhoneNumber, 20); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyAggregatorInformationSubMerchant) validatePostalCode(formats strfmt.Registry) error {
	if swag.IsZero(o.PostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"aggregatorInformation"+"."+"subMerchant"+"."+"postalCode", "body", o.PostalCode, 15); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyAggregatorInformationSubMerchant) validateRegion(formats strfmt.Registry) error {
	if swag.IsZero(o.Region) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"aggregatorInformation"+"."+"subMerchant"+"."+"region", "body", o.Region, 3); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment params body aggregator information sub merchant based on context it is used
func (o *CreatePaymentParamsBodyAggregatorInformationSubMerchant) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyAggregatorInformationSubMerchant) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyAggregatorInformationSubMerchant) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyAggregatorInformationSubMerchant
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyBuyerInformation create payment params body buyer information
swagger:model CreatePaymentParamsBodyBuyerInformation
*/
type CreatePaymentParamsBodyBuyerInformation struct {

	// Companys tax identifier. This is only used for eCheck service.
	//
	// ** TeleCheck **
	// Contact your TeleCheck representative to find out whether this field is required or optional.
	//
	// ** All Other Processors **
	// Not used.
	//
	// Max Length: 9
	CompanyTaxID string `json:"companyTaxId,omitempty"`

	// Recipients date of birth. **Format**: `YYYYMMDD`.
	//
	// This field is a `pass-through`, which means that CyberSource ensures that the value is eight numeric characters
	// but otherwise does not verify the value or modify it in any way before sending it to the processor. If the field
	// is not required for the transaction, CyberSource does not forward it to the processor.
	//
	// For more details, see `recipient_date_of_birth` field description in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// Max Length: 8
	DateOfBirth string `json:"dateOfBirth,omitempty"`

	// The merchant's password that CyberSource hashes and stores as a hashed password.
	//
	// For details about this field, see the `customer_password` field description in _Decision Manager Using the SCMP API Developer Guide_ on the [CyberSource Business Center.](https://ebc2.cybersource.com/ebc2/) Click **Decision Manager** > **Documentation** > **Guides** > _Decision Manager Using the SCMP API Developer Guide_ (PDF link).
	//
	// Max Length: 100
	HashedPassword string `json:"hashedPassword,omitempty"`

	// Your identifier for the customer.
	//
	// When a subscription or customer profile is being created, the maximum length for this field for most processors is 30. Otherwise, the maximum length is 100.
	//
	// #### Comercio Latino
	// For recurring payments in Mexico, the value is the customers contract number.
	// Note Before you request the authorization, you must inform the issuer of the customer contract numbers that will be used for recurring transactions.
	//
	// #### Worldpay VAP
	// For a follow-on credit with Worldpay VAP, CyberSource checks the following locations, in the order
	// given, for a customer account ID value and uses the first value it finds:
	// 1. `customer_account_id` value in the follow-on credit request
	// 2. Customer account ID value that was used for the capture that is being credited
	// 3. Customer account ID value that was used for the original authorization
	// If a customer account ID value cannot be found in any of these locations, then no value is used.
	//
	// For processor-specific information, see the `customer_account_id` field description in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 100
	MerchantCustomerID string `json:"merchantCustomerId,omitempty"`

	// Cardholders mobile phone number.
	// **Important** Required for Visa Secure transactions in Brazil.
	// Do not use this request field for any other types of transactions.
	//
	MobilePhone int64 `json:"mobilePhone,omitempty"`

	// personal identification
	PersonalIdentification []*CreatePaymentParamsBodyBuyerInformationPersonalIdentificationItems0 `json:"personalIdentification"`

	// Customers government-assigned tax identification number.
	//
	// #### Tax Calculation
	// Optional for international and value added taxes only. Not applicable to U.S. and Canadian taxes.
	//
	// For processor-specific information, see the purchaser_vat_registration_number field in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 20
	VatRegistrationNumber string `json:"vatRegistrationNumber,omitempty"`
}

// Validate validates this create payment params body buyer information
func (o *CreatePaymentParamsBodyBuyerInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCompanyTaxID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDateOfBirth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateHashedPassword(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMerchantCustomerID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePersonalIdentification(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateVatRegistrationNumber(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyBuyerInformation) validateCompanyTaxID(formats strfmt.Registry) error {
	if swag.IsZero(o.CompanyTaxID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"buyerInformation"+"."+"companyTaxId", "body", o.CompanyTaxID, 9); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyBuyerInformation) validateDateOfBirth(formats strfmt.Registry) error {
	if swag.IsZero(o.DateOfBirth) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"buyerInformation"+"."+"dateOfBirth", "body", o.DateOfBirth, 8); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyBuyerInformation) validateHashedPassword(formats strfmt.Registry) error {
	if swag.IsZero(o.HashedPassword) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"buyerInformation"+"."+"hashedPassword", "body", o.HashedPassword, 100); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyBuyerInformation) validateMerchantCustomerID(formats strfmt.Registry) error {
	if swag.IsZero(o.MerchantCustomerID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"buyerInformation"+"."+"merchantCustomerId", "body", o.MerchantCustomerID, 100); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyBuyerInformation) validatePersonalIdentification(formats strfmt.Registry) error {
	if swag.IsZero(o.PersonalIdentification) { // not required
		return nil
	}

	for i := 0; i < len(o.PersonalIdentification); i++ {
		if swag.IsZero(o.PersonalIdentification[i]) { // not required
			continue
		}

		if o.PersonalIdentification[i] != nil {
			if err := o.PersonalIdentification[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("createPaymentRequest" + "." + "buyerInformation" + "." + "personalIdentification" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("createPaymentRequest" + "." + "buyerInformation" + "." + "personalIdentification" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CreatePaymentParamsBodyBuyerInformation) validateVatRegistrationNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.VatRegistrationNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"buyerInformation"+"."+"vatRegistrationNumber", "body", o.VatRegistrationNumber, 20); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this create payment params body buyer information based on the context it is used
func (o *CreatePaymentParamsBodyBuyerInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidatePersonalIdentification(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyBuyerInformation) contextValidatePersonalIdentification(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.PersonalIdentification); i++ {

		if o.PersonalIdentification[i] != nil {
			if err := o.PersonalIdentification[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("createPaymentRequest" + "." + "buyerInformation" + "." + "personalIdentification" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("createPaymentRequest" + "." + "buyerInformation" + "." + "personalIdentification" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyBuyerInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyBuyerInformation) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyBuyerInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyBuyerInformationPersonalIdentificationItems0 create payment params body buyer information personal identification items0
swagger:model CreatePaymentParamsBodyBuyerInformationPersonalIdentificationItems0
*/
type CreatePaymentParamsBodyBuyerInformationPersonalIdentificationItems0 struct {

	// The value of the identification type. This field is supported only on the following processors.
	//
	// #### ComercioLatino
	// Set this field to the Cadastro de Pessoas Fisicas (CPF).
	//
	// #### CyberSource Latin American Processing
	// Supported for Redecard in Brazil. Set this field to the Cadastro de Pessoas Fisicas (CPF), which is required for AVS for Redecard in Brazil.
	// **Note** CyberSource Latin American Processing is the name of a specific processing connection that CyberSource supports. In the CyberSource API documentation, CyberSource Latin American Processing does not refer to the general topic of processing in Latin America. The information in this field description is for the specific processing connection called CyberSource Latin American Processing. It is not for any other Latin American processors that CyberSource supports.
	//
	// For processor-specific information, see the `personal_id` field in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// If `type = PASSPORT`, this is the cardholder's passport number.
	// Recommended for Discover ProtectBuy.
	//
	// Max Length: 26
	ID string `json:"id,omitempty"`

	// The government agency that issued the driver's license or passport.
	//
	// If **type**` = DRIVER_LICENSE`, this is the State or province where the customers drivers license was issued.
	//
	// If **type**` = PASSPORT`, this is the Issuing country for the cardholders passport. Recommended for Discover ProtectBuy.
	//
	// Use the two-character [State, Province, and Territory Codes for the United States and Canada](https://developer.cybersource.com/library/documentation/sbc/quickref/states_and_provinces.pdf).
	//
	// #### TeleCheck
	// Contact your TeleCheck representative to find out whether this field is required or optional.
	//
	// #### All Other Processors
	// Not used.
	//
	// For details about the country that issued the passport, see `customer_passport_country` field description in [CyberSource Payer Authentication Using the SCMP API]
	// (https://apps.cybersource.com/library/documentation/dev_guides/Payer_Authentication_SCMP_API/html/)
	//
	// For details about the state or province that issued the passport, see `driver_license_state` field description in [Electronic Check Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/EChecks_SCMP_API/html/)
	//
	IssuedBy string `json:"issuedBy,omitempty"`

	// The type of the identification.
	//
	// Possible values:
	//   - `NATIONAL`
	//   - `CPF`
	//   - `CPNJ`
	//   - `CURP`
	//   - `SSN`
	//   - `DRIVER_LICENSE`
	//   - `PASSPORT_NUMBER`
	//   - `PERSONAL_ID`
	//   - `TAX_ID`
	//
	// This field is supported only on the following processors.
	//
	// #### ComercioLatino
	// Set this field to the Cadastro de Pessoas Fisicas (CPF).
	//
	// #### CyberSource Latin American Processing
	// Supported for Redecard in Brazil. Set this field to the Cadastro de Pessoas Fisicas (CPF), which is required for AVS for Redecard in Brazil.
	// **Note** CyberSource Latin American Processing is the name of a specific processing connection that CyberSource supports. In the CyberSource API documentation, CyberSource Latin American Processing does not refer to the general topic of processing in Latin America. The information in this field description is for the specific processing connection called CyberSource Latin American Processing. It is not for any other Latin American processors that CyberSource supports.
	//
	// For processor-specific information, see the `personal_id` field in [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	Type string `json:"type,omitempty"`

	// Verification results received from Issuer or Card Network for verification transactions. Response Only Field.
	//
	VerificationResults string `json:"verificationResults,omitempty"`
}

// Validate validates this create payment params body buyer information personal identification items0
func (o *CreatePaymentParamsBodyBuyerInformationPersonalIdentificationItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyBuyerInformationPersonalIdentificationItems0) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MaxLength("id", "body", o.ID, 26); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment params body buyer information personal identification items0 based on context it is used
func (o *CreatePaymentParamsBodyBuyerInformationPersonalIdentificationItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyBuyerInformationPersonalIdentificationItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyBuyerInformationPersonalIdentificationItems0) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyBuyerInformationPersonalIdentificationItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyClientReferenceInformation create payment params body client reference information
swagger:model CreatePaymentParamsBodyClientReferenceInformation
*/
type CreatePaymentParamsBodyClientReferenceInformation struct {

	// The name of the Connection Method client (such as Virtual Terminal or SOAP Toolkit API) that the merchant uses to send a transaction request to CyberSource.
	//
	ApplicationName string `json:"applicationName,omitempty"`

	// The entity that is responsible for running the transaction and submitting the processing request to CyberSource. This could be a person, a system, or a connection method.
	//
	ApplicationUser string `json:"applicationUser,omitempty"`

	// Version of the CyberSource application or integration used for a transaction.
	//
	ApplicationVersion string `json:"applicationVersion,omitempty"`

	// Merchant-generated order reference or tracking number. It is recommended that you send a unique value for each
	// transaction so that you can perform meaningful searches for the transaction.
	//
	// #### Used by
	// **Authorization**
	// Required field.
	//
	// #### PIN Debit
	// Requests for PIN debit reversals need to use the same merchant reference number that was used in the transaction that is being
	// reversed.
	//
	// Required field for all PIN Debit requests (purchase, credit, and reversal).
	//
	// #### FDC Nashville Global
	// Certain circumstances can cause the processor to truncate this value to 15 or 17 characters for Level II and Level III processing, which can cause a discrepancy between the value you submit and the value included in some processor reports.
	//
	// Max Length: 50
	Code string `json:"code,omitempty"`

	// Comments
	Comments string `json:"comments,omitempty"`

	// partner
	Partner *CreatePaymentParamsBodyClientReferenceInformationPartner `json:"partner,omitempty"`

	// Used to resume a transaction that was paused for an order modification rule to allow for payer authentication to complete. To resume and continue with the authorization/decision service flow, call the services and include the request id from the prior decision call.
	//
	// Max Length: 26
	PausedRequestID string `json:"pausedRequestId,omitempty"`

	// Identifier that you assign to the transaction. Normally generated by a client server to identify a unique API request.
	//
	// **Note** Use this field only if you want to support merchant-initiated reversal and void operations.
	//
	// #### Used by
	// **Authorization, Authorization Reversal, Capture, Credit, and Void**
	// Optional field.
	//
	// #### PIN Debit
	// For a PIN debit reversal, your request must include a request ID or a merchant transaction identifier.
	// Optional field for PIN debit purchase or credit requests.
	//
	// Max Length: 30
	TransactionID string `json:"transactionId,omitempty"`
}

// Validate validates this create payment params body client reference information
func (o *CreatePaymentParamsBodyClientReferenceInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePartner(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePausedRequestID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTransactionID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyClientReferenceInformation) validateCode(formats strfmt.Registry) error {
	if swag.IsZero(o.Code) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"clientReferenceInformation"+"."+"code", "body", o.Code, 50); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyClientReferenceInformation) validatePartner(formats strfmt.Registry) error {
	if swag.IsZero(o.Partner) { // not required
		return nil
	}

	if o.Partner != nil {
		if err := o.Partner.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "clientReferenceInformation" + "." + "partner")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "clientReferenceInformation" + "." + "partner")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyClientReferenceInformation) validatePausedRequestID(formats strfmt.Registry) error {
	if swag.IsZero(o.PausedRequestID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"clientReferenceInformation"+"."+"pausedRequestId", "body", o.PausedRequestID, 26); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyClientReferenceInformation) validateTransactionID(formats strfmt.Registry) error {
	if swag.IsZero(o.TransactionID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"clientReferenceInformation"+"."+"transactionId", "body", o.TransactionID, 30); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this create payment params body client reference information based on the context it is used
func (o *CreatePaymentParamsBodyClientReferenceInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidatePartner(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyClientReferenceInformation) contextValidatePartner(ctx context.Context, formats strfmt.Registry) error {

	if o.Partner != nil {
		if err := o.Partner.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "clientReferenceInformation" + "." + "partner")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "clientReferenceInformation" + "." + "partner")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyClientReferenceInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyClientReferenceInformation) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyClientReferenceInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyClientReferenceInformationPartner create payment params body client reference information partner
swagger:model CreatePaymentParamsBodyClientReferenceInformationPartner
*/
type CreatePaymentParamsBodyClientReferenceInformationPartner struct {

	// Identifier for the developer that helped integrate a partner solution to CyberSource.
	//
	// Send this value in all requests that are sent through the partner solutions built by that developer.
	// CyberSource assigns the ID to the developer.
	//
	// **Note** When you see a developer ID of 999 in reports, the developer ID that was submitted is incorrect.
	//
	// Max Length: 8
	DeveloperID string `json:"developerId,omitempty"`

	// Value that links the previous transaction to the current follow-on request. This value is assigned by the client
	// software that is installed on the POS terminal, which makes it available to the terminals software and to
	// CyberSource. Therefore, you can use this value to reconcile transactions between CyberSource and the terminals
	// software.
	//
	// CyberSource does not forward this value to the processor. Instead, the value is forwarded to the CyberSource
	// reporting functionality.
	//
	// This field is supported only on these processors:
	// - American Express Direct
	// - Credit Mutuel-CIC
	// - FDC Nashville Global
	// - OmniPay Direct
	// - SIX
	//
	// Optional field.
	//
	// Max Length: 32
	OriginalTransactionID string `json:"originalTransactionId,omitempty"`

	// Identifier for the partner that is integrated to CyberSource.
	//
	// Send this value in all requests that are sent through the partner solution. CyberSource assigns the ID to the partner.
	//
	// **Note** When you see a solutionId of 999 in reports, the solutionId that was submitted is incorrect.
	//
	// Max Length: 8
	SolutionID string `json:"solutionId,omitempty"`

	// Value that identifies the application vendor and application version for a third party gateway.
	// CyberSource provides you with this value during testing and validation.
	// This field is supported only on CyberSource through VisaNet.
	//
	// #### Used by
	// **Authorization, Authorization Reversal, Capture, Credit, Incremental Authorization, and Void**
	// Optional field.
	//
	// #### PIN debit
	// Required field for PIN debit credit, PIN debit purchase, or PIN debit reversal request.
	//
	// Max Length: 12
	ThirdPartyCertificationNumber string `json:"thirdPartyCertificationNumber,omitempty"`
}

// Validate validates this create payment params body client reference information partner
func (o *CreatePaymentParamsBodyClientReferenceInformationPartner) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDeveloperID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOriginalTransactionID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSolutionID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateThirdPartyCertificationNumber(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyClientReferenceInformationPartner) validateDeveloperID(formats strfmt.Registry) error {
	if swag.IsZero(o.DeveloperID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"clientReferenceInformation"+"."+"partner"+"."+"developerId", "body", o.DeveloperID, 8); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyClientReferenceInformationPartner) validateOriginalTransactionID(formats strfmt.Registry) error {
	if swag.IsZero(o.OriginalTransactionID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"clientReferenceInformation"+"."+"partner"+"."+"originalTransactionId", "body", o.OriginalTransactionID, 32); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyClientReferenceInformationPartner) validateSolutionID(formats strfmt.Registry) error {
	if swag.IsZero(o.SolutionID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"clientReferenceInformation"+"."+"partner"+"."+"solutionId", "body", o.SolutionID, 8); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyClientReferenceInformationPartner) validateThirdPartyCertificationNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.ThirdPartyCertificationNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"clientReferenceInformation"+"."+"partner"+"."+"thirdPartyCertificationNumber", "body", o.ThirdPartyCertificationNumber, 12); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment params body client reference information partner based on context it is used
func (o *CreatePaymentParamsBodyClientReferenceInformationPartner) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyClientReferenceInformationPartner) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyClientReferenceInformationPartner) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyClientReferenceInformationPartner
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyConsumerAuthenticationInformation create payment params body consumer authentication information
swagger:model CreatePaymentParamsBodyConsumerAuthenticationInformation
*/
type CreatePaymentParamsBodyConsumerAuthenticationInformation struct {

	// Unique transaction identifier assigned by the ACS to identify a single transaction.
	//
	// This field is supported for Cartes Bancaires Fast'R transactions on Credit Mutuel-CIC.
	//
	// Max Length: 36
	AcsTransactionID string `json:"acsTransactionId,omitempty"`

	// An override field that a merchant can pass in to set the challenge window size to display to the end cardholder.  The ACS (Active Control Server) will reply with content that is formatted appropriately to this window size to allow for the best user experience.  The sizes are width x height in pixels of the window displayed in the cardholder browser window.
	//
	// 01 - 250x400
	//
	// 02 - 390x400
	//
	// 03 - 500x600
	//
	// 04 - 600x400
	//
	// 05 - Full page
	//
	// Max Length: 2
	AcsWindowSize string `json:"acsWindowSize,omitempty"`

	// Data that documents and supports a specific authentication process.
	//
	// Max Length: 2048
	AlternateAuthenticationData string `json:"alternateAuthenticationData,omitempty"`

	// Date and time in UTC of the cardholder authentication. Format: YYYYMMDDHHMM
	//
	// Max Length: 14
	AlternateAuthenticationDate string `json:"alternateAuthenticationDate,omitempty"`

	// Mechanism used by the cardholder to authenticate to the 3D Secure requestor.
	// Possible values:
	// - `01`: No authentication occurred
	// - `02`: Login using merchant system credentials
	// - `03`: Login using Federated ID
	// - `04`: Login using issuer credentials
	// - `05`: Login using third-party authenticator
	// - `06`: Login using FIDO Authenticator
	//
	AlternateAuthenticationMethod string `json:"alternateAuthenticationMethod,omitempty"`

	// The date/time of the authentication at the 3DS servers. RISK update authorization service in auth request
	// payload with value returned in `consumerAuthenticationInformation.alternateAuthenticationData` if merchant calls via CYBS or field can be
	// provided by merchant in authorization request if calling an external 3DS provider.
	//
	// This field is supported for Cartes Bancaires Fast'R transactions on Credit Mutuel-CIC.
	// Format: YYYYMMDDHHMMSS
	//
	// Max Length: 14
	AuthenticationDate string `json:"authenticationDate,omitempty"`

	// Payer authentication transaction identifier passed to link the check enrollment
	// and validate authentication messages.
	// **Note**: Required for Standard integration for enroll service.
	// Required for Hybrid integration for validate service.
	//
	// Max Length: 20
	AuthenticationTransactionID string `json:"authenticationTransactionId,omitempty"`

	// Indicates the type of authentication that will be used to challenge the card holder.
	//
	// Possible Values:
	//
	// 01 - Static
	//
	// 02 - Dynamic
	//
	// 03 - OOB (Out of Band)
	//
	// 04 - Decoupled
	// **NOTE**:  EMV 3-D Secure version 2.1.0 supports values 01-03.  Version 2.2.0 supports values 01-04.  Decoupled authentication is not supported at this time.
	//
	// Max Length: 2
	AuthenticationType string `json:"authenticationType,omitempty"`

	// Cardholder authentication verification value (CAVV).
	// Max Length: 40
	Cavv string `json:"cavv,omitempty"`

	// Algorithm used to generate the CAVV for Visa Secure or the UCAF authentication data for Mastercard Identity Check.
	//
	// Max Length: 1
	CavvAlgorithm string `json:"cavvAlgorithm,omitempty"`

	// An indicator as to why the transaction was canceled.
	// Possible Values:
	//
	// - `01`: Cardholder selected Cancel.
	// - `02`: Reserved for future EMVCo use (values invalid until defined by EMVCo).
	// - `03`: Transaction Timed OutDecoupled Authentication
	// - `04`: Transaction timed out at ACSother timeouts
	// - `05`: Transaction Timed out at ACS - First CReq not received by ACS
	// - `06`: Transaction Error
	// - `07`: Unknown
	// - `08`: Transaction Timed Out at SDK
	//
	// Max Length: 2
	ChallengeCancelCode string `json:"challengeCancelCode,omitempty"`

	// Possible values:
	// - `01`: No preference
	// - `02`: No challenge request
	// - `03`: Challenge requested (3D Secure requestor preference)
	// - `04`: Challenge requested (mandate)
	// - `05`: No challenge requested (transactional risk analysis is already performed)
	// - `06`: No challenge requested (Data share only)
	// - `07`: No challenge requested (strong consumer authentication is already performed)
	// - `08`: No challenge requested (utilize whitelist exemption if no challenge required)
	// - `09`: Challenge requested (whitelist prompt requested if challenge required)
	// **Note** This field will default to `01` on merchant configuration and can be overridden by the merchant.
	// EMV 3D Secure version 2.1.0 supports values `01-04`. Version 2.2.0 supports values `01-09`.
	//
	// For details, see `pa_challenge_code` field description in [CyberSource Payer Authentication Using the SCMP API.]
	// (https://apps.cybersource.com/library/documentation/dev_guides/Payer_Authentication_SCMP_API/html)
	//
	ChallengeCode string `json:"challengeCode,omitempty"`

	// The `consumerAuthenticationInformation.challengeCode` indicates the authentication type/level, or challenge, that was presented to the cardholder
	// at checkout by the merchant when calling the Carte Bancaire 3DS servers via CYBS RISK services. It conveys to
	// the issuer the alternative authentication methods that the consumer used.
	//
	// Max Length: 2
	ChallengeStatus string `json:"challengeStatus,omitempty"`

	// An alias that uniquely identifies the customer's account and credit card on file.
	// Note This field is required if Tokenization is enabled in the merchant profile settings.
	//
	// Max Length: 128
	CustomerCardAlias string `json:"customerCardAlias,omitempty"`

	// Indicates whether the 3DS Requestor requests the ACS to utilize Decoupled Authentication and agrees to utilize Decoupled Authentication if the ACS confirms its use.
	//
	// Possible Values:
	//
	// Y - Decoupled Authentication is supported and preferred if challenge is necessary
	//
	// N - Do not use Decoupled Authentication
	//
	// **Default Value**: N
	//
	// Max Length: 1
	DecoupledAuthenticationIndicator string `json:"decoupledAuthenticationIndicator,omitempty"`

	// Indicates the maximum amount of time that the 3DS Requestor will wait for an ACS (Active control server) to provide the results of a Decoupled Authentication transaction (in minutes).
	// Possible Values: Numeric values between 1 and 10080 accepted.
	//
	// Max Length: 5
	DecoupledAuthenticationMaxTime string `json:"decoupledAuthenticationMaxTime,omitempty"`

	// Indicates that the card being used is the one designated as the primary payment card for purchase.
	// Recommended for Discover ProtectBuy.
	//
	DefaultCard bool `json:"defaultCard,omitempty"`

	// Determines the channel that the transaction came through. Possible Values: SDK/Browser/3RI. 3RI - 3DS request initiated.
	//
	// Max Length: 10
	DeviceChannel string `json:"deviceChannel,omitempty"`

	// The Directory Server Transaction ID is generated by the Mastercard Directory Server during the authentication transaction and passed back to the merchant with the authentication results.
	// For Cybersource Through Visanet Gateway:
	// The value for this field corresponds to the following data in the TC 33 capture file3: Record: CP01 TCR7, Position: 114-149, Field: MC AVV VerificationDirectory Server Transaction ID
	//
	// Max Length: 36
	DirectoryServerTransactionID string `json:"directoryServerTransactionId,omitempty"`

	// Raw electronic commerce indicator (ECI).
	//
	// For details, see `eci_raw` request field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// Max Length: 2
	EciRaw string `json:"eciRaw,omitempty"`
	Eci string `json:"eci,omit`

	// This field describes the type of 3DS transaction flow that took place.  It can be one of three possible flows;
	// CH - Challenge
	// FR - Frictionless
	// FD - Frictionless with delegation, (challenge not generated by the issuer but by the scheme on behalf of the issuer).
	//
	// Max Length: 2
	EffectiveAuthenticationType string `json:"effectiveAuthenticationType,omitempty"`

	// An integer value greater than 1 indicating the max number of permitted authorizations for installment payments.
	// **Note** This is required if the merchant and cardholder have agreed to installment payments.
	//
	InstallmentTotalCount int64 `json:"installmentTotalCount,omitempty"`

	// Indicates whether the customer has opted in for marketing offers.
	// Recommended for Discover ProtectBuy.
	//
	MarketingOptIn bool `json:"marketingOptIn,omitempty"`

	// Indicates origin of the marketing offer. Recommended for Discover ProtectBuy.
	//
	// Max Length: 40
	MarketingSource string `json:"marketingSource,omitempty"`

	// Merchant category code.
	// **Important** Required only for Visa Secure transactions in Brazil.
	// Do not use this request field for any other types of transactions.
	//
	// Max Length: 4
	Mcc string `json:"mcc,omitempty"`

	// Calculated by merchants as per PSD2** RTS** (EEA** card fraud divided by all EEA card volumes).
	// Possible Values:
	// 1 = Represents fraud rate <=1
	//
	// 2 = Represents fraud rate >1 and <=6
	//
	// 3 = Represents fraud rate >6 and <=13
	//
	// 4 = Represents fraud rate >13 and <=25
	//
	// 5 = Represents fraud rate >25
	//
	// EEA** = European Economic Area
	// RTS** = Regulatory Technical Standards
	// PSD2** = Payment Services Directive
	//
	// Max Length: 2
	MerchantFraudRate string `json:"merchantFraudRate,omitempty"`

	// Risk Score provided by merchants. This is specific for CB transactions.
	//
	MerchantScore int64 `json:"merchantScore,omitempty"`

	// Category of the message for a specific use case. Possible values:
	//
	// - `01`: PA- payment authentication
	// - `02`: NPA- non-payment authentication
	// - `03-79`: Reserved for EMVCo future use (values invalid until defined by EMVCo)
	// - `80-99`: Reserved for DS use
	//
	MessageCategory string `json:"messageCategory,omitempty"`

	// The global score calculated by the CB scoring platform and returned to merchants.
	//
	// Possible values:
	// - '00' - '99'
	//
	// When you request the payer authentication and authorization services separately, get the value for this field from the pa_network_score reply field.
	//
	// This field is supported only for Cartes Bancaires Fast'R transactions on Credit Mutuel-CIC.
	//
	// Max Length: 2
	NetworkScore string `json:"networkScore,omitempty"`

	// Non-Payer Authentication Indicator.
	// Possible values:
	// - `01`: Add card
	// - `02`: Maintain card information
	// - `03`: Cardholder verification for EMV token
	// - `04-80` Reserved for EMVCo
	// - `80-90` Reserved DS
	//
	// Max Length: 2
	NpaCode string `json:"npaCode,omitempty"`

	// Two-character [ISO Standard Country Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf)..
	//
	// Max Length: 2
	OverrideCountryCode string `json:"overrideCountryCode,omitempty"`

	// Specifies the Brazilian payment account type used for the transaction.
	// This field overrides other payment types that might be specified in the request.
	// Use one of the following values for this field:
	// - `NA`: Not applicable. Do not override other payment types that are specified in the request.
	// - `CR`: Credit card.
	// - `DB`: Debit card.
	// - `VSAVR`: Visa Vale Refeicao
	// - `VSAVA`: Visa Vale Alimentacao
	// **Important** Required only for Visa Secure transactions in Brazil.
	// Do not use this request field for any other types of transactions.
	//
	OverridePaymentMethod string `json:"overridePaymentMethod,omitempty"`

	// This field contains 3DS version that was used for Secured Consumer Authentication (SCA). For example 3DS secure version 1.0.2 or 2.0.0 is used for Secured Consumer Authentication.
	// For Cybersource Through Visanet Gateway:
	// The value for this field corresponds to the following data in the TC 33 capture file3: Record: CP01 TCR7, Position: 113 , Field: MC AVV VerificationProgram Protocol
	// It will contain one of the following values:
	// - `1` (3D Secure Version 1.0 (3DS 1.0))
	// - `2` (EMV 3-D Secure (3DS 2.0))
	//
	// Max Length: 1
	PaSpecificationVersion string `json:"paSpecificationVersion,omitempty"`

	// Payer authentication response status.
	//
	// For details, see `pares_status` request field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// Max Length: 1
	ParesStatus string `json:"paresStatus,omitempty"`

	// This field carry data that the ACS can use to verify the authentication process.
	//
	// Max Length: 2048
	PriorAuthenticationData string `json:"priorAuthenticationData,omitempty"`

	// Mechanism used by the Cardholder to previously authenticate to the 3DS Requestor.
	//
	// 01 - Frictionless authentication occurred by ACS
	//
	// 02 - Cardholder challenge occurred by ACS
	//
	// 03 - AVS verified
	//
	// 04 - Other issuer methods
	//
	// 05-79 - Reserved for EMVCo future use (values invalid until defined by EMVCo)
	//
	// 80-99 - Reserved for DS use
	//
	// Max Length: 2
	PriorAuthenticationMethod string `json:"priorAuthenticationMethod,omitempty"`

	// This data element contains a ACS Transaction ID for a prior authenticated transaction.
	// For example, the first recurring transaction that was authenticated with the cardholder
	//
	// Max Length: 36
	PriorAuthenticationReferenceID string `json:"priorAuthenticationReferenceId,omitempty"`

	// Date and time in UTC of the prior cardholder authentication. Format  YYYYMMDDHHMM
	//
	// Max Length: 12
	PriorAuthenticationTime string `json:"priorAuthenticationTime,omitempty"`

	// Specifies the product code, which designates the type of transaction.
	// Specify one of the following values for this field:
	// - AIR: Airline purchase
	// Important Required for American Express SafeKey (U.S.).
	// - `ACC`: Accommodation Rental
	// - `ACF`: Account funding
	// - `CHA`: Check acceptance
	// - `DIG`: Digital Goods
	// - `DSP`: Cash Dispensing
	// - `GAS`: Fuel
	// - `GEN`: General Retail
	// - `LUX`: Luxury Retail
	// - `PAL`: Prepaid activation and load
	// - `PHY`: Goods or services purchase
	// - `QCT`: Quasi-cash transaction
	// - `REN`: Car Rental
	// - `RES`: Restaurant
	// - `SVC`: Services
	// - `TBD`: Other
	// - `TRA`: Travel
	// **Important** Required for Visa Secure transactions in Brazil.
	// Do not use this request field for any other types of transactions.
	//
	// Max Length: 3
	ProductCode string `json:"productCode,omitempty"`

	// Reference ID that corresponds to the device fingerprinting data that was collected previously.
	// Note Required for Hybrid integration.
	//
	// Max Length: 50
	ReferenceID string `json:"referenceId,omitempty"`

	// Cardinal's directory server assigned 3DS Requestor ID value
	// Max Length: 35
	RequestorID string `json:"requestorId,omitempty"`

	// Indicates the type of 3RI request.
	//
	// Possible Values:
	//
	// 01 - Recurring transaction
	//
	// 02 - Installment transaction
	//
	// 03 - Add card
	//
	// 04 - Maintain card
	//
	// 05 - Account verification
	//
	// 06 - Split/delayed shipment
	//
	// 07 - Top-up
	//
	// 08 - Mail Order
	//
	// 09 - Telephone Order
	//
	// 10 - Whitelist status check
	//
	// 11 - Other payment
	//
	// Max Length: 2
	RequestorInitiatedAuthenticationIndicator string `json:"requestorInitiatedAuthenticationIndicator,omitempty"`

	// Cardinal's directory server assigned 3DS Requestor Name value
	// Max Length: 40
	RequestorName string `json:"requestorName,omitempty"`

	// JWT returned by the 3D Secure provider when the authentication is complete. Required for Hybrid integration if you use the Cybersource-generated access token. Note: Max. length of this field is 2048 characters.
	//
	ResponseAccessToken string `json:"responseAccessToken,omitempty"`

	// The URL of the merchants return page. CyberSource adds this return URL to the step-up JWT and returns it in the
	// response of the Payer Authentication enrollment call. The merchant's return URL page serves as a listening URL.
	// Once the bank session completes, the merchant receives a POST to their URL. This response contains the completed
	// bank sessions transactionId. The merchants return page should capture the transaction ID and send it in the
	// Payer Authentication validation call.
	//
	// Max Length: 2048
	ReturnURL string `json:"returnUrl,omitempty"`

	// This field indicates the maximum amount of time for all 3DS 2.0 messages to be communicated between all components (in minutes).
	//
	// Possible Values:
	//
	// Greater than or equal to 05 (05 is the minimum timeout to set)
	//
	// Cardinal Default is set to 15
	//
	// NOTE: This field is a required 3DS 2.0 field and Cardinal sends in a default of 15 if nothing is passed
	//
	// Max Length: 2
	SdkMaxTimeout string `json:"sdkMaxTimeout,omitempty"`

	// Indicates dedicated payment processes and procedures were used, potential secure corporate payment exemption applies.
	// Possible Values : 0/1
	//
	// Max Length: 1
	SecureCorporatePaymentIndicator string `json:"secureCorporatePaymentIndicator,omitempty"`

	// Payer authentication result (PARes) message returned by the card-issuing bank.
	// If you need to show proof of enrollment checking, you may need to
	// decrypt and parse the string for the information required by the payment card company.
	// For more information, see "Storing Payer Authentication Data," page 160.
	// Important The value is in base64. You must remove all carriage returns and line feeds before
	// adding the PARes to the request.
	//
	SignedPares string `json:"signedPares,omitempty"`

	// Provides additional information as to why the PAResStatus has a specific value.
	//
	// Max Length: 2
	SignedParesStatusReason string `json:"signedParesStatusReason,omitempty"`

	// strong authentication
	StrongAuthentication *CreatePaymentParamsBodyConsumerAuthenticationInformationStrongAuthentication `json:"strongAuthentication,omitempty"`

	// Transaction mode identifier. Identifies the channel from which the transaction originates.
	// Possible values:
	//
	// - `M`: MOTO (Mail Order Telephone Order)
	// - `R`: Retail
	// - `S`: eCommerce
	// - `P`: Mobile Device
	// - `T`: Tablet
	//
	TransactionMode string `json:"transactionMode,omitempty"`

	// Universal cardholder authentication field (UCAF) data.
	//
	// For details, see `ucaf_authentication_data` request field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// Max Length: 32
	UcafAuthenticationData string `json:"ucafAuthenticationData,omitempty"`

	// Universal cardholder authentication field (UCAF) collection indicator.
	//
	// For details, see `ucaf_collection_indicator` request field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// #### CyberSource through VisaNet
	// The value for this field corresponds to the following data in the TC 33 capture file5:
	// - Record: CP01 TCR7
	// - Position: 5
	// - Field: Mastercard Electronic Commerce IndicatorsUCAF Collection Indicator
	//
	// Max Length: 1
	UcafCollectionIndicator string `json:"ucafCollectionIndicator,omitempty"`

	// Verification response enrollment status.
	//
	// For details, see `veres_enrolled` request field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// Max Length: 1
	VeresEnrolled string `json:"veresEnrolled,omitempty"`

	// Enables the communication of trusted beneficiary/whitelist status between the ACS, the DS and the 3DS Requestor.
	//
	// Possible Values:
	//
	// Y - 3DS Requestor is whitelisted by cardholder
	//
	// N - 3DS Requestor is not whitelisted by cardholder
	//
	// Max Length: 1
	WhiteListStatus string `json:"whiteListStatus,omitempty"`

	// Transaction identifier.
	//
	// For details, see `xid` request field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// Max Length: 40
	Xid string `json:"xid,omitempty"`
}

// Validate validates this create payment params body consumer authentication information
func (o *CreatePaymentParamsBodyConsumerAuthenticationInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAcsTransactionID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAcsWindowSize(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAlternateAuthenticationData(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAlternateAuthenticationDate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAuthenticationDate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAuthenticationTransactionID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAuthenticationType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCavv(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCavvAlgorithm(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateChallengeCancelCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateChallengeStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCustomerCardAlias(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDecoupledAuthenticationIndicator(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDecoupledAuthenticationMaxTime(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDeviceChannel(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDirectoryServerTransactionID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEciRaw(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEffectiveAuthenticationType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMarketingSource(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMcc(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMerchantFraudRate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNetworkScore(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNpaCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOverrideCountryCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePaSpecificationVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateParesStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePriorAuthenticationData(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePriorAuthenticationMethod(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePriorAuthenticationReferenceID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePriorAuthenticationTime(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProductCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateReferenceID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRequestorID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRequestorInitiatedAuthenticationIndicator(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRequestorName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateReturnURL(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSdkMaxTimeout(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSecureCorporatePaymentIndicator(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSignedParesStatusReason(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateStrongAuthentication(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateUcafAuthenticationData(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateUcafCollectionIndicator(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateVeresEnrolled(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateWhiteListStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateXid(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyConsumerAuthenticationInformation) validateAcsTransactionID(formats strfmt.Registry) error {
	if swag.IsZero(o.AcsTransactionID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"consumerAuthenticationInformation"+"."+"acsTransactionId", "body", o.AcsTransactionID, 36); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyConsumerAuthenticationInformation) validateAcsWindowSize(formats strfmt.Registry) error {
	if swag.IsZero(o.AcsWindowSize) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"consumerAuthenticationInformation"+"."+"acsWindowSize", "body", o.AcsWindowSize, 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyConsumerAuthenticationInformation) validateAlternateAuthenticationData(formats strfmt.Registry) error {
	if swag.IsZero(o.AlternateAuthenticationData) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"consumerAuthenticationInformation"+"."+"alternateAuthenticationData", "body", o.AlternateAuthenticationData, 2048); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyConsumerAuthenticationInformation) validateAlternateAuthenticationDate(formats strfmt.Registry) error {
	if swag.IsZero(o.AlternateAuthenticationDate) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"consumerAuthenticationInformation"+"."+"alternateAuthenticationDate", "body", o.AlternateAuthenticationDate, 14); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyConsumerAuthenticationInformation) validateAuthenticationDate(formats strfmt.Registry) error {
	if swag.IsZero(o.AuthenticationDate) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"consumerAuthenticationInformation"+"."+"authenticationDate", "body", o.AuthenticationDate, 14); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyConsumerAuthenticationInformation) validateAuthenticationTransactionID(formats strfmt.Registry) error {
	if swag.IsZero(o.AuthenticationTransactionID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"consumerAuthenticationInformation"+"."+"authenticationTransactionId", "body", o.AuthenticationTransactionID, 20); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyConsumerAuthenticationInformation) validateAuthenticationType(formats strfmt.Registry) error {
	if swag.IsZero(o.AuthenticationType) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"consumerAuthenticationInformation"+"."+"authenticationType", "body", o.AuthenticationType, 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyConsumerAuthenticationInformation) validateCavv(formats strfmt.Registry) error {
	if swag.IsZero(o.Cavv) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"consumerAuthenticationInformation"+"."+"cavv", "body", o.Cavv, 40); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyConsumerAuthenticationInformation) validateCavvAlgorithm(formats strfmt.Registry) error {
	if swag.IsZero(o.CavvAlgorithm) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"consumerAuthenticationInformation"+"."+"cavvAlgorithm", "body", o.CavvAlgorithm, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyConsumerAuthenticationInformation) validateChallengeCancelCode(formats strfmt.Registry) error {
	if swag.IsZero(o.ChallengeCancelCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"consumerAuthenticationInformation"+"."+"challengeCancelCode", "body", o.ChallengeCancelCode, 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyConsumerAuthenticationInformation) validateChallengeStatus(formats strfmt.Registry) error {
	if swag.IsZero(o.ChallengeStatus) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"consumerAuthenticationInformation"+"."+"challengeStatus", "body", o.ChallengeStatus, 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyConsumerAuthenticationInformation) validateCustomerCardAlias(formats strfmt.Registry) error {
	if swag.IsZero(o.CustomerCardAlias) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"consumerAuthenticationInformation"+"."+"customerCardAlias", "body", o.CustomerCardAlias, 128); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyConsumerAuthenticationInformation) validateDecoupledAuthenticationIndicator(formats strfmt.Registry) error {
	if swag.IsZero(o.DecoupledAuthenticationIndicator) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"consumerAuthenticationInformation"+"."+"decoupledAuthenticationIndicator", "body", o.DecoupledAuthenticationIndicator, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyConsumerAuthenticationInformation) validateDecoupledAuthenticationMaxTime(formats strfmt.Registry) error {
	if swag.IsZero(o.DecoupledAuthenticationMaxTime) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"consumerAuthenticationInformation"+"."+"decoupledAuthenticationMaxTime", "body", o.DecoupledAuthenticationMaxTime, 5); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyConsumerAuthenticationInformation) validateDeviceChannel(formats strfmt.Registry) error {
	if swag.IsZero(o.DeviceChannel) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"consumerAuthenticationInformation"+"."+"deviceChannel", "body", o.DeviceChannel, 10); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyConsumerAuthenticationInformation) validateDirectoryServerTransactionID(formats strfmt.Registry) error {
	if swag.IsZero(o.DirectoryServerTransactionID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"consumerAuthenticationInformation"+"."+"directoryServerTransactionId", "body", o.DirectoryServerTransactionID, 36); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyConsumerAuthenticationInformation) validateEciRaw(formats strfmt.Registry) error {
	if swag.IsZero(o.EciRaw) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"consumerAuthenticationInformation"+"."+"eciRaw", "body", o.EciRaw, 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyConsumerAuthenticationInformation) validateEffectiveAuthenticationType(formats strfmt.Registry) error {
	if swag.IsZero(o.EffectiveAuthenticationType) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"consumerAuthenticationInformation"+"."+"effectiveAuthenticationType", "body", o.EffectiveAuthenticationType, 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyConsumerAuthenticationInformation) validateMarketingSource(formats strfmt.Registry) error {
	if swag.IsZero(o.MarketingSource) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"consumerAuthenticationInformation"+"."+"marketingSource", "body", o.MarketingSource, 40); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyConsumerAuthenticationInformation) validateMcc(formats strfmt.Registry) error {
	if swag.IsZero(o.Mcc) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"consumerAuthenticationInformation"+"."+"mcc", "body", o.Mcc, 4); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyConsumerAuthenticationInformation) validateMerchantFraudRate(formats strfmt.Registry) error {
	if swag.IsZero(o.MerchantFraudRate) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"consumerAuthenticationInformation"+"."+"merchantFraudRate", "body", o.MerchantFraudRate, 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyConsumerAuthenticationInformation) validateNetworkScore(formats strfmt.Registry) error {
	if swag.IsZero(o.NetworkScore) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"consumerAuthenticationInformation"+"."+"networkScore", "body", o.NetworkScore, 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyConsumerAuthenticationInformation) validateNpaCode(formats strfmt.Registry) error {
	if swag.IsZero(o.NpaCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"consumerAuthenticationInformation"+"."+"npaCode", "body", o.NpaCode, 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyConsumerAuthenticationInformation) validateOverrideCountryCode(formats strfmt.Registry) error {
	if swag.IsZero(o.OverrideCountryCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"consumerAuthenticationInformation"+"."+"overrideCountryCode", "body", o.OverrideCountryCode, 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyConsumerAuthenticationInformation) validatePaSpecificationVersion(formats strfmt.Registry) error {
	if swag.IsZero(o.PaSpecificationVersion) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"consumerAuthenticationInformation"+"."+"paSpecificationVersion", "body", o.PaSpecificationVersion, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyConsumerAuthenticationInformation) validateParesStatus(formats strfmt.Registry) error {
	if swag.IsZero(o.ParesStatus) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"consumerAuthenticationInformation"+"."+"paresStatus", "body", o.ParesStatus, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyConsumerAuthenticationInformation) validatePriorAuthenticationData(formats strfmt.Registry) error {
	if swag.IsZero(o.PriorAuthenticationData) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"consumerAuthenticationInformation"+"."+"priorAuthenticationData", "body", o.PriorAuthenticationData, 2048); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyConsumerAuthenticationInformation) validatePriorAuthenticationMethod(formats strfmt.Registry) error {
	if swag.IsZero(o.PriorAuthenticationMethod) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"consumerAuthenticationInformation"+"."+"priorAuthenticationMethod", "body", o.PriorAuthenticationMethod, 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyConsumerAuthenticationInformation) validatePriorAuthenticationReferenceID(formats strfmt.Registry) error {
	if swag.IsZero(o.PriorAuthenticationReferenceID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"consumerAuthenticationInformation"+"."+"priorAuthenticationReferenceId", "body", o.PriorAuthenticationReferenceID, 36); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyConsumerAuthenticationInformation) validatePriorAuthenticationTime(formats strfmt.Registry) error {
	if swag.IsZero(o.PriorAuthenticationTime) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"consumerAuthenticationInformation"+"."+"priorAuthenticationTime", "body", o.PriorAuthenticationTime, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyConsumerAuthenticationInformation) validateProductCode(formats strfmt.Registry) error {
	if swag.IsZero(o.ProductCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"consumerAuthenticationInformation"+"."+"productCode", "body", o.ProductCode, 3); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyConsumerAuthenticationInformation) validateReferenceID(formats strfmt.Registry) error {
	if swag.IsZero(o.ReferenceID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"consumerAuthenticationInformation"+"."+"referenceId", "body", o.ReferenceID, 50); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyConsumerAuthenticationInformation) validateRequestorID(formats strfmt.Registry) error {
	if swag.IsZero(o.RequestorID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"consumerAuthenticationInformation"+"."+"requestorId", "body", o.RequestorID, 35); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyConsumerAuthenticationInformation) validateRequestorInitiatedAuthenticationIndicator(formats strfmt.Registry) error {
	if swag.IsZero(o.RequestorInitiatedAuthenticationIndicator) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"consumerAuthenticationInformation"+"."+"requestorInitiatedAuthenticationIndicator", "body", o.RequestorInitiatedAuthenticationIndicator, 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyConsumerAuthenticationInformation) validateRequestorName(formats strfmt.Registry) error {
	if swag.IsZero(o.RequestorName) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"consumerAuthenticationInformation"+"."+"requestorName", "body", o.RequestorName, 40); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyConsumerAuthenticationInformation) validateReturnURL(formats strfmt.Registry) error {
	if swag.IsZero(o.ReturnURL) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"consumerAuthenticationInformation"+"."+"returnUrl", "body", o.ReturnURL, 2048); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyConsumerAuthenticationInformation) validateSdkMaxTimeout(formats strfmt.Registry) error {
	if swag.IsZero(o.SdkMaxTimeout) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"consumerAuthenticationInformation"+"."+"sdkMaxTimeout", "body", o.SdkMaxTimeout, 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyConsumerAuthenticationInformation) validateSecureCorporatePaymentIndicator(formats strfmt.Registry) error {
	if swag.IsZero(o.SecureCorporatePaymentIndicator) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"consumerAuthenticationInformation"+"."+"secureCorporatePaymentIndicator", "body", o.SecureCorporatePaymentIndicator, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyConsumerAuthenticationInformation) validateSignedParesStatusReason(formats strfmt.Registry) error {
	if swag.IsZero(o.SignedParesStatusReason) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"consumerAuthenticationInformation"+"."+"signedParesStatusReason", "body", o.SignedParesStatusReason, 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyConsumerAuthenticationInformation) validateStrongAuthentication(formats strfmt.Registry) error {
	if swag.IsZero(o.StrongAuthentication) { // not required
		return nil
	}

	if o.StrongAuthentication != nil {
		if err := o.StrongAuthentication.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "consumerAuthenticationInformation" + "." + "strongAuthentication")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "consumerAuthenticationInformation" + "." + "strongAuthentication")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyConsumerAuthenticationInformation) validateUcafAuthenticationData(formats strfmt.Registry) error {
	if swag.IsZero(o.UcafAuthenticationData) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"consumerAuthenticationInformation"+"."+"ucafAuthenticationData", "body", o.UcafAuthenticationData, 32); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyConsumerAuthenticationInformation) validateUcafCollectionIndicator(formats strfmt.Registry) error {
	if swag.IsZero(o.UcafCollectionIndicator) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"consumerAuthenticationInformation"+"."+"ucafCollectionIndicator", "body", o.UcafCollectionIndicator, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyConsumerAuthenticationInformation) validateVeresEnrolled(formats strfmt.Registry) error {
	if swag.IsZero(o.VeresEnrolled) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"consumerAuthenticationInformation"+"."+"veresEnrolled", "body", o.VeresEnrolled, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyConsumerAuthenticationInformation) validateWhiteListStatus(formats strfmt.Registry) error {
	if swag.IsZero(o.WhiteListStatus) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"consumerAuthenticationInformation"+"."+"whiteListStatus", "body", o.WhiteListStatus, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyConsumerAuthenticationInformation) validateXid(formats strfmt.Registry) error {
	if swag.IsZero(o.Xid) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"consumerAuthenticationInformation"+"."+"xid", "body", o.Xid, 40); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this create payment params body consumer authentication information based on the context it is used
func (o *CreatePaymentParamsBodyConsumerAuthenticationInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateStrongAuthentication(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyConsumerAuthenticationInformation) contextValidateStrongAuthentication(ctx context.Context, formats strfmt.Registry) error {

	if o.StrongAuthentication != nil {
		if err := o.StrongAuthentication.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "consumerAuthenticationInformation" + "." + "strongAuthentication")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "consumerAuthenticationInformation" + "." + "strongAuthentication")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyConsumerAuthenticationInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyConsumerAuthenticationInformation) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyConsumerAuthenticationInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyConsumerAuthenticationInformationStrongAuthentication create payment params body consumer authentication information strong authentication
swagger:model CreatePaymentParamsBodyConsumerAuthenticationInformationStrongAuthentication
*/
type CreatePaymentParamsBodyConsumerAuthenticationInformationStrongAuthentication struct {

	// Indicates the type of Authentication request
	//
	// 01 - Payment transaction
	//
	// 02 - Recurring transaction
	//
	// 03 - Installment transaction
	//
	// 04 - Add card
	//
	// 05 - Maintain card
	//
	// 06 - Cardholder verification as part of EMV token ID and V
	//
	// Max Length: 2
	AuthenticationIndicator string `json:"authenticationIndicator,omitempty"`

	// This field will contain the delegated authentication exemption indicator with one of the following values:
	// Possible values:
	// - `0`  (delegated Authentication exemption does not apply to the transaction)
	// - `1` (Transaction exempt from SCA as authentication has been delegated to other provider (PSP,Acquirer))
	//
	// Max Length: 1
	DelegatedAuthenticationExemptionIndicator string `json:"delegatedAuthenticationExemptionIndicator,omitempty"`

	// This field will contain the low value exemption indicator with one of the following values:
	// Possible values:
	// - `0`  ( low value exemption does not apply to the transaction)
	// - `1` (Transaction exempt from SCA as the merchant/acquirer has determined it to be a low value payment)
	//
	// Max Length: 1
	LowValueExemptionIndicator string `json:"lowValueExemptionIndicator,omitempty"`

	// This field will contain the outage exemption indicator with one of the following values:
	// Possible values:
	// - `0`  (Outage Authentication exemption does not apply to the transaction)
	// - `1` (Outage exempt from SCA as authentication could not be done due to outage)
	//
	// Max Length: 1
	OutageExemptionIndicator string `json:"outageExemptionIndicator,omitempty"`

	// This field will contain the transaction risk analysis exemption indicator with one of the following values:
	// Possible values:
	// - `0`  (TRA exemption does not apply to the transaction)
	// - `1` (Transaction exempt from SCA as the merchant/acquirer has determined it to be low risk in accordance with the criteria defined by PSD2/RTS)
	//
	// Max Length: 1
	RiskAnalysisExemptionIndicator string `json:"riskAnalysisExemptionIndicator,omitempty"`

	// This field will contain the secure corporate payment exemption indicator with one of the following values:
	// Possible values:
	// - `0`  (SCA exemption does not apply to the transaction)
	// - `1` (Transaction exempt from SCA as the merchant/acquirer has determined it as a secure corporate payment)
	//
	// Max Length: 1
	SecureCorporatePaymentIndicator string `json:"secureCorporatePaymentIndicator,omitempty"`

	// Possible values:
	// - `0`  (Trusted merchant exemption does not apply to the transaction)
	// - `1` (Transaction exempt from SCA as it originated at a merchant trusted by the cardholder)
	//
	// Max Length: 1
	TrustedMerchantExemptionIndicator string `json:"trustedMerchantExemptionIndicator,omitempty"`
}

// Validate validates this create payment params body consumer authentication information strong authentication
func (o *CreatePaymentParamsBodyConsumerAuthenticationInformationStrongAuthentication) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAuthenticationIndicator(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDelegatedAuthenticationExemptionIndicator(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLowValueExemptionIndicator(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOutageExemptionIndicator(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRiskAnalysisExemptionIndicator(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSecureCorporatePaymentIndicator(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTrustedMerchantExemptionIndicator(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyConsumerAuthenticationInformationStrongAuthentication) validateAuthenticationIndicator(formats strfmt.Registry) error {
	if swag.IsZero(o.AuthenticationIndicator) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"consumerAuthenticationInformation"+"."+"strongAuthentication"+"."+"authenticationIndicator", "body", o.AuthenticationIndicator, 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyConsumerAuthenticationInformationStrongAuthentication) validateDelegatedAuthenticationExemptionIndicator(formats strfmt.Registry) error {
	if swag.IsZero(o.DelegatedAuthenticationExemptionIndicator) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"consumerAuthenticationInformation"+"."+"strongAuthentication"+"."+"delegatedAuthenticationExemptionIndicator", "body", o.DelegatedAuthenticationExemptionIndicator, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyConsumerAuthenticationInformationStrongAuthentication) validateLowValueExemptionIndicator(formats strfmt.Registry) error {
	if swag.IsZero(o.LowValueExemptionIndicator) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"consumerAuthenticationInformation"+"."+"strongAuthentication"+"."+"lowValueExemptionIndicator", "body", o.LowValueExemptionIndicator, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyConsumerAuthenticationInformationStrongAuthentication) validateOutageExemptionIndicator(formats strfmt.Registry) error {
	if swag.IsZero(o.OutageExemptionIndicator) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"consumerAuthenticationInformation"+"."+"strongAuthentication"+"."+"outageExemptionIndicator", "body", o.OutageExemptionIndicator, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyConsumerAuthenticationInformationStrongAuthentication) validateRiskAnalysisExemptionIndicator(formats strfmt.Registry) error {
	if swag.IsZero(o.RiskAnalysisExemptionIndicator) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"consumerAuthenticationInformation"+"."+"strongAuthentication"+"."+"riskAnalysisExemptionIndicator", "body", o.RiskAnalysisExemptionIndicator, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyConsumerAuthenticationInformationStrongAuthentication) validateSecureCorporatePaymentIndicator(formats strfmt.Registry) error {
	if swag.IsZero(o.SecureCorporatePaymentIndicator) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"consumerAuthenticationInformation"+"."+"strongAuthentication"+"."+"secureCorporatePaymentIndicator", "body", o.SecureCorporatePaymentIndicator, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyConsumerAuthenticationInformationStrongAuthentication) validateTrustedMerchantExemptionIndicator(formats strfmt.Registry) error {
	if swag.IsZero(o.TrustedMerchantExemptionIndicator) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"consumerAuthenticationInformation"+"."+"strongAuthentication"+"."+"trustedMerchantExemptionIndicator", "body", o.TrustedMerchantExemptionIndicator, 1); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment params body consumer authentication information strong authentication based on context it is used
func (o *CreatePaymentParamsBodyConsumerAuthenticationInformationStrongAuthentication) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyConsumerAuthenticationInformationStrongAuthentication) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyConsumerAuthenticationInformationStrongAuthentication) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyConsumerAuthenticationInformationStrongAuthentication
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyDeviceInformation create payment params body device information
swagger:model CreatePaymentParamsBodyDeviceInformation
*/
type CreatePaymentParamsBodyDeviceInformation struct {

	// Field that contains the session ID that you send to Decision Manager to obtain the device fingerprint
	// information. The string can contain uppercase and lowercase letters, digits, hyphen (-), and
	// underscore (_). However, do not use the same uppercase and lowercase letters to indicate
	// different session IDs.
	//
	// The session ID must be unique for each merchant ID. You can use any string that you are already
	// generating, such as an order number or web session ID.
	//
	// The session ID must be unique for each page load, regardless of an individuals web session ID.
	// If a user navigates to a profiled page and is assigned a web session, navigates away from the
	// profiled page, then navigates back to the profiled page, the generated session ID should be different
	// and unique. You may use a web session ID, but it is preferable to use an application GUID (Globally
	// Unique Identifier). This measure ensures that a unique ID is generated every time the page is
	// loaded, even if it is the same user reloading the page.
	//
	FingerprintSessionID string `json:"fingerprintSessionId,omitempty"`

	// DNS resolved hostname from `ipAddress`.
	// Max Length: 60
	HostName string `json:"hostName,omitempty"`

	// Value of the Accept header sent by the customers web browser.
	// **Note** If the customers browser provides a value, you must include it in your request.
	//
	// Max Length: 255
	HTTPAcceptBrowserValue string `json:"httpAcceptBrowserValue,omitempty"`

	// The exact content of the HTTP accept header.
	//
	// Max Length: 256
	HTTPAcceptContent string `json:"httpAcceptContent,omitempty"`

	// Value represents the bit depth of the color palette for displaying images, in bits per pixel.
	// Example : 24, refer https://en.wikipedia.org/wiki/Color_depth for more details
	//
	// Max Length: 2
	HTTPBrowserColorDepth string `json:"httpBrowserColorDepth,omitempty"`

	// Email address set in the customers browser, which may differ from customer email.
	//
	HTTPBrowserEmail string `json:"httpBrowserEmail,omitempty"`

	// A Boolean value that represents the ability of the cardholder browser to execute Java.
	// Value is returned from the navigator.javaEnabled property. Possible Values:True/False
	//
	HTTPBrowserJavaEnabled bool `json:"httpBrowserJavaEnabled,omitempty"`

	// A Boolean value that represents the ability of the cardholder browser to execute JavaScript. Possible Values:True/False.
	// **Note**: Merchants should be able to know the values from fingerprint details of cardholder's browser.
	//
	HTTPBrowserJavaScriptEnabled bool `json:"httpBrowserJavaScriptEnabled,omitempty"`

	// Value represents the browser language as defined in IETF BCP47.
	// Example:en-US, refer  https://en.wikipedia.org/wiki/IETF_language_tag for more details.
	//
	// Max Length: 8
	HTTPBrowserLanguage string `json:"httpBrowserLanguage,omitempty"`

	// Total height of the Cardholder's scree in pixels, example: 864.
	//
	// Max Length: 6
	HTTPBrowserScreenHeight string `json:"httpBrowserScreenHeight,omitempty"`

	// Total width of the cardholder's screen in pixels. Example: 1536.
	//
	// Max Length: 6
	HTTPBrowserScreenWidth string `json:"httpBrowserScreenWidth,omitempty"`

	// Time difference between UTC time and the cardholder browser local time, in minutes, Example:300
	//
	// Max Length: 5
	HTTPBrowserTimeDifference string `json:"httpBrowserTimeDifference,omitempty"`

	// IP address of the customer.
	//
	// #### Used by
	// **Authorization, Capture, and Credit**
	// Optional field.
	//
	// Max Length: 45
	IPAddress string `json:"ipAddress,omitempty"`

	// raw data
	RawData []*CreatePaymentParamsBodyDeviceInformationRawDataItems0 `json:"rawData"`

	// Boolean that indicates whether request contains the device fingerprint information.
	// Values:
	// - `true`: Use raw fingerprintSessionId when looking up device details.
	// - `false` (default): Use merchant id + fingerprintSessionId as the session id for Device detail collection.
	//
	UseRawFingerprintSessionID bool `json:"useRawFingerprintSessionId,omitempty"`

	// Customers browser as identified from the HTTP header data. For example, `Mozilla` is the value that identifies
	// the Netscape browser.
	//
	// Max Length: 40
	UserAgent string `json:"userAgent,omitempty"`

	// Value of the User-Agent header sent by the customers web browser.
	// Note If the customers browser provides a value, you must include it in your request.
	//
	// Max Length: 255
	UserAgentBrowserValue string `json:"userAgentBrowserValue,omitempty"`
}

// Validate validates this create payment params body device information
func (o *CreatePaymentParamsBodyDeviceInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateHostName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateHTTPAcceptBrowserValue(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateHTTPAcceptContent(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateHTTPBrowserColorDepth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateHTTPBrowserLanguage(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateHTTPBrowserScreenHeight(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateHTTPBrowserScreenWidth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateHTTPBrowserTimeDifference(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateIPAddress(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRawData(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateUserAgent(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateUserAgentBrowserValue(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyDeviceInformation) validateHostName(formats strfmt.Registry) error {
	if swag.IsZero(o.HostName) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"deviceInformation"+"."+"hostName", "body", o.HostName, 60); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyDeviceInformation) validateHTTPAcceptBrowserValue(formats strfmt.Registry) error {
	if swag.IsZero(o.HTTPAcceptBrowserValue) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"deviceInformation"+"."+"httpAcceptBrowserValue", "body", o.HTTPAcceptBrowserValue, 255); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyDeviceInformation) validateHTTPAcceptContent(formats strfmt.Registry) error {
	if swag.IsZero(o.HTTPAcceptContent) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"deviceInformation"+"."+"httpAcceptContent", "body", o.HTTPAcceptContent, 256); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyDeviceInformation) validateHTTPBrowserColorDepth(formats strfmt.Registry) error {
	if swag.IsZero(o.HTTPBrowserColorDepth) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"deviceInformation"+"."+"httpBrowserColorDepth", "body", o.HTTPBrowserColorDepth, 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyDeviceInformation) validateHTTPBrowserLanguage(formats strfmt.Registry) error {
	if swag.IsZero(o.HTTPBrowserLanguage) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"deviceInformation"+"."+"httpBrowserLanguage", "body", o.HTTPBrowserLanguage, 8); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyDeviceInformation) validateHTTPBrowserScreenHeight(formats strfmt.Registry) error {
	if swag.IsZero(o.HTTPBrowserScreenHeight) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"deviceInformation"+"."+"httpBrowserScreenHeight", "body", o.HTTPBrowserScreenHeight, 6); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyDeviceInformation) validateHTTPBrowserScreenWidth(formats strfmt.Registry) error {
	if swag.IsZero(o.HTTPBrowserScreenWidth) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"deviceInformation"+"."+"httpBrowserScreenWidth", "body", o.HTTPBrowserScreenWidth, 6); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyDeviceInformation) validateHTTPBrowserTimeDifference(formats strfmt.Registry) error {
	if swag.IsZero(o.HTTPBrowserTimeDifference) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"deviceInformation"+"."+"httpBrowserTimeDifference", "body", o.HTTPBrowserTimeDifference, 5); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyDeviceInformation) validateIPAddress(formats strfmt.Registry) error {
	if swag.IsZero(o.IPAddress) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"deviceInformation"+"."+"ipAddress", "body", o.IPAddress, 45); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyDeviceInformation) validateRawData(formats strfmt.Registry) error {
	if swag.IsZero(o.RawData) { // not required
		return nil
	}

	for i := 0; i < len(o.RawData); i++ {
		if swag.IsZero(o.RawData[i]) { // not required
			continue
		}

		if o.RawData[i] != nil {
			if err := o.RawData[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("createPaymentRequest" + "." + "deviceInformation" + "." + "rawData" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("createPaymentRequest" + "." + "deviceInformation" + "." + "rawData" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CreatePaymentParamsBodyDeviceInformation) validateUserAgent(formats strfmt.Registry) error {
	if swag.IsZero(o.UserAgent) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"deviceInformation"+"."+"userAgent", "body", o.UserAgent, 40); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyDeviceInformation) validateUserAgentBrowserValue(formats strfmt.Registry) error {
	if swag.IsZero(o.UserAgentBrowserValue) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"deviceInformation"+"."+"userAgentBrowserValue", "body", o.UserAgentBrowserValue, 255); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this create payment params body device information based on the context it is used
func (o *CreatePaymentParamsBodyDeviceInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateRawData(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyDeviceInformation) contextValidateRawData(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.RawData); i++ {

		if o.RawData[i] != nil {
			if err := o.RawData[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("createPaymentRequest" + "." + "deviceInformation" + "." + "rawData" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("createPaymentRequest" + "." + "deviceInformation" + "." + "rawData" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyDeviceInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyDeviceInformation) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyDeviceInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyDeviceInformationRawDataItems0 create payment params body device information raw data items0
swagger:model CreatePaymentParamsBodyDeviceInformationRawDataItems0
*/
type CreatePaymentParamsBodyDeviceInformationRawDataItems0 struct {

	// Field that contains the device fingerprint data from the specified provider. The value should be Base64 encoded.
	//
	Data string `json:"data,omitempty"`

	// Possible values:
	// - cardinal
	// - inauth
	// - threatmetrix
	//
	// Max Length: 32
	Provider string `json:"provider,omitempty"`
}

// Validate validates this create payment params body device information raw data items0
func (o *CreatePaymentParamsBodyDeviceInformationRawDataItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateProvider(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyDeviceInformationRawDataItems0) validateProvider(formats strfmt.Registry) error {
	if swag.IsZero(o.Provider) { // not required
		return nil
	}

	if err := validate.MaxLength("provider", "body", o.Provider, 32); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment params body device information raw data items0 based on context it is used
func (o *CreatePaymentParamsBodyDeviceInformationRawDataItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyDeviceInformationRawDataItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyDeviceInformationRawDataItems0) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyDeviceInformationRawDataItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyHealthCareInformation create payment params body health care information
swagger:model CreatePaymentParamsBodyHealthCareInformation
*/
type CreatePaymentParamsBodyHealthCareInformation struct {

	// array for Healthcare fields
	AmountDetails []*CreatePaymentParamsBodyHealthCareInformationAmountDetailsItems0 `json:"amountDetails"`
}

// Validate validates this create payment params body health care information
func (o *CreatePaymentParamsBodyHealthCareInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAmountDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyHealthCareInformation) validateAmountDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.AmountDetails) { // not required
		return nil
	}

	for i := 0; i < len(o.AmountDetails); i++ {
		if swag.IsZero(o.AmountDetails[i]) { // not required
			continue
		}

		if o.AmountDetails[i] != nil {
			if err := o.AmountDetails[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("createPaymentRequest" + "." + "healthCareInformation" + "." + "amountDetails" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("createPaymentRequest" + "." + "healthCareInformation" + "." + "amountDetails" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this create payment params body health care information based on the context it is used
func (o *CreatePaymentParamsBodyHealthCareInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateAmountDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyHealthCareInformation) contextValidateAmountDetails(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.AmountDetails); i++ {

		if o.AmountDetails[i] != nil {
			if err := o.AmountDetails[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("createPaymentRequest" + "." + "healthCareInformation" + "." + "amountDetails" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("createPaymentRequest" + "." + "healthCareInformation" + "." + "amountDetails" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyHealthCareInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyHealthCareInformation) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyHealthCareInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyHealthCareInformationAmountDetailsItems0 create payment params body health care information amount details items0
swagger:model CreatePaymentParamsBodyHealthCareInformationAmountDetailsItems0
*/
type CreatePaymentParamsBodyHealthCareInformationAmountDetailsItems0 struct {

	// Total Amount that has been spent on the corresponding amountType. This is 13 byte field including sign.
	// If the amount is positive, then it is a debit for the customer.
	// If the amount is negative, then it is a credit for the customer.
	//
	// Max Length: 13
	Amount string `json:"amount,omitempty"`

	// Total amount that has been spent on healthcare in a transaction.
	// Valid Values for **Visa**:
	// - `healthcare` - Total Amount Healthcare
	// - `healthcare-transit` - Amount Transit
	// - `vision` - Amount Vision/Optical
	// - `prescription` - Amount Prescription/RX
	// - `clinic` - Amount Clinic/Other Qualified Medical
	// - `dental` - Amount Dental
	//
	//
	// `Note:` -  Prescription, Clinic and dental amounts must be preceded with the total healthcare amount and cannot occur individually.  Vision and Transit must be sent individually and cannot be combined with total healthcare amount or any other amounts. Total Healthcare amount can be sent individually.
	//
	// Valid Values for **MasterCard**:
	// - `prescription` - Amount Prescription/RX
	// - `eligible-total` - Total Amount Healthcare
	//
	//
	// `Note:` -  Prescription must be preceded with the total healthcare amount and cannot occur individually. Total Healthcare amount can be sent individually.
	//
	// Max Length: 35
	AmountType string `json:"amountType,omitempty"`
}

// Validate validates this create payment params body health care information amount details items0
func (o *CreatePaymentParamsBodyHealthCareInformationAmountDetailsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAmountType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyHealthCareInformationAmountDetailsItems0) validateAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.Amount) { // not required
		return nil
	}

	if err := validate.MaxLength("amount", "body", o.Amount, 13); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyHealthCareInformationAmountDetailsItems0) validateAmountType(formats strfmt.Registry) error {
	if swag.IsZero(o.AmountType) { // not required
		return nil
	}

	if err := validate.MaxLength("amountType", "body", o.AmountType, 35); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment params body health care information amount details items0 based on context it is used
func (o *CreatePaymentParamsBodyHealthCareInformationAmountDetailsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyHealthCareInformationAmountDetailsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyHealthCareInformationAmountDetailsItems0) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyHealthCareInformationAmountDetailsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyInstallmentInformation create payment params body installment information
swagger:model CreatePaymentParamsBodyInstallmentInformation
*/
type CreatePaymentParamsBodyInstallmentInformation struct {

	// Amount for the current installment payment.
	//
	// This field is supported only for CyberSource through VisaNet.
	//
	// For details, see `installment_amount` field description in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// Max Length: 12
	Amount string `json:"amount,omitempty"`

	// Indicates whether the authorization request is a Crediario eligibility inquiry.
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// Set the value for this field to `Crediario`.
	//
	// This field is supported only for Crediario installment payments in Brazil on CyberSource through VisaNet.
	//
	// Max Length: 9
	EligibilityInquiry string `json:"eligibilityInquiry,omitempty"`

	// Amount of the first installment payment. The issuer provides this value when the first installment payment is successful.
	// This field is supported for Mastercard installment payments on CyberSource through VisaNet in all countries except Brazil,Croatia, Georgia, and Greece.
	// The value for this field corresponds to the following data in the TC 33 capture file:
	// - Record: CP01 TCR5
	// - Position: 23-34
	// - Field: Amount of Each Installment
	//
	// Max Length: 13
	FirstInstallmentAmount string `json:"firstInstallmentAmount,omitempty"`

	// Date of the first installment payment. Format: YYMMDD. When you do not include this field, CyberSource sends a string of six zeros (000000) to the processor.
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// This field is supported only for Crediario installment payments in Brazil on CyberSource through VisaNet.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file:
	// - Record: CP01 TCR9
	// - Position: 42-47
	// - Field: Date of First Installment
	//
	// Max Length: 6
	FirstInstallmentDate string `json:"firstInstallmentDate,omitempty"`

	// Frequency of the installment payments. When you do not include this field in a request for a
	// Crediario installment payment, CyberSource sends a space character to the processor.
	//
	// For details, see `installment_frequency` field description in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// This field is supported only for CyberSource through VisaNet. Possible values:
	// - `B`: Biweekly
	// - `M`: Monthly
	// - `W`: Weekly
	//
	// For Crediario installment payments, the value for this field corresponds to the following data in the TC 33 capture file5:
	// - Record: CP01 TCR9
	// - Position: 41
	// - Field: Installment Frequency
	//
	// For details, see "Installment Payments" in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// Max Length: 1
	Frequency string `json:"frequency,omitempty"`

	// Grace period requested by the customer before the first installment payment is due.
	//
	// When you include this field in a request, you must also include the grace period duration type field.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file3: Record: CP01 TCR5, Position: 100-101, Field: Mastercard Grace Period Details.
	//
	// This field is supported only for Mastercard installment payments in Brazil and Greece.
	//
	GracePeriodDuration string `json:"gracePeriodDuration,omitempty"`

	// Unit for the requested grace period duration.
	//
	// Possible values:
	// - `D`: Days
	// - `W`: Weeks
	// - `M`: Months
	//
	// The value for this field corresponds to the following data in the TC 33 capture file3: Record: CP01 TCR5, Position: 99, Field: Mastercard Grace Period Details
	//
	// This field is supported only for Mastercard installment payments in Brazil and Greece on CyberSource through VisaNet.
	//
	// Max Length: 1
	GracePeriodDurationType string `json:"gracePeriodDurationType,omitempty"`

	// Standing Instruction/Installment identifier.
	//
	Identifier string `json:"identifier,omitempty"`

	// Invoice information that you want to provide to the issuer. This value is similar to a tracking number and is
	// the same for all installment payments for one purchase.
	//
	// This field is supported only for installment payments with Mastercard on CyberSource through VisaNet in Brazil.
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// The value for this field corresponds to the following data in the TC 33 capture file5:
	// - Record: CP07 TCR4
	// - Position: 51-70
	// - Field: Purchase Identification
	//
	// Max Length: 20
	InvoiceData string `json:"invoiceData,omitempty"`

	// Payment plan for the installments.
	//
	// Possible values:
	// - 0 (default): Regular installment. This value is not allowed for airline transactions.
	// - 1: Installment payment with down payment.
	// - 2: Installment payment without down payment. This value is supported only for airline transactions.
	// - 3: Installment payment; down payment and boarding fee will follow. This value is supported only for airline transactions.
	// - 4: Down payment only; regular installment payment will follow.
	// - 5: Boarding fee only. This value is supported only for airline transactions.
	//
	// This field is supported only for installment payments with Visa on CyberSource through VisaNet in Brazil.
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// The value for this field corresponds to the following data in the TC 33 capture file5:
	// - Record: CP07 TCR1
	// - Position: 9
	// - Field: Merchant Installment Supporting Information
	//
	// Max Length: 1
	PaymentType string `json:"paymentType,omitempty"`

	// #### American Express Direct, Cielo, and CyberSource Latin American Processing
	// Flag that indicates the type of funding for the installment plan associated with the payment.
	//
	// Possible values:
	// - `1`: Merchant-funded installment plan
	// - `2`: Issuer-funded installment plan
	// If you do not include this field in the request, CyberSource uses the value in your CyberSource account.
	//
	// To change the value in your CyberSource account, contact CyberSource Customer Service.
	// For details, see `installment_plan_type` field description in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// #### CyberSource through VisaNet and American Express
	// Defined code that indicates the type of installment plan for this transaction.
	//
	// Contact American Express for:
	// - Information about the kinds of installment plans that American Express provides
	// - Values for this field
	//
	// For installment payments with American Express in Brazil, the value for this field corresponds to the following data in the TC 33 capture file*:
	// - Record: CP07 TCR3
	// - Position: 5-6
	// - Field: Plan Type
	//
	// * The TC 33 Capture file contains information about the purchases and refunds that a merchant submits to CyberSource. CyberSource through VisaNet creates the TC 33 Capture file at the end of the day and sends it to the merchants acquirer, who uses this information to facilitate end-of-day clearing processing with payment card companies.
	//
	// #### CyberSource through VisaNet with Visa or Mastercard
	// Flag indicating the type of funding for the installment plan associated with the payment.
	// Possible values:
	// - 1 or 01: Merchant-funded installment plan
	// - 2 or 02: Issuer-funded installment plan
	// - 43: Crediario installment planonly with Visa in Brazil
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// For installment payments with Visa in Brazil, the value for this field corresponds to the following data in the TC 33 capture file5:
	// - Record: CP07 TCR1
	// - Position: 5-6
	// - Field: Installment Type
	//
	// For all other kinds of installment payments, the value for this field corresponds to the following data in the TC 33 capture file5:
	// - Record: CP01 TCR5
	// - Position: 39-40
	// - Field: Installment Plan Type (Issuer or Merchant)
	//
	// Max Length: 1
	PlanType string `json:"planType,omitempty"`

	// Installment number when making payments in installments. Used along with `totalCount` to track which payment is being processed.
	//
	// For example, the second of 5 payments would be passed to CyberSource as `sequence` = 2 and `totalCount` = 5.
	//
	// For details, see "Installment Payments" in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// #### Chase Paymentech Solutions and FDC Compass
	// This field is optional because this value is required in the merchant descriptors.
	// For details, see "Chase Paymentech Solutions Merchant Descriptors" and "FDC Compass Merchant Descriptors" in the [Merchant Descriptors Using the SCMP API]
	// (https://apps.cybersource.com/library/documentation/dev_guides/Merchant_Descriptors_SCMP_API/html/)
	//
	// #### CyberSource through VisaNet
	// When you do not include this field in a request for a Crediario installment payment, CyberSource sends a value of 0 to the processor.
	//
	// For Crediario installment payments, the value for this field corresponds to the following data in the TC 33 capture file*:
	// - Record: CP01 TCR9
	// - Position: 38-40
	// - Field: Installment Payment Number
	//
	// * The TC 33 Capture file contains information about the purchases and refunds that a merchant submits to CyberSource. CyberSource through VisaNet creates the TC 33 Capture file at the end of the day and sends it to the merchants acquirer, who uses this information to facilitate end-of-day clearing processing with payment card companies.
	//
	// Maximum: 99
	Sequence int64 `json:"sequence,omitempty"`

	// Total amount of the loan that is being paid in installments. This field is supported only for CyberSource
	// through VisaNet.
	//
	// For details, see "Installment Payments" in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// Max Length: 12
	TotalAmount string `json:"totalAmount,omitempty"`

	// Total number of installments when making payments in installments.
	//
	// For details, see "Installment Payments" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// #### Chase Paymentech Solutions and FDC Compass
	// This field is optional because this value is required in the merchant descriptors.
	//
	// For details, see "Chase Paymentech Solutions Merchant Descriptors" and "FDC Compass Merchant Descriptors" in the [Merchant Descriptors Using the SCMP API.]
	// (https://apps.cybersource.com/library/documentation/dev_guides/Merchant_Descriptors_SCMP_API/html/)
	//
	// #### American Express Direct, Cielo, and Comercio Latino
	// This value is the total number of installments you approved.
	//
	// #### CyberSource Latin American Processing in Brazil
	// This value is the total number of installments that you approved. The default is 1.
	//
	// #### All Other Processors
	// This value is used along with _sequence_ to track which payment is being processed.
	//
	// For example, the second of 5 payments would be passed to CyberSource as _sequence_ = 2 and _totalCount_ = 5.
	//
	// #### CyberSource through VisaNet
	// For Crediario installment payments, the value for this field corresponds to the following data in the TC 33 capture file*:
	// - Record: CP01 TCR9
	// - Position: 23-25
	// - Field: Number of Installments
	//
	// For installment payments with American Express in Brazil, the value for this field corresponds to the following data in the TC 33 capture file*:
	// - Record: CP07 TCR3
	// - Position: 7-8
	// - Field: Number of Installments
	//
	// For installment payments with Visa in Brazil, the value for this field corresponds to the following data in the TC 33 capture file*:
	// - Record: CP07 TCR1
	// - Position: 7-8
	// - Field: Number of Installments
	//
	// For all other kinds of installment payments, the value for this field corresponds to the following data in the TC 33 capture file*:
	// - Record: CP01 TCR5
	// - Position: 20-22
	// - Field: Installment Total Count
	//
	// **Note** The TC 33 Capture file contains information about the purchases and refunds that a merchant submits to CyberSource. CyberSource through VisaNet creates the TC 33 Capture file at the end of the day and sends it to the merchants acquirer, who uses this information to facilitate end-of-day clearing processing with payment card companies.
	//
	// Maximum: 99
	TotalCount int64 `json:"totalCount,omitempty"`

	// Standing Instruction/Installment validation indicator.
	// - '1': Prevalidated
	// - '2': Not Validated
	//
	ValidationIndicator string `json:"validationIndicator,omitempty"`
}

// Validate validates this create payment params body installment information
func (o *CreatePaymentParamsBodyInstallmentInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEligibilityInquiry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFirstInstallmentAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFirstInstallmentDate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFrequency(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateGracePeriodDurationType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateInvoiceData(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePaymentType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePlanType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSequence(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTotalAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTotalCount(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyInstallmentInformation) validateAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.Amount) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"installmentInformation"+"."+"amount", "body", o.Amount, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyInstallmentInformation) validateEligibilityInquiry(formats strfmt.Registry) error {
	if swag.IsZero(o.EligibilityInquiry) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"installmentInformation"+"."+"eligibilityInquiry", "body", o.EligibilityInquiry, 9); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyInstallmentInformation) validateFirstInstallmentAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.FirstInstallmentAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"installmentInformation"+"."+"firstInstallmentAmount", "body", o.FirstInstallmentAmount, 13); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyInstallmentInformation) validateFirstInstallmentDate(formats strfmt.Registry) error {
	if swag.IsZero(o.FirstInstallmentDate) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"installmentInformation"+"."+"firstInstallmentDate", "body", o.FirstInstallmentDate, 6); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyInstallmentInformation) validateFrequency(formats strfmt.Registry) error {
	if swag.IsZero(o.Frequency) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"installmentInformation"+"."+"frequency", "body", o.Frequency, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyInstallmentInformation) validateGracePeriodDurationType(formats strfmt.Registry) error {
	if swag.IsZero(o.GracePeriodDurationType) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"installmentInformation"+"."+"gracePeriodDurationType", "body", o.GracePeriodDurationType, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyInstallmentInformation) validateInvoiceData(formats strfmt.Registry) error {
	if swag.IsZero(o.InvoiceData) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"installmentInformation"+"."+"invoiceData", "body", o.InvoiceData, 20); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyInstallmentInformation) validatePaymentType(formats strfmt.Registry) error {
	if swag.IsZero(o.PaymentType) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"installmentInformation"+"."+"paymentType", "body", o.PaymentType, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyInstallmentInformation) validatePlanType(formats strfmt.Registry) error {
	if swag.IsZero(o.PlanType) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"installmentInformation"+"."+"planType", "body", o.PlanType, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyInstallmentInformation) validateSequence(formats strfmt.Registry) error {
	if swag.IsZero(o.Sequence) { // not required
		return nil
	}

	if err := validate.MaximumInt("createPaymentRequest"+"."+"installmentInformation"+"."+"sequence", "body", o.Sequence, 99, false); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyInstallmentInformation) validateTotalAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.TotalAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"installmentInformation"+"."+"totalAmount", "body", o.TotalAmount, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyInstallmentInformation) validateTotalCount(formats strfmt.Registry) error {
	if swag.IsZero(o.TotalCount) { // not required
		return nil
	}

	if err := validate.MaximumInt("createPaymentRequest"+"."+"installmentInformation"+"."+"totalCount", "body", o.TotalCount, 99, false); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment params body installment information based on context it is used
func (o *CreatePaymentParamsBodyInstallmentInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyInstallmentInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyInstallmentInformation) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyInstallmentInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyIssuerInformation create payment params body issuer information
swagger:model CreatePaymentParamsBodyIssuerInformation
*/
type CreatePaymentParamsBodyIssuerInformation struct {

	// Data defined by the issuer.
	//
	// The value for this reply field will probably be the same as the value that you submitted in the authorization request, but it is possible for the processor, issuer, or acquirer to modify the value.
	//
	// This field is supported only for Visa transactions on **CyberSource through VisaNet**.
	//
	// For details, see `issuer_additional_data` field description in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// Max Length: 255
	DiscretionaryData string `json:"discretionaryData,omitempty"`
}

// Validate validates this create payment params body issuer information
func (o *CreatePaymentParamsBodyIssuerInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDiscretionaryData(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyIssuerInformation) validateDiscretionaryData(formats strfmt.Registry) error {
	if swag.IsZero(o.DiscretionaryData) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"issuerInformation"+"."+"discretionaryData", "body", o.DiscretionaryData, 255); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment params body issuer information based on context it is used
func (o *CreatePaymentParamsBodyIssuerInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyIssuerInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyIssuerInformation) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyIssuerInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyMerchantDefinedInformationItems0 create payment params body merchant defined information items0
swagger:model CreatePaymentParamsBodyMerchantDefinedInformationItems0
*/
type CreatePaymentParamsBodyMerchantDefinedInformationItems0 struct {

	// The number you assign for as the key for your merchant-defined data field. Valid values are 0 to 100.
	//
	// For example, to set or access the key for the 2nd merchant-defined data field in the array, you would reference `merchantDefinedInformation[1].key`.
	//
	// #### CyberSource through VisaNet
	// For installment payments with Mastercard in Brazil, use `merchantDefinedInformation[0].key` and
	// `merchantDefinedInformation[1].key` for data that you want to provide to the issuer to identify the
	// transaction.
	//
	// For details, see the `merchant_defined_data1` request-level field description in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// Max Length: 50
	Key string `json:"key,omitempty"`

	// The value you assign for your merchant-defined data field.
	//
	// For details, see `merchant_defined_data1` field description in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// **Warning** Merchant-defined data fields are not intended to and must not be used to capture personally identifying information. Accordingly, merchants are prohibited from capturing, obtaining, and/or transmitting any personally identifying information in or via the merchant-defined data fields. Personally identifying information includes, but is not
	// limited to, address, credit card number, social security number, driver's license number, state-issued identification number, passport number, and card verification numbers (CVV,
	// CVC2, CVV2, CID, CVN). In the event CyberSource discovers that a merchant is capturing and/or transmitting personally identifying information via the merchant-defined data fields, whether or not intentionally, CyberSource will immediately suspend the merchant's account, which will result in a rejection of any and all transaction requests submitted by the merchant after the point of suspension.
	//
	// #### CyberSource through VisaNet
	// For installment payments with Mastercard in Brazil, use `merchantDefinedInformation[0].value` and
	// `merchantDefinedInformation[1].value` for data that you want to provide to the issuer to identify the
	// transaction. For details, see "Installment Payments on CyberSource through VisaNet" in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// For installment payments with Mastercard in Brazil:
	// - The value for merchantDefinedInformation[0].value corresponds to the following data in the TC 33 capture file5:
	//   - Record: CP07 TCR5
	//   - Position: 25-44
	//   - Field: Reference Field 2
	// - The value for merchantDefinedInformation[1].value corresponds to the following data in the TC 33 capture file5:
	//   - Record: CP07 TCR5
	//   - Position: 45-64
	//   - Field: Reference Field 3
	//
	// Max Length: 255
	Value string `json:"value,omitempty"`
}

// Validate validates this create payment params body merchant defined information items0
func (o *CreatePaymentParamsBodyMerchantDefinedInformationItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateKey(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateValue(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyMerchantDefinedInformationItems0) validateKey(formats strfmt.Registry) error {
	if swag.IsZero(o.Key) { // not required
		return nil
	}

	if err := validate.MaxLength("key", "body", o.Key, 50); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyMerchantDefinedInformationItems0) validateValue(formats strfmt.Registry) error {
	if swag.IsZero(o.Value) { // not required
		return nil
	}

	if err := validate.MaxLength("value", "body", o.Value, 255); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment params body merchant defined information items0 based on context it is used
func (o *CreatePaymentParamsBodyMerchantDefinedInformationItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyMerchantDefinedInformationItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyMerchantDefinedInformationItems0) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyMerchantDefinedInformationItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyMerchantInformation create payment params body merchant information
swagger:model CreatePaymentParamsBodyMerchantInformation
*/
type CreatePaymentParamsBodyMerchantInformation struct {

	// Reference number that facilitates card acceptor/corporation communication and record keeping.
	//
	// For processor-specific information, see the `card_acceptor_ref_number` field description in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 25
	CardAcceptorReferenceNumber string `json:"cardAcceptorReferenceNumber,omitempty"`

	// The value for this field is a four-digit number that the payment card industry uses to classify
	// merchants into market segments. A payment card company assigned one or more of these values to your business when you started
	// accepting the payment card companys cards. When you do not include this field in your request, CyberSource uses the value in your
	// CyberSource account.
	//
	// For processor-specific information, see the `merchant_category_code` field description in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// #### CyberSource through VisaNet
	// The value for this field corresponds to the following data in the TC 33 capture file5:
	// - Record: CP01 TCR4
	// - Position: 150-153
	// - Field: Merchant Category Code
	//
	// Maximum: 9999
	CategoryCode int64 `json:"categoryCode,omitempty"`

	// Merchant category code for domestic transactions. The value for this field is a four-digit number that the payment
	// card industry uses to classify merchants into market segments. A payment card company assigned one or more of these
	// values to your business when you started accepting the payment card companys cards. Including this field in a request
	// for a domestic transaction might reduce interchange fees.
	//
	// When you include this field in a request:
	// - Do not include the `merchant_category_code` field.
	// - The value for this field overrides the value in your CyberSource account.
	//
	// This field is supported only for:
	// - Domestic transactions with Mastercard in Spain. Domestic means that you and the cardholder are in the same country.
	// - Merchants enrolled in the OmniPay Direct interchange program.
	// - First Data Merchant Solutions (Europe) on OmniPay Direct.
	//
	// Maximum: 9999
	CategoryCodeDomestic int64 `json:"categoryCodeDomestic,omitempty"`

	// This field will contain either the merchant url or the reverse domain as per the requirement for DSRP Format 3. This might vary transaction to transaction and might not be static. Merchant needs to have access to send this value for all DSRP program.
	//
	// Max Length: 127
	DomainName string `json:"domainName,omitempty"`

	// merchant descriptor
	MerchantDescriptor *CreatePaymentParamsBodyMerchantInformationMerchantDescriptor `json:"merchantDescriptor,omitempty"`

	// Use this field only if you are requesting payment with Payer Authentication serice together.
	//
	// Your companys name as you want it to appear to the customer in the issuing banks authentication form.
	// This value overrides the value specified by your merchant bank.
	//
	// Max Length: 25
	MerchantName string `json:"merchantName,omitempty"`

	// Company ID assigned to an independent sales organization. Get this value from Mastercard.
	//
	// #### CyberSource through VisaNet
	// The value for this field corresponds to the following data in the TC 33 capture file:
	// - Record: CP01 TCR6
	// - Position: 106-116
	// - Field: Mastercard Independent Sales Organization ID
	//
	// **Note** The TC 33 Capture file contains information about the purchases and refunds that a merchant submits to CyberSource. CyberSource through VisaNet creates the TC 33 Capture file at the end of the day and sends it to the merchants acquirer, who uses this information to facilitate end-of-day clearing processing with payment card companies.
	//
	// For processor-specific information, see the `sales_organization_ID` field description in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 11
	SalesOrganizationID string `json:"salesOrganizationId,omitempty"`

	// service fee descriptor
	ServiceFeeDescriptor *CreatePaymentParamsBodyMerchantInformationServiceFeeDescriptor `json:"serviceFeeDescriptor,omitempty"`

	// Your Cadastro Nacional da Pessoa Jurdica (CNPJ) number.
	//
	// This field is supported only for BNDES transactions on CyberSource through VisaNet.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file5:
	// - Record: CP07 TCR6
	// - Position: 40-59
	// - Field: BNDES Reference Field 1
	//
	// For details, see `bill_merchant_tax_id` field description in the [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// Max Length: 15
	TaxID string `json:"taxId,omitempty"`

	// Date and time at your physical location.
	//
	// Format: `YYYYMMDDhhmmss`, where:
	//  - `YYYY` = year
	//  - `MM` = month
	//  - `DD` = day
	//  - `hh` = hour
	//  - `mm` = minutes
	//  - `ss` = seconds
	//
	// #### Used by
	// **Authorization**
	// Required for these processors:
	// - American Express Direct                                                                                                                                                                                                                                                                                                                         - American Express Direct
	// - Credit Mutuel-CIC
	// - FDC Nashville Global
	// - SIX
	//
	// Optional for all other processors.
	//
	// Max Length: 14
	TransactionLocalDateTime string `json:"transactionLocalDateTime,omitempty"`

	// Your government-assigned tax identification number.
	//
	// #### Tax Calculation
	// Required field for value added tax only. Not applicable to U.S. and Canadian taxes.
	//
	// #### CyberSource through VisaNet
	// For CtV processors, the maximum length is 20.
	//
	// For other processor-specific information, see the `merchant_vat_registration_number` field description in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 21
	VatRegistrationNumber string `json:"vatRegistrationNumber,omitempty"`
}

// Validate validates this create payment params body merchant information
func (o *CreatePaymentParamsBodyMerchantInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCardAcceptorReferenceNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCategoryCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCategoryCodeDomestic(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDomainName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMerchantDescriptor(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMerchantName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSalesOrganizationID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateServiceFeeDescriptor(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTransactionLocalDateTime(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateVatRegistrationNumber(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyMerchantInformation) validateCardAcceptorReferenceNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.CardAcceptorReferenceNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"merchantInformation"+"."+"cardAcceptorReferenceNumber", "body", o.CardAcceptorReferenceNumber, 25); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyMerchantInformation) validateCategoryCode(formats strfmt.Registry) error {
	if swag.IsZero(o.CategoryCode) { // not required
		return nil
	}

	if err := validate.MaximumInt("createPaymentRequest"+"."+"merchantInformation"+"."+"categoryCode", "body", o.CategoryCode, 9999, false); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyMerchantInformation) validateCategoryCodeDomestic(formats strfmt.Registry) error {
	if swag.IsZero(o.CategoryCodeDomestic) { // not required
		return nil
	}

	if err := validate.MaximumInt("createPaymentRequest"+"."+"merchantInformation"+"."+"categoryCodeDomestic", "body", o.CategoryCodeDomestic, 9999, false); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyMerchantInformation) validateDomainName(formats strfmt.Registry) error {
	if swag.IsZero(o.DomainName) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"merchantInformation"+"."+"domainName", "body", o.DomainName, 127); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyMerchantInformation) validateMerchantDescriptor(formats strfmt.Registry) error {
	if swag.IsZero(o.MerchantDescriptor) { // not required
		return nil
	}

	if o.MerchantDescriptor != nil {
		if err := o.MerchantDescriptor.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "merchantInformation" + "." + "merchantDescriptor")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "merchantInformation" + "." + "merchantDescriptor")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyMerchantInformation) validateMerchantName(formats strfmt.Registry) error {
	if swag.IsZero(o.MerchantName) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"merchantInformation"+"."+"merchantName", "body", o.MerchantName, 25); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyMerchantInformation) validateSalesOrganizationID(formats strfmt.Registry) error {
	if swag.IsZero(o.SalesOrganizationID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"merchantInformation"+"."+"salesOrganizationId", "body", o.SalesOrganizationID, 11); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyMerchantInformation) validateServiceFeeDescriptor(formats strfmt.Registry) error {
	if swag.IsZero(o.ServiceFeeDescriptor) { // not required
		return nil
	}

	if o.ServiceFeeDescriptor != nil {
		if err := o.ServiceFeeDescriptor.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "merchantInformation" + "." + "serviceFeeDescriptor")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "merchantInformation" + "." + "serviceFeeDescriptor")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyMerchantInformation) validateTaxID(formats strfmt.Registry) error {
	if swag.IsZero(o.TaxID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"merchantInformation"+"."+"taxId", "body", o.TaxID, 15); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyMerchantInformation) validateTransactionLocalDateTime(formats strfmt.Registry) error {
	if swag.IsZero(o.TransactionLocalDateTime) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"merchantInformation"+"."+"transactionLocalDateTime", "body", o.TransactionLocalDateTime, 14); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyMerchantInformation) validateVatRegistrationNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.VatRegistrationNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"merchantInformation"+"."+"vatRegistrationNumber", "body", o.VatRegistrationNumber, 21); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this create payment params body merchant information based on the context it is used
func (o *CreatePaymentParamsBodyMerchantInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateMerchantDescriptor(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateServiceFeeDescriptor(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyMerchantInformation) contextValidateMerchantDescriptor(ctx context.Context, formats strfmt.Registry) error {

	if o.MerchantDescriptor != nil {
		if err := o.MerchantDescriptor.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "merchantInformation" + "." + "merchantDescriptor")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "merchantInformation" + "." + "merchantDescriptor")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyMerchantInformation) contextValidateServiceFeeDescriptor(ctx context.Context, formats strfmt.Registry) error {

	if o.ServiceFeeDescriptor != nil {
		if err := o.ServiceFeeDescriptor.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "merchantInformation" + "." + "serviceFeeDescriptor")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "merchantInformation" + "." + "serviceFeeDescriptor")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyMerchantInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyMerchantInformation) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyMerchantInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyMerchantInformationMerchantDescriptor create payment params body merchant information merchant descriptor
swagger:model CreatePaymentParamsBodyMerchantInformationMerchantDescriptor
*/
type CreatePaymentParamsBodyMerchantInformationMerchantDescriptor struct {

	// First line of merchant's address. For the descriptions, used-by information, data types, and lengths for these fields, see `merchant_descriptor_street` field description
	// in [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 60
	Address1 string `json:"address1,omitempty"`

	// The state where the merchant is located.
	//
	// #### PIN debit
	// State code or region code for your business. Use the Use the [State, Province, and Territory Codes for the United States and Canada](https://developer.cybersource.com/library/documentation/sbc/quickref/states_and_provinces.pdf) This value might be displayed on the cardholders statement.
	//
	// When you do not include this value in your PIN debit request, the merchant name from your account is used.
	// **Important** This value must consist of English characters.
	//
	// **Note** This field is supported only for businesses located in the U.S. or Canada.
	//
	// Optional field for PIN debit credit or PIN debit purchase.
	//
	AdministrativeArea string `json:"administrativeArea,omitempty"`

	// An alternate name for the merchant.
	//
	// For the descriptions, used-by information, data types, and lengths for these fields, see the `merchant_descriptor_alternate` field description
	// in [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)-->
	//
	// Max Length: 13
	AlternateName string `json:"alternateName,omitempty"`

	// For the descriptions, used-by information, data types, and lengths for these fields, see `merchant_descriptor_contact` field description
	// in [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)-->
	// Contact information for the merchant.
	//
	// **Note** These are the maximum data lengths for the following payment processors:
	// - FDCCompass (13)
	// - Paymentech (13)
	//
	// Max Length: 14
	Contact string `json:"contact,omitempty"`

	// Merchant's country.
	//
	// #### PIN debit
	// Country code for your business location. Use the [ISO Standard Country Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf)
	// This value might be displayed on the cardholders statement.
	//
	// When you do not include this value in your PIN debit request, the merchant name from your account is used.
	// **Important** This value must consist of English characters.
	// **Note** If your business is located in the U.S. or Canada and you include this field in a
	// request, you must also include `merchantInformation.merchantDescriptor.administrativeArea`.
	//
	// Optional field for PIN debit credit or PIN debit purchase.
	//
	// Max Length: 2
	Country string `json:"country,omitempty"`

	// Merchant's City.
	//
	// #### PIN debit
	// City for your business location. This value might be displayed on the cardholders statement.
	//
	// When you do not include this value in your PIN debit request, the merchant name from your account is used.
	// **Important** This value must consist of English characters.
	//
	// Optional field for PIN debit credit or PIN debit purchase requests.
	//
	// Max Length: 13
	Locality string `json:"locality,omitempty"`

	// Your merchant name.
	//
	// **Note** For Paymentech processor using Cybersource Payouts, the maximum data length is 22.
	//
	// #### PIN debit
	// Your business name. This name is displayed on the cardholders statement. When you
	// include more than one consecutive space, extra spaces are removed.
	//
	// When you do not include this value in your PIN debit request, the merchant name from your account is used.
	// **Important** This value must consist of English characters.
	//
	// Optional field for PIN debit credit or PIN debit purchase requests.
	//
	// #### Airline processing
	// Your merchant name. This name is displayed on the cardholders statement. When you include more than one consecutive space, extra spaces are removed.
	//
	// **Note** Some airline fee programs may require the original ticket number (ticket identifier) or the ancillary service description in positions 13 through 23 of this field.
	//
	// **Important** This value must consist of English characters.
	//
	// Required for captures and credits.
	//
	Name string `json:"name,omitempty"`

	// Merchnat phone as contact information for CNP transactions
	//
	// Max Length: 13
	Phone string `json:"phone,omitempty"`

	// Merchant's postal code.
	//
	// #### PIN debit
	// Postal code for your business location. This value might be displayed on the cardholders statement.
	//
	// If your business is domiciled in the U.S., you can use a 5-digit or 9-digit postal code. A 9-digit postal code must follow this format:
	// [5 digits][dash][4 digits]
	// Example: `12345-6789`
	//
	// If your business is domiciled in Canada, you can use a 6-digit or 9-digit postal code. A 6-digit postal code must follow this format:
	// [alpha][numeric][alpha][space]
	// [numeric][alpha][numeric]
	// Example: `A1B 2C3`
	//
	// When you do not include this value in your PIN debit request, the merchant name from your account is used.
	// **Important** This value must consist of English characters.
	//
	// **Note** This field is supported only for businesses located in the U.S. or Canada.
	// **Important** Mastercard requires a postal code for any country that uses postal codes.
	// You can provide the postal code in your account or you can include this field in your request.
	//
	// Optional field for PIN debit credit or PIN debit purchase.
	//
	// Max Length: 14
	PostalCode string `json:"postalCode,omitempty"`

	// Address of company's website provided by merchant
	//
	// Max Length: 255
	URL string `json:"url,omitempty"`
}

// Validate validates this create payment params body merchant information merchant descriptor
func (o *CreatePaymentParamsBodyMerchantInformationMerchantDescriptor) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAddress1(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAlternateName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateContact(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocality(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePhone(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateURL(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyMerchantInformationMerchantDescriptor) validateAddress1(formats strfmt.Registry) error {
	if swag.IsZero(o.Address1) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"merchantInformation"+"."+"merchantDescriptor"+"."+"address1", "body", o.Address1, 60); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyMerchantInformationMerchantDescriptor) validateAlternateName(formats strfmt.Registry) error {
	if swag.IsZero(o.AlternateName) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"merchantInformation"+"."+"merchantDescriptor"+"."+"alternateName", "body", o.AlternateName, 13); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyMerchantInformationMerchantDescriptor) validateContact(formats strfmt.Registry) error {
	if swag.IsZero(o.Contact) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"merchantInformation"+"."+"merchantDescriptor"+"."+"contact", "body", o.Contact, 14); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyMerchantInformationMerchantDescriptor) validateCountry(formats strfmt.Registry) error {
	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"merchantInformation"+"."+"merchantDescriptor"+"."+"country", "body", o.Country, 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyMerchantInformationMerchantDescriptor) validateLocality(formats strfmt.Registry) error {
	if swag.IsZero(o.Locality) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"merchantInformation"+"."+"merchantDescriptor"+"."+"locality", "body", o.Locality, 13); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyMerchantInformationMerchantDescriptor) validatePhone(formats strfmt.Registry) error {
	if swag.IsZero(o.Phone) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"merchantInformation"+"."+"merchantDescriptor"+"."+"phone", "body", o.Phone, 13); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyMerchantInformationMerchantDescriptor) validatePostalCode(formats strfmt.Registry) error {
	if swag.IsZero(o.PostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"merchantInformation"+"."+"merchantDescriptor"+"."+"postalCode", "body", o.PostalCode, 14); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyMerchantInformationMerchantDescriptor) validateURL(formats strfmt.Registry) error {
	if swag.IsZero(o.URL) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"merchantInformation"+"."+"merchantDescriptor"+"."+"url", "body", o.URL, 255); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment params body merchant information merchant descriptor based on context it is used
func (o *CreatePaymentParamsBodyMerchantInformationMerchantDescriptor) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyMerchantInformationMerchantDescriptor) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyMerchantInformationMerchantDescriptor) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyMerchantInformationMerchantDescriptor
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyMerchantInformationServiceFeeDescriptor create payment params body merchant information service fee descriptor
swagger:model CreatePaymentParamsBodyMerchantInformationServiceFeeDescriptor
*/
type CreatePaymentParamsBodyMerchantInformationServiceFeeDescriptor struct {

	// Contact information for the service provider that is collecting the service fee. when you include more than one
	// consecutive space, extra spaces are removed.
	//
	// When you do not include this value in your request, CyberSource uses the value that is in your CyberSource account.
	//
	// This value might be displayed on the cardholders statement.
	//
	// Max Length: 11
	Contact string `json:"contact,omitempty"`

	// Name of the service provider that is collecting the service fee. The service provider name must consist of
	// 3, 7, or 12 characters followed by an asterisk (*). This value must also include the words Service Fee.
	//
	// When you include more than one consecutive space, extra spaces are removed. Use one of the following formats
	// for this value:
	// - <3-character name>*Service Fee
	// - <7-character name>*Service Fee
	// - <12-character name>*Service Fee
	//
	// When payments are made in installments, this value must also include installment information such as
	// 1 of 5 or 3 of 7. For installment payments, use one of the following formats for this value:
	// - <3-character name>*Service Fee*<N> of <M>
	// - <7-character name>*Service Fee*<N> of <M>
	// - <12-character name>*Service Fee*<N> of <M>
	//
	// where <N> is the payment number and <M> is the total number of payments.
	//
	// When you do not include this value in your request, CyberSource uses the value that is in your CyberSource
	// account.
	//
	// This value might be displayed on the cardholders statement.
	//
	// Max Length: 22
	Name string `json:"name,omitempty"`

	// State or territory in which the service provider is located.
	//
	// When you do not include this value in your request, CyberSource uses the value that is in your CyberSource account.
	//
	// This value might be displayed on the cardholders statement.
	//
	// Max Length: 20
	State string `json:"state,omitempty"`
}

// Validate validates this create payment params body merchant information service fee descriptor
func (o *CreatePaymentParamsBodyMerchantInformationServiceFeeDescriptor) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateContact(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateState(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyMerchantInformationServiceFeeDescriptor) validateContact(formats strfmt.Registry) error {
	if swag.IsZero(o.Contact) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"merchantInformation"+"."+"serviceFeeDescriptor"+"."+"contact", "body", o.Contact, 11); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyMerchantInformationServiceFeeDescriptor) validateName(formats strfmt.Registry) error {
	if swag.IsZero(o.Name) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"merchantInformation"+"."+"serviceFeeDescriptor"+"."+"name", "body", o.Name, 22); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyMerchantInformationServiceFeeDescriptor) validateState(formats strfmt.Registry) error {
	if swag.IsZero(o.State) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"merchantInformation"+"."+"serviceFeeDescriptor"+"."+"state", "body", o.State, 20); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment params body merchant information service fee descriptor based on context it is used
func (o *CreatePaymentParamsBodyMerchantInformationServiceFeeDescriptor) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyMerchantInformationServiceFeeDescriptor) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyMerchantInformationServiceFeeDescriptor) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyMerchantInformationServiceFeeDescriptor
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyOrderInformation create payment params body order information
swagger:model CreatePaymentParamsBodyOrderInformation
*/
type CreatePaymentParamsBodyOrderInformation struct {

	// amount details
	AmountDetails *CreatePaymentParamsBodyOrderInformationAmountDetails `json:"amountDetails,omitempty"`

	// bill to
	BillTo *CreatePaymentParamsBodyOrderInformationBillTo `json:"billTo,omitempty"`

	// invoice details
	InvoiceDetails *CreatePaymentParamsBodyOrderInformationInvoiceDetails `json:"invoiceDetails,omitempty"`

	// line items
	LineItems []*CreatePaymentParamsBodyOrderInformationLineItemsItems0 `json:"lineItems"`

	// Indicates whether cardholder is placing an order with a future availability or release date.
	// This field can contain one of these values:
	// - MERCHANDISE_AVAILABLE: Merchandise available
	// - FUTURE_AVAILABILITY: Future availability
	//
	PreOrder string `json:"preOrder,omitempty"`

	// Expected date that a pre-ordered purchase will be available. Format: YYYYMMDD
	//
	// Max Length: 10
	PreOrderDate string `json:"preOrderDate,omitempty"`

	// Indicates whether the cardholder is reordering previously purchased merchandise.
	// This field can contain one of these values:
	// - false: First time ordered
	// - true: Reordered
	//
	Reordered bool `json:"reordered,omitempty"`

	// This is only needed when you are requesting both payment and DM service at same time.
	//
	// Boolean that indicates whether returns are accepted for this order.
	// This field can contain one of the following values:
	// - true: Returns are accepted for this order.
	// - false: Returns are not accepted for this order.
	//
	ReturnsAccepted bool `json:"returnsAccepted,omitempty"`

	// ship to
	ShipTo *CreatePaymentParamsBodyOrderInformationShipTo `json:"shipTo,omitempty"`

	// shipping details
	ShippingDetails *CreatePaymentParamsBodyOrderInformationShippingDetails `json:"shippingDetails,omitempty"`

	// Total number of articles/items in the order as a numeric decimal count.
	// Possible values: 00 - 99
	//
	// Max Length: 2
	TotalOffersCount string `json:"totalOffersCount,omitempty"`
}

// Validate validates this create payment params body order information
func (o *CreatePaymentParamsBodyOrderInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAmountDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBillTo(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateInvoiceDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLineItems(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePreOrderDate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateShipTo(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateShippingDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTotalOffersCount(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyOrderInformation) validateAmountDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.AmountDetails) { // not required
		return nil
	}

	if o.AmountDetails != nil {
		if err := o.AmountDetails.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "orderInformation" + "." + "amountDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "orderInformation" + "." + "amountDetails")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformation) validateBillTo(formats strfmt.Registry) error {
	if swag.IsZero(o.BillTo) { // not required
		return nil
	}

	if o.BillTo != nil {
		if err := o.BillTo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "orderInformation" + "." + "billTo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "orderInformation" + "." + "billTo")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformation) validateInvoiceDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.InvoiceDetails) { // not required
		return nil
	}

	if o.InvoiceDetails != nil {
		if err := o.InvoiceDetails.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "orderInformation" + "." + "invoiceDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "orderInformation" + "." + "invoiceDetails")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformation) validateLineItems(formats strfmt.Registry) error {
	if swag.IsZero(o.LineItems) { // not required
		return nil
	}

	for i := 0; i < len(o.LineItems); i++ {
		if swag.IsZero(o.LineItems[i]) { // not required
			continue
		}

		if o.LineItems[i] != nil {
			if err := o.LineItems[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("createPaymentRequest" + "." + "orderInformation" + "." + "lineItems" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("createPaymentRequest" + "." + "orderInformation" + "." + "lineItems" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformation) validatePreOrderDate(formats strfmt.Registry) error {
	if swag.IsZero(o.PreOrderDate) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"preOrderDate", "body", o.PreOrderDate, 10); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformation) validateShipTo(formats strfmt.Registry) error {
	if swag.IsZero(o.ShipTo) { // not required
		return nil
	}

	if o.ShipTo != nil {
		if err := o.ShipTo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "orderInformation" + "." + "shipTo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "orderInformation" + "." + "shipTo")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformation) validateShippingDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.ShippingDetails) { // not required
		return nil
	}

	if o.ShippingDetails != nil {
		if err := o.ShippingDetails.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "orderInformation" + "." + "shippingDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "orderInformation" + "." + "shippingDetails")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformation) validateTotalOffersCount(formats strfmt.Registry) error {
	if swag.IsZero(o.TotalOffersCount) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"totalOffersCount", "body", o.TotalOffersCount, 2); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this create payment params body order information based on the context it is used
func (o *CreatePaymentParamsBodyOrderInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateAmountDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateBillTo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateInvoiceDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateLineItems(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateShipTo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateShippingDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyOrderInformation) contextValidateAmountDetails(ctx context.Context, formats strfmt.Registry) error {

	if o.AmountDetails != nil {
		if err := o.AmountDetails.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "orderInformation" + "." + "amountDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "orderInformation" + "." + "amountDetails")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformation) contextValidateBillTo(ctx context.Context, formats strfmt.Registry) error {

	if o.BillTo != nil {
		if err := o.BillTo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "orderInformation" + "." + "billTo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "orderInformation" + "." + "billTo")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformation) contextValidateInvoiceDetails(ctx context.Context, formats strfmt.Registry) error {

	if o.InvoiceDetails != nil {
		if err := o.InvoiceDetails.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "orderInformation" + "." + "invoiceDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "orderInformation" + "." + "invoiceDetails")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformation) contextValidateLineItems(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.LineItems); i++ {

		if o.LineItems[i] != nil {
			if err := o.LineItems[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("createPaymentRequest" + "." + "orderInformation" + "." + "lineItems" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("createPaymentRequest" + "." + "orderInformation" + "." + "lineItems" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformation) contextValidateShipTo(ctx context.Context, formats strfmt.Registry) error {

	if o.ShipTo != nil {
		if err := o.ShipTo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "orderInformation" + "." + "shipTo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "orderInformation" + "." + "shipTo")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformation) contextValidateShippingDetails(ctx context.Context, formats strfmt.Registry) error {

	if o.ShippingDetails != nil {
		if err := o.ShippingDetails.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "orderInformation" + "." + "shippingDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "orderInformation" + "." + "shippingDetails")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyOrderInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyOrderInformation) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyOrderInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyOrderInformationAmountDetails create payment params body order information amount details
swagger:model CreatePaymentParamsBodyOrderInformationAmountDetails
*/
type CreatePaymentParamsBodyOrderInformationAmountDetails struct {

	// amex additional amounts
	AmexAdditionalAmounts []*CreatePaymentParamsBodyOrderInformationAmountDetailsAmexAdditionalAmountsItems0 `json:"amexAdditionalAmounts"`

	// Cashback amount in the acquirers currency. If a cashback amount is included in the request, it must be included
	// in the `orderInformation.amountDetails.totalAmount` value.
	//
	// This field is supported only on CyberSource through VisaNet.
	//
	// #### Used by
	// **Authorization**
	// Optional.
	// **Authorization Reversal**
	// Optional.
	//
	// #### PIN debit
	// Required field for PIN debit purchase, PIN debit credit or PIN debit reversal.
	//
	// Max Length: 13
	CashbackAmount string `json:"cashbackAmount,omitempty"`

	// Currency used for the order. Use the three-character [ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)
	//
	// #### Used by
	// **Authorization**
	// Required field.
	//
	// **Authorization Reversal**
	// For an authorization reversal (`reversalInformation`) or a capture (`processingOptions.capture` is set to `true`), you must use the same currency that you used in your payment authorization request.
	//
	// #### PIN Debit
	// Currency for the amount you requested for the PIN debit purchase. This value is returned for partial authorizations. The issuing bank can approve a partial amount if the balance on the debit card is less than the requested transaction amount. For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf).
	// Returned by PIN debit purchase.
	//
	// For PIN debit reversal requests, you must use the same currency that was used for the PIN debit purchase or PIN debit credit that you are reversing.
	// For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf).
	//
	// Required field for PIN Debit purchase and PIN Debit credit requests.
	// Optional field for PIN Debit reversal requests.
	//
	// #### GPX
	// This field is optional for reversing an authorization or credit.
	//
	// #### DCC for First Data
	// Your local currency. For details, see the `currency` field description in [Dynamic Currency Conversion For First Data Using the SCMP API](http://apps.cybersource.com/library/documentation/dev_guides/DCC_FirstData_SCMP/DCC_FirstData_SCMP_API.pdf).
	//
	// #### Tax Calculation
	// Required for international tax and value added tax only.
	// Optional for U.S. and Canadian taxes.
	// Your local currency.
	//
	// Max Length: 3
	Currency string `json:"currency,omitempty"`

	// currency conversion
	CurrencyConversion *CreatePaymentParamsBodyOrderInformationAmountDetailsCurrencyConversion `json:"currencyConversion,omitempty"`

	// Total discount amount applied to the order.
	//
	// Max Length: 15
	DiscountAmount string `json:"discountAmount,omitempty"`

	// Total charges for any import or export duties included in the order.
	//
	// Max Length: 15
	DutyAmount string `json:"dutyAmount,omitempty"`

	// Exchange rate returned by the DCC service. Includes a decimal point and a maximum of 4 decimal places.
	//
	// For details, see `exchange_rate` request-level field description in the [Dynamic Currency Conversion For First Data Using the SCMP API](http://apps.cybersource.com/library/documentation/dev_guides/DCC_FirstData_SCMP/DCC_FirstData_SCMP_API.pdf)
	//
	// Max Length: 13
	ExchangeRate string `json:"exchangeRate,omitempty"`

	// Time stamp for the exchange rate. This value is returned by the DCC service.
	//
	// Format: `YYYYMMDD~HH:MM`  where ~ denotes a space.
	//
	// Max Length: 14
	ExchangeRateTimeStamp string `json:"exchangeRateTimeStamp,omitempty"`

	// Set this field to the converted amount that was returned by the DCC provider.
	// For processor-specific information, see the `foreign_amount` field description in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// Max Length: 15
	ForeignAmount string `json:"foreignAmount,omitempty"`

	// Set this field to the converted amount that was returned by the DCC provider.
	//
	// Max Length: 5
	ForeignCurrency string `json:"foreignCurrency,omitempty"`

	// Total freight or shipping and handling charges for the order. When you include this field in your request, you
	// must also include the **totalAmount** field.
	//
	// For processor-specific information, see the freight_amount field in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 13
	FreightAmount string `json:"freightAmount,omitempty"`

	// Gratuity or tip amount for restaurants. Allowed only when industryDatatype=restaurant.
	// When your customer uses a debit card or prepaid card, and you receive a partial authorization, the payment networks recommend that you do not
	// submit a capture amount that is higher than the authorized amount. When the capture amount exceeds the partial amount that was approved, the
	// issuer has chargeback rights for the excess amount.
	//
	// Used by **Capture**
	// Optional field.
	//
	// #### CyberSource through VisaNet
	// Restaurant data is supported only on CyberSource through VisaNet when card is present.
	//
	// Max Length: 13
	GratuityAmount string `json:"gratuityAmount,omitempty"`

	// Flag that indicates whether a national tax is included in the order total.
	//
	// Possible values:
	//
	//  - **0**: national tax not included
	//  - **1**: national tax included
	//
	// Max Length: 1
	NationalTaxIncluded string `json:"nationalTaxIncluded,omitempty"`

	// Amount in your original local pricing currency.
	//
	// This value cannot be negative. You can include a decimal point (.) in this field to denote the currency
	// exponent, but you cannot include any other special characters.
	//
	// If needed, CyberSource truncates the amount to the correct number of decimal places.
	//
	// Max Length: 15
	OriginalAmount string `json:"originalAmount,omitempty"`

	// Your local pricing currency code.
	//
	// For the possible values, see the [ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)
	//
	// Max Length: 15
	OriginalCurrency string `json:"originalCurrency,omitempty"`

	// Service fee. Required for service fee transactions.
	//
	// Max Length: 15
	ServiceFeeAmount string `json:"serviceFeeAmount,omitempty"`

	// This is a multicurrency field. It contains the transaction amount (field 4), converted to the Currency used to bill the cardholders account.
	// This field is returned for OCT transactions.
	//
	// Max Length: 12
	SettlementAmount string `json:"settlementAmount,omitempty"`

	// This is a multicurrency-only field. It contains a 3-digit numeric code that identifies the currency used by the issuer to bill the cardholder's account.
	// This field is returned for OCT transactions.
	//
	// Max Length: 3
	SettlementCurrency string `json:"settlementCurrency,omitempty"`

	// surcharge
	Surcharge *CreatePaymentParamsBodyOrderInformationAmountDetailsSurcharge `json:"surcharge,omitempty"`

	// Total tax amount for all the items in the order.
	//
	// Max Length: 12
	TaxAmount string `json:"taxAmount,omitempty"`

	// Flag that indicates how the merchant manages discounts.
	//
	// Possible values:
	//
	//  - **0**: no invoice level discount included
	//  - **1**: tax calculated on the postdiscount invoice total
	//  - **2**: tax calculated on the prediscount invoice total
	//
	// Max Length: 1
	TaxAppliedAfterDiscount string `json:"taxAppliedAfterDiscount,omitempty"`

	// Flag that indicates how you calculate tax.
	//
	// Possible values:
	//
	//  - **0**: net prices with tax calculated at line item level
	//  - **1**: net prices with tax calculated at invoice level
	//  - **2**: gross prices with tax provided at line item level
	//  - **3**: gross prices with tax provided at invoice level
	//  - **4**: no tax applies on the invoice for the transaction
	//
	// Max Length: 1
	TaxAppliedLevel string `json:"taxAppliedLevel,omitempty"`

	// tax details
	TaxDetails []*CreatePaymentParamsBodyOrderInformationAmountDetailsTaxDetailsItems0 `json:"taxDetails"`

	// For tax amounts that can be categorized as one tax type.
	//
	// This field contains the tax type code that corresponds to the entry in the _lineItems.taxAmount_ field.
	//
	// Possible values:
	//
	//  - **056**: sales tax (U.S only)
	//  - **TX~**: all taxes (Canada only)   Note ~ = space.
	//
	// Max Length: 3
	TaxTypeCode string `json:"taxTypeCode,omitempty"`

	// Grand total for the order. This value cannot be negative. You can include a decimal point (.), but no other special characters.
	// CyberSource truncates the amount to the correct number of decimal places.
	//
	// **Note** For CTV, FDCCompass, Paymentech processors, the maximum length for this field is 12.
	//
	// **Important** Some processors have specific requirements and limitations, such as maximum amounts and maximum field lengths. For details, see:
	// - "Authorization Information for Specific Processors" in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/).
	// - "Capture Information for Specific Processors" in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/).
	// - "Credit Information for Specific Processors" in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/).
	//
	// If your processor supports zero amount authorizations, you can set this field to 0 for the authorization to check if the card is lost or stolen. For details, see "Zero Amount Authorizations," "Credit Information for Specific Processors" in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// #### Card Present
	// Required to include either this field or `orderInformation.lineItems[].unitPrice` for the order.
	//
	// #### Invoicing
	// Required for creating a new invoice.
	//
	// #### PIN Debit
	// Amount you requested for the PIN debit purchase. This value is returned for partial authorizations. The issuing bank can approve a partial amount if the balance on the debit card is less than the requested transaction amount.
	//
	// Required field for PIN Debit purchase and PIN Debit credit requests.
	// Optional field for PIN Debit reversal requests.
	//
	// #### GPX
	// This field is optional for reversing an authorization or credit; however, for all other processors, these fields are required.
	//
	// #### DCC with a Third-Party Provider
	// Set this field to the converted amount that was returned by the DCC provider. You must include either this field or the 1st line item in the order and the specific line-order amount in your request. For details, see `grand_total_amount` field description in [Dynamic Currency Conversion For First Data Using the SCMP API](http://apps.cybersource.com/library/documentation/dev_guides/DCC_FirstData_SCMP/DCC_FirstData_SCMP_API.pdf).
	//
	// #### FDMS South
	// If you accept IDR or CLP currencies, see the entry for FDMS South in "Authorization Information for Specific Processors" of the [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// #### DCC for First Data
	// Not used.
	//
	// Max Length: 19
	TotalAmount string `json:"totalAmount,omitempty"`
}

// Validate validates this create payment params body order information amount details
func (o *CreatePaymentParamsBodyOrderInformationAmountDetails) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAmexAdditionalAmounts(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCashbackAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCurrency(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCurrencyConversion(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDiscountAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDutyAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExchangeRate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExchangeRateTimeStamp(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateForeignAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateForeignCurrency(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFreightAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateGratuityAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNationalTaxIncluded(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOriginalAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOriginalCurrency(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateServiceFeeAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSettlementAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSettlementCurrency(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSurcharge(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxAppliedAfterDiscount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxAppliedLevel(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxTypeCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTotalAmount(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationAmountDetails) validateAmexAdditionalAmounts(formats strfmt.Registry) error {
	if swag.IsZero(o.AmexAdditionalAmounts) { // not required
		return nil
	}

	for i := 0; i < len(o.AmexAdditionalAmounts); i++ {
		if swag.IsZero(o.AmexAdditionalAmounts[i]) { // not required
			continue
		}

		if o.AmexAdditionalAmounts[i] != nil {
			if err := o.AmexAdditionalAmounts[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("createPaymentRequest" + "." + "orderInformation" + "." + "amountDetails" + "." + "amexAdditionalAmounts" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("createPaymentRequest" + "." + "orderInformation" + "." + "amountDetails" + "." + "amexAdditionalAmounts" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationAmountDetails) validateCashbackAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.CashbackAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"cashbackAmount", "body", o.CashbackAmount, 13); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationAmountDetails) validateCurrency(formats strfmt.Registry) error {
	if swag.IsZero(o.Currency) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"currency", "body", o.Currency, 3); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationAmountDetails) validateCurrencyConversion(formats strfmt.Registry) error {
	if swag.IsZero(o.CurrencyConversion) { // not required
		return nil
	}

	if o.CurrencyConversion != nil {
		if err := o.CurrencyConversion.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "orderInformation" + "." + "amountDetails" + "." + "currencyConversion")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "orderInformation" + "." + "amountDetails" + "." + "currencyConversion")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationAmountDetails) validateDiscountAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.DiscountAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"discountAmount", "body", o.DiscountAmount, 15); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationAmountDetails) validateDutyAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.DutyAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"dutyAmount", "body", o.DutyAmount, 15); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationAmountDetails) validateExchangeRate(formats strfmt.Registry) error {
	if swag.IsZero(o.ExchangeRate) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"exchangeRate", "body", o.ExchangeRate, 13); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationAmountDetails) validateExchangeRateTimeStamp(formats strfmt.Registry) error {
	if swag.IsZero(o.ExchangeRateTimeStamp) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"exchangeRateTimeStamp", "body", o.ExchangeRateTimeStamp, 14); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationAmountDetails) validateForeignAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.ForeignAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"foreignAmount", "body", o.ForeignAmount, 15); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationAmountDetails) validateForeignCurrency(formats strfmt.Registry) error {
	if swag.IsZero(o.ForeignCurrency) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"foreignCurrency", "body", o.ForeignCurrency, 5); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationAmountDetails) validateFreightAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.FreightAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"freightAmount", "body", o.FreightAmount, 13); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationAmountDetails) validateGratuityAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.GratuityAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"gratuityAmount", "body", o.GratuityAmount, 13); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationAmountDetails) validateNationalTaxIncluded(formats strfmt.Registry) error {
	if swag.IsZero(o.NationalTaxIncluded) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"nationalTaxIncluded", "body", o.NationalTaxIncluded, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationAmountDetails) validateOriginalAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.OriginalAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"originalAmount", "body", o.OriginalAmount, 15); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationAmountDetails) validateOriginalCurrency(formats strfmt.Registry) error {
	if swag.IsZero(o.OriginalCurrency) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"originalCurrency", "body", o.OriginalCurrency, 15); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationAmountDetails) validateServiceFeeAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.ServiceFeeAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"serviceFeeAmount", "body", o.ServiceFeeAmount, 15); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationAmountDetails) validateSettlementAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.SettlementAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"settlementAmount", "body", o.SettlementAmount, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationAmountDetails) validateSettlementCurrency(formats strfmt.Registry) error {
	if swag.IsZero(o.SettlementCurrency) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"settlementCurrency", "body", o.SettlementCurrency, 3); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationAmountDetails) validateSurcharge(formats strfmt.Registry) error {
	if swag.IsZero(o.Surcharge) { // not required
		return nil
	}

	if o.Surcharge != nil {
		if err := o.Surcharge.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "orderInformation" + "." + "amountDetails" + "." + "surcharge")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "orderInformation" + "." + "amountDetails" + "." + "surcharge")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationAmountDetails) validateTaxAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.TaxAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"taxAmount", "body", o.TaxAmount, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationAmountDetails) validateTaxAppliedAfterDiscount(formats strfmt.Registry) error {
	if swag.IsZero(o.TaxAppliedAfterDiscount) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"taxAppliedAfterDiscount", "body", o.TaxAppliedAfterDiscount, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationAmountDetails) validateTaxAppliedLevel(formats strfmt.Registry) error {
	if swag.IsZero(o.TaxAppliedLevel) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"taxAppliedLevel", "body", o.TaxAppliedLevel, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationAmountDetails) validateTaxDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.TaxDetails) { // not required
		return nil
	}

	for i := 0; i < len(o.TaxDetails); i++ {
		if swag.IsZero(o.TaxDetails[i]) { // not required
			continue
		}

		if o.TaxDetails[i] != nil {
			if err := o.TaxDetails[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("createPaymentRequest" + "." + "orderInformation" + "." + "amountDetails" + "." + "taxDetails" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("createPaymentRequest" + "." + "orderInformation" + "." + "amountDetails" + "." + "taxDetails" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationAmountDetails) validateTaxTypeCode(formats strfmt.Registry) error {
	if swag.IsZero(o.TaxTypeCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"taxTypeCode", "body", o.TaxTypeCode, 3); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationAmountDetails) validateTotalAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.TotalAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"totalAmount", "body", o.TotalAmount, 19); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this create payment params body order information amount details based on the context it is used
func (o *CreatePaymentParamsBodyOrderInformationAmountDetails) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateAmexAdditionalAmounts(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateCurrencyConversion(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateSurcharge(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateTaxDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationAmountDetails) contextValidateAmexAdditionalAmounts(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.AmexAdditionalAmounts); i++ {

		if o.AmexAdditionalAmounts[i] != nil {
			if err := o.AmexAdditionalAmounts[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("createPaymentRequest" + "." + "orderInformation" + "." + "amountDetails" + "." + "amexAdditionalAmounts" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("createPaymentRequest" + "." + "orderInformation" + "." + "amountDetails" + "." + "amexAdditionalAmounts" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationAmountDetails) contextValidateCurrencyConversion(ctx context.Context, formats strfmt.Registry) error {

	if o.CurrencyConversion != nil {
		if err := o.CurrencyConversion.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "orderInformation" + "." + "amountDetails" + "." + "currencyConversion")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "orderInformation" + "." + "amountDetails" + "." + "currencyConversion")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationAmountDetails) contextValidateSurcharge(ctx context.Context, formats strfmt.Registry) error {

	if o.Surcharge != nil {
		if err := o.Surcharge.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "orderInformation" + "." + "amountDetails" + "." + "surcharge")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "orderInformation" + "." + "amountDetails" + "." + "surcharge")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationAmountDetails) contextValidateTaxDetails(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.TaxDetails); i++ {

		if o.TaxDetails[i] != nil {
			if err := o.TaxDetails[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("createPaymentRequest" + "." + "orderInformation" + "." + "amountDetails" + "." + "taxDetails" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("createPaymentRequest" + "." + "orderInformation" + "." + "amountDetails" + "." + "taxDetails" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyOrderInformationAmountDetails) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyOrderInformationAmountDetails) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyOrderInformationAmountDetails
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyOrderInformationAmountDetailsAmexAdditionalAmountsItems0 create payment params body order information amount details amex additional amounts items0
swagger:model CreatePaymentParamsBodyOrderInformationAmountDetailsAmexAdditionalAmountsItems0
*/
type CreatePaymentParamsBodyOrderInformationAmountDetailsAmexAdditionalAmountsItems0 struct {

	// Additional amount. This field is supported only for **American Express Direct**.
	//
	// Max Length: 12
	Amount string `json:"amount,omitempty"`

	// Additional amount type. This field is supported only for **American Express Direct**.
	//
	// For processor-specific information, see the `additional_amount_type0` request-level field description in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 3
	Code string `json:"code,omitempty"`
}

// Validate validates this create payment params body order information amount details amex additional amounts items0
func (o *CreatePaymentParamsBodyOrderInformationAmountDetailsAmexAdditionalAmountsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationAmountDetailsAmexAdditionalAmountsItems0) validateAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.Amount) { // not required
		return nil
	}

	if err := validate.MaxLength("amount", "body", o.Amount, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationAmountDetailsAmexAdditionalAmountsItems0) validateCode(formats strfmt.Registry) error {
	if swag.IsZero(o.Code) { // not required
		return nil
	}

	if err := validate.MaxLength("code", "body", o.Code, 3); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment params body order information amount details amex additional amounts items0 based on context it is used
func (o *CreatePaymentParamsBodyOrderInformationAmountDetailsAmexAdditionalAmountsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyOrderInformationAmountDetailsAmexAdditionalAmountsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyOrderInformationAmountDetailsAmexAdditionalAmountsItems0) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyOrderInformationAmountDetailsAmexAdditionalAmountsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyOrderInformationAmountDetailsCurrencyConversion create payment params body order information amount details currency conversion
swagger:model CreatePaymentParamsBodyOrderInformationAmountDetailsCurrencyConversion
*/
type CreatePaymentParamsBodyOrderInformationAmountDetailsCurrencyConversion struct {

	// Value of the Cybersource request ID returned in a DCC Lookup transaction.
	//
	// Max Length: 26
	ID string `json:"id,omitempty"`

	// Flag indicating that DCC Lookup has been performed before this transaction. Set this field to 1 when cardholders opts to use DCC on the transaction.
	//
	// Max Length: 1
	Indicator string `json:"indicator,omitempty"`

	// Unique identifier generated by the DCC provider.
	//
	// Max Length: 60
	ReconciliationID string `json:"reconciliationId,omitempty"`
}

// Validate validates this create payment params body order information amount details currency conversion
func (o *CreatePaymentParamsBodyOrderInformationAmountDetailsCurrencyConversion) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateIndicator(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateReconciliationID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationAmountDetailsCurrencyConversion) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"currencyConversion"+"."+"id", "body", o.ID, 26); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationAmountDetailsCurrencyConversion) validateIndicator(formats strfmt.Registry) error {
	if swag.IsZero(o.Indicator) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"currencyConversion"+"."+"indicator", "body", o.Indicator, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationAmountDetailsCurrencyConversion) validateReconciliationID(formats strfmt.Registry) error {
	if swag.IsZero(o.ReconciliationID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"currencyConversion"+"."+"reconciliationId", "body", o.ReconciliationID, 60); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment params body order information amount details currency conversion based on context it is used
func (o *CreatePaymentParamsBodyOrderInformationAmountDetailsCurrencyConversion) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyOrderInformationAmountDetailsCurrencyConversion) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyOrderInformationAmountDetailsCurrencyConversion) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyOrderInformationAmountDetailsCurrencyConversion
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyOrderInformationAmountDetailsSurcharge create payment params body order information amount details surcharge
swagger:model CreatePaymentParamsBodyOrderInformationAmountDetailsSurcharge
*/
type CreatePaymentParamsBodyOrderInformationAmountDetailsSurcharge struct {

	// The surcharge amount is included in the total transaction amount but is passed in a separate field to the issuer and acquirer for tracking. The issuer can provide information about the surcharge amount to the customer.
	//
	// If the amount is positive, then it is a debit for the customer.
	// If the amount is negative, then it is a credit for the customer.
	//
	// **NOTE**: This field is supported only for CyberSource through VisaNet (CtV) for Payouts. For CtV, the maximum string length is 8.
	//
	// #### PIN debit
	// Surcharge amount that you are charging the customer for this transaction. If you include a surcharge amount
	// in the request, you must also include the surcharge amount in the value for `orderInformation.amountDetails.totalAmount`.
	//
	// Optional field for transactions that use PIN debit credit or PIN debit purchase.
	//
	// Max Length: 15
	Amount string `json:"amount,omitempty"`

	// Merchant-defined field for describing the surcharge amount.
	Description string `json:"description,omitempty"`
}

// Validate validates this create payment params body order information amount details surcharge
func (o *CreatePaymentParamsBodyOrderInformationAmountDetailsSurcharge) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAmount(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationAmountDetailsSurcharge) validateAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.Amount) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"surcharge"+"."+"amount", "body", o.Amount, 15); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment params body order information amount details surcharge based on context it is used
func (o *CreatePaymentParamsBodyOrderInformationAmountDetailsSurcharge) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyOrderInformationAmountDetailsSurcharge) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyOrderInformationAmountDetailsSurcharge) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyOrderInformationAmountDetailsSurcharge
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyOrderInformationAmountDetailsTaxDetailsItems0 create payment params body order information amount details tax details items0
swagger:model CreatePaymentParamsBodyOrderInformationAmountDetailsTaxDetailsItems0
*/
type CreatePaymentParamsBodyOrderInformationAmountDetailsTaxDetailsItems0 struct {

	// Indicates the amount of tax based on the `type` field as described in the table below:
	//
	// | type      | type description |
	// | ------------- |:-------------:|
	// | `alternate` | Total amount of alternate tax for the order. |
	// | `local`     | Sales tax for the order. |
	// | `national`  | National tax for the order. |
	// | `vat`       | Total amount of value added tax (VAT) included in the order. |
	// | `other`     | Other tax. |
	//
	// Max Length: 13
	Amount string `json:"amount,omitempty"`

	// Flag that indicates whether the alternate tax amount (`orderInformation.amountDetails.taxDetails[].amount`) is
	// included in the request.
	//
	// Possible values:
	// - `false`: alternate tax amount is not included in the request.
	// - `true`: alternate tax amount is included in the request.
	//
	// For processor-specific details, see `alternate_tax_amount_indicator` field description in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/)
	//
	Applied bool `json:"applied,omitempty"`

	// Type of tax being applied to the item.
	//
	// For possible values, see the processor-specific field descriptions in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/):
	//
	// #### FDC Nashville Global
	// - `alternate_tax_type_applied`
	// - `alternate_tax_type_identifier`
	//
	// #### Worldpay VAP
	// - `alternate_tax_type_identifier`
	//
	// #### RBS WorldPay Atlanta
	// - `tax_type_applied`
	//
	// #### TSYS Acquiring Solutions
	// - `tax_type_applied`
	// - `local_tax_indicator`
	//
	// #### Chase Paymentech Solutions
	// - `tax_type_applied`
	//
	// #### Elavon Americas
	// - `local_tax_indicator`
	//
	// #### FDC Compass
	// - `tax_type_applied`
	//
	// #### OmniPay Direct
	// - `local_tax_indicator`
	//
	// Max Length: 4
	Code string `json:"code,omitempty"`

	// Status code for exemption from sales and use tax. This field is a pass-through, which means that
	// CyberSource does not verify the value or modify it in any way before sending it to the processor.
	//
	// For possible values and important information for using this field, see _Appendix B, "Exemption
	// Status Values_ and _Offer-Level Tax Fields_ in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/)
	//
	// Max Length: 1
	ExemptionCode string `json:"exemptionCode,omitempty"`

	// Rate of VAT or other tax for the order.
	//
	// Example 0.040 (=4%)
	//
	// Valid range: 0.01 to 0.99 (1% to 99%, with only whole percentage values accepted; values with additional
	// decimal places will be truncated)
	//
	// For processor-specific details, see the `alternate_tax_amount`, `vat_rate`, `vat_tax_rate`, `local_tax`, `national_tax`, `vat_tax_amount` or `other_tax#_rate` field descriptions in the [Level II and Level III Processing Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/)
	//
	// Max Length: 6
	Rate string `json:"rate,omitempty"`

	// Your tax ID number to use for the alternate tax amount. Required if you set alternate tax amount to any value,
	// including zero. You may send this field without sending alternate tax amount.
	//
	// For processor-specific details, see `alternate_tax_id` field description in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/)
	//
	// Max Length: 15
	TaxID string `json:"taxId,omitempty"`

	// Indicates the type of tax data for the _taxDetails_ object.
	//
	// Possible values:
	//
	// - `alternate`
	// - `local`
	// - `national`
	// - `vat`
	// - `other`
	//
	// For processor-specific details, see the `alternate_tax_amount`, `local_tax`, `national_tax` or `vat_tax_amount` field
	// descriptions in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/)
	//
	Type string `json:"type,omitempty"`
}

// Validate validates this create payment params body order information amount details tax details items0
func (o *CreatePaymentParamsBodyOrderInformationAmountDetailsTaxDetailsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExemptionCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationAmountDetailsTaxDetailsItems0) validateAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.Amount) { // not required
		return nil
	}

	if err := validate.MaxLength("amount", "body", o.Amount, 13); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationAmountDetailsTaxDetailsItems0) validateCode(formats strfmt.Registry) error {
	if swag.IsZero(o.Code) { // not required
		return nil
	}

	if err := validate.MaxLength("code", "body", o.Code, 4); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationAmountDetailsTaxDetailsItems0) validateExemptionCode(formats strfmt.Registry) error {
	if swag.IsZero(o.ExemptionCode) { // not required
		return nil
	}

	if err := validate.MaxLength("exemptionCode", "body", o.ExemptionCode, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationAmountDetailsTaxDetailsItems0) validateRate(formats strfmt.Registry) error {
	if swag.IsZero(o.Rate) { // not required
		return nil
	}

	if err := validate.MaxLength("rate", "body", o.Rate, 6); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationAmountDetailsTaxDetailsItems0) validateTaxID(formats strfmt.Registry) error {
	if swag.IsZero(o.TaxID) { // not required
		return nil
	}

	if err := validate.MaxLength("taxId", "body", o.TaxID, 15); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment params body order information amount details tax details items0 based on context it is used
func (o *CreatePaymentParamsBodyOrderInformationAmountDetailsTaxDetailsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyOrderInformationAmountDetailsTaxDetailsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyOrderInformationAmountDetailsTaxDetailsItems0) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyOrderInformationAmountDetailsTaxDetailsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyOrderInformationBillTo create payment params body order information bill to
swagger:model CreatePaymentParamsBodyOrderInformationBillTo
*/
type CreatePaymentParamsBodyOrderInformationBillTo struct {

	// Payment card billing street address as it appears on the credit card issuers records.
	//
	// #### Atos
	// This field must not contain colons (:).
	//
	// #### CyberSource through VisaNet
	// **Important** When you populate orderInformation.billTo.address1 and orderInformation.billTo.address2,
	// CyberSource through VisaNet concatenates the two values. If the concatenated value exceeds 40 characters,
	// CyberSource through VisaNet truncates the value at 40 characters before sending it to Visa and the issuing bank.
	// Truncating this value affects AVS results and therefore might also affect risk decisions and chargebacks.
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet
	// accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations
	// of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the
	// credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless
	// ASCII characters for transmission to the credit card networks.
	//
	// #### FDMS Nashville
	// When the street name is numeric, it must be sent in numeric format. For example, if the address is _One First Street_,
	// it must be sent as _1 1st Street_.
	//
	// Required if keyed; not used if swiped.
	//
	// String (20)
	//
	// #### TSYS Acquiring Solutions
	// Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.
	//
	// #### All other processors:
	// Optional.
	// String (60)
	//
	// #### For Payouts
	// This field may be sent only for FDC Compass.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// Max Length: 60
	Address1 string `json:"address1,omitempty"`

	// Used for additional address information. For example: _Attention: Accounts Payable_
	// Optional field.
	//
	// For Payouts: This field may be sent only for FDC Compass.
	//
	// #### Atos
	// This field must not contain colons (:).
	//
	// #### CyberSource through VisaNet
	// **Important** When you populate `orderInformation.billTo.address1` and `orderInformation.billTo.address2`,
	// CyberSource through VisaNet concatenates the two values. If the concatenated value exceeds 40 characters,
	// CyberSource through VisaNet truncates the value at 40 characters before sending it to Visa and the issuing bank.
	// Truncating this value affects AVS results and therefore might also affect risk decisions and chargebacks.
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet
	// accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations
	// of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the
	// credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless
	// ASCII characters for transmission to the credit card networks.
	//
	// #### Chase Paymentech Solutions, FDC Compass, and TSYS Acquiring Solutions
	// This value is used for AVS.
	//
	// #### FDMS Nashville
	// `orderInformation.billTo.address1` and `orderInformation.billTo.address2` together cannot exceed 20 characters.
	// String (20)
	//
	// #### All Other Processors
	// String (60)
	//
	// Max Length: 60
	Address2 string `json:"address2,omitempty"`

	// Additional address information (third line of the billing address)
	//
	// Max Length: 60
	Address3 string `json:"address3,omitempty"`

	// Additional address information (fourth line of the billing address)
	//
	// Max Length: 60
	Address4 string `json:"address4,omitempty"`

	// State or province of the billing address. Use the [State, Province, and Territory Codes for the United States and Canada](https://developer.cybersource.com/library/documentation/sbc/quickref/states_and_provinces.pdf).
	//
	// For Payouts: This field may be sent only for FDC Compass.
	//
	// ##### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet
	// accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations
	// of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the
	// credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless
	// ASCII characters for transmission to the credit card networks.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// #### Chase Paymentech Solutions
	// Optional field.
	//
	// ####  Credit Mutuel-CIC
	// Optional field.
	//
	// #### OmniPay Direct
	// Optional field.
	//
	// #### SIX
	// Optional field.
	//
	// #### TSYS Acquiring Solutions
	// Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.
	//
	// #### Worldpay VAP
	// Optional field.
	//
	// #### All other processors
	// Not used.
	//
	// Max Length: 20
	AdministrativeArea string `json:"administrativeArea,omitempty"`

	// Building number in the street address.
	//
	// For example, if the street address is:
	// Rua da Quitanda 187
	// then the building number is 187.
	//
	// This field is supported only for:
	//  - Cielo transactions.
	//  - Redecard customer validation with CyberSource Latin American Processing.
	//
	// Max Length: 256
	BuildingNumber string `json:"buildingNumber,omitempty"`

	// company
	Company *CreatePaymentParamsBodyOrderInformationBillToCompany `json:"company,omitempty"`

	// Payment card billing country. Use the two-character [ISO Standard Country Codes](http://apps.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf).
	//
	// #### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet
	// accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations
	// of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the
	// credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII
	// characters for transmission to the credit card networks.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// #### Chase Paymentech Solutions
	// Optional field.
	//
	// ####  Credit Mutuel-CIC
	// Optional field.
	//
	// #### OmniPay Direct
	// Optional field.
	//
	// #### SIX
	// Optional field.
	//
	// #### TSYS Acquiring Solutions
	// Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.
	//
	// #### Worldpay VAP
	// Optional field.
	//
	// #### All other processors
	// Not used.
	//
	// Max Length: 2
	Country string `json:"country,omitempty"`

	// Customers neighborhood, community, or region (a barrio in Brazil) within the city or municipality. This
	// field is available only on **Cielo**.
	//
	// Max Length: 50
	District string `json:"district,omitempty"`

	// Customer's email address, including the full domain name.
	//
	// #### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// For processor-specific information, see the `customer_email` request-level field description in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// #### Invoicing
	// Email address for the customer for sending the invoice. If the invoice is in SENT status and email is updated, the old email customer payment link won't work and you must resend the invoice with the new payment link.
	//
	// #### Chase Paymentech Solutions
	// Optional field.
	//
	// ####  Credit Mutuel-CIC
	// Optional field.
	//
	// #### OmniPay Direct
	// Optional field.
	//
	// #### SIX
	// Optional field.
	//
	// #### TSYS Acquiring Solutions
	// Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.
	//
	// #### Worldpay VAP
	// Optional field.
	//
	// #### All other processors
	// Not used.
	//
	// Max Length: 255
	Email string `json:"email,omitempty"`

	// Email domain of the customer. The domain of the email address comprises all characters that follow the @ symbol, such as mail.example.com. For the Risk Update service, if the email address and the domain are sent in the request, the domain supersedes the email address.
	//
	// Max Length: 100
	EmailDomain string `json:"emailDomain,omitempty"`

	// Customers first name. This name must be the same as the name on the card.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// #### CyberSource Latin American Processing
	// **Important** For an authorization request, CyberSource Latin American Processing concatenates `orderInformation.billTo.firstName` and `orderInformation.billTo.lastName`. If the concatenated value exceeds 30 characters, CyberSource Latin American Processing declines the authorization request.\
	// **Note** CyberSource Latin American Processing is the name of a specific processing connection that CyberSource supports. In the CyberSource API documentation, CyberSource Latin American Processing does not refer to the general topic of processing in Latin America. The information in this field description is for the specific processing connection called _CyberSource Latin American Processing_. It is not for any other Latin American processors that CyberSource supports.
	//
	// #### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.
	//
	// #### For Payouts:
	// This field may be sent only for FDC Compass.
	//
	// #### Chase Paymentech Solutions
	// Optional field.
	//
	// ####  Credit Mutuel-CIC
	// Optional field.
	//
	// #### OmniPay Direct
	// Optional field.
	//
	// #### SIX
	// Optional field.
	//
	// #### TSYS Acquiring Solutions
	// Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.
	//
	// #### Worldpay VAP
	// Optional field.
	//
	// #### All other processors
	// Not used.
	//
	// Max Length: 60
	FirstName string `json:"firstName,omitempty"`

	// Customers last name. This name must be the same as the name on the card.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// #### Chase Paymentech Solutions
	// Optional field.
	//
	// ####  Credit Mutuel-CIC
	// Optional field.
	//
	// #### CyberSource Latin American Processing
	// **Important** For an authorization request, CyberSource Latin American Processing concatenates `orderInformation.billTo.firstName` and `orderInformation.billTo.lastName`. If the concatenated value exceeds 30 characters, CyberSource Latin American Processing declines the authorization request.\
	// **Note** CyberSource Latin American Processing is the name of a specific processing connection that CyberSource supports. In the CyberSource API documentation, CyberSource Latin American Processing does not refer to the general topic of processing in Latin America. The information in this field description is for the specific processing connection called CyberSource Latin American Processing. It is not for any other Latin American processors that CyberSource supports.
	//
	// #### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.
	//
	// #### For Payouts:
	// This field may be sent only for FDC Compass.
	//
	// #### OmniPay Direct
	// Optional field.
	//
	// #### RBS WorldPay Atlanta
	// Optional field.
	//
	// #### SIX
	// Optional field.
	//
	// #### TSYS Acquiring Solutions
	// Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.
	//
	// #### Worldpay VAP
	// Optional field.
	//
	// #### All other processors
	// Not used.
	//
	// Max Length: 60
	LastName string `json:"lastName,omitempty"`

	// Payment card billing city.
	//
	// #### Atos
	// This field must not contain colons (:).
	//
	// #### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.
	//
	// #### For Payouts:
	// This field may be sent only for FDC Compass.
	//
	// #### Chase Paymentech Solutions
	// Optional field.
	//
	// ####  Credit Mutuel-CIC
	// Optional field.
	//
	// #### OmniPay Direct
	// Optional field.
	//
	// #### SIX
	// Optional field.
	//
	// #### TSYS Acquiring Solutions
	// Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.
	//
	// #### Worldpay VAP
	// Optional field.
	//
	// #### All other processors
	// Not used.
	//
	// Max Length: 50
	Locality string `json:"locality,omitempty"`

	// Customers middle name.
	//
	// Max Length: 60
	MiddleName string `json:"middleName,omitempty"`

	// Customers name suffix.
	//
	// Max Length: 60
	NameSuffix string `json:"nameSuffix,omitempty"`

	// Customers phone number.
	//
	// It is recommended that you include the country code when the order is from outside the U.S.
	//
	// #### Chase Paymentech Solutions
	// Optional field.
	//
	// ####  Credit Mutuel-CIC
	// Optional field.
	//
	// #### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.
	//
	// #### For Payouts:
	// This field may be sent only for FDC Compass.
	//
	// #### OmniPay Direct
	// Optional field.
	//
	// #### SIX
	// Optional field.
	//
	// #### TSYS Acquiring Solutions
	// Optional field.
	//
	// #### Worldpay VAP
	// Optional field.
	//
	// #### All other processors
	// Not used.
	//
	// Max Length: 15
	PhoneNumber string `json:"phoneNumber,omitempty"`

	// Customer's phone number type.
	//
	// #### For Payouts:
	// This field may be sent only for FDC Compass.
	//
	// Possible Values:
	// * day
	// * home
	// * night
	// * work
	//
	PhoneType string `json:"phoneType,omitempty"`

	// Postal code for the billing address. The postal code must consist of 5 to 9 digits.
	//
	// When the billing country is the U.S., the 9-digit postal code must follow this format:
	// [5 digits][dash][4 digits]
	//
	// **Example** `12345-6789`
	//
	// When the billing country is Canada, the 6-digit postal code must follow this format:
	// [alpha][numeric][alpha][space][numeric][alpha][numeric]
	//
	// **Example** `A1B 2C3`
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// #### For Payouts:
	//  This field may be sent only for FDC Compass.
	//
	// #### American Express Direct
	// Before sending the postal code to the processor, CyberSource removes all nonalphanumeric characters and, if the remaining value is longer than nine characters, truncates the value starting from the right side.
	//
	// #### Atos
	// This field must not contain colons (:).
	//
	// #### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet
	// accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations
	// of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the
	// credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII
	// characters for transmission to the credit card networks.
	//
	// #### FDMS Nashville
	// Required if `pointOfSaleInformation.entryMode=keyed` and the address is in the U.S. or Canada.
	// Optional if `pointOfSaleInformation.entryMode=keyed` and the address is **not** in the U.S. or Canada.
	// Not used if swiped.
	//
	// #### RBS WorldPay Atlanta:
	// For best card-present keyed rates, send the postal code if `pointOfSaleInformation.entryMode=keyed`.
	//
	// #### TSYS Acquiring Solutions
	// Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.
	//
	// #### All other processors:
	// Optional field.
	//
	// Max Length: 10
	PostalCode string `json:"postalCode,omitempty"`

	// Title.
	//
	// Max Length: 60
	Title string `json:"title,omitempty"`
}

// Validate validates this create payment params body order information bill to
func (o *CreatePaymentParamsBodyOrderInformationBillTo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAddress1(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAddress2(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAddress3(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAddress4(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAdministrativeArea(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBuildingNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCompany(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDistrict(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEmail(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEmailDomain(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFirstName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLastName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocality(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMiddleName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNameSuffix(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePhoneNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTitle(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationBillTo) validateAddress1(formats strfmt.Registry) error {
	if swag.IsZero(o.Address1) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"address1", "body", o.Address1, 60); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationBillTo) validateAddress2(formats strfmt.Registry) error {
	if swag.IsZero(o.Address2) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"address2", "body", o.Address2, 60); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationBillTo) validateAddress3(formats strfmt.Registry) error {
	if swag.IsZero(o.Address3) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"address3", "body", o.Address3, 60); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationBillTo) validateAddress4(formats strfmt.Registry) error {
	if swag.IsZero(o.Address4) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"address4", "body", o.Address4, 60); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationBillTo) validateAdministrativeArea(formats strfmt.Registry) error {
	if swag.IsZero(o.AdministrativeArea) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"administrativeArea", "body", o.AdministrativeArea, 20); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationBillTo) validateBuildingNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.BuildingNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"buildingNumber", "body", o.BuildingNumber, 256); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationBillTo) validateCompany(formats strfmt.Registry) error {
	if swag.IsZero(o.Company) { // not required
		return nil
	}

	if o.Company != nil {
		if err := o.Company.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "orderInformation" + "." + "billTo" + "." + "company")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "orderInformation" + "." + "billTo" + "." + "company")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationBillTo) validateCountry(formats strfmt.Registry) error {
	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"country", "body", o.Country, 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationBillTo) validateDistrict(formats strfmt.Registry) error {
	if swag.IsZero(o.District) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"district", "body", o.District, 50); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationBillTo) validateEmail(formats strfmt.Registry) error {
	if swag.IsZero(o.Email) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"email", "body", o.Email, 255); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationBillTo) validateEmailDomain(formats strfmt.Registry) error {
	if swag.IsZero(o.EmailDomain) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"emailDomain", "body", o.EmailDomain, 100); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationBillTo) validateFirstName(formats strfmt.Registry) error {
	if swag.IsZero(o.FirstName) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"firstName", "body", o.FirstName, 60); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationBillTo) validateLastName(formats strfmt.Registry) error {
	if swag.IsZero(o.LastName) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"lastName", "body", o.LastName, 60); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationBillTo) validateLocality(formats strfmt.Registry) error {
	if swag.IsZero(o.Locality) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"locality", "body", o.Locality, 50); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationBillTo) validateMiddleName(formats strfmt.Registry) error {
	if swag.IsZero(o.MiddleName) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"middleName", "body", o.MiddleName, 60); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationBillTo) validateNameSuffix(formats strfmt.Registry) error {
	if swag.IsZero(o.NameSuffix) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"nameSuffix", "body", o.NameSuffix, 60); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationBillTo) validatePhoneNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.PhoneNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"phoneNumber", "body", o.PhoneNumber, 15); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationBillTo) validatePostalCode(formats strfmt.Registry) error {
	if swag.IsZero(o.PostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"postalCode", "body", o.PostalCode, 10); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationBillTo) validateTitle(formats strfmt.Registry) error {
	if swag.IsZero(o.Title) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"title", "body", o.Title, 60); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this create payment params body order information bill to based on the context it is used
func (o *CreatePaymentParamsBodyOrderInformationBillTo) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateCompany(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationBillTo) contextValidateCompany(ctx context.Context, formats strfmt.Registry) error {

	if o.Company != nil {
		if err := o.Company.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "orderInformation" + "." + "billTo" + "." + "company")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "orderInformation" + "." + "billTo" + "." + "company")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyOrderInformationBillTo) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyOrderInformationBillTo) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyOrderInformationBillTo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyOrderInformationBillToCompany create payment params body order information bill to company
swagger:model CreatePaymentParamsBodyOrderInformationBillToCompany
*/
type CreatePaymentParamsBodyOrderInformationBillToCompany struct {

	// First line in the street address of the company purchasing the product.
	// Max Length: 40
	Address1 string `json:"address1,omitempty"`

	// Additional address information for the company purchasing the product.
	// Max Length: 40
	Address2 string `json:"address2,omitempty"`

	// State or province in the address of the company purchasing the product. Use the State, Province, and Territory
	// Codes for the United States and Canada.
	//
	// Max Length: 2
	AdministrativeArea string `json:"administrativeArea,omitempty"`

	// Country in the address of the company purchasing the product. Use the [ISO Standard Country Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf).
	//
	// Max Length: 2
	Country string `json:"country,omitempty"`

	// City in the address of the company purchasing the product.
	// Max Length: 30
	Locality string `json:"locality,omitempty"`

	// Name of the customers company.
	//
	// **CyberSource through VisaNet**
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.
	//
	// For processor-specific information, see the `company_name` field in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 60
	Name string `json:"name,omitempty"`

	// Postal code in the address of the company purchasing the product. The postal code must consist of 5 to 9 digits.
	//
	// When the company country is the U.S., the 9-digit postal code must follow this format:
	// **[5 digits][dash][4 digits]**
	// #### Example
	// `12345-6789`
	//
	// When the company country is Canada, the 6-digit postal code must follow this format:
	// **[alpha][numeric][alpha][space][numeric][alpha][numeric]**
	// #### Example
	// `A1B 2C3`
	//
	// Max Length: 10
	PostalCode string `json:"postalCode,omitempty"`
}

// Validate validates this create payment params body order information bill to company
func (o *CreatePaymentParamsBodyOrderInformationBillToCompany) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAddress1(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAddress2(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAdministrativeArea(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocality(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationBillToCompany) validateAddress1(formats strfmt.Registry) error {
	if swag.IsZero(o.Address1) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"company"+"."+"address1", "body", o.Address1, 40); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationBillToCompany) validateAddress2(formats strfmt.Registry) error {
	if swag.IsZero(o.Address2) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"company"+"."+"address2", "body", o.Address2, 40); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationBillToCompany) validateAdministrativeArea(formats strfmt.Registry) error {
	if swag.IsZero(o.AdministrativeArea) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"company"+"."+"administrativeArea", "body", o.AdministrativeArea, 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationBillToCompany) validateCountry(formats strfmt.Registry) error {
	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"company"+"."+"country", "body", o.Country, 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationBillToCompany) validateLocality(formats strfmt.Registry) error {
	if swag.IsZero(o.Locality) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"company"+"."+"locality", "body", o.Locality, 30); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationBillToCompany) validateName(formats strfmt.Registry) error {
	if swag.IsZero(o.Name) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"company"+"."+"name", "body", o.Name, 60); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationBillToCompany) validatePostalCode(formats strfmt.Registry) error {
	if swag.IsZero(o.PostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"company"+"."+"postalCode", "body", o.PostalCode, 10); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment params body order information bill to company based on context it is used
func (o *CreatePaymentParamsBodyOrderInformationBillToCompany) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyOrderInformationBillToCompany) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyOrderInformationBillToCompany) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyOrderInformationBillToCompany
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyOrderInformationInvoiceDetails create payment params body order information invoice details
swagger:model CreatePaymentParamsBodyOrderInformationInvoiceDetails
*/
type CreatePaymentParamsBodyOrderInformationInvoiceDetails struct {

	// Barcode Number.
	BarcodeNumber string `json:"barcodeNumber,omitempty"`

	// International description code of the overall orders goods or services or the Categorizes purchases for VAT
	// reporting. Contact your acquirer for a list of codes.
	//
	// For processor-specific information, see the `summary_commodity_code` field in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 4
	CommodityCode string `json:"commodityCode,omitempty"`

	// Expiration Date.
	ExpirationDate string `json:"expirationDate,omitempty"`

	// Date of the tax calculation. Use format YYYYMMDD. You can provide a date in the past if you are calculating tax for a refund and want to know what the tax was on the date the order was placed.
	// You can provide a date in the future if you are calculating the tax for a future date, such as an upcoming tax holiday.
	//
	// The default is the date, in Pacific time, that the bank receives the request.
	// Keep this in mind if you are in a different time zone and want the tax calculated with the rates that are applicable on a specific date.
	//
	// #### Tax Calculation
	// Optional field for U.S., Canadian, international tax, and value added taxes.
	//
	// Max Length: 8
	InvoiceDate string `json:"invoiceDate,omitempty"`

	// Invoice Number.
	InvoiceNumber string `json:"invoiceNumber,omitempty"`

	// Identifier for the merchandise. This field is supported only on the processors listed in this field description.
	//
	// #### American Express Direct
	// Possible value:
	// - 1000: Gift card
	//
	// #### CyberSource through VisaNet
	// This value must be right justified. In Japan, this value is called a _goods code_.
	//
	// #### JCN Gateway
	// This value must be right justified. In Japan, this value is called a _goods code_.
	//
	MerchandiseCode int64 `json:"merchandiseCode,omitempty"`

	// The name of the individual or the company contacted for company authorized purchases.
	//
	// For processor-specific information, see the `authorized_contact_name` field in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 36
	PurchaseContactName string `json:"purchaseContactName,omitempty"`

	// Date the order was processed. `Format: YYYY-MM-DD`.
	//
	// For processor-specific information, see the `purchaser_order_date` field in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 10
	PurchaseOrderDate string `json:"purchaseOrderDate,omitempty"`

	// Value used by your customer to identify the order. This value is typically a purchase order number. CyberSource
	// recommends that you do not populate the field with all zeros or nines.
	//
	// For processor-specific information, see the `user_po` field in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 25
	PurchaseOrderNumber string `json:"purchaseOrderNumber,omitempty"`

	// Code that identifies the value of the `referenceDataNumber` field.
	//
	// For the possible values, see "Reference Data Codes" in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/).
	//
	// This field is a pass-through, which means that CyberSource does not verify the value or modify it in any way
	// before sending it to the processor.
	//
	// Max Length: 3
	ReferenceDataCode string `json:"referenceDataCode,omitempty"`

	// Reference number. The meaning of this value is identified by the value of the `referenceDataCode` field.
	//
	// This field is a pass-through, which means that CyberSource does not verify the value or modify it in any way
	// before sending it to the processor.
	//
	// Max Length: 30
	ReferenceDataNumber string `json:"referenceDataNumber,omitempty"`

	// Transaction identifier that is generated. You have the option of printing the sales slip number on the receipt.
	// This field is supported only on Cybersource through Visanet and JCN gateway.
	//
	// Optional field.
	//
	// #### Card Present processing message
	// If you included this field in the request, the returned value is the value that you sent in the request.
	// If you did not include this field in the request, the system generated this value for you.
	//
	// The difference between this reply field and the `processorInformation.systemTraceAuditNumber` field is that the
	// system generates the system trace audit number (STAN), and you must print the receipt number on the receipt;
	// whereas you can generate the sales slip number, and you can choose to print the sales slip number on the receipt.
	//
	// Maximum: 99999
	SalesSlipNumber int64 `json:"salesSlipNumber,omitempty"`

	// Flag that indicates whether an order is taxable. This value must be true if the sum of all _lineItems[].taxAmount_ values > 0.
	//
	// If you do not include any `lineItems[].taxAmount` values in your request, CyberSource does not include
	// `invoiceDetails.taxable` in the data it sends to the processor.
	//
	// For processor-specific information, see the `tax_indicator` field in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Possible values:
	//  - **true**
	//  - **false**
	//
	Taxable bool `json:"taxable,omitempty"`

	// transaction advice addendum
	TransactionAdviceAddendum []*CreatePaymentParamsBodyOrderInformationInvoiceDetailsTransactionAdviceAddendumItems0 `json:"transactionAdviceAddendum"`

	// VAT invoice number associated with the transaction.
	//
	// For processor-specific information, see the `vat_invoice_ref_number` field in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 15
	VatInvoiceReferenceNumber string `json:"vatInvoiceReferenceNumber,omitempty"`
}

// Validate validates this create payment params body order information invoice details
func (o *CreatePaymentParamsBodyOrderInformationInvoiceDetails) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCommodityCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateInvoiceDate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePurchaseContactName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePurchaseOrderDate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePurchaseOrderNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateReferenceDataCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateReferenceDataNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSalesSlipNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTransactionAdviceAddendum(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateVatInvoiceReferenceNumber(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationInvoiceDetails) validateCommodityCode(formats strfmt.Registry) error {
	if swag.IsZero(o.CommodityCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"invoiceDetails"+"."+"commodityCode", "body", o.CommodityCode, 4); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationInvoiceDetails) validateInvoiceDate(formats strfmt.Registry) error {
	if swag.IsZero(o.InvoiceDate) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"invoiceDetails"+"."+"invoiceDate", "body", o.InvoiceDate, 8); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationInvoiceDetails) validatePurchaseContactName(formats strfmt.Registry) error {
	if swag.IsZero(o.PurchaseContactName) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"invoiceDetails"+"."+"purchaseContactName", "body", o.PurchaseContactName, 36); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationInvoiceDetails) validatePurchaseOrderDate(formats strfmt.Registry) error {
	if swag.IsZero(o.PurchaseOrderDate) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"invoiceDetails"+"."+"purchaseOrderDate", "body", o.PurchaseOrderDate, 10); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationInvoiceDetails) validatePurchaseOrderNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.PurchaseOrderNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"invoiceDetails"+"."+"purchaseOrderNumber", "body", o.PurchaseOrderNumber, 25); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationInvoiceDetails) validateReferenceDataCode(formats strfmt.Registry) error {
	if swag.IsZero(o.ReferenceDataCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"invoiceDetails"+"."+"referenceDataCode", "body", o.ReferenceDataCode, 3); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationInvoiceDetails) validateReferenceDataNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.ReferenceDataNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"invoiceDetails"+"."+"referenceDataNumber", "body", o.ReferenceDataNumber, 30); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationInvoiceDetails) validateSalesSlipNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.SalesSlipNumber) { // not required
		return nil
	}

	if err := validate.MaximumInt("createPaymentRequest"+"."+"orderInformation"+"."+"invoiceDetails"+"."+"salesSlipNumber", "body", o.SalesSlipNumber, 99999, false); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationInvoiceDetails) validateTransactionAdviceAddendum(formats strfmt.Registry) error {
	if swag.IsZero(o.TransactionAdviceAddendum) { // not required
		return nil
	}

	for i := 0; i < len(o.TransactionAdviceAddendum); i++ {
		if swag.IsZero(o.TransactionAdviceAddendum[i]) { // not required
			continue
		}

		if o.TransactionAdviceAddendum[i] != nil {
			if err := o.TransactionAdviceAddendum[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("createPaymentRequest" + "." + "orderInformation" + "." + "invoiceDetails" + "." + "transactionAdviceAddendum" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("createPaymentRequest" + "." + "orderInformation" + "." + "invoiceDetails" + "." + "transactionAdviceAddendum" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationInvoiceDetails) validateVatInvoiceReferenceNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.VatInvoiceReferenceNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"invoiceDetails"+"."+"vatInvoiceReferenceNumber", "body", o.VatInvoiceReferenceNumber, 15); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this create payment params body order information invoice details based on the context it is used
func (o *CreatePaymentParamsBodyOrderInformationInvoiceDetails) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateTransactionAdviceAddendum(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationInvoiceDetails) contextValidateTransactionAdviceAddendum(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.TransactionAdviceAddendum); i++ {

		if o.TransactionAdviceAddendum[i] != nil {
			if err := o.TransactionAdviceAddendum[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("createPaymentRequest" + "." + "orderInformation" + "." + "invoiceDetails" + "." + "transactionAdviceAddendum" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("createPaymentRequest" + "." + "orderInformation" + "." + "invoiceDetails" + "." + "transactionAdviceAddendum" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyOrderInformationInvoiceDetails) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyOrderInformationInvoiceDetails) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyOrderInformationInvoiceDetails
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyOrderInformationInvoiceDetailsTransactionAdviceAddendumItems0 create payment params body order information invoice details transaction advice addendum items0
swagger:model CreatePaymentParamsBodyOrderInformationInvoiceDetailsTransactionAdviceAddendumItems0
*/
type CreatePaymentParamsBodyOrderInformationInvoiceDetailsTransactionAdviceAddendumItems0 struct {

	// Four Transaction Advice Addendum (TAA) fields. These fields are used to display descriptive information
	// about a transaction on the customers American Express card statement. When you send TAA fields, start
	// with amexdata_taa1, then ...taa2, and so on. Skipping a TAA field causes subsequent TAA fields to be
	// ignored.
	//
	// To use these fields, contact CyberSource Customer Support to have your account enabled for this feature.
	//
	// Max Length: 40
	Data string `json:"data,omitempty"`
}

// Validate validates this create payment params body order information invoice details transaction advice addendum items0
func (o *CreatePaymentParamsBodyOrderInformationInvoiceDetailsTransactionAdviceAddendumItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateData(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationInvoiceDetailsTransactionAdviceAddendumItems0) validateData(formats strfmt.Registry) error {
	if swag.IsZero(o.Data) { // not required
		return nil
	}

	if err := validate.MaxLength("data", "body", o.Data, 40); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment params body order information invoice details transaction advice addendum items0 based on context it is used
func (o *CreatePaymentParamsBodyOrderInformationInvoiceDetailsTransactionAdviceAddendumItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyOrderInformationInvoiceDetailsTransactionAdviceAddendumItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyOrderInformationInvoiceDetailsTransactionAdviceAddendumItems0) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyOrderInformationInvoiceDetailsTransactionAdviceAddendumItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyOrderInformationLineItemsItems0 create payment params body order information line items items0
swagger:model CreatePaymentParamsBodyOrderInformationLineItemsItems0
*/
type CreatePaymentParamsBodyOrderInformationLineItemsItems0 struct {

	// Flag that indicates whether the tax amount is included in the Line Item Total.
	//
	// Possible values:
	//  - **true**
	//  - **false**
	//
	AmountIncludesTax bool `json:"amountIncludesTax,omitempty"`

	// Commodity code or International description code used to classify the item. Contact your acquirer for a list of
	// codes.
	//
	// Max Length: 15
	CommodityCode string `json:"commodityCode,omitempty"`

	// Discount applied to the item.
	// Max Length: 13
	DiscountAmount string `json:"discountAmount,omitempty"`

	// Flag that indicates whether the amount is discounted.
	//
	// If you do not provide a value but you set Discount Amount to a value greater than zero, then CyberSource sets
	// this field to **true**.
	//
	// Possible values:
	//  - **true**
	//  - **false**
	//
	DiscountApplied bool `json:"discountApplied,omitempty"`

	// Rate the item is discounted. Maximum of 2 decimal places.
	//
	// Example 5.25 (=5.25%)
	//
	// Max Length: 6
	DiscountRate string `json:"discountRate,omitempty"`

	// Information about the product code used for the line item.
	// Possible values:
	// - `E`: The product code is `electronic_software`.
	// - `P`: The product code is not `electronic_software`.
	//
	// For details, see the `fulfillmentType` field description in [Business Center Reporting User Guide.]
	// (https://apps.cybersource.com/library/documentation/dev_guides/reporting_and_reconciliation/Reporting_User/html/)
	//
	FulfillmentType string `json:"fulfillmentType,omitempty"`

	// This field is only used in DM service.
	//
	// Determines whether to assign risk to the order if the billing and shipping addresses specify different cities,
	// states, or countries. This field can contain one of the following values:
	// - true: Orders are assigned only slight additional risk if billing and shipping addresses are different.
	// - false: Orders are assigned higher additional risk if billing and shipping addresses are different.
	//
	Gift bool `json:"gift,omitempty"`

	// When `orderInformation.lineItems[].productCode` is "gift_card", this is the
	// currency used for the gift card purchase.
	//
	// For details, see `pa_gift_card_currency` field description in [CyberSource Payer Authentication Using the SCMP API.]
	// (https://apps.cybersource.com/library/documentation/dev_guides/Payer_Authentication_SCMP_API/Payer_Authentication_SCMP_API.pdf)
	//
	// For the possible values, see the [ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)
	//
	GiftCardCurrency int64 `json:"giftCardCurrency,omitempty"`

	// Field to support an invoice number for a transaction. You must specify the number of line items that will
	// include an invoice number. By default, the first line item will include an invoice number field. The invoice
	// number field can be included for up to 10 line items.
	//
	// Max Length: 23
	InvoiceNumber string `json:"invoiceNumber,omitempty"`

	// passenger
	Passenger *CreatePaymentParamsBodyOrderInformationLineItemsItems0Passenger `json:"passenger,omitempty"`

	// Type of product. The value for this field is used to identify the product category (electronic, handling, physical,
	// service, or shipping). The default value is `default`.
	//
	// If you are performing an authorization transaction (`processingOptions.capture` is set to `false`), and you set
	// this field to a value other than `default` or one of the values related to shipping and/or handling, then
	// `orderInformation.lineItems[].quantity`, `orderInformation.lineItems[].productName`, and
	// `orderInformation.lineItems[].productSku` fields are required.
	//
	// Optional field.
	//
	// For details, see the `product_code` field description in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/).
	//
	// #### Tax Calculation
	// Optional field for U.S., Canadian, international tax, and value added taxes.
	//
	// To use the tax calculation service, use values listed in the Tax Product Code Guide. For information about this
	// document, contact customer support. See "Product Codes," page 14, for more information.
	//
	// Max Length: 255
	ProductCode string `json:"productCode,omitempty"`

	// Brief description of item.
	ProductDescription string `json:"productDescription,omitempty"`

	// For an authorization or capture transaction (`processingOptions.capture` is `true` or `false`),
	// this field is required when `orderInformation.lineItems[].productCode` is not `default` or one of
	// the other values that are related to shipping and/or handling.
	//
	// #### Tax Calculation
	// Optional field for U.S., Canadian, international tax, and value added taxes.
	//
	// Max Length: 255
	ProductName string `json:"productName,omitempty"`

	// Product identifier code. Also known as the Stock Keeping Unit (SKU) code for the product.
	//
	// For an authorization or capture transaction (`processingOptions.capture` is set to `true` or `false`), this field is required when `orderInformation.lineItems[].productCode` is not set to **default** or one of the other values that are related to shipping and/or handling.
	//
	// #### Tax Calculation
	// Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes.
	// For an authorization or capture transaction (`processingOptions.capture` is set to `true` or `false`), this field is
	// required when `orderInformation.lineItems[].productCode` is not `default` or one of the values related to shipping and/or handling.
	//
	// Max Length: 255
	ProductSku string `json:"productSku,omitempty"`

	// Number of units for this order. Must be a non-negative integer.
	//
	// The default is `1`. For an authorization or capture transaction (`processingOptions.capture` is set to `true` or `false`),
	// this field is required when `orderInformation.lineItems[].productCode` is not `default` or one of the other values
	// related to shipping and/or handling.
	//
	// #### Tax Calculation
	// Optional field for U.S., Canadian, international tax, and value added taxes.
	//
	// Maximum: 9.99999999e+08
	// Minimum: 1
	Quantity int64 `json:"quantity,omitempty"`

	// Code that identifies the value of the corresponding `orderInformation.lineItems[].referenceDataNumber` field.
	//
	// Possible values:
	// - AN: Client-defined asset code
	// - MG: Manufacturer's part number
	// - PO: Purchase order number
	// - SK: Supplier stock keeping unit number
	// - UP: Universal product code
	// - VC: Supplier catalog number
	// - VP: Vendor part number
	//
	// This field is a pass-through, which means that CyberSource does not verify the value or modify it in any way
	// before sending it to the processor.
	//
	// For details, see `reference_data_#_code` field description in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/)
	//
	// Max Length: 2
	ReferenceDataCode string `json:"referenceDataCode,omitempty"`

	// Reference number.
	//
	// The meaning of this value is identified by the value of the corresponding `referenceDataCode` field.
	// See Numbered Elements.
	//
	// The maximum length for this field depends on the value of the corresponding `referenceDataCode` field:
	// - When the code is `PO`, the maximum length for the reference number is 22.
	// - When the code is `VC`, the maximum length for the reference number is 20.
	// - For all other codes, the maximum length for the reference number is 30.
	//
	// This field is a pass-through, which means that CyberSource does not verify the value or modify it in any way
	// before sending it to the processor.
	//
	// Max Length: 30
	ReferenceDataNumber string `json:"referenceDataNumber,omitempty"`

	// Destination to where the item will be shipped. Example: Commercial, Residential, Store
	//
	// Max Length: 50
	ShippingDestinationTypes string `json:"shippingDestinationTypes,omitempty"`

	// Total tax to apply to the product. This value cannot be negative. The tax amount and the offer amount must
	// be in the same currency. The tax amount field is additive.
	//
	// The following example uses a two-exponent currency such as USD:
	//
	//  1. You include each line item in your request.
	//  ..- 1st line item has amount=10.00, quantity=1, and taxAmount=0.80
	//  ..- 2nd line item has amount=20.00, quantity=1, and taxAmount=1.60
	//  2. The total amount authorized will be 32.40, not 30.00 with 2.40 of tax included.
	//
	// Optional field.
	//
	// #### Airlines processing
	// Tax portion of the order amount. This value cannot exceed 99999999999999 (fourteen 9s).
	// Format: English characters only.
	// Optional request field for a line item.
	//
	// #### Tax Calculation
	// Optional field for U.S., Canadian, international tax, and value added taxes.
	//
	// Note if you send this field in your tax request, the value in the field will override the tax engine
	//
	// Max Length: 15
	TaxAmount string `json:"taxAmount,omitempty"`

	// Flag to indicate how you handle discount at the line item level.
	//
	//  - 0: no line level discount provided
	//  - 1: tax was calculated on the post-discount line item total
	//  - 2: tax was calculated on the pre-discount line item total
	//
	// `Note` Visa will inset 0 (zero) if an invalid value is included in this field.
	//
	// This field relates to the value in the _lineItems[].discountAmount_ field.
	//
	// Max Length: 1
	TaxAppliedAfterDiscount string `json:"taxAppliedAfterDiscount,omitempty"`

	// tax details
	TaxDetails []*CreatePaymentParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0 `json:"taxDetails"`

	// Tax rate applied to the item.
	//
	// For details, see `tax_rate` field description in the [Level II and Level III Processing Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/)
	//
	// **Visa**: Valid range is 0.01 to 0.99 (1% to 99%, with only whole percentage values accepted; values with additional
	// decimal places will be truncated).
	//
	// **Mastercard**: Valid range is 0.00001 to 0.99999 (0.001% to 99.999%).
	//
	// Max Length: 7
	TaxRate string `json:"taxRate,omitempty"`

	// Flag to indicate whether tax is exempted or not included.
	//
	//  - 0: tax not included
	//  - 1: tax included
	//  - 2: transaction is not subject to tax
	//
	// Max Length: 1
	TaxStatusIndicator string `json:"taxStatusIndicator,omitempty"`

	// Type of tax being applied to the item.
	//
	// For possible values, see the processor-specific field descriptions in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/):
	//
	// #### FDC Nashville Global
	// - `alternate_tax_type_applied`
	// - `alternate_tax_type_identifier`
	//
	// #### Worldpay VAP
	// - `alternate_tax_type_identifier`
	//
	// #### RBS WorldPay Atlanta
	// - `tax_type_applied`
	//
	// #### TSYS Acquiring Solutions
	// - `tax_type_applied`
	// - `local_tax_indicator`
	//
	// #### Chase Paymentech Solutions
	// - `tax_type_applied`
	//
	// #### Elavon Americas
	// - `local_tax_indicator`
	//
	// #### FDC Compass
	// - `tax_type_applied`
	//
	// #### OmniPay Direct
	// - `local_tax_indicator`
	//
	// Max Length: 4
	TaxTypeCode string `json:"taxTypeCode,omitempty"`

	// Total amount for the item. Normally calculated as the unit price times quantity.
	//
	// When `orderInformation.lineItems[].productCode` is "gift_card", this is the purchase amount total
	// for prepaid gift cards in major units.
	//
	// Example: 123.45 USD = 123
	//
	// Max Length: 13
	TotalAmount string `json:"totalAmount,omitempty"`

	// Flag to indicate whether the purchase is categorized as goods or services.
	// Possible values:
	//
	//  - 00: goods
	//  - 01: services
	//
	// Max Length: 2
	TypeOfSupply string `json:"typeOfSupply,omitempty"`

	// Unit of measure, or unit of measure code, for the item.
	//
	// Max Length: 12
	UnitOfMeasure string `json:"unitOfMeasure,omitempty"`

	// Per-item price of the product. This value for this field cannot be negative.
	//
	// You must include either this field or the request-level field `orderInformation.amountDetails.totalAmount` in your request.
	//
	// You can include a decimal point (.), but you cannot include any other special characters.
	// The value is truncated to the correct number of decimal places.
	//
	// #### DCC with a Third-Party Provider
	// Set this field to the converted amount that was returned by the DCC provider. You must include either
	// the 1st line item in the order and this field, or the request-level field `orderInformation.amountDetails.totalAmount` in your request.
	//
	// #### FDMS South
	// If you accept IDR or CLP currencies, see the entry for FDMS South in the [Merchant Descriptors Using the SCMP API Guide.]
	// (https://apps.cybersource.com/library/documentation/dev_guides/Merchant_Descriptors_SCMP_API/html/)
	//
	// #### Tax Calculation
	// Required field for U.S., Canadian, international and value added taxes.
	//
	// #### Zero Amount Authorizations
	// If your processor supports zero amount authorizations, you can set this field to 0 for the
	// authorization to check if the card is lost or stolen.
	//
	// #### Maximum Field Lengths
	// For GPN and JCN Gateway: Decimal (10)
	// All other processors: Decimal (15)
	//
	// Max Length: 15
	UnitPrice string `json:"unitPrice,omitempty"`

	// Weight of the item.
	//
	// For details, see `weight_amount` field description in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/)
	//
	// Max Length: 9
	Weight string `json:"weight,omitempty"`

	// Type of weight.
	//
	// Possible values:
	// - B: Billed weight
	// - N: Actual net weight
	//
	// For details, see `weight_identifier` offer-level field description in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/)
	//
	// Max Length: 1
	WeightIdentifier string `json:"weightIdentifier,omitempty"`

	// Code that specifies the unit of measurement for the weight amount. For example, `OZ` specifies ounce and `LB` specifies pound. The possible values are defined by the ANSI Accredited Standards Committee (ASC).
	//
	// For details, see `weight_unit_measurement` offer-level field description in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/)
	//
	// Max Length: 2
	WeightUnit string `json:"weightUnit,omitempty"`
}

// Validate validates this create payment params body order information line items items0
func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCommodityCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDiscountAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDiscountRate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateInvoiceNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePassenger(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProductCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProductName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProductSku(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateQuantity(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateReferenceDataCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateReferenceDataNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateShippingDestinationTypes(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxAppliedAfterDiscount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxRate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxStatusIndicator(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxTypeCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTotalAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTypeOfSupply(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateUnitOfMeasure(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateUnitPrice(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateWeight(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateWeightIdentifier(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateWeightUnit(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0) validateCommodityCode(formats strfmt.Registry) error {
	if swag.IsZero(o.CommodityCode) { // not required
		return nil
	}

	if err := validate.MaxLength("commodityCode", "body", o.CommodityCode, 15); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0) validateDiscountAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.DiscountAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("discountAmount", "body", o.DiscountAmount, 13); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0) validateDiscountRate(formats strfmt.Registry) error {
	if swag.IsZero(o.DiscountRate) { // not required
		return nil
	}

	if err := validate.MaxLength("discountRate", "body", o.DiscountRate, 6); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0) validateInvoiceNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.InvoiceNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("invoiceNumber", "body", o.InvoiceNumber, 23); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0) validatePassenger(formats strfmt.Registry) error {
	if swag.IsZero(o.Passenger) { // not required
		return nil
	}

	if o.Passenger != nil {
		if err := o.Passenger.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("passenger")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("passenger")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0) validateProductCode(formats strfmt.Registry) error {
	if swag.IsZero(o.ProductCode) { // not required
		return nil
	}

	if err := validate.MaxLength("productCode", "body", o.ProductCode, 255); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0) validateProductName(formats strfmt.Registry) error {
	if swag.IsZero(o.ProductName) { // not required
		return nil
	}

	if err := validate.MaxLength("productName", "body", o.ProductName, 255); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0) validateProductSku(formats strfmt.Registry) error {
	if swag.IsZero(o.ProductSku) { // not required
		return nil
	}

	if err := validate.MaxLength("productSku", "body", o.ProductSku, 255); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0) validateQuantity(formats strfmt.Registry) error {
	if swag.IsZero(o.Quantity) { // not required
		return nil
	}

	if err := validate.MinimumInt("quantity", "body", o.Quantity, 1, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("quantity", "body", o.Quantity, 9.99999999e+08, false); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0) validateReferenceDataCode(formats strfmt.Registry) error {
	if swag.IsZero(o.ReferenceDataCode) { // not required
		return nil
	}

	if err := validate.MaxLength("referenceDataCode", "body", o.ReferenceDataCode, 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0) validateReferenceDataNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.ReferenceDataNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("referenceDataNumber", "body", o.ReferenceDataNumber, 30); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0) validateShippingDestinationTypes(formats strfmt.Registry) error {
	if swag.IsZero(o.ShippingDestinationTypes) { // not required
		return nil
	}

	if err := validate.MaxLength("shippingDestinationTypes", "body", o.ShippingDestinationTypes, 50); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0) validateTaxAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.TaxAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("taxAmount", "body", o.TaxAmount, 15); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0) validateTaxAppliedAfterDiscount(formats strfmt.Registry) error {
	if swag.IsZero(o.TaxAppliedAfterDiscount) { // not required
		return nil
	}

	if err := validate.MaxLength("taxAppliedAfterDiscount", "body", o.TaxAppliedAfterDiscount, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0) validateTaxDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.TaxDetails) { // not required
		return nil
	}

	for i := 0; i < len(o.TaxDetails); i++ {
		if swag.IsZero(o.TaxDetails[i]) { // not required
			continue
		}

		if o.TaxDetails[i] != nil {
			if err := o.TaxDetails[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("taxDetails" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("taxDetails" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0) validateTaxRate(formats strfmt.Registry) error {
	if swag.IsZero(o.TaxRate) { // not required
		return nil
	}

	if err := validate.MaxLength("taxRate", "body", o.TaxRate, 7); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0) validateTaxStatusIndicator(formats strfmt.Registry) error {
	if swag.IsZero(o.TaxStatusIndicator) { // not required
		return nil
	}

	if err := validate.MaxLength("taxStatusIndicator", "body", o.TaxStatusIndicator, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0) validateTaxTypeCode(formats strfmt.Registry) error {
	if swag.IsZero(o.TaxTypeCode) { // not required
		return nil
	}

	if err := validate.MaxLength("taxTypeCode", "body", o.TaxTypeCode, 4); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0) validateTotalAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.TotalAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("totalAmount", "body", o.TotalAmount, 13); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0) validateTypeOfSupply(formats strfmt.Registry) error {
	if swag.IsZero(o.TypeOfSupply) { // not required
		return nil
	}

	if err := validate.MaxLength("typeOfSupply", "body", o.TypeOfSupply, 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0) validateUnitOfMeasure(formats strfmt.Registry) error {
	if swag.IsZero(o.UnitOfMeasure) { // not required
		return nil
	}

	if err := validate.MaxLength("unitOfMeasure", "body", o.UnitOfMeasure, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0) validateUnitPrice(formats strfmt.Registry) error {
	if swag.IsZero(o.UnitPrice) { // not required
		return nil
	}

	if err := validate.MaxLength("unitPrice", "body", o.UnitPrice, 15); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0) validateWeight(formats strfmt.Registry) error {
	if swag.IsZero(o.Weight) { // not required
		return nil
	}

	if err := validate.MaxLength("weight", "body", o.Weight, 9); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0) validateWeightIdentifier(formats strfmt.Registry) error {
	if swag.IsZero(o.WeightIdentifier) { // not required
		return nil
	}

	if err := validate.MaxLength("weightIdentifier", "body", o.WeightIdentifier, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0) validateWeightUnit(formats strfmt.Registry) error {
	if swag.IsZero(o.WeightUnit) { // not required
		return nil
	}

	if err := validate.MaxLength("weightUnit", "body", o.WeightUnit, 2); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this create payment params body order information line items items0 based on the context it is used
func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidatePassenger(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateTaxDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0) contextValidatePassenger(ctx context.Context, formats strfmt.Registry) error {

	if o.Passenger != nil {
		if err := o.Passenger.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("passenger")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("passenger")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0) contextValidateTaxDetails(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.TaxDetails); i++ {

		if o.TaxDetails[i] != nil {
			if err := o.TaxDetails[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("taxDetails" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("taxDetails" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyOrderInformationLineItemsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyOrderInformationLineItemsItems0Passenger Contains travel-related passenger details used by DM service only.
swagger:model CreatePaymentParamsBodyOrderInformationLineItemsItems0Passenger
*/
type CreatePaymentParamsBodyOrderInformationLineItemsItems0Passenger struct {

	// Passenger's email address, including the full domain name, such as jdoe@example.com.
	// Max Length: 255
	Email string `json:"email,omitempty"`

	// Passenger's first name.
	// Max Length: 60
	FirstName string `json:"firstName,omitempty"`

	// ID of the passenger to whom the ticket was issued. For example, you can use this field for the frequent flyer
	// number.
	//
	// Max Length: 40
	ID string `json:"id,omitempty"`

	// Passenger's last name.
	// Max Length: 60
	LastName string `json:"lastName,omitempty"`

	// Passenger's nationality country. Use the two character [ISO Standard Country Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf).
	// Max Length: 2
	Nationality string `json:"nationality,omitempty"`

	// Passenger's phone number. If the order is from outside the U.S., CyberSource recommends that you include
	// the [ISO Standard Country Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf).
	//
	// Max Length: 15
	Phone string `json:"phone,omitempty"`

	// Your company's passenger classification, such as with a frequent flyer program. In this case, you might use
	// values such as `standard`, `gold`, or `platinum`.
	//
	// Max Length: 32
	Status string `json:"status,omitempty"`

	// Passenger classification associated with the price of the ticket. You can use one of the following values:
	// - `ADT`: Adult
	// - `CNN`: Child
	// - `INF`: Infant
	// - `YTH`: Youth
	// - `STU`: Student
	// - `SCR`: Senior Citizen
	// - `MIL`: Military
	//
	// Max Length: 32
	Type string `json:"type,omitempty"`
}

// Validate validates this create payment params body order information line items items0 passenger
func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0Passenger) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateEmail(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFirstName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLastName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNationality(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePhone(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0Passenger) validateEmail(formats strfmt.Registry) error {
	if swag.IsZero(o.Email) { // not required
		return nil
	}

	if err := validate.MaxLength("passenger"+"."+"email", "body", o.Email, 255); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0Passenger) validateFirstName(formats strfmt.Registry) error {
	if swag.IsZero(o.FirstName) { // not required
		return nil
	}

	if err := validate.MaxLength("passenger"+"."+"firstName", "body", o.FirstName, 60); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0Passenger) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MaxLength("passenger"+"."+"id", "body", o.ID, 40); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0Passenger) validateLastName(formats strfmt.Registry) error {
	if swag.IsZero(o.LastName) { // not required
		return nil
	}

	if err := validate.MaxLength("passenger"+"."+"lastName", "body", o.LastName, 60); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0Passenger) validateNationality(formats strfmt.Registry) error {
	if swag.IsZero(o.Nationality) { // not required
		return nil
	}

	if err := validate.MaxLength("passenger"+"."+"nationality", "body", o.Nationality, 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0Passenger) validatePhone(formats strfmt.Registry) error {
	if swag.IsZero(o.Phone) { // not required
		return nil
	}

	if err := validate.MaxLength("passenger"+"."+"phone", "body", o.Phone, 15); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0Passenger) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(o.Status) { // not required
		return nil
	}

	if err := validate.MaxLength("passenger"+"."+"status", "body", o.Status, 32); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0Passenger) validateType(formats strfmt.Registry) error {
	if swag.IsZero(o.Type) { // not required
		return nil
	}

	if err := validate.MaxLength("passenger"+"."+"type", "body", o.Type, 32); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment params body order information line items items0 passenger based on context it is used
func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0Passenger) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0Passenger) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0Passenger) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyOrderInformationLineItemsItems0Passenger
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0 create payment params body order information line items items0 tax details items0
swagger:model CreatePaymentParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0
*/
type CreatePaymentParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0 struct {

	// Indicates the amount of tax based on the `type` field as described in the table below:
	//
	// | type      | type description |
	// | ------------- |:-------------:|
	// | `alternate` | Total amount of alternate tax for the order. |
	// | `local`     | Sales tax for the order. |
	// | `national`  | National tax for the order. |
	// | `vat`       | Total amount of value added tax (VAT) included in the order. |
	// | `other`     | Other tax. |
	//
	// Max Length: 13
	Amount string `json:"amount,omitempty"`

	// Flag that indicates whether the alternate tax amount (`orderInformation.amountDetails.taxDetails[].amount`) is
	// included in the request.
	//
	// Possible values:
	// - `false`: alternate tax amount is not included in the request.
	// - `true`: alternate tax amount is included in the request.
	//
	// For processor-specific details, see `alternate_tax_amount_indicator` field description in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/)
	//
	Applied bool `json:"applied,omitempty"`

	// Type of tax being applied to the item.
	//
	// For possible values, see the processor-specific field descriptions in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/):
	//
	// #### FDC Nashville Global
	// - `alternate_tax_type_applied`
	// - `alternate_tax_type_identifier`
	//
	// #### Worldpay VAP
	// - `alternate_tax_type_identifier`
	//
	// #### RBS WorldPay Atlanta
	// - `tax_type_applied`
	//
	// #### TSYS Acquiring Solutions
	// - `tax_type_applied`
	// - `local_tax_indicator`
	//
	// #### Chase Paymentech Solutions
	// - `tax_type_applied`
	//
	// #### Elavon Americas
	// - `local_tax_indicator`
	//
	// #### FDC Compass
	// - `tax_type_applied`
	//
	// #### OmniPay Direct
	// - `local_tax_indicator`
	//
	// Max Length: 4
	Code string `json:"code,omitempty"`

	// Status code for exemption from sales and use tax. This field is a pass-through, which means that
	// CyberSource does not verify the value or modify it in any way before sending it to the processor.
	//
	// For possible values and important information for using this field, see _Appendix B, "Exemption
	// Status Values_ and _Offer-Level Tax Fields_ in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/)
	//
	// Max Length: 1
	ExemptionCode string `json:"exemptionCode,omitempty"`

	// Rate of VAT or other tax for the order.
	//
	// Example 0.040 (=4%)
	//
	// Valid range: 0.01 to 0.99 (1% to 99%, with only whole percentage values accepted; values with additional
	// decimal places will be truncated)
	//
	// For processor-specific details, see the `alternate_tax_amount`, `vat_rate`, `vat_tax_rate`, `local_tax`, `national_tax`, `vat_tax_amount` or `other_tax#_rate` field descriptions in the [Level II and Level III Processing Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/)
	//
	// Max Length: 6
	Rate string `json:"rate,omitempty"`

	// Your tax ID number to use for the alternate tax amount. Required if you set alternate tax amount to any value,
	// including zero. You may send this field without sending alternate tax amount.
	//
	// For processor-specific details, see `alternate_tax_id` field description in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/)
	//
	// Max Length: 15
	TaxID string `json:"taxId,omitempty"`

	// Indicates the type of tax data for the _taxDetails_ object.
	//
	// Possible values:
	//
	// - `alternate`
	// - `local`
	// - `national`
	// - `vat`
	// - `other`
	//
	// For processor-specific details, see the `alternate_tax_amount`, `local_tax`, `national_tax` or `vat_tax_amount` field
	// descriptions in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/)
	//
	Type string `json:"type,omitempty"`
}

// Validate validates this create payment params body order information line items items0 tax details items0
func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExemptionCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0) validateAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.Amount) { // not required
		return nil
	}

	if err := validate.MaxLength("amount", "body", o.Amount, 13); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0) validateCode(formats strfmt.Registry) error {
	if swag.IsZero(o.Code) { // not required
		return nil
	}

	if err := validate.MaxLength("code", "body", o.Code, 4); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0) validateExemptionCode(formats strfmt.Registry) error {
	if swag.IsZero(o.ExemptionCode) { // not required
		return nil
	}

	if err := validate.MaxLength("exemptionCode", "body", o.ExemptionCode, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0) validateRate(formats strfmt.Registry) error {
	if swag.IsZero(o.Rate) { // not required
		return nil
	}

	if err := validate.MaxLength("rate", "body", o.Rate, 6); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0) validateTaxID(formats strfmt.Registry) error {
	if swag.IsZero(o.TaxID) { // not required
		return nil
	}

	if err := validate.MaxLength("taxId", "body", o.TaxID, 15); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment params body order information line items items0 tax details items0 based on context it is used
func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyOrderInformationShipTo create payment params body order information ship to
swagger:model CreatePaymentParamsBodyOrderInformationShipTo
*/
type CreatePaymentParamsBodyOrderInformationShipTo struct {

	// First line of the shipping address.
	//
	// Required field for authorization if any shipping address information is included in the request; otherwise, optional.
	//
	// #### Tax Calculation
	// Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes.
	// Billing address objects will be used to determine the cardholders location when shipTo objects are not present.
	//
	// Max Length: 60
	Address1 string `json:"address1,omitempty"`

	// Second line of the shipping address.
	//
	// Optional field.
	//
	// #### Tax Calculation
	// Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes.
	// Billing address objects will be used to determine the cardholders location when shipTo objects are not present.
	//
	// Max Length: 60
	Address2 string `json:"address2,omitempty"`

	// State or province of the shipping address. Use the [State, Province, and Territory Codes for the United States and Canada](https://developer.cybersource.com/library/documentation/sbc/quickref/states_and_provinces.pdf)
	//
	// Required field for authorization if any shipping address information is included in the request and shipping to the U.S.
	// or Canada; otherwise, optional.
	//
	// #### Tax Calculation
	// Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes.
	// Billing address objects will be used to determine the cardholders location when shipTo objects are not present.
	//
	// Max Length: 2
	AdministrativeArea string `json:"administrativeArea,omitempty"`

	// Building number in the street address. For example, the building number is 187 in the following address:
	//
	// Rua da Quitanda 187
	//
	// Max Length: 15
	BuildingNumber string `json:"buildingNumber,omitempty"`

	// Name of the customers company.
	//
	// For processor-specific information, see the company_name field in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 60
	Company string `json:"company,omitempty"`

	// Country of the shipping address. Use the two-character [ISO Standard Country Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf)
	//
	// Required field for authorization if any shipping address information is included in the request; otherwise, optional.
	//
	// #### Tax Calculation
	// Optional field for U.S., Canadian, international tax, and value added taxes.
	// Billing address objects will be used to determine the cardholders location when shipTo objects are not present.
	//
	// Max Length: 2
	Country string `json:"country,omitempty"`

	// Indicates destination chosen for the transaction. Possible values:
	// - 01- Ship to cardholder billing address
	// - 02- Ship to another verified address on file with merchant
	// - 03- Ship to address that is different than billing address
	// - 04- Ship to store (store address should be populated on request)
	// - 05- Digital goods
	// - 06- Travel and event tickets, not shipped
	// - 07- Other
	//
	DestinationCode int64 `json:"destinationCode,omitempty"`

	// Shipping destination of item. Example: Commercial, Residential, Store
	//
	// Max Length: 25
	DestinationTypes string `json:"destinationTypes,omitempty"`

	// Neighborhood, community, or region within a city or municipality.
	// Max Length: 50
	District string `json:"district,omitempty"`

	// First name of the recipient.
	//
	// #### Litle
	// Maximum length: 25
	//
	// #### All other processors
	// Maximum length: 60
	//
	// Optional field.
	//
	// Max Length: 60
	FirstName string `json:"firstName,omitempty"`

	// Last name of the recipient.
	//
	// #### Litle
	// Maximum length: 25
	//
	// #### All other processors
	// Maximum length: 60
	//
	// Optional field.
	//
	// Max Length: 60
	LastName string `json:"lastName,omitempty"`

	// City of the shipping address.
	//
	// Required field for authorization if any shipping address information is included in the request and shipping to the U.S. or
	// Canada; otherwise, optional.
	//
	// #### Tax Calculation
	// Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes.
	// Billing address objects will be used to determine the cardholders location when shipTo objects are not present.
	//
	// Max Length: 50
	Locality string `json:"locality,omitempty"`

	// Shipping method for the product. Possible values:
	// - lowcost: Lowest-cost service
	// - sameday: Courier or same-day service
	// - oneday: Next-day or overnight service
	// - twoday: Two-day service
	// - threeday: Three-day service
	// - pickup: Store pick-up
	// - other: Other shipping method
	// - none: No shipping method because product is a service or subscription
	// Required for American Express SafeKey (U.S.).
	//
	// Max Length: 10
	Method string `json:"method,omitempty"`

	// Phone number associated with the shipping address.
	// Max Length: 15
	PhoneNumber string `json:"phoneNumber,omitempty"`

	// Postal code for the shipping address. The postal code must consist of 5 to 9 digits.
	//
	// Required field for authorization if any shipping address information is included in the request and
	// shipping to the U.S. or Canada; otherwise, optional.
	//
	// When the billing country is the U.S., the 9-digit postal code must follow this format:
	// [5 digits][dash][4 digits]
	//
	// Example 12345-6789
	//
	// When the billing country is Canada, the 6-digit postal code must follow this format:
	// [alpha][numeric][alpha][space][numeric][alpha][numeric]
	//
	// Example A1B 2C3
	//
	// #### American Express Direct
	// Before sending the postal code to the processor, all nonalphanumeric characters are removed and, if the
	// remaining value is longer than nine characters, the value is truncated starting from the right side.
	// #### Tax Calculation
	// Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes.
	// Billing address objects will be used to determine the cardholders location when shipTo objects are not present.
	//
	// Max Length: 10
	PostalCode string `json:"postalCode,omitempty"`
}

// Validate validates this create payment params body order information ship to
func (o *CreatePaymentParamsBodyOrderInformationShipTo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAddress1(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAddress2(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAdministrativeArea(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBuildingNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCompany(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDestinationTypes(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDistrict(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFirstName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLastName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocality(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMethod(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePhoneNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationShipTo) validateAddress1(formats strfmt.Registry) error {
	if swag.IsZero(o.Address1) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"shipTo"+"."+"address1", "body", o.Address1, 60); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationShipTo) validateAddress2(formats strfmt.Registry) error {
	if swag.IsZero(o.Address2) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"shipTo"+"."+"address2", "body", o.Address2, 60); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationShipTo) validateAdministrativeArea(formats strfmt.Registry) error {
	if swag.IsZero(o.AdministrativeArea) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"shipTo"+"."+"administrativeArea", "body", o.AdministrativeArea, 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationShipTo) validateBuildingNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.BuildingNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"shipTo"+"."+"buildingNumber", "body", o.BuildingNumber, 15); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationShipTo) validateCompany(formats strfmt.Registry) error {
	if swag.IsZero(o.Company) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"shipTo"+"."+"company", "body", o.Company, 60); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationShipTo) validateCountry(formats strfmt.Registry) error {
	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"shipTo"+"."+"country", "body", o.Country, 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationShipTo) validateDestinationTypes(formats strfmt.Registry) error {
	if swag.IsZero(o.DestinationTypes) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"shipTo"+"."+"destinationTypes", "body", o.DestinationTypes, 25); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationShipTo) validateDistrict(formats strfmt.Registry) error {
	if swag.IsZero(o.District) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"shipTo"+"."+"district", "body", o.District, 50); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationShipTo) validateFirstName(formats strfmt.Registry) error {
	if swag.IsZero(o.FirstName) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"shipTo"+"."+"firstName", "body", o.FirstName, 60); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationShipTo) validateLastName(formats strfmt.Registry) error {
	if swag.IsZero(o.LastName) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"shipTo"+"."+"lastName", "body", o.LastName, 60); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationShipTo) validateLocality(formats strfmt.Registry) error {
	if swag.IsZero(o.Locality) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"shipTo"+"."+"locality", "body", o.Locality, 50); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationShipTo) validateMethod(formats strfmt.Registry) error {
	if swag.IsZero(o.Method) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"shipTo"+"."+"method", "body", o.Method, 10); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationShipTo) validatePhoneNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.PhoneNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"shipTo"+"."+"phoneNumber", "body", o.PhoneNumber, 15); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationShipTo) validatePostalCode(formats strfmt.Registry) error {
	if swag.IsZero(o.PostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"shipTo"+"."+"postalCode", "body", o.PostalCode, 10); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment params body order information ship to based on context it is used
func (o *CreatePaymentParamsBodyOrderInformationShipTo) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyOrderInformationShipTo) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyOrderInformationShipTo) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyOrderInformationShipTo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyOrderInformationShippingDetails Contains shipping information not related to address.
swagger:model CreatePaymentParamsBodyOrderInformationShippingDetails
*/
type CreatePaymentParamsBodyOrderInformationShippingDetails struct {

	// Boolean that indicates whether the customer requested gift wrapping for this
	// purchase. This field can contain one of the following
	// values:
	// - true: The customer requested gift wrapping.
	// - false: The customer did not request gift wrapping.
	//
	GiftWrap bool `json:"giftWrap,omitempty"`

	// Postal code for the address from which the goods are shipped, which is used to establish nexus. The default is
	// the postal code associated with your CyberSource account.
	//
	// The postal code must consist of 5 to 9 digits. When the billing country is the U.S., the 9-digit postal code
	// must follow this format:
	//
	// `[5 digits][dash][4 digits]`
	//
	// Example 12345-6789
	//
	// When the billing country is Canada, the 6-digit postal code must follow this format:
	//
	// `[alpha][numeric][alpha][space] [numeric][alpha][numeric]`
	//
	// Example A1B 2C3
	//
	// This field is frequently used for Level II and Level III transactions.
	//
	// Max Length: 10
	ShipFromPostalCode string `json:"shipFromPostalCode,omitempty"`

	// Shipping method for the product. Possible values:
	//
	//  - `lowcost`: Lowest-cost service
	//  - `sameday`: Courier or same-day service
	//  - `oneday`: Next-day or overnight service
	//  - `twoday`: Two-day service
	//  - `threeday`: Three-day service
	//  - `pickup`: Store pick-up
	//  - `other`: Other shipping method
	//  - `none`: No shipping method because product is a service or subscription
	//
	// Max Length: 10
	ShippingMethod string `json:"shippingMethod,omitempty"`
}

// Validate validates this create payment params body order information shipping details
func (o *CreatePaymentParamsBodyOrderInformationShippingDetails) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateShipFromPostalCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateShippingMethod(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationShippingDetails) validateShipFromPostalCode(formats strfmt.Registry) error {
	if swag.IsZero(o.ShipFromPostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"shippingDetails"+"."+"shipFromPostalCode", "body", o.ShipFromPostalCode, 10); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationShippingDetails) validateShippingMethod(formats strfmt.Registry) error {
	if swag.IsZero(o.ShippingMethod) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"shippingDetails"+"."+"shippingMethod", "body", o.ShippingMethod, 10); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment params body order information shipping details based on context it is used
func (o *CreatePaymentParamsBodyOrderInformationShippingDetails) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyOrderInformationShippingDetails) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyOrderInformationShippingDetails) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyOrderInformationShippingDetails
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyPaymentInformation create payment params body payment information
swagger:model CreatePaymentParamsBodyPaymentInformation
*/
type CreatePaymentParamsBodyPaymentInformation struct {

	// bank
	Bank *CreatePaymentParamsBodyPaymentInformationBank `json:"bank,omitempty"`

	// card
	Card *CreatePaymentParamsBodyPaymentInformationCard `json:"card,omitempty"`

	// customer
	Customer *CreatePaymentParamsBodyPaymentInformationCustomer `json:"customer,omitempty"`

	// fluid data
	FluidData *CreatePaymentParamsBodyPaymentInformationFluidData `json:"fluidData,omitempty"`

	// Mastercard-defined code that indicates how the account information was obtained.
	//
	// - `00` (default): Card
	// - `01`: Removable secure element that is personalized for use with a mobile phone and controlled by the wireless service provider; examples: subscriber identity module (SIM), universal integrated circuit card (UICC)
	// - `02`: Key fob
	// - `03`: Watch
	// - `04`: Mobile tag
	// - `05`: Wristband
	// - `06`: Mobile phone case or sleeve
	// - `07`: Mobile phone with a non-removable, secure element that is controlled by the wireless service provider; for example, code division multiple access (CDMA)
	// - `08`: Removable secure element that is personalized for use with a mobile phone and not controlled by the wireless service provider; example: memory card
	// - `09`: Mobile phone with a non-removable, secure element that is not controlled by the wireless service provider
	// - `10`: Removable secure element that is personalized for use with a tablet or e-book and is controlled by the wireless service provider; examples: subscriber identity module (SIM), universal integrated circuit card (UICC)
	// - `11`: Tablet or e-book with a non-removable, secure element that is controlled by the wireless service provider
	// - `12`: Removable secure element that is personalized for use with a tablet or e-book and is not controlled by the wireless service provider
	// - `13`: Tablet or e-book with a non-removable, secure element that is not controlled by the wireless service provider
	//
	// This field is supported only for Mastercard on CyberSource through VisaNet.
	//
	// #### Used by
	// **Authorization**
	// Optional field.
	//
	// Max Length: 2
	InitiationChannel string `json:"initiationChannel,omitempty"`

	// instrument identifier
	InstrumentIdentifier *CreatePaymentParamsBodyPaymentInformationInstrumentIdentifier `json:"instrumentIdentifier,omitempty"`

	// legacy token
	LegacyToken *CreatePaymentParamsBodyPaymentInformationLegacyToken `json:"legacyToken,omitempty"`

	// payment instrument
	PaymentInstrument *CreatePaymentParamsBodyPaymentInformationPaymentInstrument `json:"paymentInstrument,omitempty"`

	// payment type
	PaymentType *CreatePaymentParamsBodyPaymentInformationPaymentType `json:"paymentType,omitempty"`

	// shipping address
	ShippingAddress *CreatePaymentParamsBodyPaymentInformationShippingAddress `json:"shippingAddress,omitempty"`

	// tokenized card
	TokenizedCard *CreatePaymentParamsBodyPaymentInformationTokenizedCard `json:"tokenizedCard,omitempty"`
}

// Validate validates this create payment params body payment information
func (o *CreatePaymentParamsBodyPaymentInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateBank(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCard(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCustomer(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFluidData(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateInitiationChannel(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateInstrumentIdentifier(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLegacyToken(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePaymentInstrument(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePaymentType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateShippingAddress(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTokenizedCard(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformation) validateBank(formats strfmt.Registry) error {
	if swag.IsZero(o.Bank) { // not required
		return nil
	}

	if o.Bank != nil {
		if err := o.Bank.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "paymentInformation" + "." + "bank")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "paymentInformation" + "." + "bank")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformation) validateCard(formats strfmt.Registry) error {
	if swag.IsZero(o.Card) { // not required
		return nil
	}

	if o.Card != nil {
		if err := o.Card.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "paymentInformation" + "." + "card")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "paymentInformation" + "." + "card")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformation) validateCustomer(formats strfmt.Registry) error {
	if swag.IsZero(o.Customer) { // not required
		return nil
	}

	if o.Customer != nil {
		if err := o.Customer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "paymentInformation" + "." + "customer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "paymentInformation" + "." + "customer")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformation) validateFluidData(formats strfmt.Registry) error {
	if swag.IsZero(o.FluidData) { // not required
		return nil
	}

	if o.FluidData != nil {
		if err := o.FluidData.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "paymentInformation" + "." + "fluidData")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "paymentInformation" + "." + "fluidData")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformation) validateInitiationChannel(formats strfmt.Registry) error {
	if swag.IsZero(o.InitiationChannel) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"paymentInformation"+"."+"initiationChannel", "body", o.InitiationChannel, 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformation) validateInstrumentIdentifier(formats strfmt.Registry) error {
	if swag.IsZero(o.InstrumentIdentifier) { // not required
		return nil
	}

	if o.InstrumentIdentifier != nil {
		if err := o.InstrumentIdentifier.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "paymentInformation" + "." + "instrumentIdentifier")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "paymentInformation" + "." + "instrumentIdentifier")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformation) validateLegacyToken(formats strfmt.Registry) error {
	if swag.IsZero(o.LegacyToken) { // not required
		return nil
	}

	if o.LegacyToken != nil {
		if err := o.LegacyToken.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "paymentInformation" + "." + "legacyToken")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "paymentInformation" + "." + "legacyToken")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformation) validatePaymentInstrument(formats strfmt.Registry) error {
	if swag.IsZero(o.PaymentInstrument) { // not required
		return nil
	}

	if o.PaymentInstrument != nil {
		if err := o.PaymentInstrument.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "paymentInformation" + "." + "paymentInstrument")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "paymentInformation" + "." + "paymentInstrument")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformation) validatePaymentType(formats strfmt.Registry) error {
	if swag.IsZero(o.PaymentType) { // not required
		return nil
	}

	if o.PaymentType != nil {
		if err := o.PaymentType.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "paymentInformation" + "." + "paymentType")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "paymentInformation" + "." + "paymentType")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformation) validateShippingAddress(formats strfmt.Registry) error {
	if swag.IsZero(o.ShippingAddress) { // not required
		return nil
	}

	if o.ShippingAddress != nil {
		if err := o.ShippingAddress.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "paymentInformation" + "." + "shippingAddress")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "paymentInformation" + "." + "shippingAddress")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformation) validateTokenizedCard(formats strfmt.Registry) error {
	if swag.IsZero(o.TokenizedCard) { // not required
		return nil
	}

	if o.TokenizedCard != nil {
		if err := o.TokenizedCard.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "paymentInformation" + "." + "tokenizedCard")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "paymentInformation" + "." + "tokenizedCard")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this create payment params body payment information based on the context it is used
func (o *CreatePaymentParamsBodyPaymentInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateBank(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateCard(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateCustomer(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateFluidData(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateInstrumentIdentifier(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateLegacyToken(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidatePaymentInstrument(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidatePaymentType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateShippingAddress(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateTokenizedCard(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformation) contextValidateBank(ctx context.Context, formats strfmt.Registry) error {

	if o.Bank != nil {
		if err := o.Bank.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "paymentInformation" + "." + "bank")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "paymentInformation" + "." + "bank")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformation) contextValidateCard(ctx context.Context, formats strfmt.Registry) error {

	if o.Card != nil {
		if err := o.Card.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "paymentInformation" + "." + "card")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "paymentInformation" + "." + "card")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformation) contextValidateCustomer(ctx context.Context, formats strfmt.Registry) error {

	if o.Customer != nil {
		if err := o.Customer.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "paymentInformation" + "." + "customer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "paymentInformation" + "." + "customer")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformation) contextValidateFluidData(ctx context.Context, formats strfmt.Registry) error {

	if o.FluidData != nil {
		if err := o.FluidData.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "paymentInformation" + "." + "fluidData")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "paymentInformation" + "." + "fluidData")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformation) contextValidateInstrumentIdentifier(ctx context.Context, formats strfmt.Registry) error {

	if o.InstrumentIdentifier != nil {
		if err := o.InstrumentIdentifier.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "paymentInformation" + "." + "instrumentIdentifier")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "paymentInformation" + "." + "instrumentIdentifier")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformation) contextValidateLegacyToken(ctx context.Context, formats strfmt.Registry) error {

	if o.LegacyToken != nil {
		if err := o.LegacyToken.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "paymentInformation" + "." + "legacyToken")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "paymentInformation" + "." + "legacyToken")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformation) contextValidatePaymentInstrument(ctx context.Context, formats strfmt.Registry) error {

	if o.PaymentInstrument != nil {
		if err := o.PaymentInstrument.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "paymentInformation" + "." + "paymentInstrument")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "paymentInformation" + "." + "paymentInstrument")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformation) contextValidatePaymentType(ctx context.Context, formats strfmt.Registry) error {

	if o.PaymentType != nil {
		if err := o.PaymentType.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "paymentInformation" + "." + "paymentType")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "paymentInformation" + "." + "paymentType")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformation) contextValidateShippingAddress(ctx context.Context, formats strfmt.Registry) error {

	if o.ShippingAddress != nil {
		if err := o.ShippingAddress.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "paymentInformation" + "." + "shippingAddress")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "paymentInformation" + "." + "shippingAddress")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformation) contextValidateTokenizedCard(ctx context.Context, formats strfmt.Registry) error {

	if o.TokenizedCard != nil {
		if err := o.TokenizedCard.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "paymentInformation" + "." + "tokenizedCard")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "paymentInformation" + "." + "tokenizedCard")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyPaymentInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyPaymentInformation) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyPaymentInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyPaymentInformationBank create payment params body payment information bank
swagger:model CreatePaymentParamsBodyPaymentInformationBank
*/
type CreatePaymentParamsBodyPaymentInformationBank struct {

	// account
	Account *CreatePaymentParamsBodyPaymentInformationBankAccount `json:"account,omitempty"`

	// International Bank Account Number (IBAN) for the bank account. For some countries you can provide this number instead of the traditional bank account information. You can use this field only when scoring a direct debit transaction.
	//
	// For all possible values, see the `bank_iban` field description in the _Decision Manager Using the SCMP API Developer Guide_ on the [CyberSource Business Center.](https://ebc2.cybersource.com/ebc2/) Click **Decision Manager** > **Documentation** > **Guides** > _Decision Manager Using the SCMP API Developer Guide_ (PDF link).
	//
	// Max Length: 50
	Iban string `json:"iban,omitempty"`

	// Bank routing number. This is also called the _transit number_.
	//
	// For details, see `ecp_rdfi` request field description in the [Electronic Check Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/EChecks_SCMP_API/html/)
	//
	// Max Length: 9
	RoutingNumber string `json:"routingNumber,omitempty"`
}

// Validate validates this create payment params body payment information bank
func (o *CreatePaymentParamsBodyPaymentInformationBank) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAccount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateIban(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRoutingNumber(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformationBank) validateAccount(formats strfmt.Registry) error {
	if swag.IsZero(o.Account) { // not required
		return nil
	}

	if o.Account != nil {
		if err := o.Account.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "paymentInformation" + "." + "bank" + "." + "account")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "paymentInformation" + "." + "bank" + "." + "account")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformationBank) validateIban(formats strfmt.Registry) error {
	if swag.IsZero(o.Iban) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"paymentInformation"+"."+"bank"+"."+"iban", "body", o.Iban, 50); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformationBank) validateRoutingNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.RoutingNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"paymentInformation"+"."+"bank"+"."+"routingNumber", "body", o.RoutingNumber, 9); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this create payment params body payment information bank based on the context it is used
func (o *CreatePaymentParamsBodyPaymentInformationBank) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateAccount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformationBank) contextValidateAccount(ctx context.Context, formats strfmt.Registry) error {

	if o.Account != nil {
		if err := o.Account.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "paymentInformation" + "." + "bank" + "." + "account")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "paymentInformation" + "." + "bank" + "." + "account")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyPaymentInformationBank) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyPaymentInformationBank) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyPaymentInformationBank
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyPaymentInformationBankAccount create payment params body payment information bank account
swagger:model CreatePaymentParamsBodyPaymentInformationBankAccount
*/
type CreatePaymentParamsBodyPaymentInformationBankAccount struct {

	// Image reference number associated with the check. You cannot include any special characters.
	//
	// Max Length: 32
	CheckImageReferenceNumber string `json:"checkImageReferenceNumber,omitempty"`

	// Check number.
	//
	// Chase Paymentech Solutions - Optional.
	// CyberSource ACH Service - Not used.
	// RBS WorldPay Atlanta - Optional on debits. Required on credits.
	// TeleCheck - Strongly recommended on debit requests. Optional on credits.
	//
	// Max Length: 8
	CheckNumber string `json:"checkNumber,omitempty"`

	// Identifier for the bank that provided the customers encoded account number.
	//
	// To obtain the bank identifier, contact your processor.
	//
	// For details, see `account_encoder_id` request-level field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// Max Length: 3
	EncoderID string `json:"encoderId,omitempty"`

	// Account number.
	//
	// When processing encoded account numbers, use this field for the encoded account number.
	//
	// Max Length: 17
	Number string `json:"number,omitempty"`

	// Account type.
	//
	// Possible values:
	//  - **C**: Checking.
	//  - **G**: General ledger. This value is supported only on Wells Fargo ACH.
	//  - **S**: Savings (U.S. dollars only).
	//  - **X**: Corporate checking (U.S. dollars only).
	//
	// Max Length: 1
	Type string `json:"type,omitempty"`
}

// Validate validates this create payment params body payment information bank account
func (o *CreatePaymentParamsBodyPaymentInformationBankAccount) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCheckImageReferenceNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCheckNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEncoderID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformationBankAccount) validateCheckImageReferenceNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.CheckImageReferenceNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"paymentInformation"+"."+"bank"+"."+"account"+"."+"checkImageReferenceNumber", "body", o.CheckImageReferenceNumber, 32); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformationBankAccount) validateCheckNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.CheckNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"paymentInformation"+"."+"bank"+"."+"account"+"."+"checkNumber", "body", o.CheckNumber, 8); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformationBankAccount) validateEncoderID(formats strfmt.Registry) error {
	if swag.IsZero(o.EncoderID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"paymentInformation"+"."+"bank"+"."+"account"+"."+"encoderId", "body", o.EncoderID, 3); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformationBankAccount) validateNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.Number) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"paymentInformation"+"."+"bank"+"."+"account"+"."+"number", "body", o.Number, 17); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformationBankAccount) validateType(formats strfmt.Registry) error {
	if swag.IsZero(o.Type) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"paymentInformation"+"."+"bank"+"."+"account"+"."+"type", "body", o.Type, 1); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment params body payment information bank account based on context it is used
func (o *CreatePaymentParamsBodyPaymentInformationBankAccount) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyPaymentInformationBankAccount) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyPaymentInformationBankAccount) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyPaymentInformationBankAccount
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyPaymentInformationCard create payment params body payment information card
swagger:model CreatePaymentParamsBodyPaymentInformationCard
*/
type CreatePaymentParamsBodyPaymentInformationCard struct {

	// Identifier for the issuing bank that provided the customers encoded account number. Contact your processor for the banks ID.
	//
	// Max Length: 3
	AccountEncoderID string `json:"accountEncoderId,omitempty"`

	// Two-digit month in which the payment card expires.
	//
	// Format: `MM`.
	//
	// Valid values: `01` through `12`. Leading 0 is required.
	//
	// #### Barclays and Streamline
	// For Maestro (UK Domestic) and Maestro (International) cards on Barclays and Streamline, this must be a valid value
	// (`01` through `12`) but is not required to be a valid expiration date. In other words, an expiration date that is
	// in the past does not cause CyberSource to reject your request. However, an invalid expiration date might cause
	// the issuer to reject your request.
	//
	// #### Encoded Account Numbers
	// For encoded account numbers (_type_=039), if there is no expiration date on the card, use `12`.
	//
	// #### FDMS Nashville
	// Required field.
	//
	// #### All other processors
	// Required if `pointOfSaleInformation.entryMode=keyed`. However, this field is optional if your account is configured
	// for relaxed requirements for address data and expiration date. **Important** It is your responsibility to determine
	// whether a field is required for the transaction you are requesting.
	//
	// #### Google Pay transactions
	// For PAN-based Google Pay transactions, this field is returned in the API response.
	//
	// Max Length: 2
	ExpirationMonth string `json:"expirationMonth,omitempty"`

	// Four-digit year in which the payment card expires.
	//
	// Format: `YYYY`.
	//
	// #### Barclays and Streamline
	// For Maestro (UK Domestic) and Maestro (International) cards on Barclays and Streamline, this must be a valid value (`1900` through `3000`) but is not required to be a valid expiration date. In other words, an expiration date that is in the past does not cause CyberSource to reject your request. However, an invalid expiration date might cause the issuer to reject your request.
	//
	// #### Encoded Account Numbers
	// For encoded account numbers (**_type_**`=039`), if there is no expiration date on the card, use `2021`.
	//
	// #### FDMS Nashville
	// Required field.
	//
	// #### FDC Nashville Global and FDMS South
	// You can send in 2 digits or 4 digits. If you send in 2 digits, they must be the last 2 digits of the year.
	//
	// #### All other processors
	// Required if `pointOfSaleInformation.entryMode=keyed`. However, this field is optional if your account is configured
	// for relaxed requirements for address data and expiration date. **Important** It is your responsibility to determine
	// whether a field is required for the transaction you are requesting.
	//
	// #### Google Pay transactions
	// For PAN-based Google Pay transactions, this field is returned in the API response.
	//
	// Max Length: 4
	ExpirationYear string `json:"expirationYear,omitempty"`

	// Number of times a Maestro (UK Domestic) card has been issued to the account holder. The card might or might not have an issue number. The number can consist of one or two digits, and the first digit might be a zero. When you include this value in your request, include exactly what is printed on the card. A value of 2 is different than a value of 02. Do not include the field, even with a blank value, if the card is not a Maestro (UK Domestic) card.
	//
	// **Note** The issue number is not required for Maestro (UK Domestic) transactions.
	//
	// Max Length: 5
	IssueNumber string `json:"issueNumber,omitempty"`

	// The customers payment card number, also known as the Primary Account Number (PAN). You can also use this field
	// for encoded account numbers.
	//
	// #### FDMS Nashville
	// Required. String (19)
	//
	// #### GPX
	// Required if `pointOfSaleInformation.entryMode=keyed`. However, this field is optional if your account is configured
	// for relaxed requirements for address data and expiration date. **Important** It is your responsibility to determine
	// whether a field is required for the transaction you are requesting.
	//
	// #### All other processors
	// Required if `pointOfSaleInformation.entryMode=keyed`. However, this field is optional if your account is configured
	// for relaxed requirements for address data and expiration date. **Important** It is your responsibility to determine
	// whether a field is required for the transaction you are requesting.
	//
	// Max Length: 20
	Number string `json:"number,omitempty"`

	// Name of the card product.
	//
	// Possible value:
	// - BNDES
	//
	// This field is supported only for BNDES transactions on CyberSource through VisaNet.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file5:
	// - Record: CP07 TCR4
	// - Position: 115-120
	// - Field: Brazil Country Data
	//
	// Max Length: 15
	ProductName string `json:"productName,omitempty"`

	// Card Verification Number.
	//
	// #### FDMS Nashville
	// Required for American Express or if swiped; otherwise, optional.
	//
	// #### Ingenico ePayments
	// Do not include this field when `commerceIndicator=recurring`.
	// **Note** Ingenico ePayments was previously called _Global Collect_.
	//
	// #### TSYS Acquiring Solutions
	// Optional if pointOfSaleInformation.entryMode=keyed; otherwise, not used.
	//
	// #### GPX
	// Optional.
	//
	// #### All other processors:
	// Optional.
	//
	// Max Length: 4
	SecurityCode string `json:"securityCode,omitempty"`

	// Indicates whether a CVN code was sent. Possible values:
	//
	//  - `0` (default): CVN service not requested. This default value is used when you do not include
	//      `securityCode` field in the request.
	//  - `1` (default): CVN service requested and supported. This default value is used when you include
	//      `securityCode` field in the request.
	//  - `2`: CVN on credit card is illegible.
	//  - `9`: CVN was not imprinted on credit card.
	//
	// #### FDMS Nashville
	// Required for American Express cards; otherwise, optional.
	//
	// #### TSYS Acquiring Solutions
	// Optional if `pointOfSaleInformation.entryMode=keyed`; otherwise, not used.
	//
	// #### All other processors
	// Optional.
	//
	// Max Length: 1
	SecurityCodeIndicator string `json:"securityCodeIndicator,omitempty"`

	// Flag that specifies the type of account associated with the card. The cardholder provides this information
	// during the payment process.
	//
	// This field is required in the following cases:
	//   - Debit transactions on Cielo and Comercio Latino.
	//   - Transactions with Brazilian-issued cards on CyberSource through VisaNet.
	//   - Applicable only for CyberSource through VisaNet (CtV).
	//
	// **Note** Combo cards in Brazil contain credit and debit functionality in a single card. Visa systems use a credit bank
	// identification number (BIN) for this type of card. Using the BIN to determine whether a card is debit or
	// credit can cause transactions with these cards to be processed incorrectly. CyberSource strongly recommends
	// that you include this field for combo card transactions.
	//
	// Possible values include the following.
	//
	//  - `CHECKING`: Checking account
	//  - `CREDIT`: Credit card account
	//  - `SAVING`: Saving account
	//  - `LINE_OF_CREDIT`: Line of credit or credit portion of combo card
	//  - `PREPAID`: Prepaid card account or prepaid portion of combo card
	//  - `UNIVERSAL`: Universal account
	//
	// Max Length: 20
	SourceAccountType string `json:"sourceAccountType,omitempty"`

	// Type of account that is being used when the value for the override_payment_method field is line of credit (LI) or prepaid card (PP).
	// Possible values for line of credit:
	// - `AGRC`: Visa Agro Custeio
	// - `AGRE`: Visa Agro Electron
	// - `AGRI`: Visa Agro Investimento
	// - `AGRO`: Visa Agro
	// Possible values for prepaid card:
	// - `VVA`: Visa Vale Alimentacao
	// - `VVF`: Visa Vale Flex
	// - `VVR`: Visa Vale Refeicao
	// This field is supported only for combo card transactions in Brazil on CyberSource through VisaNet.
	//
	// Max Length: 4
	SourceAccountTypeDetails string `json:"sourceAccountTypeDetails,omitempty"`

	// Month of the start of the Maestro (UK Domestic) card validity period. Do not include the field, even with a blank value, if the card is not a Maestro (UK Domestic) card. `Format: MM`. Possible values: 01 through 12.
	//
	// **Note** The start date is not required for Maestro (UK Domestic) transactions.
	//
	// Max Length: 2
	StartMonth string `json:"startMonth,omitempty"`

	// Year of the start of the Maestro (UK Domestic) card validity period. Do not include the field, even with a blank value, if the card is not a Maestro (UK Domestic) card. `Format: YYYY`.
	//
	// **Note** The start date is not required for Maestro (UK Domestic) transactions.
	//
	// Max Length: 4
	StartYear string `json:"startYear,omitempty"`

	// Three-digit value that indicates the card type.
	//
	// **IMPORTANT** It is strongly recommended that you include the card type field in request messages even if it is
	// optional for your processor and card type. Omitting the card type can cause the transaction to be processed with the wrong card type.
	//
	// Possible values:
	// - `001`: Visa. For card-present transactions on all processors except SIX, the Visa Electron card type is processed the same way that the Visa debit card is processed. Use card type value `001` for Visa Electron.
	// - `002`: Mastercard, Eurocard[^1], which is a European regional brand of Mastercard.
	// - `003`: American Express
	// - `004`: Discover
	// - `005`: Diners Club
	// - `006`: Carte Blanche[^1]
	// - `007`: JCB[^1]
	// - `014`: Enroute[^1]
	// - `021`: JAL[^1]
	// - `024`: Maestro (UK Domestic)[^1]
	// - `031`: Delta[^1]: Use this value only for Ingenico ePayments. For other processors, use `001` for all Visa card types.
	// - `033`: Visa Electron[^1]. Use this value only for Ingenico ePayments and SIX. For other processors, use `001` for all Visa card types.
	// - `034`: Dankort[^1]
	// - `036`: Cartes Bancaires[^1,4]
	// - `037`: Carta Si[^1]
	// - `039`: Encoded account number[^1]
	// - `040`: UATP[^1]
	// - `042`: Maestro (International)[^1]
	// - `050`: Hipercard[^2,3]
	// - `051`: Aura
	// - `054`: Elo[^3]
	// - `062`: China UnionPay
	//
	// [^1]: For this card type, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in your request for an authorization or a stand-alone credit.
	// [^2]: For this card type on Cielo 3.0, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in a request for an authorization or a stand-alone credit. This card type is not supported on Cielo 1.5.
	// [^3]: For this card type on Getnet and Rede, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in a request for an authorization or a stand-alone credit.
	// [^4]: For this card type, you must include the `paymentInformation.card.type` in your request for any payer authentication services.
	//
	// #### Used by
	// **Authorization**
	// Required for Carte Blanche and JCB.
	// Optional for all other card types.
	//
	// #### Card Present reply
	// This field is included in the reply message when the client software that is installed on the POS terminal uses
	// the token management service (TMS) to retrieve tokenized payment details. You must contact customer support to
	// have your account enabled to receive these fields in the credit reply message.
	//
	// Returned by the Credit service.
	//
	// This reply field is only supported by the following processors:
	// - American Express Direct
	// - Credit Mutuel-CIC
	// - FDC Nashville Global
	// - OmniPay Direct
	// - SIX
	//
	// #### Google Pay transactions
	// For PAN-based Google Pay transactions, this field is returned in the API response.
	//
	// #### GPX
	// This field only supports transactions from the following card types:
	// - Visa
	// - Mastercard
	// - AMEX
	// - Discover
	// - Diners
	// - JCB
	// - Union Pay International
	//
	Type string `json:"type,omitempty"`

	// Flag that specifies the type of account associated with the card. The cardholder provides this information
	// during the payment process.
	//
	// #### Cielo and Comercio Latino
	//
	// Possible values:
	//
	//  - CREDIT: Credit card
	//  - DEBIT: Debit card
	//
	// This field is required for:
	//  - Debit transactions on Cielo and Comercio Latino.
	//  - Transactions with Brazilian-issued cards on CyberSource through VisaNet.
	//
	// **Note** The value for this field corresponds to the following data in the TC 33 capture file5:
	// - Record: CP07 TCR0
	// - Position: 51
	// - Field: Combination Card Transaction Identifier
	//
	// This field is supported only for Mastercard transactions in Brazil on CyberSource through VisaNet.
	//
	// Max Length: 20
	UseAs string `json:"useAs,omitempty"`
}

// Validate validates this create payment params body payment information card
func (o *CreatePaymentParamsBodyPaymentInformationCard) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAccountEncoderID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpirationMonth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpirationYear(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateIssueNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProductName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSecurityCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSecurityCodeIndicator(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSourceAccountType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSourceAccountTypeDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateStartMonth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateStartYear(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateUseAs(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformationCard) validateAccountEncoderID(formats strfmt.Registry) error {
	if swag.IsZero(o.AccountEncoderID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"paymentInformation"+"."+"card"+"."+"accountEncoderId", "body", o.AccountEncoderID, 3); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformationCard) validateExpirationMonth(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationMonth) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"paymentInformation"+"."+"card"+"."+"expirationMonth", "body", o.ExpirationMonth, 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformationCard) validateExpirationYear(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationYear) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"paymentInformation"+"."+"card"+"."+"expirationYear", "body", o.ExpirationYear, 4); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformationCard) validateIssueNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.IssueNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"paymentInformation"+"."+"card"+"."+"issueNumber", "body", o.IssueNumber, 5); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformationCard) validateNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.Number) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"paymentInformation"+"."+"card"+"."+"number", "body", o.Number, 20); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformationCard) validateProductName(formats strfmt.Registry) error {
	if swag.IsZero(o.ProductName) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"paymentInformation"+"."+"card"+"."+"productName", "body", o.ProductName, 15); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformationCard) validateSecurityCode(formats strfmt.Registry) error {
	if swag.IsZero(o.SecurityCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"paymentInformation"+"."+"card"+"."+"securityCode", "body", o.SecurityCode, 4); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformationCard) validateSecurityCodeIndicator(formats strfmt.Registry) error {
	if swag.IsZero(o.SecurityCodeIndicator) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"paymentInformation"+"."+"card"+"."+"securityCodeIndicator", "body", o.SecurityCodeIndicator, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformationCard) validateSourceAccountType(formats strfmt.Registry) error {
	if swag.IsZero(o.SourceAccountType) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"paymentInformation"+"."+"card"+"."+"sourceAccountType", "body", o.SourceAccountType, 20); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformationCard) validateSourceAccountTypeDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.SourceAccountTypeDetails) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"paymentInformation"+"."+"card"+"."+"sourceAccountTypeDetails", "body", o.SourceAccountTypeDetails, 4); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformationCard) validateStartMonth(formats strfmt.Registry) error {
	if swag.IsZero(o.StartMonth) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"paymentInformation"+"."+"card"+"."+"startMonth", "body", o.StartMonth, 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformationCard) validateStartYear(formats strfmt.Registry) error {
	if swag.IsZero(o.StartYear) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"paymentInformation"+"."+"card"+"."+"startYear", "body", o.StartYear, 4); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformationCard) validateUseAs(formats strfmt.Registry) error {
	if swag.IsZero(o.UseAs) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"paymentInformation"+"."+"card"+"."+"useAs", "body", o.UseAs, 20); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment params body payment information card based on context it is used
func (o *CreatePaymentParamsBodyPaymentInformationCard) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyPaymentInformationCard) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyPaymentInformationCard) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyPaymentInformationCard
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyPaymentInformationCustomer create payment params body payment information customer
swagger:model CreatePaymentParamsBodyPaymentInformationCustomer
*/
type CreatePaymentParamsBodyPaymentInformationCustomer struct {

	// Unique identifier for the customer's card and billing information.
	//
	// When you use Payment Tokenization or Recurring Billing and you include this value in
	// your request, many of the fields that are normally required for an authorization or credit
	// become optional.
	//
	// **NOTE** When you use Payment Tokenization or Recurring Billing, the value for the Customer ID is actually the Cybersource payment token for a customer. This token stores information such as the consumers card number so it can be applied towards bill payments, recurring payments, or one-time payments. By using this token in a payment API request, the merchant doesn't need to pass in data such as the card number or expiration date in the request itself.
	//
	// For details, see the `subscription_id` field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	CustomerID string `json:"customerId,omitempty"`

	// Unique identifier for the Customer token used in the transaction.
	// When you include this value in your request, many of the fields that are normally required for an authorization or credit
	// become optional.
	//
	// Max Length: 32
	// Min Length: 1
	ID string `json:"id,omitempty"`
}

// Validate validates this create payment params body payment information customer
func (o *CreatePaymentParamsBodyPaymentInformationCustomer) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformationCustomer) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MinLength("createPaymentRequest"+"."+"paymentInformation"+"."+"customer"+"."+"id", "body", o.ID, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"paymentInformation"+"."+"customer"+"."+"id", "body", o.ID, 32); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment params body payment information customer based on context it is used
func (o *CreatePaymentParamsBodyPaymentInformationCustomer) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyPaymentInformationCustomer) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyPaymentInformationCustomer) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyPaymentInformationCustomer
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyPaymentInformationFluidData create payment params body payment information fluid data
swagger:model CreatePaymentParamsBodyPaymentInformationFluidData
*/
type CreatePaymentParamsBodyPaymentInformationFluidData struct {

	// The identifier for a payment solution, which is sending the encrypted payment data for decryption. Valid values:
	// Samsung Pay: RklEPUNPTU1PTi5TQU1TVU5HLklOQVBQLlBBWU1FTlQ=
	// Note: For other payment solutions, the value may be specific to the terminal or device initiatinf the payment. For example, the descriptor for a Bluefin payment encryption would be a device-generated descriptor.
	// Used by Authorization and Standalone Credits. Required for authorizations and standalone credits.
	//
	// Card Present processing:
	// Format of the encrypted payment data.
	// The value for Bluefin PCI P2PE is `Ymx1ZWZpbg==`. paymentInformation.fluidData.encoding must be `Base64`.
	// The value for Cybersource P2PE decryption depends on the encoding method used and identified in encoding field.
	// If paymentInformation.fluidData.encoding is `Base64`, the value is: `RklEPUVNVi5QQVlNRU5ULkFQSQ==`
	// If paymentInformation.fluidData.encoding is `HEX`, the value is: `4649443D454D562E5041594D454E542E41504`
	//
	// Max Length: 128
	Descriptor string `json:"descriptor,omitempty"`

	// Encoding method used to encrypt the payment data.
	// Valid values: `Base64`, `HEX`
	// If no value is provided, `Base64` is taken as the default value. And the `Base64` descriptor is used for paymentInformation.fluidData.encoding
	//
	// Max Length: 6
	Encoding string `json:"encoding,omitempty"`

	// The encoded or encrypted value that a payment solution returns for an authorization request. For details about the valid values for a key, see [Creating an Online Authorization](https://developer.cybersource.com/api/developer-guides/dita-payments/CreatingOnlineAuth.html)
	//
	KeySerialNumber string `json:"keySerialNumber,omitempty"`

	// Represents the encrypted payment data BLOB. The entry for this field is dependent on the payment solution used by the merchant.
	// Used by Authorization and Standalone Credits. Required for authorizations and standalone credits that use a Cybersource suppored Point-to-Point encryption method.
	// Card Present processing
	// This field represents the encrypted payment data generated by the payment terminal/device.
	//
	// Max Length: 3072
	Value string `json:"value,omitempty"`
}

// Validate validates this create payment params body payment information fluid data
func (o *CreatePaymentParamsBodyPaymentInformationFluidData) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDescriptor(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEncoding(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateValue(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformationFluidData) validateDescriptor(formats strfmt.Registry) error {
	if swag.IsZero(o.Descriptor) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"paymentInformation"+"."+"fluidData"+"."+"descriptor", "body", o.Descriptor, 128); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformationFluidData) validateEncoding(formats strfmt.Registry) error {
	if swag.IsZero(o.Encoding) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"paymentInformation"+"."+"fluidData"+"."+"encoding", "body", o.Encoding, 6); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformationFluidData) validateValue(formats strfmt.Registry) error {
	if swag.IsZero(o.Value) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"paymentInformation"+"."+"fluidData"+"."+"value", "body", o.Value, 3072); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment params body payment information fluid data based on context it is used
func (o *CreatePaymentParamsBodyPaymentInformationFluidData) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyPaymentInformationFluidData) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyPaymentInformationFluidData) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyPaymentInformationFluidData
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyPaymentInformationInstrumentIdentifier create payment params body payment information instrument identifier
swagger:model CreatePaymentParamsBodyPaymentInformationInstrumentIdentifier
*/
type CreatePaymentParamsBodyPaymentInformationInstrumentIdentifier struct {

	// Unique identifier for the Instrument Identifier token used in the transaction.
	// When you include this value in your request, many of the fields that can be supplied for an authorization or credit
	// become optional.
	//
	// Max Length: 32
	// Min Length: 12
	ID string `json:"id,omitempty"`
}

// Validate validates this create payment params body payment information instrument identifier
func (o *CreatePaymentParamsBodyPaymentInformationInstrumentIdentifier) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformationInstrumentIdentifier) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MinLength("createPaymentRequest"+"."+"paymentInformation"+"."+"instrumentIdentifier"+"."+"id", "body", o.ID, 12); err != nil {
		return err
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"paymentInformation"+"."+"instrumentIdentifier"+"."+"id", "body", o.ID, 32); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment params body payment information instrument identifier based on context it is used
func (o *CreatePaymentParamsBodyPaymentInformationInstrumentIdentifier) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyPaymentInformationInstrumentIdentifier) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyPaymentInformationInstrumentIdentifier) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyPaymentInformationInstrumentIdentifier
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyPaymentInformationLegacyToken create payment params body payment information legacy token
swagger:model CreatePaymentParamsBodyPaymentInformationLegacyToken
*/
type CreatePaymentParamsBodyPaymentInformationLegacyToken struct {

	// Unique identifier for the legacy Secure Storage token used in the transaction.
	// When you include this value in your request, many of the fields that are normally required for an authorization or credit
	// become optional.
	//
	// Max Length: 22
	// Min Length: 16
	ID string `json:"id,omitempty"`
}

// Validate validates this create payment params body payment information legacy token
func (o *CreatePaymentParamsBodyPaymentInformationLegacyToken) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformationLegacyToken) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MinLength("createPaymentRequest"+"."+"paymentInformation"+"."+"legacyToken"+"."+"id", "body", o.ID, 16); err != nil {
		return err
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"paymentInformation"+"."+"legacyToken"+"."+"id", "body", o.ID, 22); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment params body payment information legacy token based on context it is used
func (o *CreatePaymentParamsBodyPaymentInformationLegacyToken) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyPaymentInformationLegacyToken) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyPaymentInformationLegacyToken) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyPaymentInformationLegacyToken
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyPaymentInformationPaymentInstrument create payment params body payment information payment instrument
swagger:model CreatePaymentParamsBodyPaymentInformationPaymentInstrument
*/
type CreatePaymentParamsBodyPaymentInformationPaymentInstrument struct {

	// Unique identifier for the Payment Instrument token used in the transaction.
	// When you include this value in your request, many of the fields that are normally required for an authorization or credit
	// become optional.
	//
	// Max Length: 32
	// Min Length: 1
	ID string `json:"id,omitempty"`
}

// Validate validates this create payment params body payment information payment instrument
func (o *CreatePaymentParamsBodyPaymentInformationPaymentInstrument) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformationPaymentInstrument) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MinLength("createPaymentRequest"+"."+"paymentInformation"+"."+"paymentInstrument"+"."+"id", "body", o.ID, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"paymentInformation"+"."+"paymentInstrument"+"."+"id", "body", o.ID, 32); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment params body payment information payment instrument based on context it is used
func (o *CreatePaymentParamsBodyPaymentInformationPaymentInstrument) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyPaymentInformationPaymentInstrument) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyPaymentInformationPaymentInstrument) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyPaymentInformationPaymentInstrument
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyPaymentInformationPaymentType create payment params body payment information payment type
swagger:model CreatePaymentParamsBodyPaymentInformationPaymentType
*/
type CreatePaymentParamsBodyPaymentInformationPaymentType struct {

	// method
	Method *CreatePaymentParamsBodyPaymentInformationPaymentTypeMethod `json:"method,omitempty"`

	// A Payment Type is an agreed means for a payee to receive legal tender from a payer. The way one pays for a commercial financial transaction. Examples: Card, Bank Transfer, Digital, Direct Debit.
	// Possible values:
	// - `CARD` (use this for a PIN debit transaction)
	// - `CHECK` (use this for all eCheck payment transactions - ECP Debit, ECP Follow-on Credit, ECP StandAlone Credit)
	//
	Name string `json:"name,omitempty"`

	// Detailed information about the Payment Type. Possible values:
	// - `DEBIT`: Use this value to indicate a PIN debit transaction.
	//
	// Examples: For Card, if Credit or Debit or PrePaid. For Bank Transfer, if Online Bank Transfer or Wire Transfers.
	//
	SubTypeName string `json:"subTypeName,omitempty"`
}

// Validate validates this create payment params body payment information payment type
func (o *CreatePaymentParamsBodyPaymentInformationPaymentType) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateMethod(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformationPaymentType) validateMethod(formats strfmt.Registry) error {
	if swag.IsZero(o.Method) { // not required
		return nil
	}

	if o.Method != nil {
		if err := o.Method.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "paymentInformation" + "." + "paymentType" + "." + "method")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "paymentInformation" + "." + "paymentType" + "." + "method")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this create payment params body payment information payment type based on the context it is used
func (o *CreatePaymentParamsBodyPaymentInformationPaymentType) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateMethod(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformationPaymentType) contextValidateMethod(ctx context.Context, formats strfmt.Registry) error {

	if o.Method != nil {
		if err := o.Method.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "paymentInformation" + "." + "paymentType" + "." + "method")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "paymentInformation" + "." + "paymentType" + "." + "method")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyPaymentInformationPaymentType) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyPaymentInformationPaymentType) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyPaymentInformationPaymentType
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyPaymentInformationPaymentTypeMethod create payment params body payment information payment type method
swagger:model CreatePaymentParamsBodyPaymentInformationPaymentTypeMethod
*/
type CreatePaymentParamsBodyPaymentInformationPaymentTypeMethod struct {

	// A Payment Type is enabled through a Method. Examples: Visa, Master Card, ApplePay, iDeal
	//
	Name string `json:"name,omitempty"`
}

// Validate validates this create payment params body payment information payment type method
func (o *CreatePaymentParamsBodyPaymentInformationPaymentTypeMethod) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this create payment params body payment information payment type method based on context it is used
func (o *CreatePaymentParamsBodyPaymentInformationPaymentTypeMethod) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyPaymentInformationPaymentTypeMethod) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyPaymentInformationPaymentTypeMethod) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyPaymentInformationPaymentTypeMethod
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyPaymentInformationShippingAddress create payment params body payment information shipping address
swagger:model CreatePaymentParamsBodyPaymentInformationShippingAddress
*/
type CreatePaymentParamsBodyPaymentInformationShippingAddress struct {

	// Unique identifier for the Customers Shipping Address token used in the transaction.
	// When you include this value in your request, many of the shipping fields that can be supplied for an authorization or credit
	// become optional.
	//
	// Max Length: 32
	// Min Length: 1
	ID string `json:"id,omitempty"`
}

// Validate validates this create payment params body payment information shipping address
func (o *CreatePaymentParamsBodyPaymentInformationShippingAddress) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformationShippingAddress) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MinLength("createPaymentRequest"+"."+"paymentInformation"+"."+"shippingAddress"+"."+"id", "body", o.ID, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"paymentInformation"+"."+"shippingAddress"+"."+"id", "body", o.ID, 32); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment params body payment information shipping address based on context it is used
func (o *CreatePaymentParamsBodyPaymentInformationShippingAddress) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyPaymentInformationShippingAddress) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyPaymentInformationShippingAddress) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyPaymentInformationShippingAddress
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyPaymentInformationTokenizedCard create payment params body payment information tokenized card
swagger:model CreatePaymentParamsBodyPaymentInformationTokenizedCard
*/
type CreatePaymentParamsBodyPaymentInformationTokenizedCard struct {

	// Confidence level of the tokenization. This value is assigned by the token service provider.
	//
	// **Note** This field is supported only for **CyberSource through VisaNet** and **FDC Nashville Global**.
	//
	// Returned by PIN debit credit or PIN debit purchase.
	//
	// Max Length: 2
	AssuranceLevel string `json:"assuranceLevel,omitempty"`

	// This field is used internally.
	// Max Length: 40
	Cryptogram string `json:"cryptogram,omitempty"`

	// One of two possible meanings:
	// - The two-digit month in which a token expires.
	// - The two-digit month in which a card expires.
	// Format: `MM`
	// Possible values: `01` through `12`
	//
	// **NOTE** The meaning of this field is dependent on the payment processor that is returning the value in an authorization reply. Please see the processor-specific details below.
	//
	// #### Barclays and Streamline
	// For Maestro (UK Domestic) and Maestro (International) cards on Barclays and Streamline, this must be a valid value (`01` through `12`) but is not required to be a valid expiration date. In other words, an expiration date that is in the past does not cause CyberSource to reject your request. However, an invalid expiration date might cause the issuer to reject your request.
	//
	// #### Encoded Account Numbers
	// For encoded account numbers (`card_type=039`), if there is no expiration date on the card, use `12`.\
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// #### Samsung Pay and Apple Pay
	// Month in which the token expires. CyberSource includes this field in the reply message when it decrypts the payment blob for the tokenized transaction.
	//
	// For processor-specific information, see the `customer_cc_expmo` field in [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 2
	ExpirationMonth string `json:"expirationMonth,omitempty"`

	// One of two possible meanings:
	// - The four-digit year in which a token expires.
	// - The four-digit year in which a card expires.
	// Format: `YYYY`
	// Possible values: `1900` through `3000`
	// Data type: Non-negative integer
	//
	// **NOTE** The meaning of this field is dependent on the payment processor that is returning the value in an authorization reply. Please see the processor-specific details below.
	//
	// #### Barclays and Streamline
	// For Maestro (UK Domestic) and Maestro (International) cards on Barclays and Streamline, this must be a valid value (1900 through
	// 3000) but is not required to be a valid expiration date. In other words, an expiration date that is in the past does not cause CyberSource to reject your request. However, an invalid expiration date might cause the issuer to reject your request.
	//
	// #### Encoded Account Numbers
	// For encoded account numbers (`card_ type=039`), if there is no expiration date on the card, use `2021`.
	//
	// #### FDC Nashville Global and FDMS South
	// You can send in 2 digits or 4 digits. When you send in 2 digits, they must be the last 2 digits of
	// the year.
	//
	// #### Samsung Pay and Apple Pay
	// Year in which the token expires. CyberSource includes this field in the reply message when it decrypts the payment blob for the tokenized transaction.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction
	// you are requesting.
	//
	// For processor-specific information, see the `customer_cc_expyr` or `token_expiration_year` field in [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 4
	ExpirationYear string `json:"expirationYear,omitempty"`

	// Customers payment network token value.
	//
	// Max Length: 20
	Number string `json:"number,omitempty"`

	// Value that identifies your business and indicates that the cardholders account number is tokenized. This value
	// is assigned by the token service provider and is unique within the token service providers database.
	//
	// **Note** This field is supported only for **CyberSource through VisaNet** and **FDC Nashville Global**.
	//
	// #### PIN debit
	// Optional field for PIN debit credit or PIN debit purchase transactions that use payment network tokens; otherwise, not used.
	//
	// Max Length: 11
	RequestorID string `json:"requestorId,omitempty"`

	// Card Verification Number (CVN).
	//
	// #### Ingenico ePayments
	// Do not include this field when **commerceIndicator=recurring**.
	// **Note** Ingenico ePayments was previously called _Global Collect_.
	//
	// For details, see `customer_cc_cv_number` field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// Max Length: 4
	SecurityCode string `json:"securityCode,omitempty"`

	// Type of technology used in the device to store token data. Possible values:
	//
	// - `001`: Secure Element (SE). Smart card or memory with restricted access and encryption to prevent data tampering. For storing payment
	//    credentials, a SE is tested against a set of requirements defined by the payment networks.
	//
	//    **Note** This field is supported only for _FDC Compass_.
	//
	// - 002: Host Card Emulation (HCE). Emulation of a smart card by using software to create a virtual and exact representation of the card.
	// Sensitive data is stored in a database that is hosted in the cloud. For storing payment credentials, a database
	// must meet very stringent security requirements that exceed PCI DSS.
	//
	// **Note** This field is supported only for _FDC Compass_.
	//
	// Max Length: 3
	StorageMethod string `json:"storageMethod,omitempty"`

	// Type of transaction that provided the token data. This value does not specify the token service provider; it specifies the entity that
	// provided you with information about the token.
	//
	// Possible value:
	// - `2`: Near-field communication (NFC) transaction. The customers mobile device provided the token data for a contactless EMV transaction. For recurring
	// transactions, use this value if the original transaction was a contactless EMV transaction.
	//
	// **NOTE** No CyberSource through VisaNet acquirers support EMV at this time.
	//
	// Required field for PIN debit credit or PIN debit purchase transactions that use payment network tokens; otherwise, not used.
	//
	// Max Length: 1
	TransactionType string `json:"transactionType,omitempty"`

	// Three-digit value that indicates the card type.
	//
	// **IMPORTANT** It is strongly recommended that you include the card type field in request messages even if it is
	// optional for your processor and card type. Omitting the card type can cause the transaction to be processed with the wrong card type.
	//
	// Possible values:
	// - `001`: Visa. For card-present transactions on all processors except SIX, the Visa Electron card type is processed the same way that the Visa debit card is processed. Use card type value `001` for Visa Electron.
	// - `002`: Mastercard, Eurocard[^1], which is a European regional brand of Mastercard.
	// - `003`: American Express
	// - `004`: Discover
	// - `005`: Diners Club
	// - `006`: Carte Blanche[^1]
	// - `007`: JCB[^1]
	// - `014`: Enroute[^1]
	// - `021`: JAL[^1]
	// - `024`: Maestro (UK Domestic)[^1]
	// - `031`: Delta[^1]: Use this value only for Ingenico ePayments. For other processors, use `001` for all Visa card types.
	// - `033`: Visa Electron[^1]. Use this value only for Ingenico ePayments and SIX. For other processors, use `001` for all Visa card types.
	// - `034`: Dankort[^1]
	// - `036`: Cartes Bancaires[^1,4]
	// - `037`: Carta Si[^1]
	// - `039`: Encoded account number[^1]
	// - `040`: UATP[^1]
	// - `042`: Maestro (International)[^1]
	// - `050`: Hipercard[^2,3]
	// - `051`: Aura
	// - `054`: Elo[^3]
	// - `062`: China UnionPay
	//
	// [^1]: For this card type, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in your request for an authorization or a stand-alone credit.
	// [^2]: For this card type on Cielo 3.0, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in a request for an authorization or a stand-alone credit. This card type is not supported on Cielo 1.5.
	// [^3]: For this card type on Getnet and Rede, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in a request for an authorization or a stand-alone credit.
	// [^4]: For this card type, you must include the `paymentInformation.card.type` in your request for any payer authentication services.
	//
	// #### Used by
	// **Authorization**
	// Required for Carte Blanche and JCB.
	// Optional for all other card types.
	//
	// #### Card Present reply
	// This field is included in the reply message when the client software that is installed on the POS terminal uses
	// the token management service (TMS) to retrieve tokenized payment details. You must contact customer support to
	// have your account enabled to receive these fields in the credit reply message.
	//
	// Returned by the Credit service.
	//
	// This reply field is only supported by the following processors:
	// - American Express Direct
	// - Credit Mutuel-CIC
	// - FDC Nashville Global
	// - OmniPay Direct
	// - SIX
	//
	// #### Google Pay transactions
	// For PAN-based Google Pay transactions, this field is returned in the API response.
	//
	// #### GPX
	// This field only supports transactions from the following card types:
	// - Visa
	// - Mastercard
	// - AMEX
	// - Discover
	// - Diners
	// - JCB
	// - Union Pay International
	//
	Type string `json:"type,omitempty"`
}

// Validate validates this create payment params body payment information tokenized card
func (o *CreatePaymentParamsBodyPaymentInformationTokenizedCard) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAssuranceLevel(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCryptogram(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpirationMonth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpirationYear(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRequestorID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSecurityCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateStorageMethod(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTransactionType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformationTokenizedCard) validateAssuranceLevel(formats strfmt.Registry) error {
	if swag.IsZero(o.AssuranceLevel) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"paymentInformation"+"."+"tokenizedCard"+"."+"assuranceLevel", "body", o.AssuranceLevel, 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformationTokenizedCard) validateCryptogram(formats strfmt.Registry) error {
	if swag.IsZero(o.Cryptogram) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"paymentInformation"+"."+"tokenizedCard"+"."+"cryptogram", "body", o.Cryptogram, 40); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformationTokenizedCard) validateExpirationMonth(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationMonth) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"paymentInformation"+"."+"tokenizedCard"+"."+"expirationMonth", "body", o.ExpirationMonth, 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformationTokenizedCard) validateExpirationYear(formats strfmt.Registry) error {
	if swag.IsZero(o.ExpirationYear) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"paymentInformation"+"."+"tokenizedCard"+"."+"expirationYear", "body", o.ExpirationYear, 4); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformationTokenizedCard) validateNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.Number) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"paymentInformation"+"."+"tokenizedCard"+"."+"number", "body", o.Number, 20); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformationTokenizedCard) validateRequestorID(formats strfmt.Registry) error {
	if swag.IsZero(o.RequestorID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"paymentInformation"+"."+"tokenizedCard"+"."+"requestorId", "body", o.RequestorID, 11); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformationTokenizedCard) validateSecurityCode(formats strfmt.Registry) error {
	if swag.IsZero(o.SecurityCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"paymentInformation"+"."+"tokenizedCard"+"."+"securityCode", "body", o.SecurityCode, 4); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformationTokenizedCard) validateStorageMethod(formats strfmt.Registry) error {
	if swag.IsZero(o.StorageMethod) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"paymentInformation"+"."+"tokenizedCard"+"."+"storageMethod", "body", o.StorageMethod, 3); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformationTokenizedCard) validateTransactionType(formats strfmt.Registry) error {
	if swag.IsZero(o.TransactionType) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"paymentInformation"+"."+"tokenizedCard"+"."+"transactionType", "body", o.TransactionType, 1); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment params body payment information tokenized card based on context it is used
func (o *CreatePaymentParamsBodyPaymentInformationTokenizedCard) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyPaymentInformationTokenizedCard) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyPaymentInformationTokenizedCard) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyPaymentInformationTokenizedCard
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyPointOfSaleInformation create payment params body point of sale information
swagger:model CreatePaymentParamsBodyPointOfSaleInformation
*/
type CreatePaymentParamsBodyPointOfSaleInformation struct {

	// Point-of-sale details for the transaction. This value is returned only for **American Express Direct**.
	// CyberSource generates this value, which consists of a series of codes that identify terminal capability,
	// security data, and specific conditions present at the time the transaction occurred. To comply with the CAPN
	// requirements, this value must be included in all subsequent follow-on requests, such as captures and follow-on
	// credits.
	//
	// When you perform authorizations, captures, and credits through CyberSource, CyberSource passes this value from
	// the authorization service to the subsequent services for you. However, when you perform authorizations through
	// CyberSource and perform subsequent services through other financial institutions, you must ensure that your
	// requests for captures and credits include this value.
	//
	// For details, see `auth_pos_data` field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// Max Length: 15
	AmexCapnData string `json:"amexCapnData,omitempty"`

	// Complete list of cardholder verification methods (CVMs) supported by the terminal.
	// Optional field.
	// Possible values:
	// - `PIN`: For terminals with a PIN Pad
	// - `Signature`: For terminals capable of receiving a signature
	// - `pinOnGlass`: For terminals where PIN is entered on a glass-based capture mechanism
	//
	// **EXAMPLE**: ["PIN","Signature"]; ["pinOnGlass","Signature"]
	//
	CardholderVerificationMethod []string `json:"cardholderVerificationMethod"`

	// Type of cardholder-activated terminal. Possible values:
	//
	//  - 1: Automated dispensing machine
	//  - 2: Self-service terminal
	//  - 3: Limited amount terminal
	//  - 4: In-flight commerce (IFC) terminal
	//  - 5: Radio frequency device
	//  - 6: Mobile acceptance terminal
	//  - 7: Electronic cash register
	//  - 8: E-commerce device at your location
	//  - 9: Terminal or cash register that uses a dialup connection to connect to the transaction processing network
	//
	// #### Chase Paymentech Solutions
	// Only values 1, 2, and 3 are supported.
	//
	// Required if `pointOfSaleInformation.terminalID` is included in the request; otherwise, optional.
	//
	// #### CyberSource through VisaNet
	// Values 1 through 6 are supported on
	// CyberSource through VisaNet, but some
	// acquirers do not support all six values.
	//
	// Optional field.
	//
	// #### FDC Nashville Global
	// Only values 7, 8, and 9 are supported.
	//
	// Optional field for EMV transactions; otherwise, not used.
	//
	// #### GPN
	// Only values 6, 7, 8, and 9 are supported.
	//
	// Required field.
	//
	// #### JCN Gateway
	// Only values 6, 7, 8, and 9 are supported.
	//
	// Required field.
	//
	// #### TSYS Acquiring Solutions
	// Only value 6 is supported.
	//
	// Required for transactions from mobile devices; otherwise, not used.
	//
	// #### All other processors
	// Not used.
	//
	// Nonnegative integer.
	//
	// Maximum: 9
	// Minimum: 1
	CatLevel int64 `json:"catLevel,omitempty"`

	// Value created by the client software that uniquely identifies the POS device. This value is provided by the
	// client software that is installed on the POS terminal.
	//
	// CyberSource does not forward this value to the processor. Instead, the value is forwarded to the CyberSource
	// reporting functionality.
	//
	// This field is supported only on American Express Direct, FDC Nashville Global, and SIX.
	//
	// Max Length: 32
	DeviceID string `json:"deviceId,omitempty"`

	// emv
	Emv *CreatePaymentParamsBodyPointOfSaleInformationEmv `json:"emv,omitempty"`

	// This 32 byte length-maximum EBCDIC-K value is used to identify which chip application was performed between the terminal and the chip product.
	// The included values are the Application Identifier (AID) and the Dedicated File (DF) name. It is available to early- or full-option VSDC issuers.
	// Only single byte Katakana characters that can map to the EBCDIC-K table expected in the name.
	//
	// Max Length: 32
	EmvApplicationIdentifierAndDedicatedFileName string `json:"emvApplicationIdentifierAndDedicatedFileName,omitempty"`

	// Combination of the device's unique identifier and a transaction counter that is used in the process of
	// decrypting the encrypted PIN. The entity that injected the PIN encryption keys into the terminal decrypts the
	// encrypted PIN and creates this value.
	//
	// For all terminals that are using derived unique key per transaction (DUKPT) encryption, this is generated as a
	// single number within the terminal.
	//
	// #### Used by
	// **Authorization, PIN Debit**
	// - Required when the cardholder enters a PIN and the card cannot verify the PIN, which means that the issuer must verify the PIN.
	// - Required for PIN debit credit or PIN debit purchase.
	// - Required for online PIN transactions
	//
	// For authorizations, this field is supported only on these processors:
	// - American Express Direct
	// - Credit Mutuel-CIC
	// - FDC Nashville Global
	// - OmniPay Direct
	// - SIX
	//
	// This field is also used by processors that support chip and online PIN transactions. The following table lists the EMV Cards
	// and Cardholder Verification Methods (CVMs) that these processors support:
	//
	// | Processor | Chip and Offline PIN | Chip and Online PIN | Chip and Signature |
	// | --- | --- | --- | --- |
	// | American Express Direct | Yes | Yes | Yes |
	// | Chase Paymentech Solutions | No | No | Yes |
	// | Credit Mutuel-CIC | Yes | Yes | Yes |
	// | CyberSource through VisaNet | Yes | No | Yes |
	// | FDC Nashville Global | Yes | Yes | Yes |
	// | GPN | No | No | Yes |
	// | OmniPay Direct | Yes | No | Yes |
	// | SIX | Yes | Yes | Yes |
	//
	// Max Length: 20
	EncryptedKeySerialNumber string `json:"encryptedKeySerialNumber,omitempty"`

	// Encrypted PIN.
	//
	// This value is provided by the client software that is installed on the POS terminal.
	//
	// #### Used by
	// **Authorization, PIN Debit**
	// Required when the cardholder enters a PIN and the card cannot verify the PIN, which means that the issuer must verify the PIN.
	// Required for PIN debit credit or PIN debit purchase.
	// Required for online PIN transactions.
	//
	// For authorizations, this field is supported only on these processors:
	// - American Express Direct
	// - Credit Mutuel-CIC
	// - FDC Nashville Global
	// - OmniPay Direct
	// - SIX
	//
	// This field is also used by processors that support chip and online PIN transactions. The following table lists the EMV Cards
	// and Cardholder Verification Methods (CVMs) that these processors support:
	//
	// | Processor | Chip and Offline PIN | Chip and Online PIN | Chip and Signature |
	// | --- | --- | --- | --- |
	// | American Express Direct | Yes | Yes | Yes |
	// | Chase Paymentech Solutions | No | No | Yes |
	// | Credit Mutuel-CIC | Yes | Yes | Yes |
	// | CyberSource through VisaNet | Yes | No | Yes |
	// | FDC Nashville Global | Yes | Yes | Yes |
	// | GPN | No | No | Yes |
	// | OmniPay Direct | Yes | No | Yes |
	// | SIX | Yes | Yes | Yes |
	//
	// Max Length: 16
	EncryptedPin string `json:"encryptedPin,omitempty"`

	// Method of entering payment card information into the POS terminal. Possible values:
	//
	//  - `contact`: Read from direct contact with chip card.
	//  - `contactless`: Read from a contactless interface using chip data.
	//  - `keyed`: Manually keyed into POS terminal. This value is not supported on OmniPay Direct.
	//  - `msd`: Read from a contactless interface using magnetic stripe data (MSD). This value is not supported on OmniPay Direct.
	//  - `swiped`: Read from credit card magnetic stripe.
	//
	// The `contact`, `contactless`, and `msd` values are supported only for EMV transactions.
	//
	// #### Used by
	// **Authorization**
	// Required field.
	//
	// #### Card Present
	// Card present information about EMV applies only to credit card processing and PIN debit processing. All other
	// card present information applies only to credit card processing.
	//
	// #### PIN debit
	// Required for a PIN debit purchase and a PIN debit credit request.
	//
	// Max Length: 11
	EntryMode string `json:"entryMode,omitempty"`

	// Type of mPOS device. Possible values:
	// - 0: Dongle
	// - 1: Phone or tablet
	//
	// This optional field is supported only for Mastercard transactions on CyberSource through VisaNet.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file:
	// - Record: CP01 TCR6
	// - Position: 141
	// - Field: Mastercard mPOS Transaction
	//
	// The TC 33 Capture file contains information about the purchases and refunds that a merchant submits to CyberSource.
	// CyberSource through VisaNet creates the TC 33 Capture file at the end of the day and sends it to the merchants
	// acquirer, who uses this information to facilitate end-of-day clearing processing with payment networks.
	//
	// Max Length: 1
	IsDedicatedHardwareTerminal string `json:"isDedicatedHardwareTerminal,omitempty"`

	// Identifier for an alternate terminal at your retail location. You define the value for this field.
	//
	// This field is supported only for MasterCard transactions on FDC Nashville Global. Otherwise, this field is not used by all other processors.
	// Use the `terminalId` field to identify the main terminal at your retail location. If your retail location has multiple terminals,
	// use this `laneNumber` field to identify the terminal used for the transaction.
	//
	// This field is a pass-through, which means that the value is not checked or modified in any way before sending it to the processor.
	//
	// Optional field.
	//
	// #### Card present reply messaging
	// Identifier for an alternate terminal at your retail location. You defined the value for this field in the request
	// message. This value must be printed on the receipt.
	//
	// This field is supported only for MasterCard transactions on FDC Nashville Global.
	//
	// Max Length: 8
	LaneNumber string `json:"laneNumber,omitempty"`

	// Operating environment.
	//
	// Possible values for all card types except Mastercard:
	// - `0`: No terminal used or unknown environment.
	// - `1`: On merchant premises, attended.
	// - `2`: On merchant premises, unattended. Examples: oil, kiosks, self-checkout, mobile telephone, personal digital assistant (PDA).
	// - `3`: Off merchant premises, attended. Examples: portable POS devices at trade shows, at service calls, or in taxis.
	// - `4`: Off merchant premises, unattended. Examples: vending machines, home computer, mobile telephone, PDA.
	// - `5`: On premises of cardholder, unattended.
	// - `9`: Unknown delivery mode.
	// - `S`: Electronic delivery of product. Examples: music, software, or eTickets that are downloaded over the internet.
	// - `T`: Physical delivery of product. Examples: music or software that is delivered by mail or by a courier.
	//
	// #### Possible values for Mastercard:
	// - `2`: On merchant premises, unattended, or cardholder terminal. Examples: oil, kiosks, self-checkout, home computer, mobile telephone, personal digital assistant (PDA). Cardholder terminal is supported only for Mastercard transactions on CyberSource through VisaNet.
	// - `4`: Off merchant premises, unattended, or cardholder terminal. Examples: vending machines, home computer, mobile telephone, PDA. Cardholder terminal is supported only for Mastercard transactions on CyberSource through VisaNet.
	//
	// This field is supported only for American Express Direct and CyberSource through VisaNet.
	//
	// Max Length: 1
	OperatingEnvironment string `json:"operatingEnvironment,omitempty"`

	// Version of the software installed on the POS terminal. This value is provided by the client software that is
	// installed on the POS terminal.
	//
	// CyberSource does not forward this value to the processor. Instead, the value is forwarded to the CyberSource
	// reporting functionality.
	//
	// This field is supported only on American Express Direct, FDC Nashville Global, and SIX.
	//
	// For authorizations and credits, this field is supported only on these processors:
	// - American Express Direct
	// - Credit Mutuel-CIC
	// - FDC Nashville Global
	// - OmniPay Direct
	// - SIX
	//
	// Max Length: 32
	PartnerSdkVersion string `json:"partnerSdkVersion,omitempty"`

	// Format that is used to encode the PIN block. This value is provided by the client software that is installed on
	// the POS terminal.
	//
	// Possible values:
	// - `0`: ISO 9564 format 0
	// - `1`: ISO 9564 format 1
	// - `2`: ISO 9564 format 2
	// - `3`: ISO 9564 format 3
	//
	// #### Used by
	// **Authorization, PIN Debit**
	// - Required when the cardholder enters a PIN and the card cannot verify the PIN, which means that the issuer must verify the PIN.
	// - Required for PIN debit credit or PIN debit purchase.
	//
	// For authorizations, this field is supported only on these processors:
	// - American Express Direct
	// - Credit Mutuel-CIC
	// - FDC Nashville Global
	// - OmniPay Direct
	// - SIX
	//
	// This field is also supported by processors that support chip and online PIN transactions. The following table lists the EMV Cards
	// and Cardholder Verification Methods (CVMs) that these processors support:
	//
	// | Processor | Chip and Offline PIN | Chip and Online PIN | Chip and Signature |
	// | --- | --- | --- | --- |
	// | American Express Direct | Yes | Yes | Yes |
	// | Chase Paymentech Solutions | No | No | Yes |
	// | Credit Mutuel-CIC | Yes | Yes | Yes |
	// | CyberSource through VisaNet | Yes | No | Yes |
	// | FDC Nashville Global | Yes | Yes | Yes |
	// | GPN | No | No | Yes |
	// | OmniPay Direct | Yes | No | Yes |
	// | SIX | Yes | Yes | Yes |
	//
	// #### GPX
	// For chip and online PIN transactions for authorization, GPX supports the following EMV Cards and Cardholder Verification Methods (CVMs):
	// - Chip and Offline PIN
	// - Chip and Signature
	//
	// For PIN Debit Purchase and Credit Service transactions, GPX supports the following EMV Cards and Cardholder Verification Methods (CVMs):
	// - Chip and Online PIN
	//
	// Maximum: 9
	PinBlockEncodingFormat int64 `json:"pinBlockEncodingFormat,omitempty"`

	// When connectivity is unavailable, the client software that is installed on the POS terminal can store a
	// transaction in its memory and send it for authorization when connectivity is restored. This value is provided by
	// the client software that is installed on the POS terminal.
	//
	// This value is not forwarded to the processor. Instead, the value is forwarded to the reporting functionality.
	//
	// Possible values:
	// - `Y`: Transaction was stored and then forwarded.
	// - `N` (default): Transaction was not stored and then forwarded.
	//
	// For authorizations and credits, this field is supported only on these processors:
	// - American Express Direct
	// - FDC Nashville Global
	// - OmniPay Direct
	// - SIX
	//
	// Optional field.
	//
	// Max Length: 1
	StoreAndForwardIndicator string `json:"storeAndForwardIndicator,omitempty"`

	// POS terminals capability. Possible values:
	//
	//  - `1`: Terminal has a magnetic stripe reader only.
	//  - `2`: Terminal has a magnetic stripe reader and manual entry capability.
	//  - `3`: Terminal has manual entry capability only.
	//  - `4`: Terminal can read chip cards.
	//  - `5`: Terminal can read contactless chip cards; cannot use contact to read chip cards.
	//
	// For an EMV transaction, the value of this field must be `4` or `5`.
	//
	// #### PIN debit
	// Required for PIN debit purchase and PIN debit credit request.
	//
	// #### Used by
	// **Authorization**
	// Required for the following processors:
	// - American Express Direct
	// - Chase Paymentech Solutions
	// - Credit Mutuel-CIC
	// - FDC Nashville Global
	// - FDMS Nashville
	// - OmniPay Direct
	// - SIX
	// - Worldpay VAP
	//
	// Optional for the following processors:
	// - CyberSource through VisaNet
	// - GPN
	// - GPX
	// - JCN Gateway
	// - RBS WorldPay Atlanta
	// - TSYS Acquiring Solutions
	//
	// Maximum: 5
	// Minimum: 1
	TerminalCapability int64 `json:"terminalCapability,omitempty"`

	// Indicates whether the terminal can capture the card.
	//
	// Possible values:
	// - `1`: Terminal can capture card.
	// - `0`: Terminal cannot capture card.
	//
	// For authorizations and credits, this field is supported only by these processors:
	// - American Express Direct
	// - Credit Mutuel-CIC
	// - OmniPay Direct
	//
	// Optional field.
	//
	// Max Length: 1
	TerminalCardCaptureCapability string `json:"terminalCardCaptureCapability,omitempty"`

	// Flag that indicates whether the terminal is compliant with standards mandated by the Reserve Bank of India for card-present domestic transactions in India.
	//
	// Format:
	// - First character indicates whether the terminal supports terminal line encryption (TLE). Possible values:
	//   - 1: Not certified
	//   - 2: Certified
	// - Second character indicates whether the terminal supports Unique Key Per Transaction (UKPT) and Derived Unique Key Per Transaction (DUKPT). Possible values:
	//   - 1: Not certified
	//   - 2: Certified
	//
	// **Example** `21` indicates that the terminal supports TLE but does not support UKPT/DUKPT.
	//
	// You and the terminal vendors are responsible for terminal certification. If you have questions, contact your acquirer.
	//
	// This field is supported only for Mastercard transactions on CyberSource through VisaNet.
	//
	// **Note** On CyberSource through VisaNet, the value for this field corresponds to the following data in the TC 33 capture file:
	// - Record: CP01 TCR6
	// - Position: 92-93
	// - Field: Mastercard Terminal Compliance Indicator
	//
	// The TC 33 Capture file contains information about the purchases and refunds that a merchant submits to CyberSource. CyberSource through VisaNet creates the TC 33 Capture file at the end of the day and sends it to the merchants acquirer, who uses this information to facilitate end-of-day clearing processing with payment networks.
	//
	// #### Used by
	// **Authorization**
	// Required for card-present transactions in India. Otherwise, not used.
	//
	// Max Length: 2
	TerminalCompliance string `json:"terminalCompliance,omitempty"`

	// Identifier for the terminal at your retail location. You can define this value yourself, but consult the processor for requirements.
	//
	// #### CyberSource through VisaNet
	// A list of all possible values is stored in your CyberSource account. If terminal ID validation is enabled for
	// your CyberSource account, the value you send for this field is validated against the list each time you include
	// the field in a request. To enable or disable terminal ID validation, contact CyberSource Customer Support.
	//
	// When you do not include this field in a request, CyberSource uses the default value that is defined in your CyberSource account.
	//
	// #### FDC Nashville Global
	// To have your account configured to support this field, contact CyberSource Customer Support. This value must be a value that FDC Nashville Global issued to you.
	//
	// #### For Payouts
	// This field is applicable for CyberSource through VisaNet.
	//
	// #### GPX
	// Identifier for the terminal at your retail location. A list of all possible values is stored in your account.
	// If terminal ID validation is enabled for your account, the value you send for this field is validated against
	// the list each time you include the field in a request. To enable or disable terminal ID validation, contact
	// customer support.
	//
	// When you do not include this field in a request, the default value that is defined in your account is used.
	//
	// Optional for authorizations.
	//
	// #### Used by
	// **Authorization**
	// Optional for the following processors. When you do not include this field in a request, the default value that is
	// defined in your account is used.
	//   - American Express Direct
	//   - Credit Mutuel-CIC
	//   - FDC Nashville Global
	//   - SIX
	// - Chase Paymentech Solutions: Optional field. If you include this field in your request, you must also include `pointOfSaleInformation.catLevel`.
	// - FDMS Nashville: The default value that is defined in your account is used.
	// - GPX
	// - OmniPay Direct: Optional field.
	//
	// For the following processors, this field is not used.
	// - GPN
	// - JCN Gateway
	// - RBS WorldPay Atlanta
	// - TSYS Acquiring Solutions
	// - Worldpay VAP
	//
	// #### Card Present reply
	// Terminal identifier assigned by the acquirer. This value must be printed on the receipt.
	//
	// Max Length: 8
	TerminalID string `json:"terminalId,omitempty"`

	// Complete list of card input methods supported by the terminal.
	//
	// Possible values:
	// - `Keyed`: Terminal can accept card data that is entered manually.
	// - `Swiped`: Terminal can accept card data from a magnetic stripe reader.
	// - `Contact`: Terminal can accept card data in EMV contact mode ("dipping a card").
	// - `Contactless`: Terminal can accept card data in EMV contactless mode ("tapping a card").
	// - `BarCode`: Terminal can read bar codes.
	// - `QRcode`: Terminal can read or scan QR codes.
	// - `OCR`: Terminal can perform optical character recognition (OCT) on the card.
	//
	// **EXAMPLE**: ["Keyed","Swiped","Contact","Contactless"]
	//
	// #### Used by
	// **Authorization and Credit**
	// Optional. This field is supported only by client software that is installed on your POS terminals for the
	// following processors:
	// - American Express Direct
	// - Credit Mutuel-CIC
	// - FDC Nashville Global
	// - OmniPay Direct
	// - SIX
	//
	TerminalInputCapability []string `json:"terminalInputCapability"`

	// This is the manufacturer name of the reader which is used to accept the payment.
	// Possible values:
	//  - PAX
	//  - Verifone
	//  - Ingenico
	//
	// Max Length: 32
	TerminalMake string `json:"terminalMake,omitempty"`

	// This is the model name of the reader which is used to accept the payment.
	// Possible values:
	//  - E3555
	//  - P400
	//  - A920
	//
	// Max Length: 32
	TerminalModel string `json:"terminalModel,omitempty"`

	// Indicates whether the terminal can print or display messages.
	//
	// Possible values:
	// - 1: Neither
	// - 2: Print only
	// - 3: Display only
	// - 4: Print and display
	//
	// This field is supported for authorizations and credits only on the following processors:
	// - American Express Direct
	// - Credit Mutuel-CIC
	// - FDC Nashville Global
	// - OmniPay Direct
	// - SIX
	//
	// Optional field.
	//
	// Max Length: 1
	TerminalOutputCapability string `json:"terminalOutputCapability,omitempty"`

	// Maximum PIN length that the terminal can capture.
	//
	// Possible values:
	// -  0: No PIN capture capability
	// -  1: PIN capture capability unknown
	// -  4: Four characters
	// -  5: Five characters
	// -  6: Six characters
	// -  7: Seven characters
	// -  8: Eight characters
	// -  9: Nine characters
	// - 10: Ten characters
	// - 11: Eleven characters
	// - 12: Twelve characters
	//
	// This field is supported for authorizations and credits only on the following processors:
	// - American Express Direct
	// - Credit Mutuel-CIC
	// - OmniPay Direct
	// - SIX
	//
	// Required field for authorization or credit of PIN transactions.
	//
	TerminalPinCapability int64 `json:"terminalPinCapability,omitempty"`

	// Terminal serial number assigned by the hardware manufacturer. This value is provided by the client software that
	// is installed on the POS terminal.
	//
	// This value is not forwarded to the processor. Instead, the value is forwarded to the reporting functionality.
	//
	// #### Used by
	// **Authorization and Credit**
	// Optional. This field is supported only by client software that is installed on your POS terminals for the
	// following processors:
	// - American Express Direct
	// - Credit Mutuel-CIC
	// - FDC Nashville Global
	// - OmniPay Direct
	// - SIX
	//
	// Max Length: 32
	TerminalSerialNumber string `json:"terminalSerialNumber,omitempty"`

	// Cards track 1 and 2 data. For all processors except FDMS Nashville, this value consists of
	// one of the following:
	//
	//  - Track 1 data
	//  - Track 2 data
	//  - Data for both tracks 1 and 2
	//
	// For FDMS Nashville, this value consists of one of the following:
	//  - Track 1 data
	//  - Data for both tracks 1 and 2
	//
	// Example: %B4111111111111111^SMITH/JOHN ^1612101976110000868000000?;4111111111111111=16121019761186800000?
	//
	// #### Used by
	// **Authorization**
	// Required for Chase Paymentech Solutions, Credit Mutuel-CIC, CyberSource through VisaNet, FDC Nashville Global,
	// JCN Gateway, OmniPay Direct, and SIX if `pointOfSaleInformation.entryMode` is equal to one of these values:
	// - `contact`
	// - `contactless`
	// - `msd`
	// - `swiped`
	// Otherwise, this field not used.
	//
	// Required for all other processors if `pointOfSaleInformation.entryMode=swiped`; otherwise, this field is not used.
	//
	// #### GPX
	// This field only supports transactions from the following card types:
	// - Visa
	// - Mastercard
	// - AMEX
	// - Discover
	// - Diners
	// - JCB
	// - Union Pay International
	//
	// #### PIN debit
	// Track 2 data from the debit card. The sentinels are required.
	// Required field for a PIN debit purchase and a PIN debit credit.
	//
	TrackData string `json:"trackData,omitempty"`
}

// Validate validates this create payment params body point of sale information
func (o *CreatePaymentParamsBodyPointOfSaleInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAmexCapnData(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCatLevel(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDeviceID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEmv(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEmvApplicationIdentifierAndDedicatedFileName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEncryptedKeySerialNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEncryptedPin(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEntryMode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateIsDedicatedHardwareTerminal(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLaneNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOperatingEnvironment(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePartnerSdkVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePinBlockEncodingFormat(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateStoreAndForwardIndicator(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTerminalCapability(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTerminalCardCaptureCapability(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTerminalCompliance(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTerminalID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTerminalMake(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTerminalModel(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTerminalOutputCapability(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTerminalSerialNumber(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyPointOfSaleInformation) validateAmexCapnData(formats strfmt.Registry) error {
	if swag.IsZero(o.AmexCapnData) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"pointOfSaleInformation"+"."+"amexCapnData", "body", o.AmexCapnData, 15); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPointOfSaleInformation) validateCatLevel(formats strfmt.Registry) error {
	if swag.IsZero(o.CatLevel) { // not required
		return nil
	}

	if err := validate.MinimumInt("createPaymentRequest"+"."+"pointOfSaleInformation"+"."+"catLevel", "body", o.CatLevel, 1, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("createPaymentRequest"+"."+"pointOfSaleInformation"+"."+"catLevel", "body", o.CatLevel, 9, false); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPointOfSaleInformation) validateDeviceID(formats strfmt.Registry) error {
	if swag.IsZero(o.DeviceID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"pointOfSaleInformation"+"."+"deviceId", "body", o.DeviceID, 32); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPointOfSaleInformation) validateEmv(formats strfmt.Registry) error {
	if swag.IsZero(o.Emv) { // not required
		return nil
	}

	if o.Emv != nil {
		if err := o.Emv.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "pointOfSaleInformation" + "." + "emv")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "pointOfSaleInformation" + "." + "emv")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyPointOfSaleInformation) validateEmvApplicationIdentifierAndDedicatedFileName(formats strfmt.Registry) error {
	if swag.IsZero(o.EmvApplicationIdentifierAndDedicatedFileName) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"pointOfSaleInformation"+"."+"emvApplicationIdentifierAndDedicatedFileName", "body", o.EmvApplicationIdentifierAndDedicatedFileName, 32); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPointOfSaleInformation) validateEncryptedKeySerialNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.EncryptedKeySerialNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"pointOfSaleInformation"+"."+"encryptedKeySerialNumber", "body", o.EncryptedKeySerialNumber, 20); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPointOfSaleInformation) validateEncryptedPin(formats strfmt.Registry) error {
	if swag.IsZero(o.EncryptedPin) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"pointOfSaleInformation"+"."+"encryptedPin", "body", o.EncryptedPin, 16); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPointOfSaleInformation) validateEntryMode(formats strfmt.Registry) error {
	if swag.IsZero(o.EntryMode) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"pointOfSaleInformation"+"."+"entryMode", "body", o.EntryMode, 11); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPointOfSaleInformation) validateIsDedicatedHardwareTerminal(formats strfmt.Registry) error {
	if swag.IsZero(o.IsDedicatedHardwareTerminal) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"pointOfSaleInformation"+"."+"isDedicatedHardwareTerminal", "body", o.IsDedicatedHardwareTerminal, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPointOfSaleInformation) validateLaneNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.LaneNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"pointOfSaleInformation"+"."+"laneNumber", "body", o.LaneNumber, 8); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPointOfSaleInformation) validateOperatingEnvironment(formats strfmt.Registry) error {
	if swag.IsZero(o.OperatingEnvironment) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"pointOfSaleInformation"+"."+"operatingEnvironment", "body", o.OperatingEnvironment, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPointOfSaleInformation) validatePartnerSdkVersion(formats strfmt.Registry) error {
	if swag.IsZero(o.PartnerSdkVersion) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"pointOfSaleInformation"+"."+"partnerSdkVersion", "body", o.PartnerSdkVersion, 32); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPointOfSaleInformation) validatePinBlockEncodingFormat(formats strfmt.Registry) error {
	if swag.IsZero(o.PinBlockEncodingFormat) { // not required
		return nil
	}

	if err := validate.MaximumInt("createPaymentRequest"+"."+"pointOfSaleInformation"+"."+"pinBlockEncodingFormat", "body", o.PinBlockEncodingFormat, 9, false); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPointOfSaleInformation) validateStoreAndForwardIndicator(formats strfmt.Registry) error {
	if swag.IsZero(o.StoreAndForwardIndicator) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"pointOfSaleInformation"+"."+"storeAndForwardIndicator", "body", o.StoreAndForwardIndicator, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPointOfSaleInformation) validateTerminalCapability(formats strfmt.Registry) error {
	if swag.IsZero(o.TerminalCapability) { // not required
		return nil
	}

	if err := validate.MinimumInt("createPaymentRequest"+"."+"pointOfSaleInformation"+"."+"terminalCapability", "body", o.TerminalCapability, 1, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("createPaymentRequest"+"."+"pointOfSaleInformation"+"."+"terminalCapability", "body", o.TerminalCapability, 5, false); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPointOfSaleInformation) validateTerminalCardCaptureCapability(formats strfmt.Registry) error {
	if swag.IsZero(o.TerminalCardCaptureCapability) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"pointOfSaleInformation"+"."+"terminalCardCaptureCapability", "body", o.TerminalCardCaptureCapability, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPointOfSaleInformation) validateTerminalCompliance(formats strfmt.Registry) error {
	if swag.IsZero(o.TerminalCompliance) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"pointOfSaleInformation"+"."+"terminalCompliance", "body", o.TerminalCompliance, 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPointOfSaleInformation) validateTerminalID(formats strfmt.Registry) error {
	if swag.IsZero(o.TerminalID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"pointOfSaleInformation"+"."+"terminalId", "body", o.TerminalID, 8); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPointOfSaleInformation) validateTerminalMake(formats strfmt.Registry) error {
	if swag.IsZero(o.TerminalMake) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"pointOfSaleInformation"+"."+"terminalMake", "body", o.TerminalMake, 32); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPointOfSaleInformation) validateTerminalModel(formats strfmt.Registry) error {
	if swag.IsZero(o.TerminalModel) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"pointOfSaleInformation"+"."+"terminalModel", "body", o.TerminalModel, 32); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPointOfSaleInformation) validateTerminalOutputCapability(formats strfmt.Registry) error {
	if swag.IsZero(o.TerminalOutputCapability) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"pointOfSaleInformation"+"."+"terminalOutputCapability", "body", o.TerminalOutputCapability, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPointOfSaleInformation) validateTerminalSerialNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.TerminalSerialNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"pointOfSaleInformation"+"."+"terminalSerialNumber", "body", o.TerminalSerialNumber, 32); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this create payment params body point of sale information based on the context it is used
func (o *CreatePaymentParamsBodyPointOfSaleInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateEmv(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyPointOfSaleInformation) contextValidateEmv(ctx context.Context, formats strfmt.Registry) error {

	if o.Emv != nil {
		if err := o.Emv.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "pointOfSaleInformation" + "." + "emv")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "pointOfSaleInformation" + "." + "emv")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyPointOfSaleInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyPointOfSaleInformation) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyPointOfSaleInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyPointOfSaleInformationEmv create payment params body point of sale information emv
swagger:model CreatePaymentParamsBodyPointOfSaleInformationEmv
*/
type CreatePaymentParamsBodyPointOfSaleInformationEmv struct {

	// Number assigned to a specific card when two or more cards are associated with the same primary account number.
	// This value enables issuers to distinguish among multiple cards that are linked to the same account. This value
	// can also act as a tracking tool when reissuing cards. When this value is available, it is provided by the chip
	// reader. When the chip reader does not provide this value, do not include this field in your request.
	//
	// **Note** Card present information about EMV applies only to credit card processing and PIN debit processing.
	// All other card present information applies only to credit card processing. PIN debit processing is
	// available only on CyberSource through VisaNet and FDC Nashville Global.
	//
	// #### Used by
	// Authorization: Optional
	// PIN Debit processing: Optional
	//
	// #### GPX
	//
	// This field only supports transactions from the following card types:
	// - Visa
	// - Mastercard
	// - AMEX
	// - Discover
	// - Diners
	// - JCB
	// - Union Pay International
	//
	// Max Length: 3
	CardSequenceNumber string `json:"cardSequenceNumber,omitempty"`

	// Method that was used to verify the cardholder's identity.
	//
	// Possible values:
	//  - `0`: No verification
	//  - `1`: Signature
	//
	// This field is supported only on **American Express Direct**.
	//
	CardholderVerificationMethodUsed int64 `json:"cardholderVerificationMethodUsed,omitempty"`

	// Indicates whether a fallback method was used to enter credit card information into the POS terminal. When a
	// technical problem prevents a successful exchange of information between a chip card and a chip-capable terminal:
	//
	//  1. Swipe the card or key the credit card information into the POS terminal.
	//  2. Use the pointOfSaleInformation.entryMode field to indicate whether the information was swiped or keyed.
	//
	//
	// Possible values:
	// - `true`: Fallback method was used.
	// - `false` (default): Fallback method was not used.
	//
	// This field is supported only on American Express Direct, Chase Paymentech Solutions, CyberSource through VisaNet,
	// FDC Nashville Global, GPN, JCN Gateway, OmniPay Direct, and SIX.
	//
	Fallback *bool `json:"fallback,omitempty"`

	// Reason for the EMV fallback transaction. An EMV fallback transaction occurs when an EMV transaction fails for
	// one of these reasons:
	//
	//  - Technical failure: the EMV terminal or EMV card cannot read and process chip data.
	//  - Empty candidate list failure: the EMV terminal does not have any applications in common with the EMV card.
	//    EMV terminals are coded to determine whether the terminal and EMV card have any applications in common.
	//    EMV terminals provide this information to you.
	//
	// Possible values:
	//
	//  - `1`: Transaction was initiated with information from a magnetic stripe, and the previous transaction at the
	//       EMV terminal either used information from a successful chip read or it was not a chip transaction.
	//  - `2`: Transaction was initiated with information from a magnetic stripe, and the previous transaction at the
	//       EMV terminal was an EMV fallback transaction because the attempted chip read was unsuccessful.
	//
	// This field is supported only on **GPN** and **JCN Gateway**.
	//
	// **NOTE**: This field is required when an EMV transaction fails for a technical reason. Do not include this field
	//  when the EMV terminal does not have any applications in common with the EMV card.
	//
	FallbackCondition int64 `json:"fallbackCondition,omitempty"`

	// EMV data that is transmitted from the chip card to the issuer, and from the issuer to the chip card. The EMV
	// data is in the tag-length-value format and includes chip card tags, terminal tags, and transaction detail tags.
	//
	// For information about the individual tags, see the Application Specification section in the EMV 4.3 Specifications: http://emvco.com
	//
	// **Note** Card present information about EMV applies only to credit card processing and PIN debit processing.
	// All other card present information applies only to credit card processing. PIN debit processing is available only
	// on FDC Nashville Global.
	//
	// **Important** The following tags contain sensitive information and **must not** be included in this field:
	//
	//  - `56`: Track 1 equivalent data
	//  - `57`: Track 2 equivalent data
	//  - `5A`: Application PAN
	//  - `5F20`: Cardholder name
	//  - `5F24`: Application expiration date (This sensitivity has been relaxed for Credit Mutuel-CIC, American Express Direct, FDC Nashville Global, First Data Merchant Solutions, and SIX)
	//  - `99`: Transaction PIN
	//  - `9F0B`: Cardholder name (extended)
	//  - `9F1F`: Track 1 discretionary data
	//  - `9F20`: Track 2 discretionary data
	//
	// For captures, this field is required for contact EMV transactions. Otherwise, it is optional.
	//
	// For credits, this field is required for contact EMV stand-alone credits and contactless EMV stand-alone credits.
	// Otherwise, it is optional.
	//
	// **Important** For contact EMV captures, contact EMV stand-alone credits, and contactless EMV stand-alone credits,
	// you must include the following tags in this field. For all other types of EMV transactions, the following tags
	// are optional.
	//
	//  - `95`: Terminal verification results
	//  - `9F10`: Issuer application data
	//  - `9F26`: Application cryptogram
	//
	//
	// #### CyberSource through VisaNet
	// - In Japan: 199 bytes
	// - In other countries: String (252)
	//
	// #### GPX
	// This field only supports transactions from the following card types:
	// - Visa
	// - Mastercard
	// - AMEX
	// - Discover
	// - Diners
	// - JCB
	// - Union Pay International
	//
	// #### JCN Gateway
	// The following tags must be included:
	// - `4F`: Application identifier
	// - `84`: Dedicated file name
	//
	// Data length: 199 bytes
	//
	// #### All other processors:
	// String (999)
	//
	// #### Used by
	// Authorization: Optional
	// Authorization Reversal: Optional
	// Credit: Optional
	// PIN Debit processing (purchase, credit and reversal): Optional
	//
	// Max Length: 1998
	Tags string `json:"tags,omitempty"`
}

// Validate validates this create payment params body point of sale information emv
func (o *CreatePaymentParamsBodyPointOfSaleInformationEmv) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCardSequenceNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTags(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyPointOfSaleInformationEmv) validateCardSequenceNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.CardSequenceNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"pointOfSaleInformation"+"."+"emv"+"."+"cardSequenceNumber", "body", o.CardSequenceNumber, 3); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPointOfSaleInformationEmv) validateTags(formats strfmt.Registry) error {
	if swag.IsZero(o.Tags) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"pointOfSaleInformation"+"."+"emv"+"."+"tags", "body", o.Tags, 1998); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment params body point of sale information emv based on context it is used
func (o *CreatePaymentParamsBodyPointOfSaleInformationEmv) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyPointOfSaleInformationEmv) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyPointOfSaleInformationEmv) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyPointOfSaleInformationEmv
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyProcessingInformation create payment params body processing information
swagger:model CreatePaymentParamsBodyProcessingInformation
*/
type CreatePaymentParamsBodyProcessingInformation struct {

	// Array of actions (one or more) to be included in the payment to invoke bundled serviecs along with payment.
	//
	// Possible values are one or more of follows:
	//
	//  - `DECISION_SKIP`: Use this when you want to skip Decision Manager service(s).
	//
	//  - `TOKEN_CREATE`: Use this when you want to create a token from the card/bank data in your payment request.
	//
	//  - `CONSUMER_AUTHENTICATION`: Use this when you want to check if a card is enrolled in Payer Authentioncation along with your payment request.
	//
	//  - `VALIDATE_CONSUMER_AUTHENTICATION`: Use this after you acquire a Payer Authentioncation result that needs to be included for your payment request.
	//
	ActionList []string `json:"actionList"`

	// CyberSource tokens types you are performing a create on.
	// If not supplied the default token type for the merchants token vault will be used.
	//
	// Valid values:
	// - customer
	// - paymentInstrument
	// - instrumentIdentifier
	// - shippingAddress
	//
	ActionTokenTypes []string `json:"actionTokenTypes"`

	// authorization options
	AuthorizationOptions *CreatePaymentParamsBodyProcessingInformationAuthorizationOptions `json:"authorizationOptions,omitempty"`

	// bank transfer options
	BankTransferOptions *CreatePaymentParamsBodyProcessingInformationBankTransferOptions `json:"bankTransferOptions,omitempty"`

	// Payouts transaction type.
	// Required for OCT transactions.
	// This field is a pass-through, which means that CyberSource does not verify the value or
	// modify it in any way before sending it to the processor.
	// **Note** When the request includes this field, this value overrides the information in your CyberSource account.
	//
	// For valid values, see the `invoiceHeader_businessApplicationID` field description in [Payouts Using the Simple Order API.](http://apps.cybersource.com/library/documentation/dev_guides/payouts_SO/Payouts_SO_API.pdf)
	//
	BusinessApplicationID string `json:"businessApplicationId,omitempty"`

	// Indicates whether to also include a capture  in the submitted authorization request or not.
	//
	// Possible values:
	// - `true`: Include a capture with an authorization request.
	// - `false`: (default) Do not include a capture with an authorization request.
	//
	// #### Used by
	// **Authorization and Capture**
	// Optional field.
	//
	Capture *bool `json:"capture,omitempty"`

	// capture options
	CaptureOptions *CreatePaymentParamsBodyProcessingInformationCaptureOptions `json:"captureOptions,omitempty"`

	// Type of transaction. Some payment card companies use this information when determining discount rates.
	//
	// #### Used by
	// **Authorization**
	// Required payer authentication transactions; otherwise, optional.
	// **Credit**
	// Required for standalone credits on Chase Paymentech solutions; otherwise, optional.
	//
	// The list of valid values in this field depends on your processor.
	// See Appendix I, "Commerce Indicators," on page 441 of the Cybersource Credit Card Guide.
	//
	// #### Ingenico ePayments
	// When you omit this field for Ingenico ePayments, the processor uses the default transaction type they have on file for you
	// instead of the default value (listed in Appendix I, "Commerce Indicators," on page 441.)
	//
	// #### Payer Authentication Transactions
	// For the possible values and requirements, see "Payer Authentication," page 195.
	//
	// #### Card Present
	// You must set this field to `retail`. This field is required for a card-present transaction. Note that this should ONLY be
	// used when the cardholder and card are present at the time of the transaction.
	// For all keyed transactions originated from a POS terminal where the cardholder and card are not present, commerceIndicator
	// should be submitted as moto"
	//
	// Max Length: 20
	CommerceIndicator string `json:"commerceIndicator,omitempty"`

	// electronic benefits transfer
	ElectronicBenefitsTransfer *CreatePaymentParamsBodyProcessingInformationElectronicBenefitsTransfer `json:"electronicBenefitsTransfer,omitempty"`

	// A private national-use field submitted by acquirers and issuers in South Africa for South Africa-domestic (intra-country) authorizations and financial requests.
	// Values for this field are 00 through 99.
	//
	// Max Length: 1
	ExtendedCreditTotalCount string `json:"extendedCreditTotalCount,omitempty"`

	// Indicates that the transaction includes industry-specific data.
	//
	// Possible Values:
	// - `airline`
	// - `restaurant`
	// - `lodging`
	// - `auto_rental`
	// - `transit`
	// - `healthcare_medical`
	// - `healthcare_transit`
	// - `transit`
	//
	// #### Card Present, Airlines and Auto Rental
	// You must set this field to `airline` in order for airline data to be sent to the processor. For example, if this
	// field is not set to `airline` or is not included in the request, no airline data is sent to the processor.
	//
	// You must set this field to `restaurant` in order for restaurant data to be sent to the processor. When this field
	// is not set to `restaurant` or is not included in the request, no restaurant data is sent to the processor.
	//
	// You must set this field to `auto_rental` in order for auto rental data to be sent to the processor. For example, if this
	// field is not set to `auto_rental` or is not included in the request, no auto rental data is sent to the processor.
	//
	// Restaurant data is supported only on CyberSource through VisaNet.
	//
	// Max Length: 20
	IndustryDataType string `json:"industryDataType,omitempty"`

	// japan payment options
	JapanPaymentOptions *CreatePaymentParamsBodyProcessingInformationJapanPaymentOptions `json:"japanPaymentOptions,omitempty"`

	// Value that links the current authorization request to the original authorization request. Set this value
	// to the ID that was returned in the reply message from the original authorization request.
	//
	// This value is used for:
	//
	// - Partial authorizations
	// - Split shipments
	//
	// For details, see `link_to_request` field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// Max Length: 26
	LinkID string `json:"linkId,omitempty"`

	// loan options
	LoanOptions *CreatePaymentParamsBodyProcessingInformationLoanOptions `json:"loanOptions,omitempty"`

	// Type of payment initiated from a cardholder's mobile device. Possible values:
	// - `1` :  Consumer-initiated remote purchase, face-to-face
	// - `2` :  Consumer-initiated remote purchase, e-commerce
	// - `3` :  Consumer-initiated remote purchase, mail order / telephone order
	// - `4` :  Consumer-initiated bill pay
	// - `5` :  Consumer-initiated top up
	// - `6` :  Consumer-initiated cash out
	// - `7` :  ATM triggered or agent-initiated cash out
	// - `8` :  Merchant-initiated remote purchase, face-to-face
	// - `9` :  Merchant-initiated remote purchase, e-commerce
	//
	// This field is supported only for Mastercard transactions on CyberSource through VisaNet.
	//
	// Optional field.
	//
	// **Note** On CyberSource through VisaNet, the value for this field corresponds to the following data in the
	// TC 33 capture file:
	// - Record: CP01 TCR6
	// - Position: 94
	// - Field: Mastercard Mobile Remote Payment Program Indicator
	//
	// The TC 33 Capture file contains information about the purchases and refunds that a merchant submits to CyberSource.
	// CyberSource through VisaNet creates the TC 33 Capture file at the end of the day and sends it to the
	// merchants acquirer, who uses this information to facilitate end-of-day clearing processing with payment networks.
	//
	// Max Length: 1
	MobileRemotePaymentType string `json:"mobileRemotePaymentType,omitempty"`

	// Supplementary domestic transaction information provided by the acquirer for National Net Settlement Service (NNSS) transactions. NNSS is a settlement service that Visa provides.
	// For transactions on CyberSource through VisaNet in countries that subscribe to NNSS:
	// VisaNet clears transactions; VisaNet transfers funds to the acquirer after deducting processing fees and interchange fees.
	// VisaNet settles transactions in the local pricing currency through a local financial institution.
	// This field is supported only on CyberSource through VisaNet for domestic data in Colombia
	//
	// Max Length: 123
	NationalNetDomesticData string `json:"nationalNetDomesticData,omitempty"`

	// On PIN Debit Gateways: This U.S.-only field is optionally used by  participants (merchants and acquirers) to specify the network access priority.
	// VisaNet checks to determine if there are issuer routing preferences for any of the networks specified by the sharing group code.
	// If an issuer preference exists for one of the specified debit networks, VisaNet makes a routing selection based on the issuers preference.
	// If an issuer preference exists for more than one of the specified debit networks, or if no issuer preference exists,
	// VisaNet makes a selection based on the acquirers routing priorities.
	//
	// #### PIN debit
	// Priority order of the networks through which he transaction will be routed. Set this value to a series of one-character network codes in your preferred order. This is a list of the network codes:
	//
	// | Network | Code |
	// | --- | --- |
	// | Accel | E |
	// | AFFN | U |
	// | Alaska Option | 3 |
	// | CU24 | C |
	// | Interlink | G |
	// | Maestro | 8 |
	// | NETS | P |
	// | NYCE | F |
	// | Pulse | H |
	// | Shazam | 7 |
	// | Star | M |
	// | Visa | V |
	//
	// For example, if the Star network is your first preference and Pulse is your second preference, set this field to a value of `MH`.
	//
	// When you do not include this value in your PIN debit request, the list of network codes from your account is used.
	// **Note** This field is supported only for businesses located in the U.S.
	//
	// Optional field for PIN debit credit or PIN debit purchase.
	//
	// Max Length: 30
	NetworkRoutingOrder string `json:"networkRoutingOrder,omitempty"`

	// Flag that indicates if the transaction is pay by points transaction
	// true: Transaction uses loyalty points
	// false: Transaction does not use loyalty points
	// Default: false
	//
	PayByPointsIndicator bool `json:"payByPointsIndicator,omitempty"`

	// Type of digital payment solution for the transaction. Possible Values:
	//
	//  - `visacheckout`: Visa Checkout. This value is required for Visa Checkout transactions. For details, see `payment_solution` field description in [Visa Checkout Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/VCO_SCMP_API/html/)
	//  - `001`: Apple Pay.
	//  - `004`: Cybersource In-App Solution.
	//  - `005`: Masterpass. This value is required for Masterpass transactions on OmniPay Direct. For details, see "Masterpass" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//  - `006`: Android Pay.
	//  - `007`: Chase Pay.
	//  - `008`: Samsung Pay.
	//  - `012`: Google Pay.
	//  - `013`: Cybersource P2PE Decryption
	//  - `014`: Mastercard credential on file (COF) payment network token. Returned in authorizations that use a payment network token associated with a TMS token.
	//  - `015`: Visa credential on file (COF) payment network token. Returned in authorizations that use a payment network token associated with a TMS token.
	//  - `027`: Click to Pay.
	//
	// Max Length: 12
	PaymentSolution string `json:"paymentSolution,omitempty"`

	// Value that identifies the processor/acquirer to use for the transaction. This value is supported only for
	// **CyberSource through VisaNet**.
	//
	// Contact CyberSource Customer Support to get the value for this field.
	//
	// Max Length: 3
	ProcessorID string `json:"processorId,omitempty"`

	// Set this field to 3 to indicate that the request includes Level III data.
	// Max Length: 1
	PurchaseLevel string `json:"purchaseLevel,omitempty"`

	// purchase options
	PurchaseOptions *CreatePaymentParamsBodyProcessingInformationPurchaseOptions `json:"purchaseOptions,omitempty"`

	// Please check with Cybersource customer support to see if your merchant account is configured correctly so you
	// can include this field in your request.
	// * For Payouts: max length for FDCCompass is String (22).
	//
	// Max Length: 60
	ReconciliationID string `json:"reconciliationId,omitempty"`

	// recurring options
	RecurringOptions *CreatePaymentParamsBodyProcessingInformationRecurringOptions `json:"recurringOptions,omitempty"`

	// Attribute that lets you define custom grouping for your processor reports. This field is supported only for **Worldpay VAP**.
	//
	// For details, see `report_group` field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// Max Length: 25
	ReportGroup string `json:"reportGroup,omitempty"`

	// Identifier for the **Visa Checkout** order. Visa Checkout provides a unique order ID for every transaction in
	// the Visa Checkout **callID** field.
	//
	// Max Length: 48
	VisaCheckoutID string `json:"visaCheckoutId,omitempty"`

	// This field carries the wallet type in authorization requests and credit requests. Possible value are:
	// - `101`: Masterpass remote payment. The customer created the wallet by manually interacting with a customer-controlled device such as a computer, tablet, or phone. This value is supported only for Masterpass transactions on Chase Paymentech Solutions and CyberSource through VisaNet.
	// - `102`: Masterpass remote near field communication (NFC) payment. The customer created the wallet by tapping a PayPass card or customer-controlled device at a contactless card reader. This value is supported only for card-present Masterpass transactions on CyberSource through VisaNet.
	// - `103`: Masterpass Apple Pay payment. The payment was made with a combination of Masterpass and Apple Pay. This value is supported only for Masterpass Apple Pay transactions on CyberSource through VisaNet.
	// - `216`: Masterpass Google Pay payment. The payment was made with a combination of Masterpass and Google Pay. This value is supported only for Masterpass Google Pay transactions on CyberSource through VisaNet.
	// - `217`: Masterpass Samsung Pay payment. The payment was made with a combination of Masterpass and Samsung Pay. This value is supported only for Masterpass Samsung Pay transactions on CyberSource through VisaNet.
	// - `SDW`: Staged digital wallet. An issuer or operator created the wallet. This value is supported only for Masterpass transactions on Chase Paymentech Solutions.
	// - `VCIND`: Visa Checkout payment. This value is supported only on CyberSource through VisaNet, FDC Compass, FDC Nashville Global, FDI Australia, and TSYS Acquiring Solutions. See Getting Started with Visa Checkout. For Visa Checkout transactions, the way CyberSource processes the value for this field depends on the processor. See the Visa Checkout section below.
	// For all other values, this field is a passthrough; therefore, CyberSource does not verify the value or modify it in any way before sending it to the processor.
	// Masterpass (101, 102, 103, 216, and 217): The Masterpass platform generates the wallet type value and passes it to you along with the customers checkout information.
	//
	// Visa Checkout:
	// This field is optional for Visa Checkout authorizations on FDI Australia. For all other processors, this field is required for Visa Checkout authorizations.
	// For Visa Checkout transactions on the following processors, CyberSource sends the value that the processor expects for this field:FDC Compass,FDC Nashville Global,FDI Australia,TSYS Acquiring
	// Solutions For all other processors, this field is a passthrough; therefore, CyberSource does not verify the value or modify it in any way before sending it to the processor.
	// For incremental authorizations, this field is supported only for Mastercard and the supported values are 101 and 102.
	// Payment card companies can introduce new values without notice. Your order management system should be able to process new values without problems.
	//
	// CyberSource through VisaNet
	// When the value for this field is 101, 102, 103, 216, or 217, it corresponds to the following data in the TC 33 capture file5: Record: CP01 TCR6, Position: 88-90,  Field: Mastercard Wallet Identifier.
	// When the value for this field is VCIND, it corresponds to the following data in the TC 33 capture file5: Record: CP01 TCR8, Position: 72-76, Field: Agent Unique ID.
	//
	// Max Length: 5
	WalletType string `json:"walletType,omitempty"`
}

// Validate validates this create payment params body processing information
func (o *CreatePaymentParamsBodyProcessingInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAuthorizationOptions(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBankTransferOptions(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCaptureOptions(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCommerceIndicator(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateElectronicBenefitsTransfer(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExtendedCreditTotalCount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateIndustryDataType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateJapanPaymentOptions(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLinkID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLoanOptions(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMobileRemotePaymentType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNationalNetDomesticData(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNetworkRoutingOrder(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePaymentSolution(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProcessorID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePurchaseLevel(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePurchaseOptions(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateReconciliationID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRecurringOptions(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateReportGroup(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateVisaCheckoutID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateWalletType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformation) validateAuthorizationOptions(formats strfmt.Registry) error {
	if swag.IsZero(o.AuthorizationOptions) { // not required
		return nil
	}

	if o.AuthorizationOptions != nil {
		if err := o.AuthorizationOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "processingInformation" + "." + "authorizationOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "processingInformation" + "." + "authorizationOptions")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformation) validateBankTransferOptions(formats strfmt.Registry) error {
	if swag.IsZero(o.BankTransferOptions) { // not required
		return nil
	}

	if o.BankTransferOptions != nil {
		if err := o.BankTransferOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "processingInformation" + "." + "bankTransferOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "processingInformation" + "." + "bankTransferOptions")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformation) validateCaptureOptions(formats strfmt.Registry) error {
	if swag.IsZero(o.CaptureOptions) { // not required
		return nil
	}

	if o.CaptureOptions != nil {
		if err := o.CaptureOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "processingInformation" + "." + "captureOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "processingInformation" + "." + "captureOptions")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformation) validateCommerceIndicator(formats strfmt.Registry) error {
	if swag.IsZero(o.CommerceIndicator) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"processingInformation"+"."+"commerceIndicator", "body", o.CommerceIndicator, 20); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformation) validateElectronicBenefitsTransfer(formats strfmt.Registry) error {
	if swag.IsZero(o.ElectronicBenefitsTransfer) { // not required
		return nil
	}

	if o.ElectronicBenefitsTransfer != nil {
		if err := o.ElectronicBenefitsTransfer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "processingInformation" + "." + "electronicBenefitsTransfer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "processingInformation" + "." + "electronicBenefitsTransfer")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformation) validateExtendedCreditTotalCount(formats strfmt.Registry) error {
	if swag.IsZero(o.ExtendedCreditTotalCount) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"processingInformation"+"."+"extendedCreditTotalCount", "body", o.ExtendedCreditTotalCount, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformation) validateIndustryDataType(formats strfmt.Registry) error {
	if swag.IsZero(o.IndustryDataType) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"processingInformation"+"."+"industryDataType", "body", o.IndustryDataType, 20); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformation) validateJapanPaymentOptions(formats strfmt.Registry) error {
	if swag.IsZero(o.JapanPaymentOptions) { // not required
		return nil
	}

	if o.JapanPaymentOptions != nil {
		if err := o.JapanPaymentOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "processingInformation" + "." + "japanPaymentOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "processingInformation" + "." + "japanPaymentOptions")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformation) validateLinkID(formats strfmt.Registry) error {
	if swag.IsZero(o.LinkID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"processingInformation"+"."+"linkId", "body", o.LinkID, 26); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformation) validateLoanOptions(formats strfmt.Registry) error {
	if swag.IsZero(o.LoanOptions) { // not required
		return nil
	}

	if o.LoanOptions != nil {
		if err := o.LoanOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "processingInformation" + "." + "loanOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "processingInformation" + "." + "loanOptions")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformation) validateMobileRemotePaymentType(formats strfmt.Registry) error {
	if swag.IsZero(o.MobileRemotePaymentType) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"processingInformation"+"."+"mobileRemotePaymentType", "body", o.MobileRemotePaymentType, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformation) validateNationalNetDomesticData(formats strfmt.Registry) error {
	if swag.IsZero(o.NationalNetDomesticData) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"processingInformation"+"."+"nationalNetDomesticData", "body", o.NationalNetDomesticData, 123); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformation) validateNetworkRoutingOrder(formats strfmt.Registry) error {
	if swag.IsZero(o.NetworkRoutingOrder) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"processingInformation"+"."+"networkRoutingOrder", "body", o.NetworkRoutingOrder, 30); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformation) validatePaymentSolution(formats strfmt.Registry) error {
	if swag.IsZero(o.PaymentSolution) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"processingInformation"+"."+"paymentSolution", "body", o.PaymentSolution, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformation) validateProcessorID(formats strfmt.Registry) error {
	if swag.IsZero(o.ProcessorID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"processingInformation"+"."+"processorId", "body", o.ProcessorID, 3); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformation) validatePurchaseLevel(formats strfmt.Registry) error {
	if swag.IsZero(o.PurchaseLevel) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"processingInformation"+"."+"purchaseLevel", "body", o.PurchaseLevel, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformation) validatePurchaseOptions(formats strfmt.Registry) error {
	if swag.IsZero(o.PurchaseOptions) { // not required
		return nil
	}

	if o.PurchaseOptions != nil {
		if err := o.PurchaseOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "processingInformation" + "." + "purchaseOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "processingInformation" + "." + "purchaseOptions")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformation) validateReconciliationID(formats strfmt.Registry) error {
	if swag.IsZero(o.ReconciliationID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"processingInformation"+"."+"reconciliationId", "body", o.ReconciliationID, 60); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformation) validateRecurringOptions(formats strfmt.Registry) error {
	if swag.IsZero(o.RecurringOptions) { // not required
		return nil
	}

	if o.RecurringOptions != nil {
		if err := o.RecurringOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "processingInformation" + "." + "recurringOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "processingInformation" + "." + "recurringOptions")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformation) validateReportGroup(formats strfmt.Registry) error {
	if swag.IsZero(o.ReportGroup) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"processingInformation"+"."+"reportGroup", "body", o.ReportGroup, 25); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformation) validateVisaCheckoutID(formats strfmt.Registry) error {
	if swag.IsZero(o.VisaCheckoutID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"processingInformation"+"."+"visaCheckoutId", "body", o.VisaCheckoutID, 48); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformation) validateWalletType(formats strfmt.Registry) error {
	if swag.IsZero(o.WalletType) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"processingInformation"+"."+"walletType", "body", o.WalletType, 5); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this create payment params body processing information based on the context it is used
func (o *CreatePaymentParamsBodyProcessingInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateAuthorizationOptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateBankTransferOptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateCaptureOptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateElectronicBenefitsTransfer(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateJapanPaymentOptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateLoanOptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidatePurchaseOptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateRecurringOptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformation) contextValidateAuthorizationOptions(ctx context.Context, formats strfmt.Registry) error {

	if o.AuthorizationOptions != nil {
		if err := o.AuthorizationOptions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "processingInformation" + "." + "authorizationOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "processingInformation" + "." + "authorizationOptions")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformation) contextValidateBankTransferOptions(ctx context.Context, formats strfmt.Registry) error {

	if o.BankTransferOptions != nil {
		if err := o.BankTransferOptions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "processingInformation" + "." + "bankTransferOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "processingInformation" + "." + "bankTransferOptions")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformation) contextValidateCaptureOptions(ctx context.Context, formats strfmt.Registry) error {

	if o.CaptureOptions != nil {
		if err := o.CaptureOptions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "processingInformation" + "." + "captureOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "processingInformation" + "." + "captureOptions")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformation) contextValidateElectronicBenefitsTransfer(ctx context.Context, formats strfmt.Registry) error {

	if o.ElectronicBenefitsTransfer != nil {
		if err := o.ElectronicBenefitsTransfer.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "processingInformation" + "." + "electronicBenefitsTransfer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "processingInformation" + "." + "electronicBenefitsTransfer")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformation) contextValidateJapanPaymentOptions(ctx context.Context, formats strfmt.Registry) error {

	if o.JapanPaymentOptions != nil {
		if err := o.JapanPaymentOptions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "processingInformation" + "." + "japanPaymentOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "processingInformation" + "." + "japanPaymentOptions")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformation) contextValidateLoanOptions(ctx context.Context, formats strfmt.Registry) error {

	if o.LoanOptions != nil {
		if err := o.LoanOptions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "processingInformation" + "." + "loanOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "processingInformation" + "." + "loanOptions")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformation) contextValidatePurchaseOptions(ctx context.Context, formats strfmt.Registry) error {

	if o.PurchaseOptions != nil {
		if err := o.PurchaseOptions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "processingInformation" + "." + "purchaseOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "processingInformation" + "." + "purchaseOptions")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformation) contextValidateRecurringOptions(ctx context.Context, formats strfmt.Registry) error {

	if o.RecurringOptions != nil {
		if err := o.RecurringOptions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "processingInformation" + "." + "recurringOptions")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "processingInformation" + "." + "recurringOptions")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyProcessingInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyProcessingInformation) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyProcessingInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyProcessingInformationAuthorizationOptions create payment params body processing information authorization options
swagger:model CreatePaymentParamsBodyProcessingInformationAuthorizationOptions
*/
type CreatePaymentParamsBodyProcessingInformationAuthorizationOptions struct {

	// Indicates if transaction is an aggregated auth
	//
	// Possible values:
	// - **true**
	// - **false**
	//
	AggregatedAuthIndicator string `json:"aggregatedAuthIndicator,omitempty"`

	// Flag that specifies the purpose of the authorization.
	//
	// Possible values:
	//  - **0**: Preauthorization
	//  - **1**: Final authorization
	//
	// To set the default for this field, contact CyberSource Customer Support.
	//
	// #### Barclays and Elavon
	// The default for Barclays and Elavon is 1 (final authorization). To change the default for this field, contact CyberSource Customer Support.
	//
	// #### CyberSource through VisaNet
	// When the value for this field is 0, it corresponds to the following data in the TC 33 capture file:
	//  - Record: CP01 TCR0
	//  - Position: 164
	//  - Field: Additional Authorization Indicators
	// When the value for this field is 1, it does not correspond to any data in the TC 33 capture file.
	//
	// Max Length: 1
	AuthIndicator string `json:"authIndicator,omitempty"`

	// Authorization type. Possible values:
	//
	//  - `AUTOCAPTURE`: automatic capture.
	//  - `STANDARDCAPTURE`: standard capture.
	//  - `VERBAL`: forced capture. Include it in the payment request for a forced capture. Include it in the capture request for a verbal payment.
	//
	// #### Asia, Middle East, and Africa Gateway; Cielo; Comercio Latino; and CyberSource Latin American Processing
	// Set this field to `AUTOCAPTURE` and include it in a bundled request to indicate that you are requesting an automatic capture. If your account is configured to enable automatic captures, set this field to `STANDARDCAPTURE` and include it in a standard authorization or bundled request to indicate that you are overriding an automatic capture. For more information, see the `auth_type` field description in [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// #### Forced Capture
	// Set this field to `VERBAL` and include it in the authorization request to indicate that you are performing a forced capture; therefore, you receive the authorization code outside the CyberSource system.
	//
	// #### Verbal Authorization
	// Set this field to `VERBAL` and include it in the capture request to indicate that the request is for a verbal authorization. For more information, see "Verbal Authorizations" in [Credit Card Services Using the SCMP API](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html).
	//
	// Max Length: 15
	AuthType string `json:"authType,omitempty"`

	// Flag that indicates whether to return balance information.
	//
	// Possible values:
	// - `true`: Return balance information.
	// - `false`: Do not return balance information.
	//
	// #### Used by
	// **Authorization**
	// Required for a balance inquiry; otherwise, not used.
	//
	// #### PIN debit
	// Required for a balance inquiry request of a PIN debit purchase; otherwise, not used.
	//
	BalanceInquiry bool `json:"balanceInquiry,omitempty"`

	// Indicates payment for bill or payment towards existing contractual loan.
	//
	// Possible values:
	// - `true`: Bill payment or loan payment.
	// - `false` (default): Not a bill payment or loan payment.
	//
	// Optional request field.
	//
	BillPayment bool `json:"billPayment,omitempty"`

	// Reason for the payment.
	//
	// Possible values:
	// - 001: Utility payment
	// - 002: Government services
	// - 003: Mobile phone top-up
	// - 004: Coupon payment
	//
	// The value for this field corresponds to the following data in the TC 33 capture file5:
	// - Record: CP07 TCR0
	// - Position: 48-50
	// - Field: Bill Payment Transaction Type Identifier
	//
	// This field is supported only for bill payments in Brazil with Mastercard on CyberSource through VisaNet.
	//
	BillPaymentType string `json:"billPaymentType,omitempty"`

	// Indicates if transaction is a debt recovery request
	//
	// Possible values:
	// - **true**
	// - **false**
	//
	DebtRecoveryIndicator string `json:"debtRecoveryIndicator,omitempty"`

	// Comma-separated list of AVS flags that cause the reply flag `DAVSNO` to be returned.
	//
	// **Important** To receive declines for the AVS code `N`, you must include the value `N` in the comma-separated
	// list.
	//
	//   ### AVS Codes for Cielo 3.0 and CyberSource Latin American Processing
	//
	//   **Note** CyberSource Latin American Processing is the name of a specific processing connection that CyberSource supports.
	//   In the CyberSource API documentation, CyberSource Latin American Processing does not refer to the general topic of processing in Latin America.
	//   The information in this section is for the specific processing connection called CyberSource Latin American Processing.
	//   It is not for any other Latin American processors that CyberSource supports.
	//
	// |AVS Code|Description|
	// |--- |--- |
	// |D|Partial match: postal code and address match.|
	// |E|Not supported: AVS is not supported for this card type. _or_ Invalid: the acquirer returned an unrecognized value for the AVS response.|
	// |F|Partial match: postal code matches, but CPF and address do not match.*|
	// |G|Not supported: AVS not supported or not verified.|
	// |I|No match: AVS information is not available.|
	// |K|Partial match: CPF matches, but postal code and address do not match.*|
	// |L|Partial match: postal code and CPF match, but address does not match.*|
	// |N|No match: postal code, CPF, and address do not match.*|
	// |O|Partial match: CPF and address match, but postal code does not match.*|
	// |R|Not supported: your implementation does not support AVS _or_ System unavailable.|
	// |T|Partial match: address matches, but postal code and CPF do not match.*|
	// |V|Match: postal code, CPF, and address match.*|
	// |* CPF (Cadastro de Pessoas Fisicas) is required only for Redecard in Brazil.||
	//
	// ### AVS Codes for All Other Processors
	//
	// **Note** The list of AVS codes for all other processors follows these descriptions of the processor-specific information for these codes.
	//
	// #### American Express Cards
	// For American Express cards only, you can receive Visa and CyberSource
	// AVS codes in addition to the American Express AVS codes.
	//
	// **Note** For CyberSource through VisaNet, the American Express AVS codes are converted to Visa
	// AVS codes before they are returned to you. As a result, you will not receive American Express AVS codes for
	// the American Express card type.<br/><br/>
	//
	// _American Express Card codes_: `F`, `H`, `K`, `L`, `O`, `T`, `V`
	//
	// #### Domestic and International Visa Cards
	// The international and domestic alphabetic AVS codes are the Visa standard AVS codes. CyberSource maps
	// the standard AVS return codes for other types of payment cards, including American Express cards, to
	// the Visa standard AVS codes.
	//
	// AVS is considered either domestic or international, depending on the location of the bank that issued the
	// customer's payment card:
	// - When the bank is in the U.S., the AVS is domestic.
	// - When the bank is outside the U.S., the AVS is international.
	//
	// You should be prepared to handle both domestic and international AVS result codes:
	// - For international cards, you can receive domestic AVS codes in addition to the international AVS codes.
	// - For domestic cards, you can receive international AVS codes in addition to the domestic AVS codes.
	//
	// _International Visa Codes_: `B`, `C`, `D`, `G`, `I`, `M`, `P`
	//
	// _Domestic Visa Codes_: `A`, `E`,`N`, `R`, `S`, `U`, `W`, `X`, `Y`, `Z`
	//
	// #### CyberSource Codes
	// The numeric AVS codes are created by CyberSource
	// and are not standard Visa codes. These AVS codes
	// can be returned for any card type.
	//
	// _CyberSource Codes_: `1`, `2`, `3`, `4`
	//
	// ### Table of AVS Codes for All Other Processors
	//
	// |AVS Code|Description|
	// |--- |--- |
	// |A|Partial match: street address matches, but 5-digit and 9-digit postal codes do not match.|
	// |B|Partial match: street address matches, but postal code is not verified. Returned only for Visa cards not issued in the U.S.|
	// |C|No match: street address and postal code do not match. Returned only for Visa cards not issued in the U.S.|
	// |D & M|Match: street address and postal code match. Returned only for Visa cards not issued in the U.S.|
	// |E|Invalid: AVS data is invalid or AVS is not allowed for this card type.|
	// |F|Partial match: card members name does not match, but billing postal code matches.|
	// |G|Not supported: issuing bank outside the U.S. does not support AVS.|
	// |H|Partial match: card members name does not match, but street address and postal code match. Returned only for the American Express card type.|
	// |I|No match: address not verified. Returned only for Visa cards not issued in the U.S.|
	// |K|Partial match: card members name matches, but billing address and billing postal code do not match. Returned only for the American Express card type.|
	// |L|Partial match: card members name and billing postal code match, but billing address does not match. Returned only for the American Express card type.|
	// |M|See the entry for D & M.|
	// |N|No match: one of the following: street address and postal code do not match _or_ (American Express card type only) card members name, street address, and postal code do not match.|
	// |O|Partial match: card members name and billing address match, but billing postal code does not match. Returned only for the American Express card type.|
	// |P|Partial match: postal code matches, but street address not verified. Returned only for Visa cards not issued in the U.S.|
	// |R|System unavailable.|
	// |S|Not supported: issuing bank in the U.S. does not support AVS.|
	// |T|Partial match: card members name does not match, but street address matches. Returned only for the American Express card type.|
	// |U|System unavailable: address information unavailable for one of these reasons: The U.S. bank does not support AVS outside the U.S. _or_ The AVS in a U.S. bank is not functioning properly.|
	// |V|Match: card members name, billing address, and billing postal code match. Returned only for the American Express card type.|
	// |W|Partial match: street address does not match, but 9-digit postal code matches.|
	// |X|Match: street address and 9-digit postal code match.|
	// |Y|Match: street address and 5-digit postal code match.|
	// |Z|Partial match: street address does not match, but 5-digit postal code matches.|
	// |1|Not supported: one of the following: AVS is not supported for this processor or card type _or_ AVS is disabled for your CyberSource account. To enable AVS, contact CyberSource Customer Support.|
	// |2|Unrecognized: the processor returned an unrecognized value for the AVS response.|
	// |3|Match: address is confirmed. Returned only for PayPal Express Checkout.|
	// |4|No match: address is not confirmed. Returned only for PayPal Express Checkout.|
	// |5|No match: no AVS code was returned by the processor.|
	//
	DeclineAvsFlags []string `json:"declineAvsFlags"`

	// Flag that indicates whether the authorization request was delayed because connectivity was interrupted.
	//
	// Possible values:
	//   - `true` (Deferred authorization)
	//   - `false` (default: Not a deferred authorization)
	//
	DeferredAuthIndicator bool `json:"deferredAuthIndicator,omitempty"`

	// Flag for a sale request that indicates whether to allow the capture service to run even when the authorization
	// receives an AVS decline, as indicated by a reply flag value of DAVSNO.
	//
	// Possible values:
	// - `true`: Ignore the results of AVS checking and run the capture service.
	// - `false` (default): If the authorization receives an AVS decline, do not run the capture service.
	// When the value of this field is `true`, the list in the `processingInformation.authorizationOptions.declineAvsFlags` field is ignored.
	//
	// #### Used by
	// **Authorization**
	// Optional field.
	// String (3)
	//
	IgnoreAvsResult *bool `json:"ignoreAvsResult,omitempty"`

	// Flag for a sale request that indicates whether to allow the capture service to run even when the authorization receives a CVN decline, as indicated by an `processorInformation.cardVerification.resultCode` value of `D` or `N`.
	// Possible values:
	// - `true`: Ignore the results of CVN checking and run the capture service.
	// - `false` (default): If the authorization receives a CVN decline, do not run the capture service.
	//
	// #### Used by
	// **Authorization**
	// Optional field.
	//
	IgnoreCvResult *bool `json:"ignoreCvResult,omitempty"`

	// initiator
	Initiator *CreatePaymentParamsBodyProcessingInformationAuthorizationOptionsInitiator `json:"initiator,omitempty"`

	// Flag that indicates whether the transaction is enabled for partial authorization. When the request includes this
	// field, this value overrides the information in your account. Possible values:
	// - `true`: Enable the transaction for partial authorization.
	// - `false`: Do not enable the transaction for partial authorization.
	//
	// #### PIN debit
	// Required field for partial authorizations that use PIN debit purchase; otherwise, not used.
	//
	// #### Used by
	// **Authorization**
	// Optional field.
	//
	// #### CyberSource through VisaNet
	// To set the default for this field, contact CyberSource Customer Support.
	// The value for this field corresponds to the following data in the TC 33 capture file5:
	// - Record: CP01 TCR0
	// - Position: 164
	// - Field: Additional Authorization Indicators
	//
	PartialAuthIndicator bool `json:"partialAuthIndicator,omitempty"`

	// Flag that indicates the payment request is a redemption inquiry.
	//
	// Possible values:
	//   - `true`
	//   - `false`
	//
	RedemptionInquiry bool `json:"redemptionInquiry,omitempty"`

	// Type of transportation mode :
	//
	// Possible Values:
	// - 00 = Unknown
	// - 01 = Urban bus
	// - 02 = Interurban bus
	// - 03=Lighttrainmasstransit(Underground Metro LTR)
	// - 04 = Train
	// - 05 = Commuter train
	// - 06 = Water-borne vehicle
	// - 07 = Toll
	// - 08 = Parking
	// - 09 = Taxi
	// - 10 = High-speed train
	// - 11 = Rural bus
	// - 12 = Express commuter train
	// - 13 = Para transit
	// - 14 = Self drive vehicle
	// - 15 = Coach
	// - 16 = Locomotive
	// - 17 = Powered motor coach
	// - 18 = Trailer
	// - 19 = Regional train
	// - 20 = Inter-city
	// - 21 = Funicular train
	// - 22 = Cable car
	//
	TransportationMode string `json:"transportationMode,omitempty"`

	// Authorization code.
	//
	// #### Forced Capture
	// Use this field to send the authorization code you received from a payment that you authorized
	// outside the CyberSource system.
	//
	// #### PIN debit
	// Authorization code that is returned by the processor.
	//
	// Returned by PIN debit purchase.
	//
	// #### Verbal Authorization
	// Use this field in CAPTURE API to send the verbally received authorization code.
	//
	// For processor-specific information, see the `auth_code` field description in [Credit Card Services Using the SCMP API](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html).
	//
	// Max Length: 7
	VerbalAuthCode string `json:"verbalAuthCode,omitempty"`

	// Transaction ID (TID).
	//
	// #### FDMS South
	// This field is required for verbal authorizations and forced captures with the American Express card type to comply
	// with the CAPN requirements:
	// - Forced capture: Obtain the value for this field from the authorization response.
	// - Verbal authorization: You cannot obtain a value for this field so CyberSource uses the default value of `000000000000000` (15
	// zeros).
	//
	// Max Length: 15
	VerbalAuthTransactionID string `json:"verbalAuthTransactionId,omitempty"`
}

// Validate validates this create payment params body processing information authorization options
func (o *CreatePaymentParamsBodyProcessingInformationAuthorizationOptions) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAuthIndicator(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAuthType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateInitiator(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateVerbalAuthCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateVerbalAuthTransactionID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformationAuthorizationOptions) validateAuthIndicator(formats strfmt.Registry) error {
	if swag.IsZero(o.AuthIndicator) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"processingInformation"+"."+"authorizationOptions"+"."+"authIndicator", "body", o.AuthIndicator, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformationAuthorizationOptions) validateAuthType(formats strfmt.Registry) error {
	if swag.IsZero(o.AuthType) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"processingInformation"+"."+"authorizationOptions"+"."+"authType", "body", o.AuthType, 15); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformationAuthorizationOptions) validateInitiator(formats strfmt.Registry) error {
	if swag.IsZero(o.Initiator) { // not required
		return nil
	}

	if o.Initiator != nil {
		if err := o.Initiator.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformationAuthorizationOptions) validateVerbalAuthCode(formats strfmt.Registry) error {
	if swag.IsZero(o.VerbalAuthCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"processingInformation"+"."+"authorizationOptions"+"."+"verbalAuthCode", "body", o.VerbalAuthCode, 7); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformationAuthorizationOptions) validateVerbalAuthTransactionID(formats strfmt.Registry) error {
	if swag.IsZero(o.VerbalAuthTransactionID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"processingInformation"+"."+"authorizationOptions"+"."+"verbalAuthTransactionId", "body", o.VerbalAuthTransactionID, 15); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this create payment params body processing information authorization options based on the context it is used
func (o *CreatePaymentParamsBodyProcessingInformationAuthorizationOptions) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateInitiator(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformationAuthorizationOptions) contextValidateInitiator(ctx context.Context, formats strfmt.Registry) error {

	if o.Initiator != nil {
		if err := o.Initiator.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyProcessingInformationAuthorizationOptions) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyProcessingInformationAuthorizationOptions) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyProcessingInformationAuthorizationOptions
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyProcessingInformationAuthorizationOptionsInitiator create payment params body processing information authorization options initiator
swagger:model CreatePaymentParamsBodyProcessingInformationAuthorizationOptionsInitiator
*/
type CreatePaymentParamsBodyProcessingInformationAuthorizationOptionsInitiator struct {

	// Indicates to the issuing bank two things:
	// - The merchant has received consent from the cardholder to store their card details on file
	// - The merchant wants the issuing bank to check out the card details before the merchant initiates their first transaction for this cardholder.
	// The purpose of the merchant-initiated transaction is to ensure that the cardholders credentials are valid (that the card is not stolen or has restrictions) and that the card details are good to be stored on the merchants file for future transactions.
	//
	// Valid values:
	// - `true` means merchant will use this transaction to store payment credentials for follow-up merchant-initiated transactions.
	// - `false` means merchant will not use this transaction to store payment credentials for follow-up merchant-initiated transactions.
	//
	// For details, see `subsequent_auth_first` field description in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// **NOTE:** The value for this field does not correspond to any data in the TC 33 capture file5.
	//
	// This field is supported only for Visa transactions on CyberSource through VisaNet.
	//
	CredentialStoredOnFile bool `json:"credentialStoredOnFile,omitempty"`

	// merchant initiated transaction
	MerchantInitiatedTransaction *CreatePaymentParamsBodyProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction `json:"merchantInitiatedTransaction,omitempty"`

	// Indicates to an issuing bank whether a merchant-initiated transaction came from a card that was already stored on file.
	//
	// Possible values:
	// - **true** means the merchant-initiated transaction came from a card that was already stored on file.
	// - **false**  means the merchant-initiated transaction came from a card that was not stored on file.
	//
	StoredCredentialUsed bool `json:"storedCredentialUsed,omitempty"`

	// This field indicates whether the transaction is a merchant-initiated transaction or customer-initiated transaction.
	//
	// Valid values:
	// - **customer**
	// - **merchant**
	//
	Type string `json:"type,omitempty"`
}

// Validate validates this create payment params body processing information authorization options initiator
func (o *CreatePaymentParamsBodyProcessingInformationAuthorizationOptionsInitiator) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateMerchantInitiatedTransaction(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformationAuthorizationOptionsInitiator) validateMerchantInitiatedTransaction(formats strfmt.Registry) error {
	if swag.IsZero(o.MerchantInitiatedTransaction) { // not required
		return nil
	}

	if o.MerchantInitiatedTransaction != nil {
		if err := o.MerchantInitiatedTransaction.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator" + "." + "merchantInitiatedTransaction")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator" + "." + "merchantInitiatedTransaction")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this create payment params body processing information authorization options initiator based on the context it is used
func (o *CreatePaymentParamsBodyProcessingInformationAuthorizationOptionsInitiator) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateMerchantInitiatedTransaction(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformationAuthorizationOptionsInitiator) contextValidateMerchantInitiatedTransaction(ctx context.Context, formats strfmt.Registry) error {

	if o.MerchantInitiatedTransaction != nil {
		if err := o.MerchantInitiatedTransaction.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator" + "." + "merchantInitiatedTransaction")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator" + "." + "merchantInitiatedTransaction")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyProcessingInformationAuthorizationOptionsInitiator) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyProcessingInformationAuthorizationOptionsInitiator) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyProcessingInformationAuthorizationOptionsInitiator
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction create payment params body processing information authorization options initiator merchant initiated transaction
swagger:model CreatePaymentParamsBodyProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction
*/
type CreatePaymentParamsBodyProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction struct {

	// Amount of the original authorization.
	//
	// This field is supported only for Apple Pay, Google Pay, and Samsung Pay transactions with Discover on FDC Nashville Global and Chase Paymentech.
	//
	// See "Recurring Payments," and "Subsequent Authorizations," field description in the [Payment Network Tokenization
	// Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/tokenization_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 61
	OriginalAuthorizedAmount string `json:"originalAuthorizedAmount,omitempty"`

	// Network transaction identifier that was returned in the payment response field _processorInformation.transactionID_
	// in the reply message for either the original merchant-initiated payment in the series or the previous
	// merchant-initiated payment in the series.
	//
	// If the current payment request includes a token instead of an account number, the following time limits apply for the value of this field:
	// - For a **resubmission**, the transaction ID must be less than 14 days old.
	// - For a **delayed charge** or **reauthorization**, the transaction ID must be less than 30 days old.
	//
	// **NOTE**: The value for this field does not correspond to any data in the TC 33 capture file5. This field is supported
	// only for Visa transactions on CyberSource through VisaNet.
	//
	// Max Length: 15
	PreviousTransactionID string `json:"previousTransactionId,omitempty"`

	// Reason for the merchant-initiated transaction or incremental authorization. Possible values:
	// - `1`: Resubmission
	// - `2`: Delayed charge
	// - `3`: Reauthorization for split shipment
	// - `4`: No show
	// - `5`: Account top up
	// This field is required only for the five kinds of transactions in the preceding list.
	// This field is supported only for merchant-initiated transactions and incremental authorizations.
	//
	// #### CyberSource through VisaNet
	// The value for this field corresponds to the following data in the TC 33 capture file5:
	// - Record: CP01 TCR0
	// - Position: 160-163
	// - Field: Message Reason Code
	//
	// #### All Processors
	// For details, see `subsequent_auth_reason` field description in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// Max Length: 1
	Reason string `json:"reason,omitempty"`
}

// Validate validates this create payment params body processing information authorization options initiator merchant initiated transaction
func (o *CreatePaymentParamsBodyProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateOriginalAuthorizedAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePreviousTransactionID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateReason(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction) validateOriginalAuthorizedAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.OriginalAuthorizedAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"processingInformation"+"."+"authorizationOptions"+"."+"initiator"+"."+"merchantInitiatedTransaction"+"."+"originalAuthorizedAmount", "body", o.OriginalAuthorizedAmount, 61); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction) validatePreviousTransactionID(formats strfmt.Registry) error {
	if swag.IsZero(o.PreviousTransactionID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"processingInformation"+"."+"authorizationOptions"+"."+"initiator"+"."+"merchantInitiatedTransaction"+"."+"previousTransactionId", "body", o.PreviousTransactionID, 15); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction) validateReason(formats strfmt.Registry) error {
	if swag.IsZero(o.Reason) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"processingInformation"+"."+"authorizationOptions"+"."+"initiator"+"."+"merchantInitiatedTransaction"+"."+"reason", "body", o.Reason, 1); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment params body processing information authorization options initiator merchant initiated transaction based on context it is used
func (o *CreatePaymentParamsBodyProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyProcessingInformationBankTransferOptions create payment params body processing information bank transfer options
swagger:model CreatePaymentParamsBodyProcessingInformationBankTransferOptions
*/
type CreatePaymentParamsBodyProcessingInformationBankTransferOptions struct {

	// Payment related information.
	//
	// This information is included on the customers statement.
	//
	// Max Length: 80
	CustomerMemo string `json:"customerMemo,omitempty"`

	// Indicates whether a customer is physically present and whether the customer is enrolling in CyberSource Recurring Billing.
	//
	// Possible values:
	// - `1`: Customer is present and not enrolling.
	// - `2`: Customer is not present and not enrolling.
	// - `3`: Customer is present and enrolling.
	// - `4`: Customer is not present and enrolling.
	//
	// Max Length: 1
	CustomerPresent string `json:"customerPresent,omitempty"`

	// Space-separated list of AVS flags that cause the request to be declined for AVS reasons.
	//
	// **Important** To receive declines for the AVS code `N`, you must include the value `N` in the space-separated list.
	//
	// ### AVS Codes for Cielo 3.0 and CyberSource Latin American Processing
	//
	// **Note** CyberSource Latin American Processing is the name of a specific processing connection that CyberSource supports. In the CyberSource API documentation, CyberSource Latin American Processing does not refer to the general topic of processing in Latin America. The information in this section is for the specific processing connection called CyberSource Latin American Processing. It is not for any other Latin American processors that CyberSource supports.
	//
	// |AVS Code|Description|
	// |--- |--- |
	// |D|Partial match: postal code and address match.|
	// |E|Not supported: AVS is not supported for this card type. _or_ Invalid: the acquirer returned an unrecognized value for the AVS response.|
	// |F|Partial match: postal code matches, but CPF and address do not match.*|
	// |G|Not supported: AVS not supported or not verified.|
	// |I|No match: AVS information is not available.|
	// |K|Partial match: CPF matches, but postal code and address do not match.*|
	// |L|Partial match: postal code and CPF match, but address does not match.*|
	// |N|No match: postal code, CPF, and address do not match.*|
	// |O|Partial match: CPF and address match, but postal code does not match.*|
	// |R|Not supported: your implementation does not support AVS _or_ System unavailable.|
	// |T|Partial match: address matches, but postal code and CPF do not match.*|
	// |V|Match: postal code, CPF, and address match.*|
	// |* CPF (Cadastro de Pessoas Fisicas) is required only for Redecard in Brazil.||
	//
	// ### AVS Codes for All Other Processors
	//
	// **Note** The list of AVS codes for all other processors follows these descriptions of the processor-specific information for these codes.
	//
	// #### American Express Cards
	// For American Express cards only, you can receive Visa and CyberSource AVS codes in addition to the American Express AVS codes.
	//
	// **Note** For CyberSource through VisaNet, the American Express AVS codes are converted to Visa AVS codes before they are returned to you. As a result, you will not receive American Express AVS codes for the American Express card type.
	//
	// _American Express Card codes_: `F`, `H`, `K`, `L`, `O`, `T`, `V`
	//
	// #### Domestic and International Visa Cards
	// The international and domestic alphabetic AVS codes are the Visa standard AVS codes. CyberSource maps the standard AVS return codes for other types of payment cards, including American Express cards, to the Visa standard AVS codes.
	//
	// AVS is considered either domestic or international, depending on the location of the bank that issued the customers payment card:
	// - When the bank is in the U.S., the AVS is domestic.
	// - When the bank is outside the U.S., the AVS is international.
	//
	// You should be prepared to handle both domestic and international AVS result codes:
	// - For international cards, you can receive domestic AVS codes in addition to the international AVS codes.
	// - For domestic cards, you can receive international AVS codes in addition to the domestic AVS codes.
	//
	// _International Visa Codes_: `B`, `C`, `D`, `G`, `I`, `M`, `P`
	//
	// _Domestic Visa Codes_: `A`, `E`,`N`, `R`, `S`, `U`, `W`, `X`, `Y`, `Z`
	//
	// #### CyberSource Codes
	// The numeric AVS codes are created by CyberSource and are not standard Visa codes. These AVS codes can be returned for any card type.
	//
	// _CyberSource Codes_: `1`, `2`, `3`, `4`
	//
	// ### Table of AVS Codes for All Other Processors
	//
	// |AVS Code|Description|
	// |--- |--- |
	// |A|Partial match: street address matches, but 5-digit and 9-digit postal codes do not match.|
	// |B|Partial match: street address matches, but postal code is not verified. Returned only for Visa cards not issued in the U.S.|
	// |C|No match: street address and postal code do not match. Returned only for Visa cards not issued in the U.S.|
	// |D & M|Match: street address and postal code match. Returned only for Visa cards not issued in the U.S.|
	// |E|Invalid: AVS data is invalid or AVS is not allowed for this card type.|
	// |F|Partial match: card members name does not match, but billing postal code matches.|
	// |G|Not supported: issuing bank outside the U.S. does not support AVS.|
	// |H|Partial match: card members name does not match, but street address and postal code match. Returned only for the American Express card type.|
	// |I|No match: address not verified. Returned only for Visa cards not issued in the U.S.|
	// |K|Partial match: card members name matches, but billing address and billing postal code do not match. Returned only for the American Express card type.|
	// |L|Partial match: card members name and billing postal code match, but billing address does not match. Returned only for the American Express card type.|
	// |M|See the entry for D & M.|
	// |N|No match: one of the following: street address and postal code do not match _or_ (American Express card type only) card members name, street address, and postal code do not match.|
	// |O|Partial match: card members name and billing address match, but billing postal code does not match. Returned only for the American Express card type.|
	// |P|Partial match: postal code matches, but street address not verified. Returned only for Visa cards not issued in the U.S.|
	// |R|System unavailable.|
	// |S|Not supported: issuing bank in the U.S. does not support AVS.|
	// |T|Partial match: card members name does not match, but street address matches. Returned only for the American Express card type.|
	// |U|System unavailable: address information unavailable for one of these reasons: The U.S. bank does not support AVS outside the U.S. _or_ The AVS in a U.S. bank is not functioning properly.|
	// |V|Match: card members name, billing address, and billing postal code match. Returned only for the American Express card type.|
	// |W|Partial match: street address does not match, but 9-digit postal code matches.|
	// |X|Match: street address and 9-digit postal code match.|
	// |Y|Match: street address and 5-digit postal code match.|
	// |Z|Partial match: street address does not match, but 5-digit postal code matches.|
	// |1|Not supported: one of the following: AVS is not supported for this processor or card type _or_ AVS is disabled for your CyberSource account. To enable AVS, contact CyberSource Customer Support.|
	// |2|Unrecognized: the processor returned an unrecognized value for the AVS response.|
	// |3|Match: address is confirmed. Returned only for PayPal Express Checkout.|
	// |4|No match: address is not confirmed. Returned only for PayPal Express Checkout.|
	// |5|No match: no AVS code was returned by the processor.|
	//
	// Max Length: 15
	DeclineAvsFlags string `json:"declineAvsFlags,omitempty"`

	// Effective date for the transaction. The effective date must be within 45 days of the current day. If you do not
	// include this value, CyberSource sets the effective date to the next business day.
	//
	// Format: `MMDDYYYY`
	//
	// Supported only for the CyberSource ACH Service.
	//
	// Max Length: 8
	EffectiveDate string `json:"effectiveDate,omitempty"`

	// Level of fraud screening.
	//
	// Possible values:
	// - `1`: Validation  default if the field has not already been configured for your merchant ID
	// - `2`: Verification
	//
	// For a description of this feature and a list of supported processors, see "Verification and Validation" in the [Electronic Check Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/EChecks_SCMP_API/html/).
	//
	// Max Length: 1
	FraudScreeningLevel string `json:"fraudScreeningLevel,omitempty"`

	// Identifier for a partial payment or partial credit.
	//
	// The value for each debit request or credit request must be unique within the scope of the order.
	// For details, see `partial_payment_id` field description in the [Electronic Check Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/EChecks_SCMP_API/html/)
	//
	// Max Length: 25
	PartialPaymentID string `json:"partialPaymentId,omitempty"`

	// Flag that indicates whether to process the payment.
	//
	// Use with deferred payments.
	// For details, see `ecp_payment_mode` field description in the [Electronic Check Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/EChecks_SCMP_API/html/)
	//
	// Possible values:
	// - `0`: Standard debit with immediate payment (default).
	// - `1`: For deferred payments, indicates that this is a deferred payment and that you will send a debit request
	// with `paymentCategoryCode = 2` in the future.
	// - `2`: For deferred payments, indicates notification to initiate payment.
	//
	// #### Chase Paymentech Solutions and TeleCheck
	// Use for deferred and partial payments.
	//
	// #### CyberSource ACH Service
	// Not used.
	//
	// #### RBS WorldPay Atlanta
	// Not used.
	//
	// Max Length: 1
	PaymentCategoryCode string `json:"paymentCategoryCode,omitempty"`

	// Specifies the authorization method for the transaction.
	//
	// #### TeleCheck
	// Accepts only the following values:
	// - `ARC`: account receivable conversion
	// - `CCD`: corporate cash disbursement
	// - `POP`: point of purchase conversion
	// - `PPD`: prearranged payment and deposit entry
	// - `TEL`: telephone-initiated entry
	// - `WEB`: internet-initiated entry
	//
	// For details, see `ecp_sec_code` field description in the [Electronic Check Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/EChecks_SCMP_API/html/)
	//
	// Max Length: 3
	SecCode string `json:"secCode,omitempty"`

	// Method used for settlement.
	//
	// Possible values:
	// - `A`: Automated Clearing House (default for credits and for transactions using Canadian dollars)
	// - `F`: Facsimile draft (U.S. dollars only)
	// - `B`: Best possible (U.S. dollars only) (default if the field has not already been configured for your
	// merchant ID)
	//
	// For details, see `ecp_settlement_method` field description for credit cars and `ecp_debit_settlement_method` for debit cards in the [Electronic Check Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/EChecks_SCMP_API/html/)
	//
	// Max Length: 1
	SettlementMethod string `json:"settlementMethod,omitempty"`

	// City in which the terminal is located. If more than four alphanumeric characters are submitted, the transaction
	// will be declined.
	//
	// You cannot include any special characters.
	//
	// Max Length: 4
	TerminalCity string `json:"terminalCity,omitempty"`

	// State in which the terminal is located. If more than two alphanumeric characters are submitted, the transaction
	// will be declined.
	//
	// You cannot include any special characters.
	//
	// Max Length: 2
	TerminalState string `json:"terminalState,omitempty"`
}

// Validate validates this create payment params body processing information bank transfer options
func (o *CreatePaymentParamsBodyProcessingInformationBankTransferOptions) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCustomerMemo(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCustomerPresent(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDeclineAvsFlags(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEffectiveDate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFraudScreeningLevel(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePartialPaymentID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePaymentCategoryCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSecCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSettlementMethod(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTerminalCity(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTerminalState(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformationBankTransferOptions) validateCustomerMemo(formats strfmt.Registry) error {
	if swag.IsZero(o.CustomerMemo) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"processingInformation"+"."+"bankTransferOptions"+"."+"customerMemo", "body", o.CustomerMemo, 80); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformationBankTransferOptions) validateCustomerPresent(formats strfmt.Registry) error {
	if swag.IsZero(o.CustomerPresent) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"processingInformation"+"."+"bankTransferOptions"+"."+"customerPresent", "body", o.CustomerPresent, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformationBankTransferOptions) validateDeclineAvsFlags(formats strfmt.Registry) error {
	if swag.IsZero(o.DeclineAvsFlags) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"processingInformation"+"."+"bankTransferOptions"+"."+"declineAvsFlags", "body", o.DeclineAvsFlags, 15); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformationBankTransferOptions) validateEffectiveDate(formats strfmt.Registry) error {
	if swag.IsZero(o.EffectiveDate) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"processingInformation"+"."+"bankTransferOptions"+"."+"effectiveDate", "body", o.EffectiveDate, 8); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformationBankTransferOptions) validateFraudScreeningLevel(formats strfmt.Registry) error {
	if swag.IsZero(o.FraudScreeningLevel) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"processingInformation"+"."+"bankTransferOptions"+"."+"fraudScreeningLevel", "body", o.FraudScreeningLevel, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformationBankTransferOptions) validatePartialPaymentID(formats strfmt.Registry) error {
	if swag.IsZero(o.PartialPaymentID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"processingInformation"+"."+"bankTransferOptions"+"."+"partialPaymentId", "body", o.PartialPaymentID, 25); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformationBankTransferOptions) validatePaymentCategoryCode(formats strfmt.Registry) error {
	if swag.IsZero(o.PaymentCategoryCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"processingInformation"+"."+"bankTransferOptions"+"."+"paymentCategoryCode", "body", o.PaymentCategoryCode, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformationBankTransferOptions) validateSecCode(formats strfmt.Registry) error {
	if swag.IsZero(o.SecCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"processingInformation"+"."+"bankTransferOptions"+"."+"secCode", "body", o.SecCode, 3); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformationBankTransferOptions) validateSettlementMethod(formats strfmt.Registry) error {
	if swag.IsZero(o.SettlementMethod) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"processingInformation"+"."+"bankTransferOptions"+"."+"settlementMethod", "body", o.SettlementMethod, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformationBankTransferOptions) validateTerminalCity(formats strfmt.Registry) error {
	if swag.IsZero(o.TerminalCity) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"processingInformation"+"."+"bankTransferOptions"+"."+"terminalCity", "body", o.TerminalCity, 4); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformationBankTransferOptions) validateTerminalState(formats strfmt.Registry) error {
	if swag.IsZero(o.TerminalState) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"processingInformation"+"."+"bankTransferOptions"+"."+"terminalState", "body", o.TerminalState, 2); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment params body processing information bank transfer options based on context it is used
func (o *CreatePaymentParamsBodyProcessingInformationBankTransferOptions) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyProcessingInformationBankTransferOptions) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyProcessingInformationBankTransferOptions) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyProcessingInformationBankTransferOptions
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyProcessingInformationCaptureOptions create payment params body processing information capture options
swagger:model CreatePaymentParamsBodyProcessingInformationCaptureOptions
*/
type CreatePaymentParamsBodyProcessingInformationCaptureOptions struct {

	// Capture number when requesting multiple partial captures for one authorization.
	// Used along with `totalCaptureCount` to track which capture is being processed.
	//
	// For example, the second of five captures would be passed to CyberSource as:
	//   - `captureSequenceNumber_ = 2`, and
	//   - `totalCaptureCount = 5`
	//
	// Maximum: 99
	// Minimum: 1
	CaptureSequenceNumber int64 `json:"captureSequenceNumber,omitempty"`

	// Date on which you want the capture to occur. This field is supported only for CyberSource through VisaNet.
	// Format: `MMDD`
	//
	// #### Used by
	// **Authorization**
	// Optional field.
	//
	// Max Length: 4
	DateToCapture string `json:"dateToCapture,omitempty"`

	// Total number of captures when requesting multiple partial captures for one payment.
	// Used along with `captureSequenceNumber` field to track which capture is being processed.
	//
	// For example, the second of five captures would be passed to CyberSource as:
	//   - `captureSequenceNumber = 2`, and
	//   - `totalCaptureCount = 5`
	//
	// Maximum: 99
	// Minimum: 1
	TotalCaptureCount int64 `json:"totalCaptureCount,omitempty"`
}

// Validate validates this create payment params body processing information capture options
func (o *CreatePaymentParamsBodyProcessingInformationCaptureOptions) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCaptureSequenceNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDateToCapture(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTotalCaptureCount(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformationCaptureOptions) validateCaptureSequenceNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.CaptureSequenceNumber) { // not required
		return nil
	}

	if err := validate.MinimumInt("createPaymentRequest"+"."+"processingInformation"+"."+"captureOptions"+"."+"captureSequenceNumber", "body", o.CaptureSequenceNumber, 1, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("createPaymentRequest"+"."+"processingInformation"+"."+"captureOptions"+"."+"captureSequenceNumber", "body", o.CaptureSequenceNumber, 99, false); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformationCaptureOptions) validateDateToCapture(formats strfmt.Registry) error {
	if swag.IsZero(o.DateToCapture) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"processingInformation"+"."+"captureOptions"+"."+"dateToCapture", "body", o.DateToCapture, 4); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformationCaptureOptions) validateTotalCaptureCount(formats strfmt.Registry) error {
	if swag.IsZero(o.TotalCaptureCount) { // not required
		return nil
	}

	if err := validate.MinimumInt("createPaymentRequest"+"."+"processingInformation"+"."+"captureOptions"+"."+"totalCaptureCount", "body", o.TotalCaptureCount, 1, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("createPaymentRequest"+"."+"processingInformation"+"."+"captureOptions"+"."+"totalCaptureCount", "body", o.TotalCaptureCount, 99, false); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment params body processing information capture options based on context it is used
func (o *CreatePaymentParamsBodyProcessingInformationCaptureOptions) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyProcessingInformationCaptureOptions) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyProcessingInformationCaptureOptions) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyProcessingInformationCaptureOptions
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyProcessingInformationElectronicBenefitsTransfer create payment params body processing information electronic benefits transfer
swagger:model CreatePaymentParamsBodyProcessingInformationElectronicBenefitsTransfer
*/
type CreatePaymentParamsBodyProcessingInformationElectronicBenefitsTransfer struct {

	// Flag that specifies the category for the EBT transaction.
	//
	// Possible values:
	// - `CASH`: Cash benefits, which can be used to purchase any item at a participating retailer, as well as to obtain cash-back or make a cash withdrawal from a participating ATM.
	// - `FOOD`: Food stamp benefits, which can be used only to purchase food items authorized by the USDA SNAP program.
	//
	// #### PIN debit
	// Required field for EBT transactions that use PIN debit credit or PIN debit purchase; otherwise, not used.
	//
	// Max Length: 4
	Category string `json:"category,omitempty"`

	// The serial number printed on the EBT voucher.
	//
	// #### PIN debit
	// Required field for EBT voucher transactions that use PIN debit purchase; otherwise, not used.
	//
	// Max Length: 15
	VoucherSerialNumber string `json:"voucherSerialNumber,omitempty"`
}

// Validate validates this create payment params body processing information electronic benefits transfer
func (o *CreatePaymentParamsBodyProcessingInformationElectronicBenefitsTransfer) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCategory(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateVoucherSerialNumber(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformationElectronicBenefitsTransfer) validateCategory(formats strfmt.Registry) error {
	if swag.IsZero(o.Category) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"processingInformation"+"."+"electronicBenefitsTransfer"+"."+"category", "body", o.Category, 4); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformationElectronicBenefitsTransfer) validateVoucherSerialNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.VoucherSerialNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"processingInformation"+"."+"electronicBenefitsTransfer"+"."+"voucherSerialNumber", "body", o.VoucherSerialNumber, 15); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment params body processing information electronic benefits transfer based on context it is used
func (o *CreatePaymentParamsBodyProcessingInformationElectronicBenefitsTransfer) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyProcessingInformationElectronicBenefitsTransfer) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyProcessingInformationElectronicBenefitsTransfer) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyProcessingInformationElectronicBenefitsTransfer
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyProcessingInformationJapanPaymentOptions create payment params body processing information japan payment options
swagger:model CreatePaymentParamsBodyProcessingInformationJapanPaymentOptions
*/
type CreatePaymentParamsBodyProcessingInformationJapanPaymentOptions struct {

	// Business name in Japanese characters. This field is supported only on JCN Gateway and for the Sumitomo Mitsui Card Co. acquirer on CyberSource through VisaNet.
	//
	// Max Length: 25
	BusinessName string `json:"businessName,omitempty"`

	// Business name in alphanumeric characters. This field is supported only on JCN Gateway and for the Sumitomo Mitsui Card Co. acquirer on CyberSource through VisaNet.
	//
	// Max Length: 25
	BusinessNameAlphaNumeric string `json:"businessNameAlphaNumeric,omitempty"`

	// Business name in Katakana characters. This field is supported only on JCN Gateway and for the Sumitomo Mitsui Card Co. acquirer on CyberSource through VisaNet.
	//
	// Max Length: 25
	BusinessNameKatakana string `json:"businessNameKatakana,omitempty"`

	// Billing month in MM format.
	//
	// Max Length: 2
	FirstBillingMonth string `json:"firstBillingMonth,omitempty"`

	// Number of Installments.
	//
	Installments string `json:"installments,omitempty"`

	// Japanese Industrial Standard Type 2 (JIS2) track data from the front of the card.
	//
	// This field is supported only on CyberSource through VisaNet and JCN Gateway.
	//
	// Optional field.
	//
	// Max Length: 69
	Jis2TrackData string `json:"jis2TrackData,omitempty"`

	// This value is a 2-digit code indicating the payment method.
	// Use Payment Method Code value that applies to the tranasction.
	// - 10 (One-time payment)
	// - 21, 22, 23, 24  (Bonus(one-time)payment)
	// - 61 (Installment payment)
	// - 31, 32, 33, 34  (Integrated (Bonus + Installment)payment)
	// - 80 (Revolving payment)
	//
	// Max Length: 2
	PaymentMethod string `json:"paymentMethod,omitempty"`

	// Unique Japan Credit Card Association (JCCA) terminal identifier.
	//
	// The difference between this field and the `pointOfSaleInformation.terminalID` field is that you can define
	// `pointOfSaleInformation.terminalID`, but `processingInformation.japanPaymentOptions.terminalId` is
	// defined by the JCCA and is used only in Japan.
	//
	// This field is supported only on CyberSource through VisaNet and JCN Gateway.
	//
	// Optional field.
	//
	// Max Length: 13
	TerminalID string `json:"terminalId,omitempty"`
}

// Validate validates this create payment params body processing information japan payment options
func (o *CreatePaymentParamsBodyProcessingInformationJapanPaymentOptions) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateBusinessName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBusinessNameAlphaNumeric(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBusinessNameKatakana(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFirstBillingMonth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateJis2TrackData(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePaymentMethod(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTerminalID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformationJapanPaymentOptions) validateBusinessName(formats strfmt.Registry) error {
	if swag.IsZero(o.BusinessName) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"processingInformation"+"."+"japanPaymentOptions"+"."+"businessName", "body", o.BusinessName, 25); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformationJapanPaymentOptions) validateBusinessNameAlphaNumeric(formats strfmt.Registry) error {
	if swag.IsZero(o.BusinessNameAlphaNumeric) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"processingInformation"+"."+"japanPaymentOptions"+"."+"businessNameAlphaNumeric", "body", o.BusinessNameAlphaNumeric, 25); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformationJapanPaymentOptions) validateBusinessNameKatakana(formats strfmt.Registry) error {
	if swag.IsZero(o.BusinessNameKatakana) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"processingInformation"+"."+"japanPaymentOptions"+"."+"businessNameKatakana", "body", o.BusinessNameKatakana, 25); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformationJapanPaymentOptions) validateFirstBillingMonth(formats strfmt.Registry) error {
	if swag.IsZero(o.FirstBillingMonth) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"processingInformation"+"."+"japanPaymentOptions"+"."+"firstBillingMonth", "body", o.FirstBillingMonth, 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformationJapanPaymentOptions) validateJis2TrackData(formats strfmt.Registry) error {
	if swag.IsZero(o.Jis2TrackData) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"processingInformation"+"."+"japanPaymentOptions"+"."+"jis2TrackData", "body", o.Jis2TrackData, 69); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformationJapanPaymentOptions) validatePaymentMethod(formats strfmt.Registry) error {
	if swag.IsZero(o.PaymentMethod) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"processingInformation"+"."+"japanPaymentOptions"+"."+"paymentMethod", "body", o.PaymentMethod, 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformationJapanPaymentOptions) validateTerminalID(formats strfmt.Registry) error {
	if swag.IsZero(o.TerminalID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"processingInformation"+"."+"japanPaymentOptions"+"."+"terminalId", "body", o.TerminalID, 13); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment params body processing information japan payment options based on context it is used
func (o *CreatePaymentParamsBodyProcessingInformationJapanPaymentOptions) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyProcessingInformationJapanPaymentOptions) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyProcessingInformationJapanPaymentOptions) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyProcessingInformationJapanPaymentOptions
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyProcessingInformationLoanOptions create payment params body processing information loan options
swagger:model CreatePaymentParamsBodyProcessingInformationLoanOptions
*/
type CreatePaymentParamsBodyProcessingInformationLoanOptions struct {

	// Indicates whether a loan is for a recoverable item or a non-recoverable item.
	// Possible values:
	// - `N`: non-recoverable item
	// - `R`: recoverable item
	// This field is supported only for BNDES transactions on CyberSource through VisaNet.
	// The value for this field corresponds to the following data in the TC 33 capture file5:
	//  Record: CP07 TCR2, Position: 26, Field: Asset Indicator
	//
	// Max Length: 1
	AssetType string `json:"assetType,omitempty"`

	// Type of loan based on an agreement between you and the issuer.
	// Examples: AGROCUSTEIO, AGRO-INVEST, BNDES-Type1, CBN, FINAME.
	// This field is supported only for these kinds of payments:
	// - BNDES transactions on CyberSource through VisaNet.
	// - Installment payments with Mastercard on CyberSource through VisaNet in Brazil.
	//
	// See ""Installment Payments on CyberSource through VisaNet,"" in the SCMP/SO guide
	//
	// For BNDES transactions, the value for this field corresponds to the following data in the TC 33 capture file:
	// - Record: CP07 TCR2, Position: 27-46, Field: Loan Type
	//
	// For installment payments with Mastercard in Brazil, the value for this field corresponds to the following data in the TC 33 capture file:
	// - Record: CP07 TCR4, Position: 5-24,Field: Financing Type
	//
	// Max Length: 20
	Type string `json:"type,omitempty"`
}

// Validate validates this create payment params body processing information loan options
func (o *CreatePaymentParamsBodyProcessingInformationLoanOptions) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAssetType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformationLoanOptions) validateAssetType(formats strfmt.Registry) error {
	if swag.IsZero(o.AssetType) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"processingInformation"+"."+"loanOptions"+"."+"assetType", "body", o.AssetType, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformationLoanOptions) validateType(formats strfmt.Registry) error {
	if swag.IsZero(o.Type) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"processingInformation"+"."+"loanOptions"+"."+"type", "body", o.Type, 20); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment params body processing information loan options based on context it is used
func (o *CreatePaymentParamsBodyProcessingInformationLoanOptions) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyProcessingInformationLoanOptions) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyProcessingInformationLoanOptions) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyProcessingInformationLoanOptions
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyProcessingInformationPurchaseOptions create payment params body processing information purchase options
swagger:model CreatePaymentParamsBodyProcessingInformationPurchaseOptions
*/
type CreatePaymentParamsBodyProcessingInformationPurchaseOptions struct {

	// Flag that indicates whether this transaction is an EBT transaction. Possible values:
	// - `true`
	// - `false`
	//
	// #### PIN debit
	// Required field for EBT and EBT voucher transactions that use PIN debit credit or PIN debit purchase; otherwise, not used.
	//
	IsElectronicBenefitsTransfer bool `json:"isElectronicBenefitsTransfer,omitempty"`

	// Flag that indicates an EBT voucher transaction. Possible value:
	// - `EBT_VOUCHER`: Indicates the PIN debit transaction is an EBT voucher.
	//
	// #### PIN debit
	// Required field for EBT voucher transactions that use PIN debit purchase; otherwise, not used.
	//
	// Max Length: 6
	Type string `json:"type,omitempty"`
}

// Validate validates this create payment params body processing information purchase options
func (o *CreatePaymentParamsBodyProcessingInformationPurchaseOptions) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformationPurchaseOptions) validateType(formats strfmt.Registry) error {
	if swag.IsZero(o.Type) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"processingInformation"+"."+"purchaseOptions"+"."+"type", "body", o.Type, 6); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment params body processing information purchase options based on context it is used
func (o *CreatePaymentParamsBodyProcessingInformationPurchaseOptions) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyProcessingInformationPurchaseOptions) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyProcessingInformationPurchaseOptions) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyProcessingInformationPurchaseOptions
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyProcessingInformationRecurringOptions create payment params body processing information recurring options
swagger:model CreatePaymentParamsBodyProcessingInformationRecurringOptions
*/
type CreatePaymentParamsBodyProcessingInformationRecurringOptions struct {

	// Flag that indicates whether this transaction is the first in a series of recurring payments.
	//
	// This field is supported only for **Atos**, **FDC Nashville Global**, and **OmniPay Direct**.
	//
	// Possible values:
	//  - `true` Indicates this is the first payment in a series of recurring payments
	//  - `false` (default) Indicates this is not the first payment in a series of recurring payments.
	//
	// For details, see `auth_first_recurring_payment` field description and "Recurring Payments" in
	// [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	FirstRecurringPayment *bool `json:"firstRecurringPayment,omitempty"`

	// Flag that indicates whether this is a payment towards an existing contractual loan.
	//
	// Possible values:
	// - `true`: Loan payment
	// - `false`: (default) Not a loan payment
	//
	// For processor-specific details, see `debt_indicator` field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	LoanPayment *bool `json:"loanPayment,omitempty"`
}

// Validate validates this create payment params body processing information recurring options
func (o *CreatePaymentParamsBodyProcessingInformationRecurringOptions) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this create payment params body processing information recurring options based on context it is used
func (o *CreatePaymentParamsBodyProcessingInformationRecurringOptions) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyProcessingInformationRecurringOptions) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyProcessingInformationRecurringOptions) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyProcessingInformationRecurringOptions
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyPromotionInformation create payment params body promotion information
swagger:model CreatePaymentParamsBodyPromotionInformation
*/
type CreatePaymentParamsBodyPromotionInformation struct {

	// Additional rental agency marketed coupons for consumers to discount the rate of the vehicle rental agreement.
	//
	// Max Length: 12
	AdditionalCode string `json:"additionalCode,omitempty"`

	// Code for a promotion or discount.
	//
	// Max Length: 12
	Code string `json:"code,omitempty"`
}

// Validate validates this create payment params body promotion information
func (o *CreatePaymentParamsBodyPromotionInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAdditionalCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyPromotionInformation) validateAdditionalCode(formats strfmt.Registry) error {
	if swag.IsZero(o.AdditionalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"promotionInformation"+"."+"additionalCode", "body", o.AdditionalCode, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPromotionInformation) validateCode(formats strfmt.Registry) error {
	if swag.IsZero(o.Code) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"promotionInformation"+"."+"code", "body", o.Code, 12); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment params body promotion information based on context it is used
func (o *CreatePaymentParamsBodyPromotionInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyPromotionInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyPromotionInformation) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyPromotionInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyRecipientInformation create payment params body recipient information
swagger:model CreatePaymentParamsBodyRecipientInformation
*/
type CreatePaymentParamsBodyRecipientInformation struct {

	// Identifier for the recipients account. Use the first six digits and last four digits of the recipients account
	// number. This field is a _pass-through_, which means that CyberSource does not verify the value or modify it in
	// any way before sending it to the processor. If the field is not required for the transaction, CyberSource does
	// not forward it to the processor.
	//
	// For details, see the `recipient_account_id` field description in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// Max Length: 10
	AccountID string `json:"accountId,omitempty"`

	// Recipients last name. This field is a _passthrough_, which means that CyberSource does not verify the value or
	// modify it in any way before sending it to the processor. If the field is not required for the transaction,
	// CyberSource does not forward it to the processor.
	//
	// For details, see the `recipient_lastname` field description in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// Max Length: 6
	LastName string `json:"lastName,omitempty"`

	// Recipients middle name. This field is a _passthrough_, which means that CyberSource does not verify the value or
	// modify it in any way before sending it to the processor. If the field is not required for the transaction,
	// CyberSource does not forward it to the processor.
	//
	// For details, see the `recipient_middlename` field description in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// Max Length: 35
	MiddleName string `json:"middleName,omitempty"`

	// Partial postal code for the recipients address. For example, if the postal code is **NN5 7SG**, the value for
	// this field should be the first part of the postal code: **NN5**. This field is a _pass-through_, which means that
	// CyberSource does not verify the value or modify it in any way before sending it to the processor. If the field
	// is not required for the transaction, CyberSource does not forward it to the processor.
	//
	// For details, see the `recipient_postal_code` field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/)
	//
	// Max Length: 6
	PostalCode string `json:"postalCode,omitempty"`
}

// Validate validates this create payment params body recipient information
func (o *CreatePaymentParamsBodyRecipientInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAccountID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLastName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMiddleName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyRecipientInformation) validateAccountID(formats strfmt.Registry) error {
	if swag.IsZero(o.AccountID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"recipientInformation"+"."+"accountId", "body", o.AccountID, 10); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyRecipientInformation) validateLastName(formats strfmt.Registry) error {
	if swag.IsZero(o.LastName) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"recipientInformation"+"."+"lastName", "body", o.LastName, 6); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyRecipientInformation) validateMiddleName(formats strfmt.Registry) error {
	if swag.IsZero(o.MiddleName) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"recipientInformation"+"."+"middleName", "body", o.MiddleName, 35); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyRecipientInformation) validatePostalCode(formats strfmt.Registry) error {
	if swag.IsZero(o.PostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"recipientInformation"+"."+"postalCode", "body", o.PostalCode, 6); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment params body recipient information based on context it is used
func (o *CreatePaymentParamsBodyRecipientInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyRecipientInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyRecipientInformation) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyRecipientInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyRecurringPaymentInformation This object contains recurring payment information.
swagger:model CreatePaymentParamsBodyRecurringPaymentInformation
*/
type CreatePaymentParamsBodyRecurringPaymentInformation struct {

	// The date after which no further recurring authorizations should be performed. Format: `YYYY-MM-DD`
	// **Note** This field is required for recurring transactions.
	//
	// Max Length: 10
	EndDate string `json:"endDate,omitempty"`

	// Integer value indicating the minimum number of days between recurring authorizations. A frequency
	// of monthly is indicated by the value 28. Multiple of 28 days will be used to indicate months.
	//
	// Example: 6 months = 168
	//
	// Example values accepted (31 days):
	// - 31
	// - 031
	// - 0031
	//
	// **Note** This field is required for recurring transactions.
	//
	Frequency int64 `json:"frequency,omitempty"`

	// Total number of payments for the duration of the recurring subscription.
	//
	NumberOfPayments int64 `json:"numberOfPayments,omitempty"`

	// Date of original purchase. Required for recurring transactions.
	// Format: `YYYY-MM-DDTHH:MM:SSZ`
	// **Note**: If this field is empty, the current date is used.
	//
	// Max Length: 17
	OriginalPurchaseDate string `json:"originalPurchaseDate,omitempty"`

	// This field is mandatory for Cartes Bancaires recurring transactions on Credit Mutuel-CIC.
	// This field records recurring sequence, e.g. 1st for initial,  2 for subsequent, 3 etc
	//
	SequenceNumber int64 `json:"sequenceNumber,omitempty"`
}

// Validate validates this create payment params body recurring payment information
func (o *CreatePaymentParamsBodyRecurringPaymentInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateEndDate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOriginalPurchaseDate(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyRecurringPaymentInformation) validateEndDate(formats strfmt.Registry) error {
	if swag.IsZero(o.EndDate) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"recurringPaymentInformation"+"."+"endDate", "body", o.EndDate, 10); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyRecurringPaymentInformation) validateOriginalPurchaseDate(formats strfmt.Registry) error {
	if swag.IsZero(o.OriginalPurchaseDate) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"recurringPaymentInformation"+"."+"originalPurchaseDate", "body", o.OriginalPurchaseDate, 17); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment params body recurring payment information based on context it is used
func (o *CreatePaymentParamsBodyRecurringPaymentInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyRecurringPaymentInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyRecurringPaymentInformation) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyRecurringPaymentInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyRiskInformation This object is only needed when you are requesting both payment and DM services at same time.
swagger:model CreatePaymentParamsBodyRiskInformation
*/
type CreatePaymentParamsBodyRiskInformation struct {

	// auxiliary data
	AuxiliaryData []*CreatePaymentParamsBodyRiskInformationAuxiliaryDataItems0 `json:"auxiliaryData"`

	// buyer history
	BuyerHistory *CreatePaymentParamsBodyRiskInformationBuyerHistory `json:"buyerHistory,omitempty"`

	// Specifies one of the following types of events:
	// - login
	// - account_creation
	// - account_update
	// For regular payment transactions, do not send this field.
	//
	// Max Length: 255
	EventType string `json:"eventType,omitempty"`

	// profile
	Profile *CreatePaymentParamsBodyRiskInformationProfile `json:"profile,omitempty"`
}

// Validate validates this create payment params body risk information
func (o *CreatePaymentParamsBodyRiskInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAuxiliaryData(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBuyerHistory(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEventType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProfile(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyRiskInformation) validateAuxiliaryData(formats strfmt.Registry) error {
	if swag.IsZero(o.AuxiliaryData) { // not required
		return nil
	}

	for i := 0; i < len(o.AuxiliaryData); i++ {
		if swag.IsZero(o.AuxiliaryData[i]) { // not required
			continue
		}

		if o.AuxiliaryData[i] != nil {
			if err := o.AuxiliaryData[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("createPaymentRequest" + "." + "riskInformation" + "." + "auxiliaryData" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("createPaymentRequest" + "." + "riskInformation" + "." + "auxiliaryData" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CreatePaymentParamsBodyRiskInformation) validateBuyerHistory(formats strfmt.Registry) error {
	if swag.IsZero(o.BuyerHistory) { // not required
		return nil
	}

	if o.BuyerHistory != nil {
		if err := o.BuyerHistory.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "riskInformation" + "." + "buyerHistory")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "riskInformation" + "." + "buyerHistory")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyRiskInformation) validateEventType(formats strfmt.Registry) error {
	if swag.IsZero(o.EventType) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"riskInformation"+"."+"eventType", "body", o.EventType, 255); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyRiskInformation) validateProfile(formats strfmt.Registry) error {
	if swag.IsZero(o.Profile) { // not required
		return nil
	}

	if o.Profile != nil {
		if err := o.Profile.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "riskInformation" + "." + "profile")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "riskInformation" + "." + "profile")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this create payment params body risk information based on the context it is used
func (o *CreatePaymentParamsBodyRiskInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateAuxiliaryData(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateBuyerHistory(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateProfile(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyRiskInformation) contextValidateAuxiliaryData(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.AuxiliaryData); i++ {

		if o.AuxiliaryData[i] != nil {
			if err := o.AuxiliaryData[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("createPaymentRequest" + "." + "riskInformation" + "." + "auxiliaryData" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("createPaymentRequest" + "." + "riskInformation" + "." + "auxiliaryData" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CreatePaymentParamsBodyRiskInformation) contextValidateBuyerHistory(ctx context.Context, formats strfmt.Registry) error {

	if o.BuyerHistory != nil {
		if err := o.BuyerHistory.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "riskInformation" + "." + "buyerHistory")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "riskInformation" + "." + "buyerHistory")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyRiskInformation) contextValidateProfile(ctx context.Context, formats strfmt.Registry) error {

	if o.Profile != nil {
		if err := o.Profile.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "riskInformation" + "." + "profile")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "riskInformation" + "." + "profile")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyRiskInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyRiskInformation) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyRiskInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyRiskInformationAuxiliaryDataItems0 Contains auxiliary key-value pairs.
swagger:model CreatePaymentParamsBodyRiskInformationAuxiliaryDataItems0
*/
type CreatePaymentParamsBodyRiskInformationAuxiliaryDataItems0 struct {

	// Fields that you can use to send additional data to Risk services.
	// **Warning** Auxiliary fields are not intended to and MUST NOT
	// be used to capture personally identifying information.
	// Accordingly, merchants are prohibited from capturing,
	// obtaining, and/or transmitting any personally identifying
	// information in or via the auxiliary data fields. Personally
	// identifying information includes, but is not limited to,
	// address, credit card number, social security number,
	// driver's license number, state-issued identification
	// number, passport number, and card verification numbers
	// (CVV, CVC2, CVV2, CID, CVN). In the event CyberSource
	// discovers that a merchant is capturing and/or transmitting
	// personally identifying information via the auxiliary data
	// fields, whether or not intentionally, CyberSource WILL
	// immediately suspend the merchant's account, which will
	// result in a rejection of any and all transaction requests
	// submitted by the merchant after the point of suspension.
	//
	// Max Length: 255
	Key string `json:"key,omitempty"`

	// String value for the key
	// Max Length: 255
	Value string `json:"value,omitempty"`
}

// Validate validates this create payment params body risk information auxiliary data items0
func (o *CreatePaymentParamsBodyRiskInformationAuxiliaryDataItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateKey(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateValue(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyRiskInformationAuxiliaryDataItems0) validateKey(formats strfmt.Registry) error {
	if swag.IsZero(o.Key) { // not required
		return nil
	}

	if err := validate.MaxLength("key", "body", o.Key, 255); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyRiskInformationAuxiliaryDataItems0) validateValue(formats strfmt.Registry) error {
	if swag.IsZero(o.Value) { // not required
		return nil
	}

	if err := validate.MaxLength("value", "body", o.Value, 255); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment params body risk information auxiliary data items0 based on context it is used
func (o *CreatePaymentParamsBodyRiskInformationAuxiliaryDataItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyRiskInformationAuxiliaryDataItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyRiskInformationAuxiliaryDataItems0) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyRiskInformationAuxiliaryDataItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyRiskInformationBuyerHistory create payment params body risk information buyer history
swagger:model CreatePaymentParamsBodyRiskInformationBuyerHistory
*/
type CreatePaymentParamsBodyRiskInformationBuyerHistory struct {

	// account history
	AccountHistory *CreatePaymentParamsBodyRiskInformationBuyerHistoryAccountHistory `json:"accountHistory,omitempty"`

	// Number of purchases with this cardholder account during the previous six months.
	// Recommended for Discover ProtectBuy.
	//
	AccountPurchases int64 `json:"accountPurchases,omitempty"`

	// Number of add card attempts in the last 24 hours.
	// Recommended for Discover ProtectBuy.
	//
	AddCardAttempts int64 `json:"addCardAttempts,omitempty"`

	// customer account
	CustomerAccount *CreatePaymentParamsBodyRiskInformationBuyerHistoryCustomerAccount `json:"customerAccount,omitempty"`

	// Date applicable only for PAYMENT_ACCOUNT_EXISTS in paymentAccountHistory
	//
	PaymentAccountDate int64 `json:"paymentAccountDate,omitempty"`

	// This only applies for NEW_ACCOUNT and EXISTING_ACCOUNT in creationHistory. Possible values are:
	// - PAYMENT_ACCOUNT_EXISTS
	// - PAYMENT_ACCOUNT_ADDED_NOW
	//
	PaymentAccountHistory string `json:"paymentAccountHistory,omitempty"`

	// Indicates whether the merchant experienced suspicious activity (including previous fraud) on the account.
	// Recommended for Discover ProtectBuy.
	//
	PriorSuspiciousActivity bool `json:"priorSuspiciousActivity,omitempty"`

	// Number of transaction (successful or abandoned) for this cardholder account within the last 24 hours.
	// Recommended for Discover ProtectBuy.
	//
	TransactionCountDay int64 `json:"transactionCountDay,omitempty"`

	// Number of transaction (successful or abandoned) for this cardholder account within the last year.
	// Recommended for Discover ProtectBuy.
	//
	TransactionCountYear int64 `json:"transactionCountYear,omitempty"`
}

// Validate validates this create payment params body risk information buyer history
func (o *CreatePaymentParamsBodyRiskInformationBuyerHistory) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAccountHistory(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCustomerAccount(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyRiskInformationBuyerHistory) validateAccountHistory(formats strfmt.Registry) error {
	if swag.IsZero(o.AccountHistory) { // not required
		return nil
	}

	if o.AccountHistory != nil {
		if err := o.AccountHistory.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "riskInformation" + "." + "buyerHistory" + "." + "accountHistory")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "riskInformation" + "." + "buyerHistory" + "." + "accountHistory")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyRiskInformationBuyerHistory) validateCustomerAccount(formats strfmt.Registry) error {
	if swag.IsZero(o.CustomerAccount) { // not required
		return nil
	}

	if o.CustomerAccount != nil {
		if err := o.CustomerAccount.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "riskInformation" + "." + "buyerHistory" + "." + "customerAccount")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "riskInformation" + "." + "buyerHistory" + "." + "customerAccount")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this create payment params body risk information buyer history based on the context it is used
func (o *CreatePaymentParamsBodyRiskInformationBuyerHistory) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateAccountHistory(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateCustomerAccount(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyRiskInformationBuyerHistory) contextValidateAccountHistory(ctx context.Context, formats strfmt.Registry) error {

	if o.AccountHistory != nil {
		if err := o.AccountHistory.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "riskInformation" + "." + "buyerHistory" + "." + "accountHistory")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "riskInformation" + "." + "buyerHistory" + "." + "accountHistory")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyRiskInformationBuyerHistory) contextValidateCustomerAccount(ctx context.Context, formats strfmt.Registry) error {

	if o.CustomerAccount != nil {
		if err := o.CustomerAccount.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "riskInformation" + "." + "buyerHistory" + "." + "customerAccount")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "riskInformation" + "." + "buyerHistory" + "." + "customerAccount")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyRiskInformationBuyerHistory) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyRiskInformationBuyerHistory) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyRiskInformationBuyerHistory
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyRiskInformationBuyerHistoryAccountHistory create payment params body risk information buyer history account history
swagger:model CreatePaymentParamsBodyRiskInformationBuyerHistoryAccountHistory
*/
type CreatePaymentParamsBodyRiskInformationBuyerHistoryAccountHistory struct {

	// Applicable when this is not a guest account.
	//
	FirstUseOfShippingAddress bool `json:"firstUseOfShippingAddress,omitempty"`

	// Date when the shipping address for this transaction was first used.
	// Recommended for Discover ProtectBuy.
	// If `firstUseOfShippingAddress` is false and not a guest account, then this date is entered.
	//
	// Max Length: 10
	ShippingAddressUsageDate string `json:"shippingAddressUsageDate,omitempty"`
}

// Validate validates this create payment params body risk information buyer history account history
func (o *CreatePaymentParamsBodyRiskInformationBuyerHistoryAccountHistory) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateShippingAddressUsageDate(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyRiskInformationBuyerHistoryAccountHistory) validateShippingAddressUsageDate(formats strfmt.Registry) error {
	if swag.IsZero(o.ShippingAddressUsageDate) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"riskInformation"+"."+"buyerHistory"+"."+"accountHistory"+"."+"shippingAddressUsageDate", "body", o.ShippingAddressUsageDate, 10); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment params body risk information buyer history account history based on context it is used
func (o *CreatePaymentParamsBodyRiskInformationBuyerHistoryAccountHistory) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyRiskInformationBuyerHistoryAccountHistory) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyRiskInformationBuyerHistoryAccountHistory) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyRiskInformationBuyerHistoryAccountHistory
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyRiskInformationBuyerHistoryCustomerAccount create payment params body risk information buyer history customer account
swagger:model CreatePaymentParamsBodyRiskInformationBuyerHistoryCustomerAccount
*/
type CreatePaymentParamsBodyRiskInformationBuyerHistoryCustomerAccount struct {

	// Date the cardholder opened the account.
	// Recommended for Discover ProtectBuy.
	// This only applies for EXISTING_ACCOUNT in creationHistory.
	//
	// Max Length: 10
	CreateDate string `json:"createDate,omitempty"`

	// The values from the enum can be:
	// - GUEST
	// - NEW_ACCOUNT
	// - EXISTING_ACCOUNT
	//
	CreationHistory string `json:"creationHistory,omitempty"`

	// Date the cardholders account was last changed.
	// This includes changes to the billing or shipping address, new payment accounts or new users added.
	// Recommended for Discover ProtectBuy.
	//
	// Max Length: 10
	LastChangeDate string `json:"lastChangeDate,omitempty"`

	// This field is applicable only in case of EXISTING_ACCOUNT in creationHistory. Possible values:
	// - ACCOUNT_UPDATED_NOW
	// - ACCOUNT_UPDATED_PAST
	//
	ModificationHistory string `json:"modificationHistory,omitempty"`

	// Date the cardholder last changed or reset password on account.
	// Recommended for Discover ProtectBuy.
	// This only applies for PASSWORD_CHANGED_PAST in passwordHistory.
	//
	// Max Length: 10
	PasswordChangeDate string `json:"passwordChangeDate,omitempty"`

	// This only applies for EXISTING_ACCOUNT in creationHistory.
	// The values from the enum can be:
	// - PASSWORD_CHANGED_NOW
	// - PASSWORD_CHANGED_PAST
	// - PASSWORD_NEVER_CHANGED
	//
	PasswordHistory string `json:"passwordHistory,omitempty"`
}

// Validate validates this create payment params body risk information buyer history customer account
func (o *CreatePaymentParamsBodyRiskInformationBuyerHistoryCustomerAccount) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCreateDate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLastChangeDate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePasswordChangeDate(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyRiskInformationBuyerHistoryCustomerAccount) validateCreateDate(formats strfmt.Registry) error {
	if swag.IsZero(o.CreateDate) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"riskInformation"+"."+"buyerHistory"+"."+"customerAccount"+"."+"createDate", "body", o.CreateDate, 10); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyRiskInformationBuyerHistoryCustomerAccount) validateLastChangeDate(formats strfmt.Registry) error {
	if swag.IsZero(o.LastChangeDate) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"riskInformation"+"."+"buyerHistory"+"."+"customerAccount"+"."+"lastChangeDate", "body", o.LastChangeDate, 10); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyRiskInformationBuyerHistoryCustomerAccount) validatePasswordChangeDate(formats strfmt.Registry) error {
	if swag.IsZero(o.PasswordChangeDate) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"riskInformation"+"."+"buyerHistory"+"."+"customerAccount"+"."+"passwordChangeDate", "body", o.PasswordChangeDate, 10); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment params body risk information buyer history customer account based on context it is used
func (o *CreatePaymentParamsBodyRiskInformationBuyerHistoryCustomerAccount) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyRiskInformationBuyerHistoryCustomerAccount) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyRiskInformationBuyerHistoryCustomerAccount) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyRiskInformationBuyerHistoryCustomerAccount
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyRiskInformationProfile Identifies a risk profile.
swagger:model CreatePaymentParamsBodyRiskInformationProfile
*/
type CreatePaymentParamsBodyRiskInformationProfile struct {

	// Name of the active profile chosen by the profile selector. If no profile selector exists,
	// the default active profile is chosen.
	//
	// **Note** By default, your default profile is the active profile, or the Profile Selector chooses the active profile. Use this field
	// only if you want to specify the name of a different profile. The passed-in profile will then become the active profile.
	//
	// Max Length: 30
	Name string `json:"name,omitempty"`
}

// Validate validates this create payment params body risk information profile
func (o *CreatePaymentParamsBodyRiskInformationProfile) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyRiskInformationProfile) validateName(formats strfmt.Registry) error {
	if swag.IsZero(o.Name) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"riskInformation"+"."+"profile"+"."+"name", "body", o.Name, 30); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment params body risk information profile based on context it is used
func (o *CreatePaymentParamsBodyRiskInformationProfile) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyRiskInformationProfile) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyRiskInformationProfile) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyRiskInformationProfile
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyTokenInformation create payment params body token information
swagger:model CreatePaymentParamsBodyTokenInformation
*/
type CreatePaymentParamsBodyTokenInformation struct {

	// TMS Transient Token, 64 hexadecimal id value representing captured payment credentials (including Sensitive Authentication Data, e.g. CVV).
	//
	// Max Length: 64
	Jti string `json:"jti,omitempty"`

	// Indicates whether a payment network token associated with a TMS token should be used for authorization. This field can contain one of following values:
	//
	// - `ignore`: Use a tokenized card number for an authorization, even if the TMS token has an associated payment network token.
	// - `prefer`: (Default) Use an associated payment network token for an authorization if the TMS token has one; otherwise, use the tokenized card number.
	//
	NetworkTokenOption string `json:"networkTokenOption,omitempty"`

	// payment instrument
	PaymentInstrument *CreatePaymentParamsBodyTokenInformationPaymentInstrument `json:"paymentInstrument,omitempty"`

	// shipping address
	ShippingAddress *CreatePaymentParamsBodyTokenInformationShippingAddress `json:"shippingAddress,omitempty"`

	// Flex API Transient Token encoded as JWT (JSON Web Token), e.g. Flex microform or Unified Payment checkout result.
	//
	TransientTokenJwt string `json:"transientTokenJwt,omitempty"`
}

// Validate validates this create payment params body token information
func (o *CreatePaymentParamsBodyTokenInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateJti(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePaymentInstrument(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateShippingAddress(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyTokenInformation) validateJti(formats strfmt.Registry) error {
	if swag.IsZero(o.Jti) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"tokenInformation"+"."+"jti", "body", o.Jti, 64); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTokenInformation) validatePaymentInstrument(formats strfmt.Registry) error {
	if swag.IsZero(o.PaymentInstrument) { // not required
		return nil
	}

	if o.PaymentInstrument != nil {
		if err := o.PaymentInstrument.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "tokenInformation" + "." + "paymentInstrument")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "tokenInformation" + "." + "paymentInstrument")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyTokenInformation) validateShippingAddress(formats strfmt.Registry) error {
	if swag.IsZero(o.ShippingAddress) { // not required
		return nil
	}

	if o.ShippingAddress != nil {
		if err := o.ShippingAddress.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "tokenInformation" + "." + "shippingAddress")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "tokenInformation" + "." + "shippingAddress")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this create payment params body token information based on the context it is used
func (o *CreatePaymentParamsBodyTokenInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidatePaymentInstrument(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateShippingAddress(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyTokenInformation) contextValidatePaymentInstrument(ctx context.Context, formats strfmt.Registry) error {

	if o.PaymentInstrument != nil {
		if err := o.PaymentInstrument.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "tokenInformation" + "." + "paymentInstrument")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "tokenInformation" + "." + "paymentInstrument")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyTokenInformation) contextValidateShippingAddress(ctx context.Context, formats strfmt.Registry) error {

	if o.ShippingAddress != nil {
		if err := o.ShippingAddress.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "tokenInformation" + "." + "shippingAddress")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "tokenInformation" + "." + "shippingAddress")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyTokenInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyTokenInformation) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyTokenInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyTokenInformationPaymentInstrument create payment params body token information payment instrument
swagger:model CreatePaymentParamsBodyTokenInformationPaymentInstrument
*/
type CreatePaymentParamsBodyTokenInformationPaymentInstrument struct {

	// Flag that specifies if the Payment Instrument should be made the Customers default.
	// Possible values:
	// - true
	// - false : (default)
	//
	Default *bool `json:"default,omitempty"`
}

// Validate validates this create payment params body token information payment instrument
func (o *CreatePaymentParamsBodyTokenInformationPaymentInstrument) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this create payment params body token information payment instrument based on context it is used
func (o *CreatePaymentParamsBodyTokenInformationPaymentInstrument) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyTokenInformationPaymentInstrument) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyTokenInformationPaymentInstrument) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyTokenInformationPaymentInstrument
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyTokenInformationShippingAddress create payment params body token information shipping address
swagger:model CreatePaymentParamsBodyTokenInformationShippingAddress
*/
type CreatePaymentParamsBodyTokenInformationShippingAddress struct {

	// Flag that specifies if the Shipping Address should be made the Customers default.
	// Possible values:
	// - true
	// - false : (default)
	//
	Default *bool `json:"default,omitempty"`
}

// Validate validates this create payment params body token information shipping address
func (o *CreatePaymentParamsBodyTokenInformationShippingAddress) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this create payment params body token information shipping address based on context it is used
func (o *CreatePaymentParamsBodyTokenInformationShippingAddress) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyTokenInformationShippingAddress) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyTokenInformationShippingAddress) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyTokenInformationShippingAddress
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyTravelInformation create payment params body travel information
swagger:model CreatePaymentParamsBodyTravelInformation
*/
type CreatePaymentParamsBodyTravelInformation struct {

	// agency
	Agency *CreatePaymentParamsBodyTravelInformationAgency `json:"agency,omitempty"`

	// auto rental
	AutoRental *CreatePaymentParamsBodyTravelInformationAutoRental `json:"autoRental,omitempty"`

	// Duration of the auto rental or lodging rental.
	//
	// #### Auto rental
	// This field is supported for Visa, MasterCard, and American Express.
	// **Important** If this field is not included when the `processingInformation.industryDataType` is auto rental,
	// the transaction is declined.
	//
	// Max Length: 2
	Duration string `json:"duration,omitempty"`

	// lodging
	Lodging *CreatePaymentParamsBodyTravelInformationLodging `json:"lodging,omitempty"`

	// transit
	Transit *CreatePaymentParamsBodyTravelInformationTransit `json:"transit,omitempty"`
}

// Validate validates this create payment params body travel information
func (o *CreatePaymentParamsBodyTravelInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAgency(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAutoRental(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDuration(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLodging(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTransit(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyTravelInformation) validateAgency(formats strfmt.Registry) error {
	if swag.IsZero(o.Agency) { // not required
		return nil
	}

	if o.Agency != nil {
		if err := o.Agency.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "travelInformation" + "." + "agency")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "travelInformation" + "." + "agency")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformation) validateAutoRental(formats strfmt.Registry) error {
	if swag.IsZero(o.AutoRental) { // not required
		return nil
	}

	if o.AutoRental != nil {
		if err := o.AutoRental.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "travelInformation" + "." + "autoRental")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "travelInformation" + "." + "autoRental")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformation) validateDuration(formats strfmt.Registry) error {
	if swag.IsZero(o.Duration) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"duration", "body", o.Duration, 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformation) validateLodging(formats strfmt.Registry) error {
	if swag.IsZero(o.Lodging) { // not required
		return nil
	}

	if o.Lodging != nil {
		if err := o.Lodging.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "travelInformation" + "." + "lodging")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "travelInformation" + "." + "lodging")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformation) validateTransit(formats strfmt.Registry) error {
	if swag.IsZero(o.Transit) { // not required
		return nil
	}

	if o.Transit != nil {
		if err := o.Transit.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "travelInformation" + "." + "transit")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "travelInformation" + "." + "transit")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this create payment params body travel information based on the context it is used
func (o *CreatePaymentParamsBodyTravelInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateAgency(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateAutoRental(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateLodging(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateTransit(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyTravelInformation) contextValidateAgency(ctx context.Context, formats strfmt.Registry) error {

	if o.Agency != nil {
		if err := o.Agency.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "travelInformation" + "." + "agency")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "travelInformation" + "." + "agency")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformation) contextValidateAutoRental(ctx context.Context, formats strfmt.Registry) error {

	if o.AutoRental != nil {
		if err := o.AutoRental.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "travelInformation" + "." + "autoRental")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "travelInformation" + "." + "autoRental")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformation) contextValidateLodging(ctx context.Context, formats strfmt.Registry) error {

	if o.Lodging != nil {
		if err := o.Lodging.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "travelInformation" + "." + "lodging")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "travelInformation" + "." + "lodging")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformation) contextValidateTransit(ctx context.Context, formats strfmt.Registry) error {

	if o.Transit != nil {
		if err := o.Transit.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "travelInformation" + "." + "transit")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "travelInformation" + "." + "transit")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyTravelInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyTravelInformation) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyTravelInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyTravelInformationAgency create payment params body travel information agency
swagger:model CreatePaymentParamsBodyTravelInformationAgency
*/
type CreatePaymentParamsBodyTravelInformationAgency struct {

	// International Air Transport Association (IATA) code of travel agency that made the vehicle rental reservation.
	//
	// Max Length: 8
	Code string `json:"code,omitempty"`

	// Name of travel agency that made the reservation.
	//
	// Max Length: 25
	Name string `json:"name,omitempty"`
}

// Validate validates this create payment params body travel information agency
func (o *CreatePaymentParamsBodyTravelInformationAgency) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationAgency) validateCode(formats strfmt.Registry) error {
	if swag.IsZero(o.Code) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"agency"+"."+"code", "body", o.Code, 8); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationAgency) validateName(formats strfmt.Registry) error {
	if swag.IsZero(o.Name) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"agency"+"."+"name", "body", o.Name, 25); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment params body travel information agency based on context it is used
func (o *CreatePaymentParamsBodyTravelInformationAgency) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyTravelInformationAgency) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyTravelInformationAgency) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyTravelInformationAgency
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyTravelInformationAutoRental create payment params body travel information auto rental
swagger:model CreatePaymentParamsBodyTravelInformationAutoRental
*/
type CreatePaymentParamsBodyTravelInformationAutoRental struct {

	// Adjusted Amount indicates whether any miscellaneous charges were incurred after the vehicle was returned.
	//
	// For authorizations, this field is supported only for American Express.
	//
	// For captures, this field is supported only for MasterCard and American Express.
	// **NOTE** For American Express, this field is required if the `travelInformation.autoRental.adjustedAmountIndicator` field
	// is included in the request and has a value; otherwise, this field is optional.
	//
	// For all other card types, this field is ignored.
	//
	// Max Length: 12
	AdjustedAmount string `json:"adjustedAmount,omitempty"`

	// For **MasterCard** and **Discover**:
	// Adjusted amount indicator code that indicates
	// any miscellaneous charges incurred after the
	// auto was returned. Possible values:
	// - `A` - Drop-off charges
	// - `B` - Delivery charges
	// - `C` - Parking expenses
	// - `D` - Extra hours
	// - `E` - Violations
	// - `X` - More than one of the above charges
	//
	// For **American Express**:
	// Audit indicator code that indicates any
	// adjustment for mileage, fuel, auto damage,
	// etc. made to a rental agreement and whether
	// the cardholder was notified.
	//
	// Possible value for the authorization service:
	// - `A` (default): adjustment amount greater than 0 (zero)
	//
	// Possible values for the capture service:
	// - `X` - Multiple adjustments
	// - `Y` - One adjustment only; Cardmember notified
	// - `Z` - One adjustment only; Cardmember not notified. This value is used as the default if the request does not include this field and includes an adjustment amount greater than 0 (zero).
	// This is an optional field.
	//
	// Max Length: 1
	AdjustedAmountIndicator string `json:"adjustedAmountIndicator,omitempty"`

	// Auto rental agencys agreement (invoice) number provided to the customer. It is used to trace any inquiries about transactions.
	// This field is supported for Visa, MasterCard, and American Express.
	// This Merchant-defined value, which may be composed of any combination of characters and/or numerals, may become
	// part of the descriptive bill on the Cardmember's statement.
	//
	// Max Length: 25
	AgreementNumber string `json:"agreementNumber,omitempty"`

	// Commodity code or International description code used to classify the item. Contact your acquirer for a list of
	// codes.
	//
	// Max Length: 15
	CommodityCode string `json:"commodityCode,omitempty"`

	// Corporate Identifier provides the unique identifier of the corporation or entity renting the vehicle:
	//
	// |Card Specific Validation|VISA|MasterCard|Discover|AMEX|
	// |--- |--- |--- |--- |
	// | Filed Length| NA| 12| NA| NA|
	// | Field Type| NA| AN| NA| NA|
	// | M/O/C| NA| O| NA| NA|
	//
	// Max Length: 12
	CompanyID string `json:"companyId,omitempty"`

	// Name of the individual making the rental agreement.
	//
	// Valid data lengths by card:
	//
	// |Card Specific Validation|VISA|MasterCard|Discover|AMEX|
	// |--- |--- |--- |--- |
	// | Filed Length| 40| 40| 29| 26|
	// | Field Type| AN| ANS| AN| AN|
	// | M/O/C| O| M| M| M|
	//
	// Max Length: 40
	CustomerName string `json:"customerName,omitempty"`

	// Customer service telephone number that is used to resolve questions or disputes. Include the area code, exchange, and number.
	// This field is supported only for MasterCard and American Express.
	//
	// Max Length: 17
	CustomerServicePhoneNumber string `json:"customerServicePhoneNumber,omitempty"`

	// Daily auto rental rate charged.
	// This field is supported only for MasterCard and American Express.
	//
	// Field - Time Period needs to be populated with Daily if this field is present
	//
	// Max Length: 12
	DailyRentalRate string `json:"dailyRentalRate,omitempty"`

	// Total number of miles driven by the customer.
	// This field is supported only for MasterCard and American Express.
	//
	// Max Length: 5
	DistanceTravelled string `json:"distanceTravelled,omitempty"`

	// Miles/Kilometers Indicator shows whether the miles fields are expressed in miles or kilometers.
	//
	// Allowed values:
	// - `K` - Kilometers
	// - `M` - Miles
	//
	// Max Length: 1
	DistanceUnit string `json:"distanceUnit,omitempty"`

	// Age of the driver renting the vehicle.
	//
	// Max Length: 3
	DriverAge string `json:"driverAge,omitempty"`

	// (Extra Charges) provides the extra charges associated with the vehicle rental.
	//
	// Max Length: 12
	ExtraCharge string `json:"extraCharge,omitempty"`

	// Extra mileage charges that extend beyond the basic rental agreement.
	// This field is supported only for Visa.
	//
	// Max Length: 12
	ExtraMileageCharge string `json:"extraMileageCharge,omitempty"`

	// Extra gasoline charges that extend beyond the basic rental agreement.
	// This field is supported only for Visa.
	//
	// Max Length: 12
	FuelCharges string `json:"fuelCharges,omitempty"`

	// Amount charged for renting a Global Positioning Service (GPS).
	//
	// Max Length: 12
	GpsCharge string `json:"gpsCharge,omitempty"`

	// Insurance charges.
	// Field is conditional and can include decimal point.
	//
	// Max Length: 12
	InsuranceAmount string `json:"insuranceAmount,omitempty"`

	// Used for MC and Discover
	//
	// Valid values:
	// - `true` - Yes (insurance was purchased)
	// - `false` - No (insurance was not purchased)
	//
	InsuranceIndicator bool `json:"insuranceIndicator,omitempty"`

	// Extra charges related to a late return of the rented auto.
	// This field is supported only for Visa.
	//
	// Max Length: 12
	LateFeeAmount string `json:"lateFeeAmount,omitempty"`

	// Maximum number of free miles or kilometers allowed to a customer for the duration of the auto rental agreement.
	// This field is supported only for MasterCard and American Express.
	//
	// Max Length: 4
	MaxFreeDistance string `json:"maxFreeDistance,omitempty"`

	// Regular Mileage Charge provides the amount charged for regular miles traveled during vehicle rental. Two decimal places
	//
	// Max Length: 12
	MileageCharge string `json:"mileageCharge,omitempty"`

	// No Show Indicator provides an indicator noting that the individual did not show up after making a reservation for a vehicle.
	// Possible values:
	// - true
	// - false
	//
	NoShowIndicator bool `json:"noShowIndicator,omitempty"`

	// The number of additional drivers included on the rental agreement not including the individual who signed the rental agreement.
	//
	// Max Length: 1
	NumberOfAdditionalDrivers string `json:"numberOfAdditionalDrivers,omitempty"`

	// Odometer reading at time of vehicle rental.
	//
	// Max Length: 8
	OdometerReading string `json:"odometerReading,omitempty"`

	// Extra charges incurred for a one-way rental agreement for the auto.
	// This field is supported only for Visa.
	//
	// Max Length: 12
	OneWayDropOffAmount string `json:"oneWayDropOffAmount,omitempty"`

	// Total amount charged for all other miscellaneous charges not previously defined.
	//
	// Max Length: 12
	OtherCharges string `json:"otherCharges,omitempty"`

	// Extra charges incurred due to a parking violation for the auto.
	// This field is supported only for Visa.
	//
	// Max Length: 12
	ParkingViolationCharge string `json:"parkingViolationCharge,omitempty"`

	// Additional charges incurred for phone usage included on the total bill.
	//
	// Max Length: 12
	PhoneCharge string `json:"phoneCharge,omitempty"`

	// Used to identify special circumstances applicable to the Card Transaction or Cardholder, such as "renter or show.
	//
	// This code is `2 digit` value agreed by Merchant and processor.
	//
	// Max Length: 2
	ProgramCode string `json:"programCode,omitempty"`

	// Rate charged for each mile.
	// This field is supported only for MasterCard and American Express.
	//
	// Max Length: 12
	RatePerMile string `json:"ratePerMile,omitempty"`

	// rental address
	RentalAddress *CreatePaymentParamsBodyTravelInformationAutoRentalRentalAddress `json:"rentalAddress,omitempty"`

	// Date/time the auto was picked up from the rental agency.
	// Format: `yyyy-MM-dd HH-mm-ss z`
	// This field is supported for Visa, MasterCard, and American Express.
	//
	// Max Length: 21
	RentalDateTime string `json:"rentalDateTime,omitempty"`

	// return address
	ReturnAddress *CreatePaymentParamsBodyTravelInformationAutoRentalReturnAddress `json:"returnAddress,omitempty"`

	// Date/time the auto was returned to the rental agency.
	// Format: ``yyyy-MM-dd HH-mm-ss z``
	// This field is supported for Visa, MasterCard, and American Express.
	//
	// Max Length: 21
	ReturnDateTime string `json:"returnDateTime,omitempty"`

	// Program code used to identify special circumstances, such as frequent renter or no show status for the renter.
	// Possible values:
	// - `0`: not applicable (default)
	// - `1`: frequent renter
	// - `2`: no show
	//
	// For authorizations, this field is supported only for Visa.
	//
	// For captures, this field is supported for Visa, MasterCard, and American Express.
	//
	// Code for special programs applicable to the Card Transaction or the Cardholder.
	//
	// Max Length: 2
	SpecialProgramCode string `json:"specialProgramCode,omitempty"`

	// tax details
	TaxDetails *CreatePaymentParamsBodyTravelInformationAutoRentalTaxDetails `json:"taxDetails,omitempty"`

	// Indicates the time period for which the vehicle rental rate applies (e.g., daily, weekly or monthly). Daily, Weekly and Monthly are valid values.
	//
	// Max Length: 7
	TimePeriod string `json:"timePeriod,omitempty"`

	// (Towing Charges) provides the amount charged to tow the rental vehicle.
	//
	// Max Length: 4
	TowingCharge string `json:"towingCharge,omitempty"`

	// Classification of the rented auto.
	//
	// **NOTE** For VISA, this is a 2-byte optional code.
	//
	// Valid values for American Express & MasterCard:
	//
	// |American Express |MasterCard |Description|
	// |--- |--- |--- |
	// | 0001| 0001| Mini|
	// | 0002| 0002| Subcompact|
	// | 0003| 0003| Economy|
	// | 0004| 0004| Compact|
	// | 0005| 0005| Midsize|
	// | 0006| 0006| Intermediate|
	// | 0007| 0007| Standard|
	// | 0008| 0008| Fulll size|
	// | 0009| 0009| Luxury|
	// | 0010| 0010| Premium|
	// | 0011| 0011| Minivan|
	// | 0012| 0012| 12-passenger van|
	// | 0013| 0013| Moving van|
	// | 0014| 0014| 15-passenger van|
	// | 0015| 0015| Cargo van|
	// | 0016| 0016| 12-foot truck|
	// | 0017| 0017| 20-foot truck|
	// | 0018| 0018| 24-foot truck|
	// | 0019| 0019| 26-foot truck|
	// | 0020| 0020| Moped|
	// | 0021| 0021| Stretch|
	// | 0022| 0022| Regular|
	// | 0023| 0023| Unique|
	// | 0024| 0024| Exotic|
	// | 0025| 0025| Small/medium truck|
	// | 0026| 0026| Large truck|
	// | 0027| 0027| Small SUV|
	// | 0028| 0028| Medium SUV|
	// | 0029| 0029| Large SUV|
	// | 0030| 0030| Exotic SUV|
	// | 9999| 9999| Miscellaneous|
	//
	// Additional Values allowed **only** for `American Express`:
	//
	// |American Express|MasterCard|Description|
	// |--- |--- |--- |
	// | 0031| NA| Four Wheel Drive|
	// | 0032| NA| Special|
	// | 0099| NA| Taxi|
	//
	// Max Length: 4
	VehicleClass string `json:"vehicleClass,omitempty"`

	// This field contains a unique identifier assigned by the company to the vehicle.
	//
	// Max Length: 20
	VehicleIdentificationNumber string `json:"vehicleIdentificationNumber,omitempty"`

	// Make of the vehicle being rented (e.g., Chevrolet or Ford).
	//
	// Max Length: 10
	VehicleMake string `json:"vehicleMake,omitempty"`

	// Model of the vehicle being rented (e.g., Cavalier or Focus).
	//
	// Max Length: 10
	VehicleModel string `json:"vehicleModel,omitempty"`

	// Weekly Rental Amount provides the amount charged for a seven-day rental period. Field - Time Period needs to be populated with Weekly if this field is present
	//
	// Max Length: 12
	WeeklyRentalRate string `json:"weeklyRentalRate,omitempty"`
}

// Validate validates this create payment params body travel information auto rental
func (o *CreatePaymentParamsBodyTravelInformationAutoRental) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAdjustedAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAdjustedAmountIndicator(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAgreementNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCommodityCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCompanyID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCustomerName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCustomerServicePhoneNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDailyRentalRate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDistanceTravelled(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDistanceUnit(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDriverAge(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExtraCharge(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExtraMileageCharge(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFuelCharges(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateGpsCharge(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateInsuranceAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLateFeeAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMaxFreeDistance(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMileageCharge(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNumberOfAdditionalDrivers(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOdometerReading(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOneWayDropOffAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOtherCharges(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateParkingViolationCharge(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePhoneCharge(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProgramCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRatePerMile(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRentalAddress(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRentalDateTime(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateReturnAddress(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateReturnDateTime(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSpecialProgramCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTimePeriod(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTowingCharge(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateVehicleClass(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateVehicleIdentificationNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateVehicleMake(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateVehicleModel(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateWeeklyRentalRate(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationAutoRental) validateAdjustedAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.AdjustedAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"adjustedAmount", "body", o.AdjustedAmount, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationAutoRental) validateAdjustedAmountIndicator(formats strfmt.Registry) error {
	if swag.IsZero(o.AdjustedAmountIndicator) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"adjustedAmountIndicator", "body", o.AdjustedAmountIndicator, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationAutoRental) validateAgreementNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.AgreementNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"agreementNumber", "body", o.AgreementNumber, 25); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationAutoRental) validateCommodityCode(formats strfmt.Registry) error {
	if swag.IsZero(o.CommodityCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"commodityCode", "body", o.CommodityCode, 15); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationAutoRental) validateCompanyID(formats strfmt.Registry) error {
	if swag.IsZero(o.CompanyID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"companyId", "body", o.CompanyID, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationAutoRental) validateCustomerName(formats strfmt.Registry) error {
	if swag.IsZero(o.CustomerName) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"customerName", "body", o.CustomerName, 40); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationAutoRental) validateCustomerServicePhoneNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.CustomerServicePhoneNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"customerServicePhoneNumber", "body", o.CustomerServicePhoneNumber, 17); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationAutoRental) validateDailyRentalRate(formats strfmt.Registry) error {
	if swag.IsZero(o.DailyRentalRate) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"dailyRentalRate", "body", o.DailyRentalRate, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationAutoRental) validateDistanceTravelled(formats strfmt.Registry) error {
	if swag.IsZero(o.DistanceTravelled) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"distanceTravelled", "body", o.DistanceTravelled, 5); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationAutoRental) validateDistanceUnit(formats strfmt.Registry) error {
	if swag.IsZero(o.DistanceUnit) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"distanceUnit", "body", o.DistanceUnit, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationAutoRental) validateDriverAge(formats strfmt.Registry) error {
	if swag.IsZero(o.DriverAge) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"driverAge", "body", o.DriverAge, 3); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationAutoRental) validateExtraCharge(formats strfmt.Registry) error {
	if swag.IsZero(o.ExtraCharge) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"extraCharge", "body", o.ExtraCharge, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationAutoRental) validateExtraMileageCharge(formats strfmt.Registry) error {
	if swag.IsZero(o.ExtraMileageCharge) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"extraMileageCharge", "body", o.ExtraMileageCharge, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationAutoRental) validateFuelCharges(formats strfmt.Registry) error {
	if swag.IsZero(o.FuelCharges) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"fuelCharges", "body", o.FuelCharges, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationAutoRental) validateGpsCharge(formats strfmt.Registry) error {
	if swag.IsZero(o.GpsCharge) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"gpsCharge", "body", o.GpsCharge, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationAutoRental) validateInsuranceAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.InsuranceAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"insuranceAmount", "body", o.InsuranceAmount, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationAutoRental) validateLateFeeAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.LateFeeAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"lateFeeAmount", "body", o.LateFeeAmount, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationAutoRental) validateMaxFreeDistance(formats strfmt.Registry) error {
	if swag.IsZero(o.MaxFreeDistance) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"maxFreeDistance", "body", o.MaxFreeDistance, 4); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationAutoRental) validateMileageCharge(formats strfmt.Registry) error {
	if swag.IsZero(o.MileageCharge) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"mileageCharge", "body", o.MileageCharge, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationAutoRental) validateNumberOfAdditionalDrivers(formats strfmt.Registry) error {
	if swag.IsZero(o.NumberOfAdditionalDrivers) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"numberOfAdditionalDrivers", "body", o.NumberOfAdditionalDrivers, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationAutoRental) validateOdometerReading(formats strfmt.Registry) error {
	if swag.IsZero(o.OdometerReading) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"odometerReading", "body", o.OdometerReading, 8); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationAutoRental) validateOneWayDropOffAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.OneWayDropOffAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"oneWayDropOffAmount", "body", o.OneWayDropOffAmount, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationAutoRental) validateOtherCharges(formats strfmt.Registry) error {
	if swag.IsZero(o.OtherCharges) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"otherCharges", "body", o.OtherCharges, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationAutoRental) validateParkingViolationCharge(formats strfmt.Registry) error {
	if swag.IsZero(o.ParkingViolationCharge) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"parkingViolationCharge", "body", o.ParkingViolationCharge, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationAutoRental) validatePhoneCharge(formats strfmt.Registry) error {
	if swag.IsZero(o.PhoneCharge) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"phoneCharge", "body", o.PhoneCharge, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationAutoRental) validateProgramCode(formats strfmt.Registry) error {
	if swag.IsZero(o.ProgramCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"programCode", "body", o.ProgramCode, 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationAutoRental) validateRatePerMile(formats strfmt.Registry) error {
	if swag.IsZero(o.RatePerMile) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"ratePerMile", "body", o.RatePerMile, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationAutoRental) validateRentalAddress(formats strfmt.Registry) error {
	if swag.IsZero(o.RentalAddress) { // not required
		return nil
	}

	if o.RentalAddress != nil {
		if err := o.RentalAddress.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "travelInformation" + "." + "autoRental" + "." + "rentalAddress")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "travelInformation" + "." + "autoRental" + "." + "rentalAddress")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationAutoRental) validateRentalDateTime(formats strfmt.Registry) error {
	if swag.IsZero(o.RentalDateTime) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"rentalDateTime", "body", o.RentalDateTime, 21); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationAutoRental) validateReturnAddress(formats strfmt.Registry) error {
	if swag.IsZero(o.ReturnAddress) { // not required
		return nil
	}

	if o.ReturnAddress != nil {
		if err := o.ReturnAddress.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "travelInformation" + "." + "autoRental" + "." + "returnAddress")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "travelInformation" + "." + "autoRental" + "." + "returnAddress")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationAutoRental) validateReturnDateTime(formats strfmt.Registry) error {
	if swag.IsZero(o.ReturnDateTime) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"returnDateTime", "body", o.ReturnDateTime, 21); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationAutoRental) validateSpecialProgramCode(formats strfmt.Registry) error {
	if swag.IsZero(o.SpecialProgramCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"specialProgramCode", "body", o.SpecialProgramCode, 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationAutoRental) validateTaxDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.TaxDetails) { // not required
		return nil
	}

	if o.TaxDetails != nil {
		if err := o.TaxDetails.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "travelInformation" + "." + "autoRental" + "." + "taxDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "travelInformation" + "." + "autoRental" + "." + "taxDetails")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationAutoRental) validateTimePeriod(formats strfmt.Registry) error {
	if swag.IsZero(o.TimePeriod) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"timePeriod", "body", o.TimePeriod, 7); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationAutoRental) validateTowingCharge(formats strfmt.Registry) error {
	if swag.IsZero(o.TowingCharge) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"towingCharge", "body", o.TowingCharge, 4); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationAutoRental) validateVehicleClass(formats strfmt.Registry) error {
	if swag.IsZero(o.VehicleClass) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"vehicleClass", "body", o.VehicleClass, 4); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationAutoRental) validateVehicleIdentificationNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.VehicleIdentificationNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"vehicleIdentificationNumber", "body", o.VehicleIdentificationNumber, 20); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationAutoRental) validateVehicleMake(formats strfmt.Registry) error {
	if swag.IsZero(o.VehicleMake) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"vehicleMake", "body", o.VehicleMake, 10); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationAutoRental) validateVehicleModel(formats strfmt.Registry) error {
	if swag.IsZero(o.VehicleModel) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"vehicleModel", "body", o.VehicleModel, 10); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationAutoRental) validateWeeklyRentalRate(formats strfmt.Registry) error {
	if swag.IsZero(o.WeeklyRentalRate) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"weeklyRentalRate", "body", o.WeeklyRentalRate, 12); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this create payment params body travel information auto rental based on the context it is used
func (o *CreatePaymentParamsBodyTravelInformationAutoRental) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateRentalAddress(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateReturnAddress(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateTaxDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationAutoRental) contextValidateRentalAddress(ctx context.Context, formats strfmt.Registry) error {

	if o.RentalAddress != nil {
		if err := o.RentalAddress.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "travelInformation" + "." + "autoRental" + "." + "rentalAddress")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "travelInformation" + "." + "autoRental" + "." + "rentalAddress")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationAutoRental) contextValidateReturnAddress(ctx context.Context, formats strfmt.Registry) error {

	if o.ReturnAddress != nil {
		if err := o.ReturnAddress.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "travelInformation" + "." + "autoRental" + "." + "returnAddress")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "travelInformation" + "." + "autoRental" + "." + "returnAddress")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationAutoRental) contextValidateTaxDetails(ctx context.Context, formats strfmt.Registry) error {

	if o.TaxDetails != nil {
		if err := o.TaxDetails.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "travelInformation" + "." + "autoRental" + "." + "taxDetails")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "travelInformation" + "." + "autoRental" + "." + "taxDetails")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyTravelInformationAutoRental) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyTravelInformationAutoRental) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyTravelInformationAutoRental
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyTravelInformationAutoRentalRentalAddress create payment params body travel information auto rental rental address
swagger:model CreatePaymentParamsBodyTravelInformationAutoRentalRentalAddress
*/
type CreatePaymentParamsBodyTravelInformationAutoRentalRentalAddress struct {

	// Address from where the vehicle was rented.
	//
	// Max Length: 13
	Address1 string `json:"address1,omitempty"`

	// Address from where the vehicle was rented.
	//
	// Max Length: 13
	Address2 string `json:"address2,omitempty"`

	// City in which the auto was rented.
	//
	// For authorizations, this field is supported for Visa, MasterCard, and American Express.
	//
	// For captures, this field is supported only for American Express.
	//
	// For all other card types, this field is ignored.
	//
	// Max Length: 25
	City string `json:"city,omitempty"`

	// Country where the auto was rented. Use the [ISO Standard Country Codes.](https://developer.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf)
	// This field is supported only for American Express.
	//
	// Max Length: 3
	Country string `json:"country,omitempty"`

	// This field contains the location where a taxi passenger was picked up or where an auto rental vehicle was picked up. In most cases, this is the rental agency's business name that appears on the storefront and/or customer receipts, commonly referred to as the DBA (Doing Business As) name. However, if the vehicle was picked up at another location (e.g., a hotel,auto dealership, repair shop, etc.), the name of that location should be used. This entry must be easily recognized by the Cardmember to avoid unnecessary inquiries. If the name is more than 38  characters, use proper and meaningful abbreviation, when possible.
	//
	// Max Length: 38
	Location string `json:"location,omitempty"`

	// The agency code, address, phone number, etc., used to identify the location where the vehicle was rented.
	//
	// Max Length: 10
	LocationID string `json:"locationId,omitempty"`

	// State in which the auto was rented. Use the [State, Province, and Territory Codes for the United States and Canada](https://developer.cybersource.com/library/documentation/sbc/quickref/states_and_provinces.pdf).
	//
	// Max Length: 3
	State string `json:"state,omitempty"`
}

// Validate validates this create payment params body travel information auto rental rental address
func (o *CreatePaymentParamsBodyTravelInformationAutoRentalRentalAddress) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAddress1(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAddress2(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCity(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocationID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateState(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationAutoRentalRentalAddress) validateAddress1(formats strfmt.Registry) error {
	if swag.IsZero(o.Address1) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"rentalAddress"+"."+"address1", "body", o.Address1, 13); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationAutoRentalRentalAddress) validateAddress2(formats strfmt.Registry) error {
	if swag.IsZero(o.Address2) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"rentalAddress"+"."+"address2", "body", o.Address2, 13); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationAutoRentalRentalAddress) validateCity(formats strfmt.Registry) error {
	if swag.IsZero(o.City) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"rentalAddress"+"."+"city", "body", o.City, 25); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationAutoRentalRentalAddress) validateCountry(formats strfmt.Registry) error {
	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"rentalAddress"+"."+"country", "body", o.Country, 3); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationAutoRentalRentalAddress) validateLocation(formats strfmt.Registry) error {
	if swag.IsZero(o.Location) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"rentalAddress"+"."+"location", "body", o.Location, 38); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationAutoRentalRentalAddress) validateLocationID(formats strfmt.Registry) error {
	if swag.IsZero(o.LocationID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"rentalAddress"+"."+"locationId", "body", o.LocationID, 10); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationAutoRentalRentalAddress) validateState(formats strfmt.Registry) error {
	if swag.IsZero(o.State) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"rentalAddress"+"."+"state", "body", o.State, 3); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment params body travel information auto rental rental address based on context it is used
func (o *CreatePaymentParamsBodyTravelInformationAutoRentalRentalAddress) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyTravelInformationAutoRentalRentalAddress) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyTravelInformationAutoRentalRentalAddress) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyTravelInformationAutoRentalRentalAddress
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyTravelInformationAutoRentalReturnAddress create payment params body travel information auto rental return address
swagger:model CreatePaymentParamsBodyTravelInformationAutoRentalReturnAddress
*/
type CreatePaymentParamsBodyTravelInformationAutoRentalReturnAddress struct {

	// City where the auto was returned to the rental agency.
	//
	// Max Length: 25
	City string `json:"city,omitempty"`

	// Country where the auto was returned to the rental agency. Use the [ISO Standard Country Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf).
	//
	// Max Length: 3
	Country string `json:"country,omitempty"`

	// This field contains the location where the taxi passenger was dropped off or where the auto rental vehicle was returned.
	//
	// Max Length: 38
	Location string `json:"location,omitempty"`

	// Code, address, phone number, etc. used to identify the location of the auto rental return.
	// This field is supported only for MasterCard and American Express.
	//
	// Max Length: 10
	LocationID string `json:"locationId,omitempty"`

	// State in which the auto was returned to the rental agency. Use the [State, Province, and Territory Codes for the United States and Canada](https://developer.cybersource.com/library/documentation/sbc/quickref/states_and_provinces.pdf).
	//
	// For authorizations, this field is supported for Visa, MasterCard, and American Express.
	//
	// For captures, this field is supported only for MasterCard and American Express.
	//
	// Max Length: 3
	State string `json:"state,omitempty"`
}

// Validate validates this create payment params body travel information auto rental return address
func (o *CreatePaymentParamsBodyTravelInformationAutoRentalReturnAddress) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCity(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocationID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateState(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationAutoRentalReturnAddress) validateCity(formats strfmt.Registry) error {
	if swag.IsZero(o.City) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"returnAddress"+"."+"city", "body", o.City, 25); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationAutoRentalReturnAddress) validateCountry(formats strfmt.Registry) error {
	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"returnAddress"+"."+"country", "body", o.Country, 3); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationAutoRentalReturnAddress) validateLocation(formats strfmt.Registry) error {
	if swag.IsZero(o.Location) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"returnAddress"+"."+"location", "body", o.Location, 38); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationAutoRentalReturnAddress) validateLocationID(formats strfmt.Registry) error {
	if swag.IsZero(o.LocationID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"returnAddress"+"."+"locationId", "body", o.LocationID, 10); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationAutoRentalReturnAddress) validateState(formats strfmt.Registry) error {
	if swag.IsZero(o.State) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"returnAddress"+"."+"state", "body", o.State, 3); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment params body travel information auto rental return address based on context it is used
func (o *CreatePaymentParamsBodyTravelInformationAutoRentalReturnAddress) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyTravelInformationAutoRentalReturnAddress) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyTravelInformationAutoRentalReturnAddress) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyTravelInformationAutoRentalReturnAddress
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyTravelInformationAutoRentalTaxDetails create payment params body travel information auto rental tax details
swagger:model CreatePaymentParamsBodyTravelInformationAutoRentalTaxDetails
*/
type CreatePaymentParamsBodyTravelInformationAutoRentalTaxDetails struct {

	// Indicates the amount of tax based on the `type` field as described in the table below:
	//
	// Max Length: 13
	Amount string `json:"amount,omitempty"`

	// Flag that indicates whether the tax amount (`travelInformation.autoRental.taxDetails.amount`) is
	// included in the request.
	//
	// Possible values:
	// - `false`: tax amount is not included in the request.
	// - `true`:  tax amount is included in the request.
	//
	Applied bool `json:"applied,omitempty"`

	// Status code for exemption from sales and use tax. This field is a pass-through, which means that
	// CyberSource does not verify the value or modify it in any way before sending it to the processor.
	//
	// Max Length: 1
	ExemptionCode string `json:"exemptionCode,omitempty"`

	// Rate of VAT or other tax for the order.
	//
	// Example 0.040 (=4%)
	//
	// Valid range: 0.01 to 0.99 (1% to 99%, with only whole percentage values accepted; values with additional
	// decimal places will be truncated)
	//
	// Max Length: 6
	Rate string `json:"rate,omitempty"`

	// Summary of all tax types
	//
	// Max Length: 12
	TaxSummary string `json:"taxSummary,omitempty"`

	// Different taxes the rental agency applies to the rental agreement such as tourist tax, airport tax, or rental tax.
	//
	// Max Length: 10
	TaxType string `json:"taxType,omitempty"`
}

// Validate validates this create payment params body travel information auto rental tax details
func (o *CreatePaymentParamsBodyTravelInformationAutoRentalTaxDetails) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExemptionCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxSummary(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationAutoRentalTaxDetails) validateAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.Amount) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"taxDetails"+"."+"amount", "body", o.Amount, 13); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationAutoRentalTaxDetails) validateExemptionCode(formats strfmt.Registry) error {
	if swag.IsZero(o.ExemptionCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"taxDetails"+"."+"exemptionCode", "body", o.ExemptionCode, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationAutoRentalTaxDetails) validateRate(formats strfmt.Registry) error {
	if swag.IsZero(o.Rate) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"taxDetails"+"."+"rate", "body", o.Rate, 6); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationAutoRentalTaxDetails) validateTaxSummary(formats strfmt.Registry) error {
	if swag.IsZero(o.TaxSummary) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"taxDetails"+"."+"taxSummary", "body", o.TaxSummary, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationAutoRentalTaxDetails) validateTaxType(formats strfmt.Registry) error {
	if swag.IsZero(o.TaxType) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"autoRental"+"."+"taxDetails"+"."+"taxType", "body", o.TaxType, 10); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment params body travel information auto rental tax details based on context it is used
func (o *CreatePaymentParamsBodyTravelInformationAutoRentalTaxDetails) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyTravelInformationAutoRentalTaxDetails) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyTravelInformationAutoRentalTaxDetails) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyTravelInformationAutoRentalTaxDetails
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyTravelInformationLodging create payment params body travel information lodging
swagger:model CreatePaymentParamsBodyTravelInformationLodging
*/
type CreatePaymentParamsBodyTravelInformationLodging struct {

	// Amount of an additional coupon or discount.
	//
	// Max Length: 12
	AdditionalDiscountAmount string `json:"additionalDiscountAmount,omitempty"`

	// Adjusted amount charged in addition to the reservation amount after the stay is complete.
	//
	// Max Length: 12
	AdjustmentAmount string `json:"adjustmentAmount,omitempty"`

	// Cost of audio visual services.
	//
	// Max Length: 12
	AudioVisualCost string `json:"audioVisualCost,omitempty"`

	// Cost of banquet services.
	//
	// Max Length: 12
	BanquestCost string `json:"banquestCost,omitempty"`

	// Cost of business center services.
	//
	// Max Length: 12
	BusinessCenterCost string `json:"businessCenterCost,omitempty"`

	// Cost of the cash that was disbursed plus any associated service fees
	//
	// Max Length: 12
	CashDisbursementCost string `json:"cashDisbursementCost,omitempty"`

	// Date on which the guest checked in. In the case of a no-show or a reservation, the scheduled arrival date.
	// Format: `MMDDYY`. For best interchange rates, make sure it is a valid date.
	//
	// Max Length: 6
	CheckInDate string `json:"checkInDate,omitempty"`

	// Date on which the guest checked out.
	// Format: `MMDDYY`. For best interchange rates, make sure it is a valid date.
	//
	// Max Length: 6
	CheckOutDate string `json:"checkOutDate,omitempty"`

	// Cost of conference room services.
	//
	// Max Length: 12
	ConferenceRoomCost string `json:"conferenceRoomCost,omitempty"`

	// Code assigned to a business. You can use this code to identify corporate rates and discounts for guests.
	//
	// Max Length: 17
	CorporateClientCode string `json:"corporateClientCode,omitempty"`

	// Your toll-free customer service phone number.
	//
	// Max Length: 17
	CustomerServicePhoneNumber string `json:"customerServicePhoneNumber,omitempty"`

	// Service fee for early departure.
	//
	// Max Length: 12
	EarlyCheckOutCost string `json:"earlyCheckOutCost,omitempty"`

	// Cost for all food and beverages.
	//
	// Max Length: 12
	FoodAndBeverageCost string `json:"foodAndBeverageCost,omitempty"`

	// Cost of gift shop purchases.
	//
	// Max Length: 12
	GiftShopCost string `json:"giftShopCost,omitempty"`

	// Gratuity.
	//
	// Max Length: 12
	GratuityAmount string `json:"gratuityAmount,omitempty"`

	// Name of the guest under which the room is reserved.
	//
	// Max Length: 40
	GuestName string `json:"guestName,omitempty"`

	// Cost of health club services.
	//
	// Max Length: 12
	HealthClubCost string `json:"healthClubCost,omitempty"`

	// Cost of Internet access.
	//
	// Max Length: 12
	InternetAccessCost string `json:"internetAccessCost,omitempty"`

	// Cost of laundry services.
	//
	// Max Length: 12
	LaundryCost string `json:"laundryCost,omitempty"`

	// Cost of lounge and bar purchases.
	//
	// Max Length: 12
	LoungeBarCost string `json:"loungeBarCost,omitempty"`

	// Cost of mini-bar purchases.
	//
	// Max Length: 12
	MiniBarCost string `json:"miniBarCost,omitempty"`

	// Miscellaneous costs.
	//
	// Max Length: 12
	MiscellaneousCost string `json:"miscellaneousCost,omitempty"`

	// Cost of movies.
	//
	// Max Length: 12
	MovieCost string `json:"movieCost,omitempty"`

	// Cost of non-room purchases, such as meals and gifts.
	//
	// Max Length: 12
	NonRoomCost string `json:"nonRoomCost,omitempty"`

	// Tax on non-room purchases.
	//
	// Max Length: 12
	NonRoomTaxAmount string `json:"nonRoomTaxAmount,omitempty"`

	// Number of guests staying in the room.
	//
	// Maximum: 99
	// Minimum: 1
	NumberOfGuests int64 `json:"numberOfGuests,omitempty"`

	// Number of rooms booked by the cardholder.
	//
	// Maximum: 99
	// Minimum: 1
	NumberOfRooms int64 `json:"numberOfRooms,omitempty"`

	// Cost of telephone services.
	//
	// Max Length: 12
	PhoneCost string `json:"phoneCost,omitempty"`

	// Prepaid amount, such as a deposit.
	//
	// Max Length: 12
	PrepaidCost string `json:"prepaidCost,omitempty"`

	// Cost of restaurant purchases
	//
	// Max Length: 12
	RestaurantCost string `json:"restaurantCost,omitempty"`

	// The object containing the number of nights and the daily rate that applies for that no of nights.
	//
	Room []*CreatePaymentParamsBodyTravelInformationLodgingRoomItems0 `json:"room"`

	// Type of room, such as queen, king, or two doubles.
	//
	// Max Length: 12
	RoomBedType string `json:"roomBedType,omitempty"`

	// Location of room, such as lake view or ocean view.
	//
	// Max Length: 10
	RoomLocation string `json:"roomLocation,omitempty"`

	// Type of rate, such as corporate or senior citizen.
	//
	// Max Length: 12
	RoomRateType string `json:"roomRateType,omitempty"`

	// Cost of room service.
	//
	// Max Length: 12
	RoomServiceCost string `json:"roomServiceCost,omitempty"`

	// Total tax for the room.
	//
	// Max Length: 12
	RoomTaxAmount string `json:"roomTaxAmount,omitempty"`

	// Type of tax, such as tourist or hotel.
	//
	// Max Length: 10
	RoomTaxType string `json:"roomTaxType,omitempty"`

	// Smoking preference of the guest.
	// Possible values:
	// - `Y`: smoking room
	// - `N`: non-smoking room
	//
	// Max Length: 1
	SmokingPreference string `json:"smokingPreference,omitempty"`

	// Code that identifies special circumstances.
	// Possible values:
	// - `1`: lodging (default)
	// - `2`: no show reservation
	// - `3`: advanced deposit
	//
	// Max Length: 1
	SpecialProgramCode string `json:"specialProgramCode,omitempty"`

	// Total tax amount.
	//
	// Max Length: 12
	TotalTaxAmount string `json:"totalTaxAmount,omitempty"`

	// Cost of transportation services.
	//
	// Max Length: 12
	TransportationCost string `json:"transportationCost,omitempty"`

	// Cost of valet parking services.
	//
	// Max Length: 12
	ValetParkingCost string `json:"valetParkingCost,omitempty"`
}

// Validate validates this create payment params body travel information lodging
func (o *CreatePaymentParamsBodyTravelInformationLodging) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAdditionalDiscountAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAdjustmentAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAudioVisualCost(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBanquestCost(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBusinessCenterCost(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCashDisbursementCost(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCheckInDate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCheckOutDate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateConferenceRoomCost(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCorporateClientCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCustomerServicePhoneNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEarlyCheckOutCost(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFoodAndBeverageCost(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateGiftShopCost(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateGratuityAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateGuestName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateHealthClubCost(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateInternetAccessCost(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLaundryCost(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLoungeBarCost(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMiniBarCost(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMiscellaneousCost(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMovieCost(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNonRoomCost(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNonRoomTaxAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNumberOfGuests(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNumberOfRooms(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePhoneCost(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePrepaidCost(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRestaurantCost(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRoom(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRoomBedType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRoomLocation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRoomRateType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRoomServiceCost(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRoomTaxAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRoomTaxType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSmokingPreference(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSpecialProgramCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTotalTaxAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTransportationCost(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateValetParkingCost(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationLodging) validateAdditionalDiscountAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.AdditionalDiscountAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"additionalDiscountAmount", "body", o.AdditionalDiscountAmount, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationLodging) validateAdjustmentAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.AdjustmentAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"adjustmentAmount", "body", o.AdjustmentAmount, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationLodging) validateAudioVisualCost(formats strfmt.Registry) error {
	if swag.IsZero(o.AudioVisualCost) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"audioVisualCost", "body", o.AudioVisualCost, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationLodging) validateBanquestCost(formats strfmt.Registry) error {
	if swag.IsZero(o.BanquestCost) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"banquestCost", "body", o.BanquestCost, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationLodging) validateBusinessCenterCost(formats strfmt.Registry) error {
	if swag.IsZero(o.BusinessCenterCost) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"businessCenterCost", "body", o.BusinessCenterCost, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationLodging) validateCashDisbursementCost(formats strfmt.Registry) error {
	if swag.IsZero(o.CashDisbursementCost) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"cashDisbursementCost", "body", o.CashDisbursementCost, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationLodging) validateCheckInDate(formats strfmt.Registry) error {
	if swag.IsZero(o.CheckInDate) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"checkInDate", "body", o.CheckInDate, 6); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationLodging) validateCheckOutDate(formats strfmt.Registry) error {
	if swag.IsZero(o.CheckOutDate) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"checkOutDate", "body", o.CheckOutDate, 6); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationLodging) validateConferenceRoomCost(formats strfmt.Registry) error {
	if swag.IsZero(o.ConferenceRoomCost) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"conferenceRoomCost", "body", o.ConferenceRoomCost, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationLodging) validateCorporateClientCode(formats strfmt.Registry) error {
	if swag.IsZero(o.CorporateClientCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"corporateClientCode", "body", o.CorporateClientCode, 17); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationLodging) validateCustomerServicePhoneNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.CustomerServicePhoneNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"customerServicePhoneNumber", "body", o.CustomerServicePhoneNumber, 17); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationLodging) validateEarlyCheckOutCost(formats strfmt.Registry) error {
	if swag.IsZero(o.EarlyCheckOutCost) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"earlyCheckOutCost", "body", o.EarlyCheckOutCost, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationLodging) validateFoodAndBeverageCost(formats strfmt.Registry) error {
	if swag.IsZero(o.FoodAndBeverageCost) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"foodAndBeverageCost", "body", o.FoodAndBeverageCost, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationLodging) validateGiftShopCost(formats strfmt.Registry) error {
	if swag.IsZero(o.GiftShopCost) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"giftShopCost", "body", o.GiftShopCost, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationLodging) validateGratuityAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.GratuityAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"gratuityAmount", "body", o.GratuityAmount, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationLodging) validateGuestName(formats strfmt.Registry) error {
	if swag.IsZero(o.GuestName) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"guestName", "body", o.GuestName, 40); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationLodging) validateHealthClubCost(formats strfmt.Registry) error {
	if swag.IsZero(o.HealthClubCost) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"healthClubCost", "body", o.HealthClubCost, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationLodging) validateInternetAccessCost(formats strfmt.Registry) error {
	if swag.IsZero(o.InternetAccessCost) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"internetAccessCost", "body", o.InternetAccessCost, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationLodging) validateLaundryCost(formats strfmt.Registry) error {
	if swag.IsZero(o.LaundryCost) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"laundryCost", "body", o.LaundryCost, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationLodging) validateLoungeBarCost(formats strfmt.Registry) error {
	if swag.IsZero(o.LoungeBarCost) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"loungeBarCost", "body", o.LoungeBarCost, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationLodging) validateMiniBarCost(formats strfmt.Registry) error {
	if swag.IsZero(o.MiniBarCost) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"miniBarCost", "body", o.MiniBarCost, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationLodging) validateMiscellaneousCost(formats strfmt.Registry) error {
	if swag.IsZero(o.MiscellaneousCost) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"miscellaneousCost", "body", o.MiscellaneousCost, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationLodging) validateMovieCost(formats strfmt.Registry) error {
	if swag.IsZero(o.MovieCost) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"movieCost", "body", o.MovieCost, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationLodging) validateNonRoomCost(formats strfmt.Registry) error {
	if swag.IsZero(o.NonRoomCost) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"nonRoomCost", "body", o.NonRoomCost, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationLodging) validateNonRoomTaxAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.NonRoomTaxAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"nonRoomTaxAmount", "body", o.NonRoomTaxAmount, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationLodging) validateNumberOfGuests(formats strfmt.Registry) error {
	if swag.IsZero(o.NumberOfGuests) { // not required
		return nil
	}

	if err := validate.MinimumInt("createPaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"numberOfGuests", "body", o.NumberOfGuests, 1, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("createPaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"numberOfGuests", "body", o.NumberOfGuests, 99, false); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationLodging) validateNumberOfRooms(formats strfmt.Registry) error {
	if swag.IsZero(o.NumberOfRooms) { // not required
		return nil
	}

	if err := validate.MinimumInt("createPaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"numberOfRooms", "body", o.NumberOfRooms, 1, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("createPaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"numberOfRooms", "body", o.NumberOfRooms, 99, false); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationLodging) validatePhoneCost(formats strfmt.Registry) error {
	if swag.IsZero(o.PhoneCost) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"phoneCost", "body", o.PhoneCost, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationLodging) validatePrepaidCost(formats strfmt.Registry) error {
	if swag.IsZero(o.PrepaidCost) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"prepaidCost", "body", o.PrepaidCost, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationLodging) validateRestaurantCost(formats strfmt.Registry) error {
	if swag.IsZero(o.RestaurantCost) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"restaurantCost", "body", o.RestaurantCost, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationLodging) validateRoom(formats strfmt.Registry) error {
	if swag.IsZero(o.Room) { // not required
		return nil
	}

	for i := 0; i < len(o.Room); i++ {
		if swag.IsZero(o.Room[i]) { // not required
			continue
		}

		if o.Room[i] != nil {
			if err := o.Room[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("createPaymentRequest" + "." + "travelInformation" + "." + "lodging" + "." + "room" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("createPaymentRequest" + "." + "travelInformation" + "." + "lodging" + "." + "room" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationLodging) validateRoomBedType(formats strfmt.Registry) error {
	if swag.IsZero(o.RoomBedType) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"roomBedType", "body", o.RoomBedType, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationLodging) validateRoomLocation(formats strfmt.Registry) error {
	if swag.IsZero(o.RoomLocation) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"roomLocation", "body", o.RoomLocation, 10); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationLodging) validateRoomRateType(formats strfmt.Registry) error {
	if swag.IsZero(o.RoomRateType) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"roomRateType", "body", o.RoomRateType, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationLodging) validateRoomServiceCost(formats strfmt.Registry) error {
	if swag.IsZero(o.RoomServiceCost) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"roomServiceCost", "body", o.RoomServiceCost, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationLodging) validateRoomTaxAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.RoomTaxAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"roomTaxAmount", "body", o.RoomTaxAmount, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationLodging) validateRoomTaxType(formats strfmt.Registry) error {
	if swag.IsZero(o.RoomTaxType) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"roomTaxType", "body", o.RoomTaxType, 10); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationLodging) validateSmokingPreference(formats strfmt.Registry) error {
	if swag.IsZero(o.SmokingPreference) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"smokingPreference", "body", o.SmokingPreference, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationLodging) validateSpecialProgramCode(formats strfmt.Registry) error {
	if swag.IsZero(o.SpecialProgramCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"specialProgramCode", "body", o.SpecialProgramCode, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationLodging) validateTotalTaxAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.TotalTaxAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"totalTaxAmount", "body", o.TotalTaxAmount, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationLodging) validateTransportationCost(formats strfmt.Registry) error {
	if swag.IsZero(o.TransportationCost) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"transportationCost", "body", o.TransportationCost, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationLodging) validateValetParkingCost(formats strfmt.Registry) error {
	if swag.IsZero(o.ValetParkingCost) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"lodging"+"."+"valetParkingCost", "body", o.ValetParkingCost, 12); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this create payment params body travel information lodging based on the context it is used
func (o *CreatePaymentParamsBodyTravelInformationLodging) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateRoom(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationLodging) contextValidateRoom(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.Room); i++ {

		if o.Room[i] != nil {
			if err := o.Room[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("createPaymentRequest" + "." + "travelInformation" + "." + "lodging" + "." + "room" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("createPaymentRequest" + "." + "travelInformation" + "." + "lodging" + "." + "room" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyTravelInformationLodging) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyTravelInformationLodging) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyTravelInformationLodging
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyTravelInformationLodgingRoomItems0 create payment params body travel information lodging room items0
swagger:model CreatePaymentParamsBodyTravelInformationLodgingRoomItems0
*/
type CreatePaymentParamsBodyTravelInformationLodgingRoomItems0 struct {

	// Daily cost of the room.
	//
	// Max Length: 8
	DailyRate string `json:"dailyRate,omitempty"`

	// Number of nights billed at the rate specified by `travelInformation.lodging.room[].dailyRate`.
	//
	// Maximum: 9999
	// Minimum: 1
	NumberOfNights int64 `json:"numberOfNights,omitempty"`
}

// Validate validates this create payment params body travel information lodging room items0
func (o *CreatePaymentParamsBodyTravelInformationLodgingRoomItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDailyRate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNumberOfNights(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationLodgingRoomItems0) validateDailyRate(formats strfmt.Registry) error {
	if swag.IsZero(o.DailyRate) { // not required
		return nil
	}

	if err := validate.MaxLength("dailyRate", "body", o.DailyRate, 8); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationLodgingRoomItems0) validateNumberOfNights(formats strfmt.Registry) error {
	if swag.IsZero(o.NumberOfNights) { // not required
		return nil
	}

	if err := validate.MinimumInt("numberOfNights", "body", o.NumberOfNights, 1, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("numberOfNights", "body", o.NumberOfNights, 9999, false); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment params body travel information lodging room items0 based on context it is used
func (o *CreatePaymentParamsBodyTravelInformationLodgingRoomItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyTravelInformationLodgingRoomItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyTravelInformationLodgingRoomItems0) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyTravelInformationLodgingRoomItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyTravelInformationTransit create payment params body travel information transit
swagger:model CreatePaymentParamsBodyTravelInformationTransit
*/
type CreatePaymentParamsBodyTravelInformationTransit struct {

	// airline
	Airline *CreatePaymentParamsBodyTravelInformationTransitAirline `json:"airline,omitempty"`
}

// Validate validates this create payment params body travel information transit
func (o *CreatePaymentParamsBodyTravelInformationTransit) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAirline(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationTransit) validateAirline(formats strfmt.Registry) error {
	if swag.IsZero(o.Airline) { // not required
		return nil
	}

	if o.Airline != nil {
		if err := o.Airline.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "travelInformation" + "." + "transit" + "." + "airline")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "travelInformation" + "." + "transit" + "." + "airline")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this create payment params body travel information transit based on the context it is used
func (o *CreatePaymentParamsBodyTravelInformationTransit) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateAirline(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationTransit) contextValidateAirline(ctx context.Context, formats strfmt.Registry) error {

	if o.Airline != nil {
		if err := o.Airline.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "travelInformation" + "." + "transit" + "." + "airline")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "travelInformation" + "." + "transit" + "." + "airline")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyTravelInformationTransit) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyTravelInformationTransit) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyTravelInformationTransit
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyTravelInformationTransitAirline create payment params body travel information transit airline
swagger:model CreatePaymentParamsBodyTravelInformationTransitAirline
*/
type CreatePaymentParamsBodyTravelInformationTransitAirline struct {

	// Description of the charge if the charge does not involve an airline ticket.
	// For example: Excess baggage.
	//
	// Max Length: 20
	AdditionalCharges string `json:"additionalCharges,omitempty"`

	// ancillary information
	AncillaryInformation *CreatePaymentParamsBodyTravelInformationTransitAirlineAncillaryInformation `json:"ancillaryInformation,omitempty"`

	// Date of arrival for the last leg of the trip.
	// Format: `MMDDYYYY`
	// English characters only.
	// Optional request field.
	//
	// Max Length: 8
	ArrivalDate string `json:"arrivalDate,omitempty"`

	// Boarding fee.
	//
	// Max Length: 12
	BoardingFeeAmount string `json:"boardingFeeAmount,omitempty"`

	// Reference number for the airline booking.
	// Required if ticket numbers are not issued.
	//
	// Max Length: 15
	BookingReferenceNumber string `json:"bookingReferenceNumber,omitempty"`

	// Airline that generated the ticket.
	// Format: English characters only.
	// Optional request field.
	//
	// Max Length: 15
	CarrierName string `json:"carrierName,omitempty"`

	// Check digit for the ticket number. CyberSource recommends that you validate the check digit.
	// With Discover and Diners Club, a valid ticket number has these characteristics:
	// - The value is numeric.
	// - The first three digits are a valid IATA2 license plate carrier code.
	// - The last digit is a check digit or zero (0).
	// - All remaining digits are nonzero.
	//
	// Max Length: 1
	CheckDigit string `json:"checkDigit,omitempty"`

	// Total number of clearing messages associated with the authorization request.
	// Format: English characters only.
	// Optional request field.
	//
	// Max Length: 2
	ClearingCount string `json:"clearingCount,omitempty"`

	// Number that identifies the clearing message when multiple clearing messages are allowed per authorized transaction.
	// Each clearing message linked to one authorization request must include a unique clearing sequence number between 1 and the total number of clearing records.
	// Format: English characters only.
	// Optional request field.
	//
	// Max Length: 2
	ClearingSequence string `json:"clearingSequence,omitempty"`

	// Reason for the credit.
	// Possible values:
	// - `A`: Cancellation of the ancillary passenger transport purchase.
	// - `B`: Cancellation of the airline ticket and the passenger transport ancillary purchase.
	// - `C`: Cancellation of the airline ticket.
	// - `O`: Other.
	// - `P`: Partial refund of the airline ticket.
	// Format: English characters only.
	//
	// Optional request field.
	//
	// Max Length: 1
	CreditReasonIndicator string `json:"creditReasonIndicator,omitempty"`

	// Reference number or code that identifies the cardholder.
	// Format: English characters only.
	// Restricted string data type that indicates a sequence of letters, numbers, and spaces;
	// special characters are not included.
	// Optional request field.
	//
	// Max Length: 40
	CustomerCode string `json:"customerCode,omitempty"`

	// The field is not currently supported.
	//
	// Max Length: 14
	DocumentNumber string `json:"documentNumber,omitempty"`

	// The field is not currently supported.
	//
	DocumentNumberOfParts int64 `json:"documentNumberOfParts,omitempty"`

	// Airline document type code that specifies the purpose of the transaction.
	// Format: English characters only.
	// Optional request field.
	//
	// | Code | Description |
	// | --- | --- |
	// | 01 | Passenger ticket |
	// | 02 | Additional collection |
	// | 03 | Excess baggage |
	// | 04 | Miscellaneous charge order (MCO) or prepaid ticket authorization |
	// | 05 | Special service ticket |
	// | 06 | Supported refund |
	// | 07 | Unsupported refund |
	// | 08 | Lost ticket application |
	// | 09 | Tour order voucher |
	// | 10 | Ticket by mail |
	// | 11 | Undercharge adjustment |
	// | 12 | Group ticket |
	// | 13 | Exchange adjustment |
	// | 14 | SPD or air freight |
	// | 15 | In-flight adjustment |
	// | 16 | Agency passenger ticket |
	// | 17 | Agency tour order or voucher |
	// | 18 | Agency miscellaneous charge order (MCO) |
	// | 19 | Agency exchange order |
	// | 20 | Agency group ticket |
	// | 21 | Debit adjustment for duplicate refund or use |
	// | 22 | In-flight merchandise order |
	// | 23 | Catalogue merchandise order |
	// | 24 | In-flight phone charges |
	// | 25 | Frequent flyer fee or purchase |
	// | 26 | Kennel charge |
	// | 27 | Animal transportation charge |
	// | 28 | Firearms case |
	// | 29 | Upgrade charge |
	// | 30 | Credit for unused transportation |
	// | 31 | Credit for class of service adjustment |
	// | 32 | Credit for denied boarding |
	// | 33 | Credit for miscellaneous refund |
	// | 34 | Credit for lost ticket refund |
	// | 35 | Credit for exchange refund |
	// | 36 | Credit for overcharge adjustment |
	// | 37 | Credit for multiple Unused tickets |
	// | 38 | Exchange order |
	// | 39 | Self-service ticket |
	// | 41 | In-flight duty-free purchase |
	// | 42 | Senior citizen discount booklets |
	// | 43 | Club membership fee |
	// | 44 | Coupon book |
	// | 45 | In-flight charges |
	// | 46 | Tour deposit |
	// | 47 | Frequent flyer overnight delivery charge |
	// | 48 | Frequent flyer fulfillment |
	// | 49 | Small package delivery |
	// | 50 | Vendor sale |
	// | 51 | Miscellaneous taxes or fees |
	// | 52 | Travel agency fee |
	// | 60 | Vendor refund or credit |
	// | 64 | Duty free sale |
	// | 65 | Preferred seat upgrade |
	// | 66 | Cabin upgrade |
	// | 67 | Lounge or club access or day pass |
	// | 68 | Agent assisted reservation or ticketing fee |
	// | 69 | Ticket change or cancel fee |
	// | 70 | Trip insurance |
	// | 71 | Unaccompanied minor |
	// | 72 | Standby fee |
	// | 73 | Curbside baggage |
	// | 74 | In-flight medical equipment |
	// | 75 | Ticket or pass print fee |
	// | 76 | Checked sporting or special equipment |
	// | 77 | Dry ice fee |
	// | 78 | Mail or postage fee |
	// | 79 | Club membership fee or temporary trial |
	// | 80 | Frequent flyer activation or reinstatement |
	// | 81 | Gift certificate |
	// | 82 | Onboard or in-flight prepaid voucher |
	// | 83 | Optional services fee |
	// | 84 | Advance purchase for excess baggage |
	// | 85 | Advance purchase for preferred seat upgrade |
	// | 86 | Advance purchase for cabin upgrade |
	// | 87 | Advance purchase for optional services |
	// | 88 | WiFi |
	// | 89 | Packages |
	// | 90 | In-flight entertainment or internet access |
	// | 91 | Overweight bag fee |
	// | 92 | Sleep sets |
	// | 93 | Special purchase fee |
	//
	// Max Length: 1
	DocumentType string `json:"documentType,omitempty"`

	// Flag that indicates whether an electronic ticket was issued.
	// Possible values:
	// - `true`
	// - `false`
	// Optional request field.
	//
	ElectronicTicketIndicator bool `json:"electronicTicketIndicator,omitempty"`

	// Amount of the exchanged ticket.
	// Format: English characters only.
	//
	// Max Length: 12
	ExchangeTicketAmount string `json:"exchangeTicketAmount,omitempty"`

	// Fee for exchanging the ticket.
	// Format: English characters only.
	// Optional request field.
	//
	// Max Length: 12
	ExchangeTicketFeeAmount string `json:"exchangeTicketFeeAmount,omitempty"`

	// The field is not currently supported.
	//
	// Max Length: 3
	ExtendedPaymentCode string `json:"extendedPaymentCode,omitempty"`

	// Invoice date. The format is YYYYMMDD.
	// If this value is
	// included in the request, it is used in the creation of the invoice number. See "Invoice Number,"
	//
	InvoiceDate int64 `json:"invoiceDate,omitempty"`

	// Invoice number for the airline transaction.
	//
	// Max Length: 25
	InvoiceNumber string `json:"invoiceNumber,omitempty"`

	// legs
	Legs []*CreatePaymentParamsBodyTravelInformationTransitAirlineLegsItems0 `json:"legs"`

	// Number of passengers for whom the ticket was issued.
	// Format: English characters only.
	// Optional request field.
	//
	NumberOfPassengers int64 `json:"numberOfPassengers,omitempty"`

	// Original ticket number when the transaction is for a replacement ticket.
	//
	// Max Length: 14
	OriginalTicketNumber string `json:"originalTicketNumber,omitempty"`

	// Name of the passenger to whom the ticket was issued.  This will always be a single passenger's name.
	// If there are more than one passengers, provide only the primary passenger's name.
	// Do not include special characters such as commas, hyphens, or apostrophes.
	// Only ASCII characters are supported.
	// Format: English characters only.
	// Optional request field.
	//
	// Max Length: 42
	PassengerName string `json:"passengerName,omitempty"`

	// Plan number based on the fare.
	// This value is provided by the airline.
	// Format: English characters only.
	// Optional request field.
	//
	// Max Length: 1
	PlanNumber string `json:"planNumber,omitempty"`

	// Airline process identifier. This value is the airlines three-digit IATA1 code
	// which is used to process extended payment airline tickets.
	//
	// Max Length: 3
	ProcessIdentifier string `json:"processIdentifier,omitempty"`

	// Type of purchase. Possible values:
	// - `EXC`: Exchange ticket
	// - `MSC`: Miscellaneous (not a ticket purchase and not a transaction related to an exchange ticket)
	// - `REF`: Refund
	// - `TKT`: Ticket
	// Format: English characters only.
	// Optional request field.
	//
	// Max Length: 3
	PurchaseType string `json:"purchaseType,omitempty"`

	// Code that specifies the computerized reservation system used to make the reservation and purchase the ticket.
	// Format: English characters only.
	// Restricted string data type that indicates a sequence of letters, numbers, and spaces;
	// special characters are not included.
	// Optional request field.
	//
	// Max Length: 4
	ReservationSystemCode string `json:"reservationSystemCode,omitempty"`

	// The field is not currently supported.
	//
	// Max Length: 32
	ReservationType string `json:"reservationType,omitempty"`

	// Text that describes the ticket limitations, such as _nonrefundable_.
	// Format: English characters only.
	// Optional request field.
	//
	// Max Length: 20
	RestrictedTicketDesciption string `json:"restrictedTicketDesciption,omitempty"`

	// Flag that indicates whether or not the ticket is restricted (nonrefundable).
	// Possible values:
	// - 0: No restriction (refundable)
	// - 1: Restricted (nonrefundable)
	// Format: English characters only.
	// Restricted string data type that indicates a sequence of letters, numbers, and spaces;
	// special characters are not included.
	// Optional request field.
	//
	RestrictedTicketIndicator int64 `json:"restrictedTicketIndicator,omitempty"`

	// Type of update.
	// Possible values:
	// - `C`: Change to the existing ticket.
	// - `N`: New ticket.
	// Format: English characters only
	// Optional request field.
	//
	// Max Length: 1
	TicketChangeIndicator string `json:"ticketChangeIndicator,omitempty"`

	// Date on which the transaction occurred.
	// Format: `YYYYMMDD`
	// Format: English characters only.
	// Optional request field.
	//
	// Max Length: 8
	TicketIssueDate string `json:"ticketIssueDate,omitempty"`

	// ticket issuer
	TicketIssuer *CreatePaymentParamsBodyTravelInformationTransitAirlineTicketIssuer `json:"ticketIssuer,omitempty"`

	// Ticket number.
	// Format: English characters only.
	// Restricted string data type that indicates a sequence of letters, numbers, and spaces;
	// special characters are not included.
	// Optional request field.
	//
	// Max Length: 15
	TicketNumber string `json:"ticketNumber,omitempty"`

	// Total clearing amount for all transactions in the clearing count set.
	// This value cannot exceed `99999999999999999999` (twenty 9s).
	// Format: English characters only.
	// If this field is not set and if the total amount from the original authorization is not NULL,
	// the total clearing amount is set to the total amount from the original authorization.
	//
	// Max Length: 20
	TotalClearingAmount string `json:"totalClearingAmount,omitempty"`

	// Total fee for the ticket. This value cannot exceed `99999999999999999999` (twenty 9s).
	// Format: English characters only.
	// Optional request field.
	//
	// Max Length: 12
	TotalFeeAmount string `json:"totalFeeAmount,omitempty"`

	// Type of charge.
	// Possible values:
	// - 01: Charge is for an airline ticket
	// - 02: Charge is for an item that is not an airline ticket
	//
	TransactionType int64 `json:"transactionType,omitempty"`
}

// Validate validates this create payment params body travel information transit airline
func (o *CreatePaymentParamsBodyTravelInformationTransitAirline) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAdditionalCharges(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAncillaryInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateArrivalDate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBoardingFeeAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBookingReferenceNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCarrierName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCheckDigit(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateClearingCount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateClearingSequence(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCreditReasonIndicator(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCustomerCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDocumentNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDocumentType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExchangeTicketAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExchangeTicketFeeAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExtendedPaymentCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateInvoiceNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLegs(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOriginalTicketNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePassengerName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePlanNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProcessIdentifier(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePurchaseType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateReservationSystemCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateReservationType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRestrictedTicketDesciption(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTicketChangeIndicator(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTicketIssueDate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTicketIssuer(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTicketNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTotalClearingAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTotalFeeAmount(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationTransitAirline) validateAdditionalCharges(formats strfmt.Registry) error {
	if swag.IsZero(o.AdditionalCharges) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"additionalCharges", "body", o.AdditionalCharges, 20); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationTransitAirline) validateAncillaryInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.AncillaryInformation) { // not required
		return nil
	}

	if o.AncillaryInformation != nil {
		if err := o.AncillaryInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "travelInformation" + "." + "transit" + "." + "airline" + "." + "ancillaryInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "travelInformation" + "." + "transit" + "." + "airline" + "." + "ancillaryInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationTransitAirline) validateArrivalDate(formats strfmt.Registry) error {
	if swag.IsZero(o.ArrivalDate) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"arrivalDate", "body", o.ArrivalDate, 8); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationTransitAirline) validateBoardingFeeAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.BoardingFeeAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"boardingFeeAmount", "body", o.BoardingFeeAmount, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationTransitAirline) validateBookingReferenceNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.BookingReferenceNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"bookingReferenceNumber", "body", o.BookingReferenceNumber, 15); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationTransitAirline) validateCarrierName(formats strfmt.Registry) error {
	if swag.IsZero(o.CarrierName) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"carrierName", "body", o.CarrierName, 15); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationTransitAirline) validateCheckDigit(formats strfmt.Registry) error {
	if swag.IsZero(o.CheckDigit) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"checkDigit", "body", o.CheckDigit, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationTransitAirline) validateClearingCount(formats strfmt.Registry) error {
	if swag.IsZero(o.ClearingCount) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"clearingCount", "body", o.ClearingCount, 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationTransitAirline) validateClearingSequence(formats strfmt.Registry) error {
	if swag.IsZero(o.ClearingSequence) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"clearingSequence", "body", o.ClearingSequence, 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationTransitAirline) validateCreditReasonIndicator(formats strfmt.Registry) error {
	if swag.IsZero(o.CreditReasonIndicator) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"creditReasonIndicator", "body", o.CreditReasonIndicator, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationTransitAirline) validateCustomerCode(formats strfmt.Registry) error {
	if swag.IsZero(o.CustomerCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"customerCode", "body", o.CustomerCode, 40); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationTransitAirline) validateDocumentNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.DocumentNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"documentNumber", "body", o.DocumentNumber, 14); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationTransitAirline) validateDocumentType(formats strfmt.Registry) error {
	if swag.IsZero(o.DocumentType) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"documentType", "body", o.DocumentType, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationTransitAirline) validateExchangeTicketAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.ExchangeTicketAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"exchangeTicketAmount", "body", o.ExchangeTicketAmount, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationTransitAirline) validateExchangeTicketFeeAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.ExchangeTicketFeeAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"exchangeTicketFeeAmount", "body", o.ExchangeTicketFeeAmount, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationTransitAirline) validateExtendedPaymentCode(formats strfmt.Registry) error {
	if swag.IsZero(o.ExtendedPaymentCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"extendedPaymentCode", "body", o.ExtendedPaymentCode, 3); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationTransitAirline) validateInvoiceNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.InvoiceNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"invoiceNumber", "body", o.InvoiceNumber, 25); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationTransitAirline) validateLegs(formats strfmt.Registry) error {
	if swag.IsZero(o.Legs) { // not required
		return nil
	}

	for i := 0; i < len(o.Legs); i++ {
		if swag.IsZero(o.Legs[i]) { // not required
			continue
		}

		if o.Legs[i] != nil {
			if err := o.Legs[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("createPaymentRequest" + "." + "travelInformation" + "." + "transit" + "." + "airline" + "." + "legs" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("createPaymentRequest" + "." + "travelInformation" + "." + "transit" + "." + "airline" + "." + "legs" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationTransitAirline) validateOriginalTicketNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.OriginalTicketNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"originalTicketNumber", "body", o.OriginalTicketNumber, 14); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationTransitAirline) validatePassengerName(formats strfmt.Registry) error {
	if swag.IsZero(o.PassengerName) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"passengerName", "body", o.PassengerName, 42); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationTransitAirline) validatePlanNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.PlanNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"planNumber", "body", o.PlanNumber, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationTransitAirline) validateProcessIdentifier(formats strfmt.Registry) error {
	if swag.IsZero(o.ProcessIdentifier) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"processIdentifier", "body", o.ProcessIdentifier, 3); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationTransitAirline) validatePurchaseType(formats strfmt.Registry) error {
	if swag.IsZero(o.PurchaseType) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"purchaseType", "body", o.PurchaseType, 3); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationTransitAirline) validateReservationSystemCode(formats strfmt.Registry) error {
	if swag.IsZero(o.ReservationSystemCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"reservationSystemCode", "body", o.ReservationSystemCode, 4); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationTransitAirline) validateReservationType(formats strfmt.Registry) error {
	if swag.IsZero(o.ReservationType) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"reservationType", "body", o.ReservationType, 32); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationTransitAirline) validateRestrictedTicketDesciption(formats strfmt.Registry) error {
	if swag.IsZero(o.RestrictedTicketDesciption) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"restrictedTicketDesciption", "body", o.RestrictedTicketDesciption, 20); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationTransitAirline) validateTicketChangeIndicator(formats strfmt.Registry) error {
	if swag.IsZero(o.TicketChangeIndicator) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"ticketChangeIndicator", "body", o.TicketChangeIndicator, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationTransitAirline) validateTicketIssueDate(formats strfmt.Registry) error {
	if swag.IsZero(o.TicketIssueDate) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"ticketIssueDate", "body", o.TicketIssueDate, 8); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationTransitAirline) validateTicketIssuer(formats strfmt.Registry) error {
	if swag.IsZero(o.TicketIssuer) { // not required
		return nil
	}

	if o.TicketIssuer != nil {
		if err := o.TicketIssuer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "travelInformation" + "." + "transit" + "." + "airline" + "." + "ticketIssuer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "travelInformation" + "." + "transit" + "." + "airline" + "." + "ticketIssuer")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationTransitAirline) validateTicketNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.TicketNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"ticketNumber", "body", o.TicketNumber, 15); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationTransitAirline) validateTotalClearingAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.TotalClearingAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"totalClearingAmount", "body", o.TotalClearingAmount, 20); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationTransitAirline) validateTotalFeeAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.TotalFeeAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"totalFeeAmount", "body", o.TotalFeeAmount, 12); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this create payment params body travel information transit airline based on the context it is used
func (o *CreatePaymentParamsBodyTravelInformationTransitAirline) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateAncillaryInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateLegs(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateTicketIssuer(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationTransitAirline) contextValidateAncillaryInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.AncillaryInformation != nil {
		if err := o.AncillaryInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "travelInformation" + "." + "transit" + "." + "airline" + "." + "ancillaryInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "travelInformation" + "." + "transit" + "." + "airline" + "." + "ancillaryInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationTransitAirline) contextValidateLegs(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.Legs); i++ {

		if o.Legs[i] != nil {
			if err := o.Legs[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("createPaymentRequest" + "." + "travelInformation" + "." + "transit" + "." + "airline" + "." + "legs" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("createPaymentRequest" + "." + "travelInformation" + "." + "transit" + "." + "airline" + "." + "legs" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationTransitAirline) contextValidateTicketIssuer(ctx context.Context, formats strfmt.Registry) error {

	if o.TicketIssuer != nil {
		if err := o.TicketIssuer.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "travelInformation" + "." + "transit" + "." + "airline" + "." + "ticketIssuer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("createPaymentRequest" + "." + "travelInformation" + "." + "transit" + "." + "airline" + "." + "ticketIssuer")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyTravelInformationTransitAirline) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyTravelInformationTransitAirline) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyTravelInformationTransitAirline
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyTravelInformationTransitAirlineAncillaryInformation create payment params body travel information transit airline ancillary information
swagger:model CreatePaymentParamsBodyTravelInformationTransitAirlineAncillaryInformation
*/
type CreatePaymentParamsBodyTravelInformationTransitAirlineAncillaryInformation struct {

	// Number for the airline ticket to which the ancillary purchase is connected.
	//
	// If this purchase has a connection or relationship to another purchase such as a baggage fee for a passenger transport ticket, this field must contain the ticket number for the other purchase.
	//
	// For a stand-alone purchase, the value for this field must be the same as the value for the `travelInformation.transit.airline.ancillaryInformation.ticketNumber` field.
	// **Important** This field is required in the U.S. in order for you to qualify for either the custom payment service (CPS) or the electronic interchange reimbursement fee (EIRF)
	// program.
	// Format: English characters only.
	// Optional request field for ancillary services.
	//
	// Max Length: 15
	ConnectedTicketNumber string `json:"connectedTicketNumber,omitempty"`

	// Reason for the credit.
	// Possible values:
	// - `A`: Cancellation of the ancillary passenger transport purchase.
	// - `B`: Cancellation of the airline ticket and the passenger transport ancillary purchase.
	// - `C`: Cancellation of the airline ticket.
	// - `O`: Other.
	// - `P`: Partial refund of the airline ticket.
	// Format: English characters only.
	// Optional field for ancillary services.
	//
	// Max Length: 15
	CreditReasonIndicator string `json:"creditReasonIndicator,omitempty"`

	// Name of the passenger. If the passengers name is not available, this value is the cardholders name. If neither the passengers name nor the cardholders name is available,
	// this value is a description of the ancillary purchase.
	// **Important** This field is required in the U.S. in order for you to qualify for either the custom payment service (CPS) or the electronic interchange reimbursement fee (EIRF)
	// program.
	// Format: English characters only.
	// Optional field for ancillary service.
	//
	// Max Length: 20
	PassengerName string `json:"passengerName,omitempty"`

	// service
	Service []*CreatePaymentParamsBodyTravelInformationTransitAirlineAncillaryInformationServiceItems0 `json:"service"`

	// Ticket number, which consists of the carrier code, form, and serial number, without the check digit.
	// **Important** This field is required in the U.S. in order for you to qualify for either the
	// custom payment service (CPS) or the electronic interchange reimbursement fee (EIRF) program.
	// Format: English characters only.
	// Optional field for ancillary services.
	//
	// Max Length: 15
	TicketNumber string `json:"ticketNumber,omitempty"`
}

// Validate validates this create payment params body travel information transit airline ancillary information
func (o *CreatePaymentParamsBodyTravelInformationTransitAirlineAncillaryInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateConnectedTicketNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCreditReasonIndicator(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePassengerName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateService(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTicketNumber(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationTransitAirlineAncillaryInformation) validateConnectedTicketNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.ConnectedTicketNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"ancillaryInformation"+"."+"connectedTicketNumber", "body", o.ConnectedTicketNumber, 15); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationTransitAirlineAncillaryInformation) validateCreditReasonIndicator(formats strfmt.Registry) error {
	if swag.IsZero(o.CreditReasonIndicator) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"ancillaryInformation"+"."+"creditReasonIndicator", "body", o.CreditReasonIndicator, 15); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationTransitAirlineAncillaryInformation) validatePassengerName(formats strfmt.Registry) error {
	if swag.IsZero(o.PassengerName) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"ancillaryInformation"+"."+"passengerName", "body", o.PassengerName, 20); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationTransitAirlineAncillaryInformation) validateService(formats strfmt.Registry) error {
	if swag.IsZero(o.Service) { // not required
		return nil
	}

	for i := 0; i < len(o.Service); i++ {
		if swag.IsZero(o.Service[i]) { // not required
			continue
		}

		if o.Service[i] != nil {
			if err := o.Service[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("createPaymentRequest" + "." + "travelInformation" + "." + "transit" + "." + "airline" + "." + "ancillaryInformation" + "." + "service" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("createPaymentRequest" + "." + "travelInformation" + "." + "transit" + "." + "airline" + "." + "ancillaryInformation" + "." + "service" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationTransitAirlineAncillaryInformation) validateTicketNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.TicketNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"ancillaryInformation"+"."+"ticketNumber", "body", o.TicketNumber, 15); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this create payment params body travel information transit airline ancillary information based on the context it is used
func (o *CreatePaymentParamsBodyTravelInformationTransitAirlineAncillaryInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateService(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationTransitAirlineAncillaryInformation) contextValidateService(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.Service); i++ {

		if o.Service[i] != nil {
			if err := o.Service[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("createPaymentRequest" + "." + "travelInformation" + "." + "transit" + "." + "airline" + "." + "ancillaryInformation" + "." + "service" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("createPaymentRequest" + "." + "travelInformation" + "." + "transit" + "." + "airline" + "." + "ancillaryInformation" + "." + "service" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyTravelInformationTransitAirlineAncillaryInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyTravelInformationTransitAirlineAncillaryInformation) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyTravelInformationTransitAirlineAncillaryInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyTravelInformationTransitAirlineAncillaryInformationServiceItems0 create payment params body travel information transit airline ancillary information service items0
swagger:model CreatePaymentParamsBodyTravelInformationTransitAirlineAncillaryInformationServiceItems0
*/
type CreatePaymentParamsBodyTravelInformationTransitAirlineAncillaryInformationServiceItems0 struct {

	// Category code for the ancillary service that is provided. Obtain the codes from the International
	// Air Transport Association (IATA).
	// **Note** `#` is either 0, 1, 2, or 3.
	// **Important** This field is required in the U.S. in order for you to qualify for either the custom
	// payment service (CPS) or the electronic interchange reimbursement fee (EIRF)program.
	// Format: English characters only.
	// Optional request field for ancillary services.
	//
	// Max Length: 4
	CategoryCode string `json:"categoryCode,omitempty"`

	// Subcategory code for the ancillary service category. Obtain the codes from the International
	// Air Transport Association (IATA).
	// **Note** `#` is either 0, 1, 2, or 3.
	// Format  English characters only.
	// Optional request field for ancillary services.
	//
	// Max Length: 4
	SubCategoryCode string `json:"subCategoryCode,omitempty"`
}

// Validate validates this create payment params body travel information transit airline ancillary information service items0
func (o *CreatePaymentParamsBodyTravelInformationTransitAirlineAncillaryInformationServiceItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCategoryCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSubCategoryCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationTransitAirlineAncillaryInformationServiceItems0) validateCategoryCode(formats strfmt.Registry) error {
	if swag.IsZero(o.CategoryCode) { // not required
		return nil
	}

	if err := validate.MaxLength("categoryCode", "body", o.CategoryCode, 4); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationTransitAirlineAncillaryInformationServiceItems0) validateSubCategoryCode(formats strfmt.Registry) error {
	if swag.IsZero(o.SubCategoryCode) { // not required
		return nil
	}

	if err := validate.MaxLength("subCategoryCode", "body", o.SubCategoryCode, 4); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment params body travel information transit airline ancillary information service items0 based on context it is used
func (o *CreatePaymentParamsBodyTravelInformationTransitAirlineAncillaryInformationServiceItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyTravelInformationTransitAirlineAncillaryInformationServiceItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyTravelInformationTransitAirlineAncillaryInformationServiceItems0) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyTravelInformationTransitAirlineAncillaryInformationServiceItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyTravelInformationTransitAirlineLegsItems0 create payment params body travel information transit airline legs items0
swagger:model CreatePaymentParamsBodyTravelInformationTransitAirlineLegsItems0
*/
type CreatePaymentParamsBodyTravelInformationTransitAirlineLegsItems0 struct {

	// Time of arrival for this leg of the trip.
	// The format is military time and HHMM:
	// If not all zeros, then the hours must be `00-23` and the minutes must be `00-59`
	// Format: English characters only.
	// Optional request field for travel legs.
	//
	ArrivalTime int64 `json:"arrivalTime,omitempty"`

	// AM or PM for the arrival time for this leg of the trip.
	// Possible values:
	// - `A`: 12:00 midnight to 11:59 a.m.
	// - `P`: 12:00 noon to 11:59 p.m.
	// Format: English characters only.
	// Restricted string data type that indicates a sequence of letters, numbers, and spaces; special characters are not included.
	// Optional request field for travel legs.
	//
	// Max Length: 1
	ArrivalTimeMeridian string `json:"arrivalTimeMeridian,omitempty"`

	// IATA code for the carrier for this leg of the trip.
	// Format: English characters only.
	// Restricted string data type that indicates a sequence of letters, numbers, and spaces; special characters are not included.
	// Optional request field for travel legs.
	//
	// Max Length: 4
	CarrierCode string `json:"carrierCode,omitempty"`

	// IATA code for the class of service for this leg of the trip.
	// Format: English characters only.
	// Restricted string data type that indicates a sequence of letters, numbers, and spaces; special characters are not included.
	// Optional request field for travel legs.
	//
	// Max Length: 3
	Class string `json:"class,omitempty"`

	// Ticket that contains additional coupons for this leg of the trip on an itinerary that has more than four segments.
	// Format: English characters only.
	// Restricted string data type that indicates a sequence of letters, numbers, and spaces; special characters are not included.
	// Optional request field for travel legs.
	//
	// Max Length: 25
	ConjunctionTicket string `json:"conjunctionTicket,omitempty"`

	// Coupon number. Each leg on the ticket requires a separate coupon, and each coupon is identified by the coupon number.
	// Format: English characters only.
	// Restricted string data type that indicates a sequence of letters, numbers, and spaces; special characters are not included.
	// Optional request field for travel legs.
	//
	// Max Length: 1
	CouponNumber string `json:"couponNumber,omitempty"`

	// Amount of departure tax for this leg of the trip.
	//
	// Max Length: 12
	DepartTaxAmount string `json:"departTaxAmount,omitempty"`

	// Departure date for the first leg of the trip.
	// Format: `YYYYMMDD`.
	// Format: English characters only.
	// Optional request field for travel legs.
	//
	DepartureDate int64 `json:"departureDate,omitempty"`

	// Time of departure for this leg of the trip. The format is military time and HHMM:
	// If not all zeros, then the hours must be `00-23` and the minutes must be `00-59`.
	// Format: English characters only.
	// Optional request field for travel legs.
	//
	DepartureTime int64 `json:"departureTime,omitempty"`

	// AM or PM for the departure time.
	// Possible values:
	// - A: 12:00 midnight to 11:59 a.m.
	// - P: 12:00 noon to 11:59 p.m
	// Format: English characters only.
	// Restricted string data type that indicates a sequence of letters, numbers, and spaces; special characters are not included.
	// Optional request field for travel legs.
	//
	// Max Length: 1
	DepartureTimeMeridian string `json:"departureTimeMeridian,omitempty"`

	// IATA code for the destination airport for this leg of the trip.
	// Format: English characters only.
	// Restricted string data type that indicates a sequence of letters, numbers, and spaces; special characters are not included.
	// Optional request field for travel legs.
	//
	// Max Length: 3
	DestinationAirportCode string `json:"destinationAirportCode,omitempty"`

	// Notes or notations about endorsements and restrictions for this leg of the trip.
	// Endorsements can be notations added by the travel agency, including mandatory government-required notations such as value added tax.
	// Restrictions are limitations for the ticket based on the type of fare, such as a nonrefundable ticket or a 3-day minimum stay.
	// Format: English characters only.
	// Optional request field for travel legs.
	//
	// Max Length: 20
	EndorsementsRestrictions string `json:"endorsementsRestrictions,omitempty"`

	// New ticket number that is issued when the ticket is exchanged for this leg of the trip.
	// Restrictions are limitations for the ticket based on the type of fare, such as a nonrefundable ticket or a 3-day minimum stay.
	// Format: English characters only.
	// Optional request field for travel legs.
	//
	// Max Length: 25
	ExchangeTicketNumber string `json:"exchangeTicketNumber,omitempty"`

	// Code for the fare basis for this leg of the trip.
	// The fare basis is assigned by the carriers and indicates a particular ticket type,
	// such as business class or discounted/nonrefundable.
	// Restricted string data type that indicates a sequence of letters, numbers, and spaces; special characters are not included.
	// Format: English characters only.
	// Optional request field for travel legs.auto_rental_regular_mileage_cost
	//
	// Max Length: 15
	FareBasis string `json:"fareBasis,omitempty"`

	// Fee for this leg of the trip, such as an airport fee or country fee.
	// Format: English characters only.
	// Optional request field for travel legs.
	//
	// Max Length: 12
	FeeAmount string `json:"feeAmount,omitempty"`

	// Flight number for this leg of the trip.
	// Restrictions are limitations for the ticket based on the type of fare, such as a nonrefundable ticket or a 3-day minimum stay.
	// Format: English characters only.
	// Optional request field for travel legs.
	//
	// Max Length: 6
	FlightNumber string `json:"flightNumber,omitempty"`

	// IATA code for the originating airport for this leg of the trip.
	// Format: English characters only.
	// Restricted string data type that indicates a sequence of letters, numbers, and spaces; special characters are not included.
	// Optional request field for travel legs.
	//
	// Max Length: 5
	OriginatingAirportCode string `json:"originatingAirportCode,omitempty"`

	// Code that indicates whether a stopover is allowed on this leg of the trip. Possible values:
	// - `O` (capital letter O) (default): Stopover allowed
	// - `X` (capital letter X): Stopover not allowed
	// Format: English characters only.
	// Restricted string data type that indicates a sequence of letters, numbers, and spaces; special characters are not included.
	// Optional request field for travel legs.
	//
	StopoverIndicator int64 `json:"stopoverIndicator,omitempty"`

	// Tax for this leg of the trip.
	// Format: English characters only.
	// Optional request field for travel legs.
	//
	// Max Length: 12
	TaxAmount string `json:"taxAmount,omitempty"`

	// Total fare for this leg of the trip.
	// Format: English characters only.
	// Optional request field for travel legs.
	//
	// Max Length: 15
	TotalFareAmount string `json:"totalFareAmount,omitempty"`
}

// Validate validates this create payment params body travel information transit airline legs items0
func (o *CreatePaymentParamsBodyTravelInformationTransitAirlineLegsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateArrivalTimeMeridian(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCarrierCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateClass(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateConjunctionTicket(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCouponNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDepartTaxAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDepartureTimeMeridian(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDestinationAirportCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEndorsementsRestrictions(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExchangeTicketNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFareBasis(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFeeAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFlightNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOriginatingAirportCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTotalFareAmount(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationTransitAirlineLegsItems0) validateArrivalTimeMeridian(formats strfmt.Registry) error {
	if swag.IsZero(o.ArrivalTimeMeridian) { // not required
		return nil
	}

	if err := validate.MaxLength("arrivalTimeMeridian", "body", o.ArrivalTimeMeridian, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationTransitAirlineLegsItems0) validateCarrierCode(formats strfmt.Registry) error {
	if swag.IsZero(o.CarrierCode) { // not required
		return nil
	}

	if err := validate.MaxLength("carrierCode", "body", o.CarrierCode, 4); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationTransitAirlineLegsItems0) validateClass(formats strfmt.Registry) error {
	if swag.IsZero(o.Class) { // not required
		return nil
	}

	if err := validate.MaxLength("class", "body", o.Class, 3); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationTransitAirlineLegsItems0) validateConjunctionTicket(formats strfmt.Registry) error {
	if swag.IsZero(o.ConjunctionTicket) { // not required
		return nil
	}

	if err := validate.MaxLength("conjunctionTicket", "body", o.ConjunctionTicket, 25); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationTransitAirlineLegsItems0) validateCouponNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.CouponNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("couponNumber", "body", o.CouponNumber, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationTransitAirlineLegsItems0) validateDepartTaxAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.DepartTaxAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("departTaxAmount", "body", o.DepartTaxAmount, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationTransitAirlineLegsItems0) validateDepartureTimeMeridian(formats strfmt.Registry) error {
	if swag.IsZero(o.DepartureTimeMeridian) { // not required
		return nil
	}

	if err := validate.MaxLength("departureTimeMeridian", "body", o.DepartureTimeMeridian, 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationTransitAirlineLegsItems0) validateDestinationAirportCode(formats strfmt.Registry) error {
	if swag.IsZero(o.DestinationAirportCode) { // not required
		return nil
	}

	if err := validate.MaxLength("destinationAirportCode", "body", o.DestinationAirportCode, 3); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationTransitAirlineLegsItems0) validateEndorsementsRestrictions(formats strfmt.Registry) error {
	if swag.IsZero(o.EndorsementsRestrictions) { // not required
		return nil
	}

	if err := validate.MaxLength("endorsementsRestrictions", "body", o.EndorsementsRestrictions, 20); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationTransitAirlineLegsItems0) validateExchangeTicketNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.ExchangeTicketNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("exchangeTicketNumber", "body", o.ExchangeTicketNumber, 25); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationTransitAirlineLegsItems0) validateFareBasis(formats strfmt.Registry) error {
	if swag.IsZero(o.FareBasis) { // not required
		return nil
	}

	if err := validate.MaxLength("fareBasis", "body", o.FareBasis, 15); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationTransitAirlineLegsItems0) validateFeeAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.FeeAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("feeAmount", "body", o.FeeAmount, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationTransitAirlineLegsItems0) validateFlightNumber(formats strfmt.Registry) error {
	if swag.IsZero(o.FlightNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("flightNumber", "body", o.FlightNumber, 6); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationTransitAirlineLegsItems0) validateOriginatingAirportCode(formats strfmt.Registry) error {
	if swag.IsZero(o.OriginatingAirportCode) { // not required
		return nil
	}

	if err := validate.MaxLength("originatingAirportCode", "body", o.OriginatingAirportCode, 5); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationTransitAirlineLegsItems0) validateTaxAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.TaxAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("taxAmount", "body", o.TaxAmount, 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationTransitAirlineLegsItems0) validateTotalFareAmount(formats strfmt.Registry) error {
	if swag.IsZero(o.TotalFareAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("totalFareAmount", "body", o.TotalFareAmount, 15); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment params body travel information transit airline legs items0 based on context it is used
func (o *CreatePaymentParamsBodyTravelInformationTransitAirlineLegsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyTravelInformationTransitAirlineLegsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyTravelInformationTransitAirlineLegsItems0) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyTravelInformationTransitAirlineLegsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyTravelInformationTransitAirlineTicketIssuer create payment params body travel information transit airline ticket issuer
swagger:model CreatePaymentParamsBodyTravelInformationTransitAirlineTicketIssuer
*/
type CreatePaymentParamsBodyTravelInformationTransitAirlineTicketIssuer struct {

	// Address of the company issuing the ticket.
	//
	// Max Length: 16
	Address string `json:"address,omitempty"`

	// State in which transaction occured.
	//
	// Max Length: 18
	AdministrativeArea string `json:"administrativeArea,omitempty"`

	// IATA2 airline code.
	// Format: English characters only.
	// Required for Mastercard; optional for all other card types.
	//
	// Max Length: 4
	Code string `json:"code,omitempty"`

	// Country in which transaction occured.
	//
	// Max Length: 18
	Country string `json:"country,omitempty"`

	// City in which the transaction occurred.
	// If the name of the city exceeds 18 characters, use meaningful abbreviations.
	// Format: English characters only.
	// Optional request field.
	//
	// Max Length: 18
	Locality string `json:"locality,omitempty"`

	// Name of the ticket issuer. If you do not include this field,
	// CyberSource uses the value for your merchant name that is in the CyberSource merchant configuration database.
	//
	// Max Length: 20
	Name string `json:"name,omitempty"`

	// Zip code of the city in which transaction occured.
	//
	// Max Length: 15
	PostalCode string `json:"postalCode,omitempty"`
}

// Validate validates this create payment params body travel information transit airline ticket issuer
func (o *CreatePaymentParamsBodyTravelInformationTransitAirlineTicketIssuer) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAddress(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAdministrativeArea(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocality(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationTransitAirlineTicketIssuer) validateAddress(formats strfmt.Registry) error {
	if swag.IsZero(o.Address) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"ticketIssuer"+"."+"address", "body", o.Address, 16); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationTransitAirlineTicketIssuer) validateAdministrativeArea(formats strfmt.Registry) error {
	if swag.IsZero(o.AdministrativeArea) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"ticketIssuer"+"."+"administrativeArea", "body", o.AdministrativeArea, 18); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationTransitAirlineTicketIssuer) validateCode(formats strfmt.Registry) error {
	if swag.IsZero(o.Code) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"ticketIssuer"+"."+"code", "body", o.Code, 4); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationTransitAirlineTicketIssuer) validateCountry(formats strfmt.Registry) error {
	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"ticketIssuer"+"."+"country", "body", o.Country, 18); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationTransitAirlineTicketIssuer) validateLocality(formats strfmt.Registry) error {
	if swag.IsZero(o.Locality) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"ticketIssuer"+"."+"locality", "body", o.Locality, 18); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationTransitAirlineTicketIssuer) validateName(formats strfmt.Registry) error {
	if swag.IsZero(o.Name) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"ticketIssuer"+"."+"name", "body", o.Name, 20); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyTravelInformationTransitAirlineTicketIssuer) validatePostalCode(formats strfmt.Registry) error {
	if swag.IsZero(o.PostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"travelInformation"+"."+"transit"+"."+"airline"+"."+"ticketIssuer"+"."+"postalCode", "body", o.PostalCode, 15); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this create payment params body travel information transit airline ticket issuer based on context it is used
func (o *CreatePaymentParamsBodyTravelInformationTransitAirlineTicketIssuer) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyTravelInformationTransitAirlineTicketIssuer) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyTravelInformationTransitAirlineTicketIssuer) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyTravelInformationTransitAirlineTicketIssuer
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}
