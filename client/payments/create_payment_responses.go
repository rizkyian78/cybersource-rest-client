// Code generated by go-swagger; DO NOT EDIT.

package payments

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"
	"io"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"

	strfmt "github.com/go-openapi/strfmt"
)

// CreatePaymentReader is a Reader for the CreatePayment structure.
type CreatePaymentReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *CreatePaymentReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 201:
		result := NewCreatePaymentCreated()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	case 400:
		result := NewCreatePaymentBadRequest()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 502:
		result := NewCreatePaymentBadGateway()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result

	default:
		return nil, runtime.NewAPIError("unknown error", response, response.Code())
	}
}

// NewCreatePaymentCreated creates a CreatePaymentCreated with default headers values
func NewCreatePaymentCreated() *CreatePaymentCreated {
	return &CreatePaymentCreated{}
}

/*CreatePaymentCreated handles this case with default header values.

Successful response.
*/
type CreatePaymentCreated struct {
	Payload *CreatePaymentCreatedBody
}

func (o *CreatePaymentCreated) Error() string {
	return fmt.Sprintf("[POST /pts/v2/payments/][%d] createPaymentCreated  %+v", 201, o.Payload)
}

func (o *CreatePaymentCreated) GetPayload() *CreatePaymentCreatedBody {
	return o.Payload
}

func (o *CreatePaymentCreated) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(CreatePaymentCreatedBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewCreatePaymentBadRequest creates a CreatePaymentBadRequest with default headers values
func NewCreatePaymentBadRequest() *CreatePaymentBadRequest {
	return &CreatePaymentBadRequest{}
}

/*CreatePaymentBadRequest handles this case with default header values.

Invalid request.
*/
type CreatePaymentBadRequest struct {
	Payload *CreatePaymentBadRequestBody
}

func (o *CreatePaymentBadRequest) Error() string {
	return fmt.Sprintf("[POST /pts/v2/payments/][%d] createPaymentBadRequest  %+v", 400, o.Payload)
}

func (o *CreatePaymentBadRequest) GetPayload() *CreatePaymentBadRequestBody {
	return o.Payload
}

func (o *CreatePaymentBadRequest) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(CreatePaymentBadRequestBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewCreatePaymentBadGateway creates a CreatePaymentBadGateway with default headers values
func NewCreatePaymentBadGateway() *CreatePaymentBadGateway {
	return &CreatePaymentBadGateway{}
}

/*CreatePaymentBadGateway handles this case with default header values.

Unexpected system error or system timeout.
*/
type CreatePaymentBadGateway struct {
	Payload *CreatePaymentBadGatewayBody
}

func (o *CreatePaymentBadGateway) Error() string {
	return fmt.Sprintf("[POST /pts/v2/payments/][%d] createPaymentBadGateway  %+v", 502, o.Payload)
}

func (o *CreatePaymentBadGateway) GetPayload() *CreatePaymentBadGatewayBody {
	return o.Payload
}

func (o *CreatePaymentBadGateway) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(CreatePaymentBadGatewayBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

/*CreatePaymentBadGatewayBody ptsV2PaymentsPost502Response
swagger:model CreatePaymentBadGatewayBody
*/
type CreatePaymentBadGatewayBody struct {

	// The detail message related to the status and reason listed above.
	Message string `json:"message,omitempty"`

	// The reason of the status.
	//
	// Possible values:
	//  - SYSTEM_ERROR
	//  - SERVER_TIMEOUT
	//  - SERVICE_TIMEOUT
	//  - INVALID_OR_MISSING_CONFIG
	//
	Reason string `json:"reason,omitempty"`

	// The status of the submitted transaction.
	//
	// Possible values:
	//  - SERVER_ERROR
	//
	Status string `json:"status,omitempty"`

	// Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ`
	// Example `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the
	// time. The `Z` indicates UTC.
	//
	SubmitTimeUtc string `json:"submitTimeUtc,omitempty"`
}

// Validate validates this create payment bad gateway body
func (o *CreatePaymentBadGatewayBody) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentBadGatewayBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentBadGatewayBody) UnmarshalBinary(b []byte) error {
	var res CreatePaymentBadGatewayBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentBadRequestBody ptsV2PaymentsPost400Response
swagger:model CreatePaymentBadRequestBody
*/
type CreatePaymentBadRequestBody struct {

	// details
	Details []*DetailsItems0 `json:"details"`

	// The detail message related to the status and reason listed above.
	Message string `json:"message,omitempty"`

	// The reason of the status.
	//
	// Possible values:
	//  - MISSING_FIELD
	//  - INVALID_DATA
	//  - DUPLICATE_REQUEST
	//  - INVALID_CARD
	//  - CARD_TYPE_NOT_ACCEPTED
	//  - INVALID_MERCHANT_CONFIGURATION
	//  - PROCESSOR_UNAVAILABLE
	//  - INVALID_AMOUNT
	//  - INVALID_CARD_TYPE
	//  - INVALID_PAYMENT_ID
	//  - DEBIT_CARD_USEAGE_EXCEEDD_LIMIT
	//
	Reason string `json:"reason,omitempty"`

	// The status of the submitted transaction.
	//
	// Possible values:
	//  - INVALID_REQUEST
	//
	Status string `json:"status,omitempty"`

	// Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ`
	// Example `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the
	// time. The `Z` indicates UTC.
	//
	SubmitTimeUtc string `json:"submitTimeUtc,omitempty"`
}

// Validate validates this create payment bad request body
func (o *CreatePaymentBadRequestBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentBadRequestBody) validateDetails(formats strfmt.Registry) error {

	if swag.IsZero(o.Details) { // not required
		return nil
	}

	for i := 0; i < len(o.Details); i++ {
		if swag.IsZero(o.Details[i]) { // not required
			continue
		}

		if o.Details[i] != nil {
			if err := o.Details[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("createPaymentBadRequest" + "." + "details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentBadRequestBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentBadRequestBody) UnmarshalBinary(b []byte) error {
	var res CreatePaymentBadRequestBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentBody create payment body
swagger:model CreatePaymentBody
*/
type CreatePaymentBody struct {

	// aggregator information
	AggregatorInformation *CreatePaymentParamsBodyAggregatorInformation `json:"aggregatorInformation,omitempty"`

	// buyer information
	BuyerInformation *CreatePaymentParamsBodyBuyerInformation `json:"buyerInformation,omitempty"`

	// client reference information
	ClientReferenceInformation *CreatePaymentParamsBodyClientReferenceInformation `json:"clientReferenceInformation,omitempty"`

	// consumer authentication information
	ConsumerAuthenticationInformation *CreatePaymentParamsBodyConsumerAuthenticationInformation `json:"consumerAuthenticationInformation,omitempty"`

	// device information
	DeviceInformation *CreatePaymentParamsBodyDeviceInformation `json:"deviceInformation,omitempty"`

	// installment information
	InstallmentInformation *CreatePaymentParamsBodyInstallmentInformation `json:"installmentInformation,omitempty"`

	// issuer information
	IssuerInformation *CreatePaymentParamsBodyIssuerInformation `json:"issuerInformation,omitempty"`

	// The object containing the custom data that the merchant defines.
	//
	MerchantDefinedInformation []*MerchantDefinedInformationItems0 `json:"merchantDefinedInformation"`

	// merchant information
	MerchantInformation *CreatePaymentParamsBodyMerchantInformation `json:"merchantInformation,omitempty"`

	// order information
	OrderInformation *CreatePaymentParamsBodyOrderInformation `json:"orderInformation,omitempty"`

	// payment information
	PaymentInformation *CreatePaymentParamsBodyPaymentInformation `json:"paymentInformation,omitempty"`

	// point of sale information
	PointOfSaleInformation *CreatePaymentParamsBodyPointOfSaleInformation `json:"pointOfSaleInformation,omitempty"`

	// processing information
	ProcessingInformation *CreatePaymentParamsBodyProcessingInformation `json:"processingInformation,omitempty"`

	// recipient information
	RecipientInformation *CreatePaymentParamsBodyRecipientInformation `json:"recipientInformation,omitempty"`
}

// Validate validates this create payment body
func (o *CreatePaymentBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAggregatorInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBuyerInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateClientReferenceInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateConsumerAuthenticationInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDeviceInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateInstallmentInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateIssuerInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMerchantDefinedInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMerchantInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOrderInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePaymentInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePointOfSaleInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProcessingInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRecipientInformation(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentBody) validateAggregatorInformation(formats strfmt.Registry) error {

	if swag.IsZero(o.AggregatorInformation) { // not required
		return nil
	}

	if o.AggregatorInformation != nil {
		if err := o.AggregatorInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "aggregatorInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentBody) validateBuyerInformation(formats strfmt.Registry) error {

	if swag.IsZero(o.BuyerInformation) { // not required
		return nil
	}

	if o.BuyerInformation != nil {
		if err := o.BuyerInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "buyerInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentBody) validateClientReferenceInformation(formats strfmt.Registry) error {

	if swag.IsZero(o.ClientReferenceInformation) { // not required
		return nil
	}

	if o.ClientReferenceInformation != nil {
		if err := o.ClientReferenceInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "clientReferenceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentBody) validateConsumerAuthenticationInformation(formats strfmt.Registry) error {

	if swag.IsZero(o.ConsumerAuthenticationInformation) { // not required
		return nil
	}

	if o.ConsumerAuthenticationInformation != nil {
		if err := o.ConsumerAuthenticationInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "consumerAuthenticationInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentBody) validateDeviceInformation(formats strfmt.Registry) error {

	if swag.IsZero(o.DeviceInformation) { // not required
		return nil
	}

	if o.DeviceInformation != nil {
		if err := o.DeviceInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "deviceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentBody) validateInstallmentInformation(formats strfmt.Registry) error {

	if swag.IsZero(o.InstallmentInformation) { // not required
		return nil
	}

	if o.InstallmentInformation != nil {
		if err := o.InstallmentInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "installmentInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentBody) validateIssuerInformation(formats strfmt.Registry) error {

	if swag.IsZero(o.IssuerInformation) { // not required
		return nil
	}

	if o.IssuerInformation != nil {
		if err := o.IssuerInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "issuerInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentBody) validateMerchantDefinedInformation(formats strfmt.Registry) error {

	if swag.IsZero(o.MerchantDefinedInformation) { // not required
		return nil
	}

	for i := 0; i < len(o.MerchantDefinedInformation); i++ {
		if swag.IsZero(o.MerchantDefinedInformation[i]) { // not required
			continue
		}

		if o.MerchantDefinedInformation[i] != nil {
			if err := o.MerchantDefinedInformation[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("createPaymentRequest" + "." + "merchantDefinedInformation" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CreatePaymentBody) validateMerchantInformation(formats strfmt.Registry) error {

	if swag.IsZero(o.MerchantInformation) { // not required
		return nil
	}

	if o.MerchantInformation != nil {
		if err := o.MerchantInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "merchantInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentBody) validateOrderInformation(formats strfmt.Registry) error {

	if swag.IsZero(o.OrderInformation) { // not required
		return nil
	}

	if o.OrderInformation != nil {
		if err := o.OrderInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "orderInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentBody) validatePaymentInformation(formats strfmt.Registry) error {

	if swag.IsZero(o.PaymentInformation) { // not required
		return nil
	}

	if o.PaymentInformation != nil {
		if err := o.PaymentInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "paymentInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentBody) validatePointOfSaleInformation(formats strfmt.Registry) error {

	if swag.IsZero(o.PointOfSaleInformation) { // not required
		return nil
	}

	if o.PointOfSaleInformation != nil {
		if err := o.PointOfSaleInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "pointOfSaleInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentBody) validateProcessingInformation(formats strfmt.Registry) error {

	if swag.IsZero(o.ProcessingInformation) { // not required
		return nil
	}

	if o.ProcessingInformation != nil {
		if err := o.ProcessingInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "processingInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentBody) validateRecipientInformation(formats strfmt.Registry) error {

	if swag.IsZero(o.RecipientInformation) { // not required
		return nil
	}

	if o.RecipientInformation != nil {
		if err := o.RecipientInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "recipientInformation")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentBody) UnmarshalBinary(b []byte) error {
	var res CreatePaymentBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBody ptsV2PaymentsPost201Response
swagger:model CreatePaymentCreatedBody
*/
type CreatePaymentCreatedBody struct {

	// links
	Links *CreatePaymentCreatedBodyLinks `json:"_links,omitempty"`

	// client reference information
	ClientReferenceInformation *CreatePaymentCreatedBodyClientReferenceInformation `json:"clientReferenceInformation,omitempty"`

	// error information
	ErrorInformation *CreatePaymentCreatedBodyErrorInformation `json:"errorInformation,omitempty"`

	// An unique identification number assigned by CyberSource to identify the submitted request. It is also appended to the endpoint of the resource.
	// Max Length: 26
	ID string `json:"id,omitempty"`

	// installment information
	InstallmentInformation *CreatePaymentCreatedBodyInstallmentInformation `json:"installmentInformation,omitempty"`

	// issuer information
	IssuerInformation *CreatePaymentCreatedBodyIssuerInformation `json:"issuerInformation,omitempty"`

	// order information
	OrderInformation *CreatePaymentCreatedBodyOrderInformation `json:"orderInformation,omitempty"`

	// payment information
	PaymentInformation *CreatePaymentCreatedBodyPaymentInformation `json:"paymentInformation,omitempty"`

	// point of sale information
	PointOfSaleInformation *CreatePaymentCreatedBodyPointOfSaleInformation `json:"pointOfSaleInformation,omitempty"`

	// processing information
	ProcessingInformation *CreatePaymentCreatedBodyProcessingInformation `json:"processingInformation,omitempty"`

	// processor information
	ProcessorInformation *CreatePaymentCreatedBodyProcessorInformation `json:"processorInformation,omitempty"`

	// The reconciliation id for the submitted transaction. This value is not returned for all processors.
	//
	// Max Length: 60
	ReconciliationID string `json:"reconciliationId,omitempty"`

	// The status of the submitted transaction.
	//
	// Possible values:
	//  - AUTHORIZED
	//  - PARTIAL_AUTHORIZED
	//  - AUTHORIZED_PENDING_REVIEW
	//  - DECLINED
	//  - INVALID_REQUEST
	//
	Status string `json:"status,omitempty"`

	// Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ`
	// Example `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the
	// time. The `Z` indicates UTC.
	//
	SubmitTimeUtc string `json:"submitTimeUtc,omitempty"`
}

// Validate validates this create payment created body
func (o *CreatePaymentCreatedBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateClientReferenceInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateErrorInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateInstallmentInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateIssuerInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOrderInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePaymentInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePointOfSaleInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProcessingInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProcessorInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateReconciliationID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBody) validateLinks(formats strfmt.Registry) error {

	if swag.IsZero(o.Links) { // not required
		return nil
	}

	if o.Links != nil {
		if err := o.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBody) validateClientReferenceInformation(formats strfmt.Registry) error {

	if swag.IsZero(o.ClientReferenceInformation) { // not required
		return nil
	}

	if o.ClientReferenceInformation != nil {
		if err := o.ClientReferenceInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "clientReferenceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBody) validateErrorInformation(formats strfmt.Registry) error {

	if swag.IsZero(o.ErrorInformation) { // not required
		return nil
	}

	if o.ErrorInformation != nil {
		if err := o.ErrorInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "errorInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBody) validateID(formats strfmt.Registry) error {

	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"id", "body", string(o.ID), 26); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBody) validateInstallmentInformation(formats strfmt.Registry) error {

	if swag.IsZero(o.InstallmentInformation) { // not required
		return nil
	}

	if o.InstallmentInformation != nil {
		if err := o.InstallmentInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "installmentInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBody) validateIssuerInformation(formats strfmt.Registry) error {

	if swag.IsZero(o.IssuerInformation) { // not required
		return nil
	}

	if o.IssuerInformation != nil {
		if err := o.IssuerInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "issuerInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBody) validateOrderInformation(formats strfmt.Registry) error {

	if swag.IsZero(o.OrderInformation) { // not required
		return nil
	}

	if o.OrderInformation != nil {
		if err := o.OrderInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "orderInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBody) validatePaymentInformation(formats strfmt.Registry) error {

	if swag.IsZero(o.PaymentInformation) { // not required
		return nil
	}

	if o.PaymentInformation != nil {
		if err := o.PaymentInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "paymentInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBody) validatePointOfSaleInformation(formats strfmt.Registry) error {

	if swag.IsZero(o.PointOfSaleInformation) { // not required
		return nil
	}

	if o.PointOfSaleInformation != nil {
		if err := o.PointOfSaleInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "pointOfSaleInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBody) validateProcessingInformation(formats strfmt.Registry) error {

	if swag.IsZero(o.ProcessingInformation) { // not required
		return nil
	}

	if o.ProcessingInformation != nil {
		if err := o.ProcessingInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "processingInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBody) validateProcessorInformation(formats strfmt.Registry) error {

	if swag.IsZero(o.ProcessorInformation) { // not required
		return nil
	}

	if o.ProcessorInformation != nil {
		if err := o.ProcessorInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "processorInformation")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBody) validateReconciliationID(formats strfmt.Registry) error {

	if swag.IsZero(o.ReconciliationID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"reconciliationId", "body", string(o.ReconciliationID), 60); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBody) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyClientReferenceInformation create payment created body client reference information
swagger:model CreatePaymentCreatedBodyClientReferenceInformation
*/
type CreatePaymentCreatedBodyClientReferenceInformation struct {

	// Client-generated order reference or tracking number. CyberSource recommends that you send a unique value for each
	// transaction so that you can perform meaningful searches for the transaction.
	//
	// For information about tracking orders, see "Tracking and Reconciling Your Orders" in [Getting Started with CyberSource Advanced for the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Getting_Started_SCMP/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// #### FDC Nashville Global
	// Certain circumstances can cause the processor to truncate this value to 15 or 17 characters for Level II and Level III processing, which can cause a discrepancy between the value you submit and the value included in some processor reports.
	//
	// Max Length: 50
	Code string `json:"code,omitempty"`

	// Merchant ID that was used to create the subscription or customer profile for which the service was requested.
	//
	// If your CyberSource account is enabled for Recurring Billing, this field is returned only if you are using
	// subscription sharing and if your merchant ID is in the same merchant ID pool as the owner merchant ID.
	//
	// If your CyberSource account is enabled for Payment Tokenization, this field is returned only if you are using
	// profile sharing and if your merchant ID is in the same merchant ID pool as the owner merchant ID.
	//
	// For details about how this field is used for Recurring Billing or Payment Tokenization, see the `ecp_debit_owner_merchant_id` field description in the [Electronic Check Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/EChecks_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	OwnerMerchantID string `json:"ownerMerchantId,omitempty"`

	// Date and time at your physical location.
	//
	// Format: `YYYYMMDDhhmmss`, where YYYY = year, MM = month, DD = day, hh = hour, mm = minutes ss = seconds
	//
	// Max Length: 14
	SubmitLocalDateTime string `json:"submitLocalDateTime,omitempty"`
}

// Validate validates this create payment created body client reference information
func (o *CreatePaymentCreatedBodyClientReferenceInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSubmitLocalDateTime(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyClientReferenceInformation) validateCode(formats strfmt.Registry) error {

	if swag.IsZero(o.Code) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"clientReferenceInformation"+"."+"code", "body", string(o.Code), 50); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyClientReferenceInformation) validateSubmitLocalDateTime(formats strfmt.Registry) error {

	if swag.IsZero(o.SubmitLocalDateTime) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"clientReferenceInformation"+"."+"submitLocalDateTime", "body", string(o.SubmitLocalDateTime), 14); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyClientReferenceInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyClientReferenceInformation) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyClientReferenceInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyErrorInformation create payment created body error information
swagger:model CreatePaymentCreatedBodyErrorInformation
*/
type CreatePaymentCreatedBodyErrorInformation struct {

	// details
	Details []*CreatePaymentCreatedBodyErrorInformationDetailsItems0 `json:"details"`

	// The detail message related to the status and reason listed above.
	Message string `json:"message,omitempty"`

	// The reason of the status.
	//
	// Possible values:
	//  - AVS_FAILED
	//  - CONTACT_PROCESSOR
	//  - EXPIRED_CARD
	//  - PROCESSOR_DECLINED
	//  - INSUFFICIENT_FUND
	//  - STOLEN_LOST_CARD
	//  - ISSUER_UNAVAILABLE
	//  - UNAUTHORIZED_CARD
	//  - CVN_NOT_MATCH
	//  - EXCEEDS_CREDIT_LIMIT
	//  - INVALID_CVN
	//  - DECLINED_CHECK
	//  - BLACKLISTED_CUSTOMER
	//  - SUSPENDED_ACCOUNT
	//  - PAYMENT_REFUSED
	//  - CV_FAILED
	//  - INVALID_ACCOUNT
	//  - GENERAL_DECLINE
	//  - INVALID_MERCHANT_CONFIGURATION
	//  - DECISION_PROFILE_REJECT
	//  - SCORE_EXCEEDS_THRESHOLD
	//  - PENDING_AUTHENTICATION
	//
	Reason string `json:"reason,omitempty"`
}

// Validate validates this create payment created body error information
func (o *CreatePaymentCreatedBodyErrorInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyErrorInformation) validateDetails(formats strfmt.Registry) error {

	if swag.IsZero(o.Details) { // not required
		return nil
	}

	for i := 0; i < len(o.Details); i++ {
		if swag.IsZero(o.Details[i]) { // not required
			continue
		}

		if o.Details[i] != nil {
			if err := o.Details[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("createPaymentCreated" + "." + "errorInformation" + "." + "details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyErrorInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyErrorInformation) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyErrorInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyErrorInformationDetailsItems0 create payment created body error information details items0
swagger:model CreatePaymentCreatedBodyErrorInformationDetailsItems0
*/
type CreatePaymentCreatedBodyErrorInformationDetailsItems0 struct {

	// This is the flattened JSON object field name/path that is either missing or invalid.
	Field string `json:"field,omitempty"`

	// Possible reasons for the error.
	//
	// Possible values:
	//  - MISSING_FIELD
	//  - INVALID_DATA
	//
	Reason string `json:"reason,omitempty"`
}

// Validate validates this create payment created body error information details items0
func (o *CreatePaymentCreatedBodyErrorInformationDetailsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyErrorInformationDetailsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyErrorInformationDetailsItems0) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyErrorInformationDetailsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyInstallmentInformation create payment created body installment information
swagger:model CreatePaymentCreatedBodyInstallmentInformation
*/
type CreatePaymentCreatedBodyInstallmentInformation struct {

	// Additional costs charged by the issuer to fund the installment payments.
	//
	// This field is included in the authorization reply for the Crediario eligibility request when the issuer approves
	// the cardholder's request for Crediario installment payments in Brazil.
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file1:
	// - Record: CP01 TCR9
	// - Position: 128-139
	// - Field: Total Other Costs
	//
	// Max Length: 12
	AdditionalCosts string `json:"additionalCosts,omitempty"`

	// Additional costs divided by the amount funded.
	//
	// For example:
	// - A value of 1.0 specifies 1%.
	// - A value of 4.0 specifies 4%.
	//
	// This field is included in the authorization reply for the Crediario eligibility request when the issuer approves
	// the cardholder's request for Crediario installment payments in Brazil.
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file1:
	// - Record: CP01 TCR9
	// - Position: 140-143
	// - Field: Percent of Total Other Costs
	//
	// Max Length: 4
	AdditionalCostsPercentage string `json:"additionalCostsPercentage,omitempty"`

	// Amount funded.
	//
	// This field is included in the authorization reply for the Crediario eligibility request when the issuer approves
	// the cardholder's request for Crediario installment payments in Brazil.
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file1:
	// - Record: CP01 TCR9
	// - Position: 48-59
	// - Field: Total Amount Funded
	//
	// Max Length: 12
	AmountFunded string `json:"amountFunded,omitempty"`

	// Amount requested divided by the amount funded.
	//
	// For example:
	// - A value of 90.0 specifies 90%.
	// - A value of 93.7 specifies 93.7%.
	//
	// This field is included in the authorization reply for the Crediario eligibility request when the issuer approves
	// the cardholder's request for Crediario installment payments in Brazil.
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file1:
	// - Record: CP01 TCR9
	// - Position: 60-63
	// - Field: Percent of Amount Requested
	//
	// Max Length: 4
	AmountRequestedPercentage string `json:"amountRequestedPercentage,omitempty"`

	// Annual cost of financing the installment payments.
	//
	// This field is included in the authorization reply for the Crediario eligibility request when the issuer approves
	// the cardholder's request for Crediario installment payments in Brazil.
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file1:
	// - Record: CP01 TCR9
	// - Position: 158-164
	// - Field: Annual Total Cost of Financing
	//
	// Max Length: 7
	AnnualFinancingCost string `json:"annualFinancingCost,omitempty"`

	// Annual interest rate.
	//
	// For example:
	// - A value of 1.0 specifies 1%.
	// - A value of 4.0 specifies 4%.
	//
	// This field is included in the authorization reply for the Crediario eligibility request when the issuer approves
	// the cardholder's request for Crediario installment payments in Brazil.
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file1:
	// - Record: CP01 TCR9
	// - Position: 151-157
	// - Field: Annual Interest Rate
	//
	// Max Length: 7
	AnnualInterestRate string `json:"annualInterestRate,omitempty"`

	// Expenses charged by the issuer to fund the installment payments.
	//
	// This field is included in the authorization reply for the Crediario eligibility request when the issuer approves
	// the cardholder's request for Crediario installment payments in Brazil.
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file1:
	// - Record: CP01 TCR9
	// - Position: 64-75
	// - Field: Total Expenses
	//
	// Max Length: 12
	Expenses string `json:"expenses,omitempty"`

	// Expenses divided by the amount funded.
	//
	// For example:
	// - A value of 1.0 specifies 1%.
	// - A value of 4.0 specifies 4%.
	//
	// This field is included in the authorization reply for the Crediario eligibility request when the issuer approves
	// the cardholder's request for Crediario installment payments in Brazil.
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file1:
	// - Record: CP01 TCR9
	// - Position: 76-79
	// - Field: Percent of Total Expenses
	//
	// Max Length: 4
	ExpensesPercentage string `json:"expensesPercentage,omitempty"`

	// Fees charged by the issuer to fund the installment payments.
	//
	// This field is included in the authorization reply for the Crediario eligibility request when the issuer approves
	// the cardholder's request for Crediario installment payments in Brazil.
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file1:
	// - Record: CP01 TCR9
	// - Position: 80-91
	// - Field: Total Fees
	//
	// Max Length: 12
	Fees string `json:"fees,omitempty"`

	// Fees divided by the amount funded.
	//
	// For example:
	// - A value of 1.0 specifies 1%.
	// - A value of 4.0 specifies 4%.
	//
	// This field is included in the authorization reply for the Crediario eligibility request when the issuer approves
	// the cardholder's request for Crediario installment payments in Brazil.
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// This field is supported only for Crediario installment payments in Brazil on CyberSource through VisaNet.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file1:
	// - Record: CP01 TCR9
	// - Position: 92-95
	// - Field: Percent of Total Fees
	//
	// Max Length: 4
	FeesPercentage string `json:"feesPercentage,omitempty"`

	// Insurance charged by the issuer to fund the installment payments.
	//
	// This field is included in the authorization reply for the Crediario eligibility request when the issuer approves
	// the cardholder's request for Crediario installment payments in Brazil.
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file1:
	// - Record: CP01 TCR9
	// - Position: 112-123
	// - Field: Total Insurance
	//
	// Max Length: 12
	Insurance string `json:"insurance,omitempty"`

	// Insurance costs divided by the amount funded.
	//
	// For example:
	// - A value of 1.0 specifies 1%.
	// - A value of 4.0 specifies 4%.
	//
	// This field is included in the authorization reply for the Crediario eligibility request when the issuer approves
	// the cardholder's request for Crediario installment payments in Brazil.
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file1:
	// - Record: CP01 TCR9
	// - Position: 124-127
	// - Field: Percent Of Total Insurance
	//
	// Max Length: 4
	InsurancePercentage string `json:"insurancePercentage,omitempty"`

	// Monthly interest rate.
	//
	// For example:
	// - A value of 1.0 specifies 1%.
	// - A value of 4.0 specifies 4%.
	//
	// This field is included in the authorization reply for the Crediario eligibility request when the issuer approves
	// the cardholder's request for Crediario installment payments in Brazil.
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file1:
	// - Record: CP01 TCR9
	// - Position: 144-150
	// - Field: Monthly Interest Rate
	//
	// Max Length: 7
	MonthlyInterestRate string `json:"monthlyInterestRate,omitempty"`

	// Taxes collected by the issuer to fund the installment payments.
	//
	// This field is included in the authorization reply for the Crediario eligibility request when the issuer approves
	// the cardholder's request for Crediario installment payments in Brazil.
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file1:
	// - Record: CP01 TCR9
	// - Position: 96-107
	// - Field: Total Taxes
	//
	// Max Length: 12
	Taxes string `json:"taxes,omitempty"`

	// Taxes divided by the amount funded.
	//
	// For example:
	// - A value of 1.0 specifies 1%.
	// - A value of 4.0 specifies 4%.
	//
	// This field is included in the authorization reply for the Crediario eligibility request when the issuer approves
	// the cardholder's request for Crediario installment payments in Brazil.
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file1:
	// - Record: CP01 TCR9
	// - Position: 108-111
	// - Field: Percent of Total Taxes
	//
	// Max Length: 4
	TaxesPercentage string `json:"taxesPercentage,omitempty"`
}

// Validate validates this create payment created body installment information
func (o *CreatePaymentCreatedBodyInstallmentInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAdditionalCosts(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAdditionalCostsPercentage(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAmountFunded(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAmountRequestedPercentage(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAnnualFinancingCost(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAnnualInterestRate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpenses(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpensesPercentage(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFees(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFeesPercentage(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateInsurance(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateInsurancePercentage(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMonthlyInterestRate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxes(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxesPercentage(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyInstallmentInformation) validateAdditionalCosts(formats strfmt.Registry) error {

	if swag.IsZero(o.AdditionalCosts) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"installmentInformation"+"."+"additionalCosts", "body", string(o.AdditionalCosts), 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyInstallmentInformation) validateAdditionalCostsPercentage(formats strfmt.Registry) error {

	if swag.IsZero(o.AdditionalCostsPercentage) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"installmentInformation"+"."+"additionalCostsPercentage", "body", string(o.AdditionalCostsPercentage), 4); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyInstallmentInformation) validateAmountFunded(formats strfmt.Registry) error {

	if swag.IsZero(o.AmountFunded) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"installmentInformation"+"."+"amountFunded", "body", string(o.AmountFunded), 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyInstallmentInformation) validateAmountRequestedPercentage(formats strfmt.Registry) error {

	if swag.IsZero(o.AmountRequestedPercentage) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"installmentInformation"+"."+"amountRequestedPercentage", "body", string(o.AmountRequestedPercentage), 4); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyInstallmentInformation) validateAnnualFinancingCost(formats strfmt.Registry) error {

	if swag.IsZero(o.AnnualFinancingCost) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"installmentInformation"+"."+"annualFinancingCost", "body", string(o.AnnualFinancingCost), 7); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyInstallmentInformation) validateAnnualInterestRate(formats strfmt.Registry) error {

	if swag.IsZero(o.AnnualInterestRate) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"installmentInformation"+"."+"annualInterestRate", "body", string(o.AnnualInterestRate), 7); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyInstallmentInformation) validateExpenses(formats strfmt.Registry) error {

	if swag.IsZero(o.Expenses) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"installmentInformation"+"."+"expenses", "body", string(o.Expenses), 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyInstallmentInformation) validateExpensesPercentage(formats strfmt.Registry) error {

	if swag.IsZero(o.ExpensesPercentage) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"installmentInformation"+"."+"expensesPercentage", "body", string(o.ExpensesPercentage), 4); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyInstallmentInformation) validateFees(formats strfmt.Registry) error {

	if swag.IsZero(o.Fees) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"installmentInformation"+"."+"fees", "body", string(o.Fees), 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyInstallmentInformation) validateFeesPercentage(formats strfmt.Registry) error {

	if swag.IsZero(o.FeesPercentage) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"installmentInformation"+"."+"feesPercentage", "body", string(o.FeesPercentage), 4); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyInstallmentInformation) validateInsurance(formats strfmt.Registry) error {

	if swag.IsZero(o.Insurance) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"installmentInformation"+"."+"insurance", "body", string(o.Insurance), 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyInstallmentInformation) validateInsurancePercentage(formats strfmt.Registry) error {

	if swag.IsZero(o.InsurancePercentage) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"installmentInformation"+"."+"insurancePercentage", "body", string(o.InsurancePercentage), 4); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyInstallmentInformation) validateMonthlyInterestRate(formats strfmt.Registry) error {

	if swag.IsZero(o.MonthlyInterestRate) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"installmentInformation"+"."+"monthlyInterestRate", "body", string(o.MonthlyInterestRate), 7); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyInstallmentInformation) validateTaxes(formats strfmt.Registry) error {

	if swag.IsZero(o.Taxes) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"installmentInformation"+"."+"taxes", "body", string(o.Taxes), 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyInstallmentInformation) validateTaxesPercentage(formats strfmt.Registry) error {

	if swag.IsZero(o.TaxesPercentage) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"installmentInformation"+"."+"taxesPercentage", "body", string(o.TaxesPercentage), 4); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyInstallmentInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyInstallmentInformation) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyInstallmentInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyIssuerInformation create payment created body issuer information
swagger:model CreatePaymentCreatedBodyIssuerInformation
*/
type CreatePaymentCreatedBodyIssuerInformation struct {

	// Country in which the card was issued. This information enables you to determine whether the card was issued
	// domestically or internationally. Use the two-character ISO Standard Country Codes.
	//
	// This field is supported for Visa, Mastercard, Discover, Diners Club, JCB, and Maestro (International) on Chase
	// Paymentech Solutions.
	//
	// For details, see `auth_card_issuer_country` field description in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 3
	Country string `json:"country,omitempty"`

	// Data defined by the issuer.
	//
	// The value for this reply field will probably be the same as the value that you submitted in the authorization request, but it is possible for the processor, issuer, or acquirer to modify the value.
	//
	// This field is supported only for Visa transactions on **CyberSource through VisaNet**.
	//
	// For details, see `issuer_additional_data` field description in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 255
	DiscretionaryData string `json:"discretionaryData,omitempty"`

	// Additional authorization code that must be printed on the receipt when returned by the processor.
	//
	// This value is generated by the processor and is returned only for a successful transaction.
	//
	// This field is supported only on FDC Nashville Global and SIX.
	//
	// Max Length: 6
	ResponseCode string `json:"responseCode,omitempty"`
}

// Validate validates this create payment created body issuer information
func (o *CreatePaymentCreatedBodyIssuerInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDiscretionaryData(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateResponseCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyIssuerInformation) validateCountry(formats strfmt.Registry) error {

	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"issuerInformation"+"."+"country", "body", string(o.Country), 3); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyIssuerInformation) validateDiscretionaryData(formats strfmt.Registry) error {

	if swag.IsZero(o.DiscretionaryData) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"issuerInformation"+"."+"discretionaryData", "body", string(o.DiscretionaryData), 255); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyIssuerInformation) validateResponseCode(formats strfmt.Registry) error {

	if swag.IsZero(o.ResponseCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"issuerInformation"+"."+"responseCode", "body", string(o.ResponseCode), 6); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyIssuerInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyIssuerInformation) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyIssuerInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyLinks create payment created body links
swagger:model CreatePaymentCreatedBodyLinks
*/
type CreatePaymentCreatedBodyLinks struct {

	// capture
	Capture *CreatePaymentCreatedBodyLinksCapture `json:"capture,omitempty"`

	// reversal
	Reversal *CreatePaymentCreatedBodyLinksReversal `json:"reversal,omitempty"`

	// self
	Self *CreatePaymentCreatedBodyLinksSelf `json:"self,omitempty"`
}

// Validate validates this create payment created body links
func (o *CreatePaymentCreatedBodyLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCapture(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateReversal(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyLinks) validateCapture(formats strfmt.Registry) error {

	if swag.IsZero(o.Capture) { // not required
		return nil
	}

	if o.Capture != nil {
		if err := o.Capture.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "_links" + "." + "capture")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyLinks) validateReversal(formats strfmt.Registry) error {

	if swag.IsZero(o.Reversal) { // not required
		return nil
	}

	if o.Reversal != nil {
		if err := o.Reversal.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "_links" + "." + "reversal")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyLinks) validateSelf(formats strfmt.Registry) error {

	if swag.IsZero(o.Self) { // not required
		return nil
	}

	if o.Self != nil {
		if err := o.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyLinks) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyLinks) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyLinksCapture create payment created body links capture
swagger:model CreatePaymentCreatedBodyLinksCapture
*/
type CreatePaymentCreatedBodyLinksCapture struct {

	// This is the endpoint of the resource that was created by the successful request.
	Href string `json:"href,omitempty"`

	// `method` refers to the HTTP method that you can send to the `self` endpoint to retrieve details of the resource.
	Method string `json:"method,omitempty"`
}

// Validate validates this create payment created body links capture
func (o *CreatePaymentCreatedBodyLinksCapture) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyLinksCapture) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyLinksCapture) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyLinksCapture
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyLinksReversal create payment created body links reversal
swagger:model CreatePaymentCreatedBodyLinksReversal
*/
type CreatePaymentCreatedBodyLinksReversal struct {

	// This is the endpoint of the resource that was created by the successful request.
	Href string `json:"href,omitempty"`

	// `method` refers to the HTTP method that you can send to the `self` endpoint to retrieve details of the resource.
	Method string `json:"method,omitempty"`
}

// Validate validates this create payment created body links reversal
func (o *CreatePaymentCreatedBodyLinksReversal) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyLinksReversal) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyLinksReversal) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyLinksReversal
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyLinksSelf create payment created body links self
swagger:model CreatePaymentCreatedBodyLinksSelf
*/
type CreatePaymentCreatedBodyLinksSelf struct {

	// This is the endpoint of the resource that was created by the successful request.
	Href string `json:"href,omitempty"`

	// `method` refers to the HTTP method that you can send to the `self` endpoint to retrieve details of the resource.
	Method string `json:"method,omitempty"`
}

// Validate validates this create payment created body links self
func (o *CreatePaymentCreatedBodyLinksSelf) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyLinksSelf) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyLinksSelf) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyLinksSelf
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyOrderInformation create payment created body order information
swagger:model CreatePaymentCreatedBodyOrderInformation
*/
type CreatePaymentCreatedBodyOrderInformation struct {

	// amount details
	AmountDetails *CreatePaymentCreatedBodyOrderInformationAmountDetails `json:"amountDetails,omitempty"`

	// invoice details
	InvoiceDetails *CreatePaymentCreatedBodyOrderInformationInvoiceDetails `json:"invoiceDetails,omitempty"`
}

// Validate validates this create payment created body order information
func (o *CreatePaymentCreatedBodyOrderInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAmountDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateInvoiceDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyOrderInformation) validateAmountDetails(formats strfmt.Registry) error {

	if swag.IsZero(o.AmountDetails) { // not required
		return nil
	}

	if o.AmountDetails != nil {
		if err := o.AmountDetails.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "orderInformation" + "." + "amountDetails")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyOrderInformation) validateInvoiceDetails(formats strfmt.Registry) error {

	if swag.IsZero(o.InvoiceDetails) { // not required
		return nil
	}

	if o.InvoiceDetails != nil {
		if err := o.InvoiceDetails.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "orderInformation" + "." + "invoiceDetails")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyOrderInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyOrderInformation) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyOrderInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyOrderInformationAmountDetails create payment created body order information amount details
swagger:model CreatePaymentCreatedBodyOrderInformationAmountDetails
*/
type CreatePaymentCreatedBodyOrderInformationAmountDetails struct {

	// Amount that was authorized.
	//
	// Max Length: 15
	AuthorizedAmount string `json:"authorizedAmount,omitempty"`

	// Currency used for the order. Use the three-character I[ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)
	//
	// For details about currency as used in partial authorizations, see "Features for Debit Cards and Prepaid Cards" in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// For an authorization reversal (`reversalInformation`) or a capture (`processingOptions.capture` is set to `true`), you must use the same currency that you used in your payment authorization request.
	//
	// #### DCC for First Data
	// Your local currency. For details, see the `currency` field description in [Dynamic Currency Conversion For First Data Using the SCMP API](http://apps.cybersource.com/library/documentation/dev_guides/DCC_FirstData_SCMP/DCC_FirstData_SCMP_API.pdf).
	//
	// Max Length: 3
	Currency string `json:"currency,omitempty"`

	// Amount you requested for the payment or capture.
	//
	// This value is returned for partial authorizations.
	//
	// Max Length: 15
	TotalAmount string `json:"totalAmount,omitempty"`
}

// Validate validates this create payment created body order information amount details
func (o *CreatePaymentCreatedBodyOrderInformationAmountDetails) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAuthorizedAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCurrency(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTotalAmount(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyOrderInformationAmountDetails) validateAuthorizedAmount(formats strfmt.Registry) error {

	if swag.IsZero(o.AuthorizedAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"orderInformation"+"."+"amountDetails"+"."+"authorizedAmount", "body", string(o.AuthorizedAmount), 15); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyOrderInformationAmountDetails) validateCurrency(formats strfmt.Registry) error {

	if swag.IsZero(o.Currency) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"orderInformation"+"."+"amountDetails"+"."+"currency", "body", string(o.Currency), 3); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyOrderInformationAmountDetails) validateTotalAmount(formats strfmt.Registry) error {

	if swag.IsZero(o.TotalAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"orderInformation"+"."+"amountDetails"+"."+"totalAmount", "body", string(o.TotalAmount), 15); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyOrderInformationAmountDetails) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyOrderInformationAmountDetails) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyOrderInformationAmountDetails
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyOrderInformationInvoiceDetails create payment created body order information invoice details
swagger:model CreatePaymentCreatedBodyOrderInformationInvoiceDetails
*/
type CreatePaymentCreatedBodyOrderInformationInvoiceDetails struct {

	// Indicates whether CyberSource sent the Level III information to the processor. The possible values are:
	//
	// If your account is not enabled for Level III data or if you did not include the purchasing level field in your
	// request, CyberSource does not include the Level III data in the request sent to the processor.
	//
	// For processor-specific information, see the `bill_purchasing_level3_enabled` field description in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Possible values:
	// - **true**
	// - **false**
	//
	Level3TransmissionStatus bool `json:"level3TransmissionStatus,omitempty"`
}

// Validate validates this create payment created body order information invoice details
func (o *CreatePaymentCreatedBodyOrderInformationInvoiceDetails) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyOrderInformationInvoiceDetails) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyOrderInformationInvoiceDetails) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyOrderInformationInvoiceDetails
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyPaymentInformation create payment created body payment information
swagger:model CreatePaymentCreatedBodyPaymentInformation
*/
type CreatePaymentCreatedBodyPaymentInformation struct {

	// account features
	AccountFeatures *CreatePaymentCreatedBodyPaymentInformationAccountFeatures `json:"accountFeatures,omitempty"`

	// bank
	Bank *CreatePaymentCreatedBodyPaymentInformationBank `json:"bank,omitempty"`

	// card
	Card *CreatePaymentCreatedBodyPaymentInformationCard `json:"card,omitempty"`

	// tokenized card
	TokenizedCard *CreatePaymentCreatedBodyPaymentInformationTokenizedCard `json:"tokenizedCard,omitempty"`
}

// Validate validates this create payment created body payment information
func (o *CreatePaymentCreatedBodyPaymentInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAccountFeatures(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBank(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCard(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTokenizedCard(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformation) validateAccountFeatures(formats strfmt.Registry) error {

	if swag.IsZero(o.AccountFeatures) { // not required
		return nil
	}

	if o.AccountFeatures != nil {
		if err := o.AccountFeatures.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "paymentInformation" + "." + "accountFeatures")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformation) validateBank(formats strfmt.Registry) error {

	if swag.IsZero(o.Bank) { // not required
		return nil
	}

	if o.Bank != nil {
		if err := o.Bank.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "paymentInformation" + "." + "bank")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformation) validateCard(formats strfmt.Registry) error {

	if swag.IsZero(o.Card) { // not required
		return nil
	}

	if o.Card != nil {
		if err := o.Card.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "paymentInformation" + "." + "card")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformation) validateTokenizedCard(formats strfmt.Registry) error {

	if swag.IsZero(o.TokenizedCard) { // not required
		return nil
	}

	if o.TokenizedCard != nil {
		if err := o.TokenizedCard.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "paymentInformation" + "." + "tokenizedCard")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyPaymentInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyPaymentInformation) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyPaymentInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyPaymentInformationAccountFeatures create payment created body payment information account features
swagger:model CreatePaymentCreatedBodyPaymentInformationAccountFeatures
*/
type CreatePaymentCreatedBodyPaymentInformationAccountFeatures struct {

	// Possible values:
	//
	//  - `N`: Nonregulated
	//  - `R`: Regulated
	//
	// **Note** This field is returned only for CyberSource through VisaNet.
	//
	// Max Length: 1
	AccountStatus string `json:"accountStatus,omitempty"`

	// Type of account. This value is returned only if you requested a balance inquiry. Possible values:
	//
	//  - `00`: Not applicable or not specified
	//  - `10`: Savings account
	//  - `20`: Checking account
	//  - `30`: Credit card account
	//  - `40`: Universal account
	//
	// Max Length: 2
	AccountType string `json:"accountType,omitempty"`

	// **Chase Paymentech Solutions**
	//
	// Indicates whether a customer has high credit limits. This information enables you to market high cost items to
	// these customers and to understand the kinds of cards that high income customers are using.
	//
	// This field is supported for Visa, Mastercard, Discover, and Diners Club. Possible values:
	//
	//  - **Y**: Yes
	//  - **N**: No
	//  - **X**: Not applicable / Unknown
	//
	// **Litle**
	//
	// Flag that indicates that a Visa cardholder or Mastercard cardholder is in one of the affluent categories.
	// Possible values:
	//
	//  - **AFFLUENT**: High income customer with high spending pattern (>100k USD annual income and >40k USD annual
	//    card usage).
	//  - **MASS AFFLUENT**: High income customer (>100k USD annual income).
	//
	// **Processor specific maximum length**:
	//
	//  - Chase Paymentech Solutions: 1
	//  - Litle: 13
	//
	// Max Length: 13
	AffluenceIndicator string `json:"affluenceIndicator,omitempty"`

	// Remaining balance on the account.
	//
	// Max Length: 12
	BalanceAmount string `json:"balanceAmount,omitempty"`

	// Type of amount. This value is returned only if you requested a balance inquiry. The issuer determines the value
	// that is returned. Possible values for deposit accounts:
	//
	//  - `01`: Current ledger (posted) balance.
	//  - `02`: Current available balance, which is typically the ledger balance less outstanding authorizations.
	//
	// Some depository institutions also include pending deposits and the credit or overdraft line associated with the
	// account. Possible values for credit card accounts:
	//
	//  - `01`: Credit amount remaining for customer (open to buy).
	//  - `02`: Credit limit.
	//
	// Max Length: 2
	BalanceAmountType string `json:"balanceAmountType,omitempty"`

	// Sign for the remaining balance on the account. Returned only when the processor returns this value. Possible values:
	//
	// Possible values:
	//  - **+**
	//  - **-**
	//
	// Max Length: 1
	BalanceSign string `json:"balanceSign,omitempty"`

	// #### CyberSource through VisaNet
	// Visa or Mastercard product ID that is associated with the primary account number (PAN).
	// For descriptions of the Visa product IDs, see the Product ID table on the [Visa
	// Request & Response Codes web page.](https://developer.visa.com/guides/request_response_codes)
	//
	// Data Length: String (3)
	//
	// #### GPN
	// Visa or Mastercard product ID that is associated with the primary account number (PAN).
	// For descriptions of the Visa product IDs, seepag the Product ID table on the
	// [Visa Request & Response Codes web page.](https://developer.visa.com/guides/request_response_codes) For descriptions of the
	// Mastercard product IDs, see "Product IDs" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Data Length: String (3)
	//
	// #### Worldpay VAP
	// **Important** Before using this field on Worldpay VAP,
	// you must contact CyberSource Customer Support to have
	// your account configured for this feature.
	//
	// Type of card used in the transaction. The only possible value is:
	// - `PREPAID`: Prepaid Card
	//
	// Data Length: String (7)
	//
	// #### RBS WorldPay Atlanta
	// Type of card used in the transaction. Possible values:
	// - `B`: Business Card
	// - `O`: Noncommercial Card
	// - `R`: Corporate Card
	// - `S`: Purchase Card
	// - `Blank`: Purchase card not supported
	//
	// Data Length: String (1)
	//
	// Max Length: 7
	Category string `json:"category,omitempty"`

	// Indicates whether the card is a commercial card, which enables you to include Level II data in your transaction
	// requests. This field is supported for Visa and Mastercard on **Chase Paymentech Solutions**. Possible values:
	//
	//  - **Y**: Yes
	//  - **N**: No
	//  - **X**: Not applicable / Unknown
	//
	// For details, see `auth_card_commercial` reply field description in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 1
	Commercial string `json:"commercial,omitempty"`

	// Currency of the remaining balance on the account. For the possible values, see the [ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)
	//
	// For details, see `auth_account_balance_currency` field description in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 5
	Currency string `json:"currency,omitempty"`

	// Type of commercial card. This field is supported only for CyberSource through VisaNet. Possible values:
	//
	//  - **B**: Business card
	//  - **R**: Corporate card
	//  - **S**: Purchasing card
	//  - **0**: Noncommercial card
	//
	// Max Length: 1
	Group string `json:"group,omitempty"`

	// Indicates whether the card is a healthcare card. This field is supported for Visa and Mastercard on **Chase
	// Paymentech Solutions**. Possible values:
	//
	//  - `Y`: Yes
	//  - `N`: No
	//  - `X`: Not applicable / Unknown
	//
	// For details, see `auth_card_healthcare` reply field description in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 1
	HealthCare string `json:"healthCare,omitempty"`

	// Indicates whether the card is eligible for Level III interchange fees, which enables you to include Level III
	// data in your transaction requests. This field is supported for Visa and Mastercard on **Chase Paymentech
	// Solutions**. Possible values:
	//
	//  - `Y`: Yes
	//  - `N`: No
	//  - `X`: Not applicable / Unknown
	//
	// For details, see `auth_card_level_3_eligible` reply field description in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 1
	Level3Eligible string `json:"level3Eligible,omitempty"`

	// Indicates whether the card is a payroll card. This field is supported for Visa, Discover, Diners Club, and JCB
	// on **Chase Paymentech Solutions**. Possible values:
	//
	//  - `Y`: Yes
	//  - `N`: No
	//  - `X`: Not applicable / Unknown
	//
	// For details, see `auth_card_payroll` field description in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 1
	Payroll string `json:"payroll,omitempty"`

	// Indicates whether the card is a PINless debit card. This field is supported for Visa and Mastercard on **Chase
	// Paymentech Solutions**. Possible values:
	//
	//  - `Y`: Yes
	//  - `N`: No
	//  - `X`: Not applicable / Unknown
	//
	// For details, see `auth_card_pinless_debit` reply field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 1
	PinlessDebit string `json:"pinlessDebit,omitempty"`

	// Indicates whether the card is a prepaid card. This information enables you to determine when a gift card or
	// prepaid card is presented for use when establishing a new recurring, installment, or deferred billing
	// relationship.
	//
	// This field is supported for Visa, Mastercard, Discover, Diners Club, and JCB on Chase Paymentech Solutions.
	// Possible values:
	//
	//  - `Y`: Yes
	//  - `N`: No
	//  - `X`: Not applicable / Unknown
	//
	// For details, see the `auth_card_prepaid` field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 1
	Prepaid string `json:"prepaid,omitempty"`

	// Indicates whether the card is regulated according to the Durbin Amendment. If the card is regulated, the card
	// issuer is subject to price caps and interchange rules. This field is supported for Visa, Mastercard, Discover,
	// Diners Club, and JCB on Chase Paymentech Solutions. Possible values:
	//
	//  - `Y`: Yes
	//  - `N`: No
	//  - `X`: Not applicable / Unknown
	//
	// For details, see `auth_card_regulated` field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 1
	Regulated string `json:"regulated,omitempty"`

	// Indicates whether the card is a signature debit card.
	//
	// This information enables you to alter the way an order is processed. For example, you might not want to reauthorize a transaction for a signature debit card, or you might
	// want to perform reversals promptly for a signature debit card. This field is supported for Visa, Mastercard, and
	// Maestro (International) on Chase Paymentech Solutions. Possible values:
	//
	//  - `Y`: Yes
	//  - `N`: No
	//  - `X`: Not applicable / Unknown
	//
	// For details, see `auth_card_signature_debit` reply field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 1
	SignatureDebit string `json:"signatureDebit,omitempty"`
}

// Validate validates this create payment created body payment information account features
func (o *CreatePaymentCreatedBodyPaymentInformationAccountFeatures) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAccountStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAccountType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAffluenceIndicator(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBalanceAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBalanceAmountType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBalanceSign(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCategory(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCommercial(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCurrency(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateGroup(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateHealthCare(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLevel3Eligible(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePayroll(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePinlessDebit(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePrepaid(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRegulated(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSignatureDebit(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformationAccountFeatures) validateAccountStatus(formats strfmt.Registry) error {

	if swag.IsZero(o.AccountStatus) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"paymentInformation"+"."+"accountFeatures"+"."+"accountStatus", "body", string(o.AccountStatus), 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformationAccountFeatures) validateAccountType(formats strfmt.Registry) error {

	if swag.IsZero(o.AccountType) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"paymentInformation"+"."+"accountFeatures"+"."+"accountType", "body", string(o.AccountType), 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformationAccountFeatures) validateAffluenceIndicator(formats strfmt.Registry) error {

	if swag.IsZero(o.AffluenceIndicator) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"paymentInformation"+"."+"accountFeatures"+"."+"affluenceIndicator", "body", string(o.AffluenceIndicator), 13); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformationAccountFeatures) validateBalanceAmount(formats strfmt.Registry) error {

	if swag.IsZero(o.BalanceAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"paymentInformation"+"."+"accountFeatures"+"."+"balanceAmount", "body", string(o.BalanceAmount), 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformationAccountFeatures) validateBalanceAmountType(formats strfmt.Registry) error {

	if swag.IsZero(o.BalanceAmountType) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"paymentInformation"+"."+"accountFeatures"+"."+"balanceAmountType", "body", string(o.BalanceAmountType), 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformationAccountFeatures) validateBalanceSign(formats strfmt.Registry) error {

	if swag.IsZero(o.BalanceSign) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"paymentInformation"+"."+"accountFeatures"+"."+"balanceSign", "body", string(o.BalanceSign), 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformationAccountFeatures) validateCategory(formats strfmt.Registry) error {

	if swag.IsZero(o.Category) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"paymentInformation"+"."+"accountFeatures"+"."+"category", "body", string(o.Category), 7); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformationAccountFeatures) validateCommercial(formats strfmt.Registry) error {

	if swag.IsZero(o.Commercial) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"paymentInformation"+"."+"accountFeatures"+"."+"commercial", "body", string(o.Commercial), 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformationAccountFeatures) validateCurrency(formats strfmt.Registry) error {

	if swag.IsZero(o.Currency) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"paymentInformation"+"."+"accountFeatures"+"."+"currency", "body", string(o.Currency), 5); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformationAccountFeatures) validateGroup(formats strfmt.Registry) error {

	if swag.IsZero(o.Group) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"paymentInformation"+"."+"accountFeatures"+"."+"group", "body", string(o.Group), 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformationAccountFeatures) validateHealthCare(formats strfmt.Registry) error {

	if swag.IsZero(o.HealthCare) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"paymentInformation"+"."+"accountFeatures"+"."+"healthCare", "body", string(o.HealthCare), 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformationAccountFeatures) validateLevel3Eligible(formats strfmt.Registry) error {

	if swag.IsZero(o.Level3Eligible) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"paymentInformation"+"."+"accountFeatures"+"."+"level3Eligible", "body", string(o.Level3Eligible), 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformationAccountFeatures) validatePayroll(formats strfmt.Registry) error {

	if swag.IsZero(o.Payroll) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"paymentInformation"+"."+"accountFeatures"+"."+"payroll", "body", string(o.Payroll), 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformationAccountFeatures) validatePinlessDebit(formats strfmt.Registry) error {

	if swag.IsZero(o.PinlessDebit) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"paymentInformation"+"."+"accountFeatures"+"."+"pinlessDebit", "body", string(o.PinlessDebit), 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformationAccountFeatures) validatePrepaid(formats strfmt.Registry) error {

	if swag.IsZero(o.Prepaid) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"paymentInformation"+"."+"accountFeatures"+"."+"prepaid", "body", string(o.Prepaid), 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformationAccountFeatures) validateRegulated(formats strfmt.Registry) error {

	if swag.IsZero(o.Regulated) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"paymentInformation"+"."+"accountFeatures"+"."+"regulated", "body", string(o.Regulated), 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformationAccountFeatures) validateSignatureDebit(formats strfmt.Registry) error {

	if swag.IsZero(o.SignatureDebit) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"paymentInformation"+"."+"accountFeatures"+"."+"signatureDebit", "body", string(o.SignatureDebit), 1); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyPaymentInformationAccountFeatures) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyPaymentInformationAccountFeatures) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyPaymentInformationAccountFeatures
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyPaymentInformationBank create payment created body payment information bank
swagger:model CreatePaymentCreatedBodyPaymentInformationBank
*/
type CreatePaymentCreatedBodyPaymentInformationBank struct {

	// account
	Account *CreatePaymentCreatedBodyPaymentInformationBankAccount `json:"account,omitempty"`

	// Corrected account number from the ACH verification service.
	//
	// For details, see `ecp_debit_corrected_routing_number` or `ecp_credit_corrected_routing_number` reply field descriptions in the [Electronic Check Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/EChecks_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 9
	CorrectedRoutingNumber string `json:"correctedRoutingNumber,omitempty"`
}

// Validate validates this create payment created body payment information bank
func (o *CreatePaymentCreatedBodyPaymentInformationBank) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAccount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCorrectedRoutingNumber(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformationBank) validateAccount(formats strfmt.Registry) error {

	if swag.IsZero(o.Account) { // not required
		return nil
	}

	if o.Account != nil {
		if err := o.Account.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "paymentInformation" + "." + "bank" + "." + "account")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformationBank) validateCorrectedRoutingNumber(formats strfmt.Registry) error {

	if swag.IsZero(o.CorrectedRoutingNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"paymentInformation"+"."+"bank"+"."+"correctedRoutingNumber", "body", string(o.CorrectedRoutingNumber), 9); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyPaymentInformationBank) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyPaymentInformationBank) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyPaymentInformationBank
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyPaymentInformationBankAccount create payment created body payment information bank account
swagger:model CreatePaymentCreatedBodyPaymentInformationBankAccount
*/
type CreatePaymentCreatedBodyPaymentInformationBankAccount struct {

	// Corrected account number from the ACH verification service.
	//
	// For details, see `ecp_debit_corrected_account_number` or `ecp_credit_corrected_account_number` field descriptions in [Electronic Check Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/EChecks_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 17
	CorrectedAccountNumber string `json:"correctedAccountNumber,omitempty"`
}

// Validate validates this create payment created body payment information bank account
func (o *CreatePaymentCreatedBodyPaymentInformationBankAccount) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCorrectedAccountNumber(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformationBankAccount) validateCorrectedAccountNumber(formats strfmt.Registry) error {

	if swag.IsZero(o.CorrectedAccountNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"paymentInformation"+"."+"bank"+"."+"account"+"."+"correctedAccountNumber", "body", string(o.CorrectedAccountNumber), 17); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyPaymentInformationBankAccount) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyPaymentInformationBankAccount) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyPaymentInformationBankAccount
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyPaymentInformationCard create payment created body payment information card
swagger:model CreatePaymentCreatedBodyPaymentInformationCard
*/
type CreatePaymentCreatedBodyPaymentInformationCard struct {

	// Last four digits of the cardholders account number. This field is returned only for tokenized transactions.
	// You can use this value on the receipt that you give to the cardholder.
	//
	// **Note** This field is returned only for CyberSource through VisaNet and FDC Nashville Global.
	//
	// #### CyberSource through VisaNet
	// The value for this field corresponds to the following data in the TC 33 capture file:
	// - Record: CP01 TCRB
	// - Position: 85
	// - Field: American Express last 4 PAN return indicator.
	//
	Suffix string `json:"suffix,omitempty"`
}

// Validate validates this create payment created body payment information card
func (o *CreatePaymentCreatedBodyPaymentInformationCard) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyPaymentInformationCard) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyPaymentInformationCard) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyPaymentInformationCard
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyPaymentInformationTokenizedCard create payment created body payment information tokenized card
swagger:model CreatePaymentCreatedBodyPaymentInformationTokenizedCard
*/
type CreatePaymentCreatedBodyPaymentInformationTokenizedCard struct {

	// Confidence level of the tokenization. This value is assigned by the token service provider.
	//
	// **Note** This field is supported only for **CyberSource through VisaNet** and **FDC Nashville Global**.
	//
	// Max Length: 2
	AssuranceLevel string `json:"assuranceLevel,omitempty"`

	// One of two possible meanings:
	// - The two-digit month in which a token expires.
	// - The two-digit month in which a card expires.
	// Format: `MM`
	// Possible values: `01` through `12`
	//
	// **NOTE** The meaning of this field is dependent on the payment processor that is returning the value in an authorization reply. Please see the processor-specific details below.
	//
	// #### Barclays and Streamline
	// For Maestro (UK Domestic) and Maestro (International) cards on Barclays and Streamline, this must be a valid value (`01` through `12`) but is not required to be a valid expiration date. In other words, an expiration date that is in the past does not cause CyberSource to reject your request. However, an invalid expiration date might cause the issuer to reject your request.
	//
	// #### Encoded Account Numbers
	// For encoded account numbers (`card_type=039`), if there is no expiration date on the card, use `12`.\
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// #### Samsung Pay and Apple Pay
	// Month in which the token expires. CyberSource includes this field in the reply message when it decrypts the payment blob for the tokenized transaction.
	//
	// For processor-specific information, see the `customer_cc_expmo` field in [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 2
	ExpirationMonth string `json:"expirationMonth,omitempty"`

	// One of two possible meanings:
	// - The four-digit year in which a token expires.
	// - The four-digit year in which a card expires.
	// Format: `YYYY`
	// Possible values: `1900` through `3000`
	// Data type: Non-negative integer
	//
	// **NOTE** The meaning of this field is dependent on the payment processor that is returning the value in an authorization reply. Please see the processor-specific details below.
	//
	// #### Barclays and Streamline
	// For Maestro (UK Domestic) and Maestro (International) cards on Barclays and Streamline, this must be a valid value (1900 through
	// 3000) but is not required to be a valid expiration date. In other words, an expiration date that is in the past does not cause CyberSource to reject your request. However, an invalid expiration date might cause the issuer to reject your request.
	//
	// #### Encoded Account Numbers
	// For encoded account numbers (`card_ type=039`), if there is no expiration date on the card, use `2021`.
	//
	// #### FDC Nashville Global and FDMS South
	// You can send in 2 digits or 4 digits. When you send in 2 digits, they must be the last 2 digits of
	// the year.
	//
	// #### Samsung Pay and Apple Pay
	// Year in which the token expires. CyberSource includes this field in the reply message when it decrypts the payment blob for the tokenized transaction.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction
	// you are requesting.
	//
	// For processor-specific information, see the `customer_cc_expyr` or `token_expiration_year` field in [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 4
	ExpirationYear string `json:"expirationYear,omitempty"`

	// First six digits of token. CyberSource includes this field in the reply message when it decrypts the payment
	// blob for the tokenized transaction.
	//
	// For details, see `token_prefix` field description in [Google Pay Using the SCMP API.]
	// (https://apps.cybersource.com/library/documentation/dev_guides/Google_Pay_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 6
	Prefix string `json:"prefix,omitempty"`

	// Value that identifies your business and indicates that the cardholders account number is tokenized. This value
	// is assigned by the token service provider and is unique within the token service providers database.
	//
	// **Note** This field is supported only for **CyberSource through VisaNet** and **FDC Nashville Global**.
	//
	// Max Length: 11
	RequestorID string `json:"requestorId,omitempty"`

	// Last four digits of token. CyberSource includes this field in the reply message when it decrypts the payment
	// blob for the tokenized transaction.
	//
	// For details, see `token_suffix` field description in [Google Pay Using the SCMP API.]
	// (https://apps.cybersource.com/library/documentation/dev_guides/Google_Pay_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 4
	Suffix string `json:"suffix,omitempty"`

	// Three-digit value that indicates the card type.
	//
	// Type of card to authorize.
	// - 001 Visa
	// - 002 Mastercard
	// - 003 Amex
	// - 004 Discover
	// - 005: Diners Club
	// - 007: JCB
	// - 024: Maestro (UK Domestic)
	// - 039 Encoded account number
	// - 042: Maestro (International)
	//
	// For the complete list of possible values, see `card_type` field description in the [Credit Card Services Using the SCMP API Guide.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	Type string `json:"type,omitempty"`
}

// Validate validates this create payment created body payment information tokenized card
func (o *CreatePaymentCreatedBodyPaymentInformationTokenizedCard) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAssuranceLevel(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpirationMonth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpirationYear(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePrefix(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRequestorID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSuffix(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformationTokenizedCard) validateAssuranceLevel(formats strfmt.Registry) error {

	if swag.IsZero(o.AssuranceLevel) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"paymentInformation"+"."+"tokenizedCard"+"."+"assuranceLevel", "body", string(o.AssuranceLevel), 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformationTokenizedCard) validateExpirationMonth(formats strfmt.Registry) error {

	if swag.IsZero(o.ExpirationMonth) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"paymentInformation"+"."+"tokenizedCard"+"."+"expirationMonth", "body", string(o.ExpirationMonth), 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformationTokenizedCard) validateExpirationYear(formats strfmt.Registry) error {

	if swag.IsZero(o.ExpirationYear) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"paymentInformation"+"."+"tokenizedCard"+"."+"expirationYear", "body", string(o.ExpirationYear), 4); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformationTokenizedCard) validatePrefix(formats strfmt.Registry) error {

	if swag.IsZero(o.Prefix) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"paymentInformation"+"."+"tokenizedCard"+"."+"prefix", "body", string(o.Prefix), 6); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformationTokenizedCard) validateRequestorID(formats strfmt.Registry) error {

	if swag.IsZero(o.RequestorID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"paymentInformation"+"."+"tokenizedCard"+"."+"requestorId", "body", string(o.RequestorID), 11); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPaymentInformationTokenizedCard) validateSuffix(formats strfmt.Registry) error {

	if swag.IsZero(o.Suffix) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"paymentInformation"+"."+"tokenizedCard"+"."+"suffix", "body", string(o.Suffix), 4); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyPaymentInformationTokenizedCard) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyPaymentInformationTokenizedCard) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyPaymentInformationTokenizedCard
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyPointOfSaleInformation create payment created body point of sale information
swagger:model CreatePaymentCreatedBodyPointOfSaleInformation
*/
type CreatePaymentCreatedBodyPointOfSaleInformation struct {

	// Point-of-sale details for the transaction. This value is returned only for **American Express Direct**.
	// CyberSource generates this value, which consists of a series of codes that identify terminal capability,
	// security data, and specific conditions present at the time the transaction occurred. To comply with the CAPN
	// requirements, this value must be included in all subsequent follow-on requests, such as captures and follow-on
	// credits.
	//
	// When you perform authorizations, captures, and credits through CyberSource, CyberSource passes this value from
	// the authorization service to the subsequent services for you. However, when you perform authorizations through
	// CyberSource and perform subsequent services through other financial institutions, you must ensure that your
	// requests for captures and credits include this value.
	//
	// For details, see `auth_pos_data` field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 12
	AmexCapnData string `json:"amexCapnData,omitempty"`

	// emv
	Emv *CreatePaymentCreatedBodyPointOfSaleInformationEmv `json:"emv,omitempty"`
}

// Validate validates this create payment created body point of sale information
func (o *CreatePaymentCreatedBodyPointOfSaleInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAmexCapnData(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEmv(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyPointOfSaleInformation) validateAmexCapnData(formats strfmt.Registry) error {

	if swag.IsZero(o.AmexCapnData) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"pointOfSaleInformation"+"."+"amexCapnData", "body", string(o.AmexCapnData), 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPointOfSaleInformation) validateEmv(formats strfmt.Registry) error {

	if swag.IsZero(o.Emv) { // not required
		return nil
	}

	if o.Emv != nil {
		if err := o.Emv.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "pointOfSaleInformation" + "." + "emv")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyPointOfSaleInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyPointOfSaleInformation) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyPointOfSaleInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyPointOfSaleInformationEmv create payment created body point of sale information emv
swagger:model CreatePaymentCreatedBodyPointOfSaleInformationEmv
*/
type CreatePaymentCreatedBodyPointOfSaleInformationEmv struct {

	// Cryptogram validation results returned by the entity or service specified in **chipValidationType**.
	//
	// Possible values:
	// - **A**: Application cryptogram is valid, but the application transaction counter (ATC) is outside allowed range. (A large jump in ATC values may indicate data copying or other fraud.)
	// - **C**: Chip validation was completed successfully.
	// - **E**: Application cryptogram is valid but the ATC indicates possible replay fraud.
	// - **F**: Format error in the chip data.
	// - **G**: Application cryptogram is valid but is not a valid authorization request cryptogram (ARQC).
	// - **I**: Application cryptogram is invalid.
	// - **T**: Application cryptogram is valid but terminal verification results (TVR) or card verification results (CVR) are invalid.
	// - **U**: Application cryptogram could not be validated because of a technical error.
	//
	// This field is returned only for NFC payment network tokenization transactions with MasterCard.
	//
	// **Note** No CyberSource through VisaNet acquirers support EMV at this time.
	//
	// Max Length: 1
	ChipValidationResult string `json:"chipValidationResult,omitempty"`

	// Entity or service that provided the validation results returned in **chipValidationResult**.
	//
	// Possible values:
	//  - **02**: MasterCard on-behalf pre-validation service (The MasterCard authorization platform validated the M/Chip cryptogram before the authorization request reached the issuer.)
	//  - **03**: MasterCard on-behalf stand-in service (The MasterCard authorization platform validated the M/Chip cryptogram because the issuer was not available.)
	//  - **50**: Issuer
	//  - **90**: Chip fall-back transaction downgrade process (The chip could not be read.)
	//
	// This field is returned only for NFC payment network tokenization transactions with MasterCard.
	//
	// **Note** No CyberSource through VisaNet acquirers support EMV at this time.
	//
	// Max Length: 2
	ChipValidationType string `json:"chipValidationType,omitempty"`

	// EMV data that is transmitted from the chip card to the issuer, and from the issuer to the chip card. The EMV
	// data is in the tag-length-value format and includes chip card tags, terminal tags, and transaction detail tags.
	//
	// For details, see the `emv_request_combined_tags` field description in [Card-Present Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Retail_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// **Note** The information about EMV applies to credit card processing and PIN debit
	// processing. All other information in this guide applies only to credit card processing. PIN debit
	// processing is available only on FDC Nashville Global.
	//
	// **Note** For information about the individual tags, see the Application Specification section in the EMV 4.3 Specifications: http://emvco.com
	//
	// **Important** The following tags contain sensitive information and **must not** be included in this field:
	//
	//  - **56**: Track 1 equivalent data
	//  - **57**: Track 2 equivalent data
	//  - **5A**: Application PAN
	//  - **5F20**: Cardholder name
	//  - **5F24**: Application expiration date (This sensitivity has been relaxed for cmcic, amexdirect, fdiglobal, opdfde, and six)
	//  - **99**: Transaction PIN
	//  - **9F0B**: Cardholder name (extended)
	//  - **9F1F**: Track 1 discretionary data
	//  - **9F20**: Track 2 discretionary data
	//
	// For captures, this field is required for contact EMV transactions. Otherwise, it is optional.
	//
	// For credits, this field is required for contact EMV stand-alone credits and contactless EMV stand-alone credits.
	// Otherwise, it is optional.
	//
	// **Important** For contact EMV captures, contact EMV stand-alone credits, and contactless EMV stand-alone credits,
	// you must include the following tags in this field. For all other types of EMV transactions, the following tags
	// are optional.
	//
	//  - **95**: Terminal verification results
	//  - **9F10**: Issuer application data
	//  - **9F26**: Application cryptogram
	//
	// Max Length: 1998
	Tags string `json:"tags,omitempty"`
}

// Validate validates this create payment created body point of sale information emv
func (o *CreatePaymentCreatedBodyPointOfSaleInformationEmv) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateChipValidationResult(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateChipValidationType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTags(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyPointOfSaleInformationEmv) validateChipValidationResult(formats strfmt.Registry) error {

	if swag.IsZero(o.ChipValidationResult) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"pointOfSaleInformation"+"."+"emv"+"."+"chipValidationResult", "body", string(o.ChipValidationResult), 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPointOfSaleInformationEmv) validateChipValidationType(formats strfmt.Registry) error {

	if swag.IsZero(o.ChipValidationType) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"pointOfSaleInformation"+"."+"emv"+"."+"chipValidationType", "body", string(o.ChipValidationType), 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyPointOfSaleInformationEmv) validateTags(formats strfmt.Registry) error {

	if swag.IsZero(o.Tags) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"pointOfSaleInformation"+"."+"emv"+"."+"tags", "body", string(o.Tags), 1998); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyPointOfSaleInformationEmv) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyPointOfSaleInformationEmv) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyPointOfSaleInformationEmv
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyProcessingInformation create payment created body processing information
swagger:model CreatePaymentCreatedBodyProcessingInformation
*/
type CreatePaymentCreatedBodyProcessingInformation struct {

	// bank transfer options
	BankTransferOptions *CreatePaymentCreatedBodyProcessingInformationBankTransferOptions `json:"bankTransferOptions,omitempty"`
}

// Validate validates this create payment created body processing information
func (o *CreatePaymentCreatedBodyProcessingInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateBankTransferOptions(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyProcessingInformation) validateBankTransferOptions(formats strfmt.Registry) error {

	if swag.IsZero(o.BankTransferOptions) { // not required
		return nil
	}

	if o.BankTransferOptions != nil {
		if err := o.BankTransferOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "processingInformation" + "." + "bankTransferOptions")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyProcessingInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyProcessingInformation) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyProcessingInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyProcessingInformationBankTransferOptions create payment created body processing information bank transfer options
swagger:model CreatePaymentCreatedBodyProcessingInformationBankTransferOptions
*/
type CreatePaymentCreatedBodyProcessingInformationBankTransferOptions struct {

	// Level of fraud screening.
	//
	// Possible values:
	// - `1`: Validation  default if the field has not already been configured for your merchant ID
	// - `2`: Verification
	//
	// For a description of this feature and a list of supported processors, see "Verification and Validation" in the [Electronic Check Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/EChecks_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm).
	//
	// Max Length: 1
	FraudScreeningLevel string `json:"fraudScreeningLevel,omitempty"`

	// Method used for settlement.
	//
	// Possible values:
	// - `A`: Automated Clearing House (default for credits and for transactions using Canadian dollars)
	// - `F`: Facsimile draft (U.S. dollars only)
	// - `B`: Best possible (U.S. dollars only) (default if the field has not already been configured for your
	// merchant ID)
	//
	// For details, see `ecp_settlement_method` field description for credit cars and `ecp_debit_settlement_method` for debit cards in the [Electronic Check Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/EChecks_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 1
	SettlementMethod string `json:"settlementMethod,omitempty"`
}

// Validate validates this create payment created body processing information bank transfer options
func (o *CreatePaymentCreatedBodyProcessingInformationBankTransferOptions) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateFraudScreeningLevel(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSettlementMethod(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyProcessingInformationBankTransferOptions) validateFraudScreeningLevel(formats strfmt.Registry) error {

	if swag.IsZero(o.FraudScreeningLevel) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processingInformation"+"."+"bankTransferOptions"+"."+"fraudScreeningLevel", "body", string(o.FraudScreeningLevel), 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessingInformationBankTransferOptions) validateSettlementMethod(formats strfmt.Registry) error {

	if swag.IsZero(o.SettlementMethod) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processingInformation"+"."+"bankTransferOptions"+"."+"settlementMethod", "body", string(o.SettlementMethod), 1); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyProcessingInformationBankTransferOptions) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyProcessingInformationBankTransferOptions) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyProcessingInformationBankTransferOptions
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyProcessorInformation create payment created body processor information
swagger:model CreatePaymentCreatedBodyProcessorInformation
*/
type CreatePaymentCreatedBodyProcessorInformation struct {

	// ach verification
	AchVerification *CreatePaymentCreatedBodyProcessorInformationAchVerification `json:"achVerification,omitempty"`

	// Referral response number for a verbal authorization with FDMS Nashville when using an American Express card.
	// Give this number to American Express when you call them for the verbal authorization.
	//
	// Max Length: 6
	AmexVerbalAuthReferenceNumber string `json:"amexVerbalAuthReferenceNumber,omitempty"`

	// Authorization code. Returned only when the processor returns this value.
	//
	ApprovalCode string `json:"approvalCode,omitempty"`

	// Flag that specifies the purpose of the authorization.
	//
	// Possible values:
	//  - **0**: Preauthorization
	//  - **1**: Final authorization
	//
	// For processor-specific information, see the auth_indicator field in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 1
	AuthIndicator string `json:"authIndicator,omitempty"`

	// avs
	Avs *CreatePaymentCreatedBodyProcessorInformationAvs `json:"avs,omitempty"`

	// card verification
	CardVerification *CreatePaymentCreatedBodyProcessorInformationCardVerification `json:"cardVerification,omitempty"`

	// consumer authentication response
	ConsumerAuthenticationResponse *CreatePaymentCreatedBodyProcessorInformationConsumerAuthenticationResponse `json:"consumerAuthenticationResponse,omitempty"`

	// customer
	Customer *CreatePaymentCreatedBodyProcessorInformationCustomer `json:"customer,omitempty"`

	// electronic verification results
	ElectronicVerificationResults *CreatePaymentCreatedBodyProcessorInformationElectronicVerificationResults `json:"electronicVerificationResults,omitempty"`

	// Name of the Japanese acquirer that processed the transaction. Returned only for JCN Gateway.
	// Please contact the CyberSource Japan Support Group for more information.
	//
	// Max Length: 32
	ForwardedAcquirerCode string `json:"forwardedAcquirerCode,omitempty"`

	// Type of authentication for which the transaction qualifies as determined by the Mastercard authentication
	// service, which confirms the identity of the cardholder. Mastercard provides this value to CyberSource.
	//
	// Possible values:
	//
	//  - `1`: Transaction qualifies for Mastercard authentication type 1.
	//  - `2`: Transaction qualifies for Mastercard authentication type 2.
	//
	// #### CyberSource through VisaNet
	// The value for this field corresponds to the following data in the TC 33 capture file:
	// - Record: CP01 TCR6
	// - Position: 132
	// - Field: Mastercard Member Defined service.
	// **Note** This field is returned only for CyberSource through VisaNet.
	//
	// Max Length: 1
	MasterCardAuthenticationType string `json:"masterCardAuthenticationType,omitempty"`

	// Mastercard service that was used for the transaction. Mastercard provides this value to CyberSource.
	//
	// Possible value:
	//  - 53: Mastercard card-on-file token service
	//
	// #### CyberSource through VisaNet
	// The value for this field corresponds to the following data in the TC 33 capture file:
	// - Record: CP01 TCR6
	// - Position: 133-134
	// - Field: Mastercard Merchant on-behalf service.
	// **Note** This field is returned only for CyberSource through VisaNet.
	//
	// Max Length: 2
	MasterCardServiceCode string `json:"masterCardServiceCode,omitempty"`

	// Result of the Mastercard card-on-file token service. Mastercard provides this value to CyberSource.
	//
	// Possible values:
	//
	//  - `C`: Service completed successfully.
	//  - `F`: One of the following:
	//    - Incorrect Mastercard POS entry mode. The Mastercard POS entry mode should be 81 for an authorization or
	//      authorization reversal.
	//    - Incorrect Mastercard POS entry mode. The Mastercard POS entry mode should be 01 for a tokenized request.
	//    - Token requestor ID is missing or formatted incorrectly.
	//  - `I`: One of the following:
	//    - Invalid token requestor ID.
	//    - Suspended or deactivated token.
	//    - Invalid token (not in mapping table).
	//  - `T`: Invalid combination of token requestor ID and token.
	//  - `U`: Expired token.
	//  - `W`: Primary account number (PAN) listed in electronic warning bulletin.
	//
	// **Note** This field is returned only for **CyberSource through VisaNet**.
	//
	// Max Length: 1
	MasterCardServiceReplyCode string `json:"masterCardServiceReplyCode,omitempty"`

	// merchant advice
	MerchantAdvice *CreatePaymentCreatedBodyProcessorInformationMerchantAdvice `json:"merchantAdvice,omitempty"`

	// Identifier that was assigned to you by your acquirer.
	//
	// This value must be printed on the receipt.
	//
	// This field is supported only on **American Express Direct**, **FDC Nashville Global**, and **SIX**.
	//
	// Max Length: 15
	MerchantNumber string `json:"merchantNumber,omitempty"`

	// Name of the Processor.
	//
	// Max Length: 30
	Name string `json:"name,omitempty"`

	// The description for this field is not available.
	NetworkTransactionID string `json:"networkTransactionId,omitempty"`

	// Visa-generated reference number that identifies a card-present transaction for which you provided one of the
	// following:
	//
	//  - Visa primary account number (PAN)
	//  - Visa-generated token for a PAN
	//
	// This reference number serves as a link to the cardholder account and to all transactions for that account.
	//
	// Max Length: 32
	PaymentAccountReferenceNumber string `json:"paymentAccountReferenceNumber,omitempty"`

	// The description for this field is not available.
	ProviderTransactionID string `json:"providerTransactionId,omitempty"`

	// Processor-defined response category code. The associated detail error code is in the `responseCode`
	// field of the service you requested.
	//
	// This field is supported only for:
	//
	//  - Japanese issuers
	//  - Domestic transactions in Japan
	//  - Comercio Latinoprocessor transaction ID required for troubleshooting
	//
	// **Maximum length for processors**:
	//
	//  - Comercio Latino: 32
	//  - All other processors: 3
	//
	// Max Length: 32
	ResponseCategoryCode string `json:"responseCategoryCode,omitempty"`

	// For most processors, this is the error message sent directly from the bank. Returned only when the processor
	// returns this value.
	//
	// **Important** Do not use this field to evaluate the result of the authorization.
	//
	// #### AIBMS
	// If this value is `08`, you can accept the transaction if the customer provides you with identification.
	//
	// #### Atos
	// This value is the response code sent from Atos and it might also include the response code from the bank.
	// Format: `aa,bb` with the two values separated by a comma and where:
	// - `aa` is the two-digit error message from Atos.
	// - `bb` is the optional two-digit error message from the bank.
	//
	// #### Comercio Latino
	// This value is the status code and the error or
	// response code received from the processor
	// separated by a colon.
	// Format: [status code]:E[error code] or
	// [status code]:R[response code]
	// Example `2:R06`
	//
	// #### JCN Gateway
	// Processor-defined detail error code. The associated response category code is in the `responseCategoryCode` field.
	//
	// Max Length: 10
	ResponseCode string `json:"responseCode,omitempty"`

	// Used by Visa only and contains the response source/reason code that identifies the source of the response decision.
	//
	// Max Length: 1
	ResponseCodeSource string `json:"responseCodeSource,omitempty"`

	// This field might contain information about a decline. This field is supported only for **CyberSource through
	// VisaNet**.
	//
	// Max Length: 255
	ResponseDetails string `json:"responseDetails,omitempty"`

	// routing
	Routing *CreatePaymentCreatedBodyProcessorInformationRouting `json:"routing,omitempty"`

	// Transaction identifier that CyberSource generates. You have the option of printing the sales slip number on
	// the receipt.
	//
	// This field is supported only for **JCN Gateway**.
	//
	// Maximum: 99999
	SalesSlipNumber int64 `json:"salesSlipNumber,omitempty"`

	// This field is returned only for **American Express Direct** and **CyberSource through VisaNet**.
	//
	// #### American Express Direct
	//
	// System trace audit number (STAN). This value identifies the transaction and is useful when investigating a
	// chargeback dispute.
	//
	// #### CyberSource through VisaNet
	//
	// System trace number that must be printed on the customers receipt.
	//
	// For details, see `receipt_number` field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 6
	SystemTraceAuditNumber string `json:"systemTraceAuditNumber,omitempty"`

	// Network transaction identifier (TID). You can use this value to identify a specific transaction when you are
	// discussing the transaction with your processor. Not all processors provide this value.
	//
	// #### Cielo
	// For Cielo, this value is the non-sequential unit (NSU) and is supported for all transactions. The value is generated by Cielo or the issuing bank.
	//
	// #### Comercio Latino
	// For Comercio Latino, this value is the proof of sale or non-sequential unit (NSU) number generated by the acquirers Cielo and Rede, or the issuing bank.
	//
	// #### CyberSource through VisaNet and GPN
	// For details about this value for CyberSource through VisaNet and GPN, see "Network Transaction Identifiers" in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 50
	TransactionID string `json:"transactionId,omitempty"`

	// Transaction integrity classification provided by Mastercard. This value specifies Mastercards evaluation of
	// the transactions safety and security. This field is returned only for **CyberSource through VisaNet**.
	//
	// For card-present transactions, possible values:
	//
	//  - `A1`: EMV or token in a secure, trusted environment
	//  - `B1`: EMV or chip equivalent
	//  - `C1`: Magnetic stripe
	//  - `E1`: Key entered
	//  - `U0`: Unclassified
	//
	// For card-not-present transactions, possible values:
	//
	//  - `A2`: Digital transactions
	//  - `B2`: Authenticated checkout
	//  - `C2`: Transaction validation
	//  - `D2`: Enhanced data
	//  - `E2`: Generic messaging
	//  - `U0`: Unclassified
	//
	// For information about these values, contact Mastercard or your acquirer.
	//
	// #### CyberSource through VisaNet
	//
	// The value for this field corresponds to the following data in the TC 33 capture file,<sup>1</sup>:
	// - Record: CP01 TCR6
	// - Position: 136-137
	// - Field: Mastercard Transaction Integrity Classification
	//
	// <sup>1</sup> The TC 33 Capture file contains information about the purchases and refunds that a merchant submits to CyberSource.
	// CyberSource through VisaNet creates the TC 33 Capture file at the end of the day and sends it to the merchants acquirer, who uses
	// this information to facilitate end-of-day clearing processing with payment networks.
	//
	// Max Length: 2
	TransactionIntegrityCode string `json:"transactionIntegrityCode,omitempty"`
}

// Validate validates this create payment created body processor information
func (o *CreatePaymentCreatedBodyProcessorInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAchVerification(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAmexVerbalAuthReferenceNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAuthIndicator(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAvs(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCardVerification(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateConsumerAuthenticationResponse(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCustomer(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateElectronicVerificationResults(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateForwardedAcquirerCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMasterCardAuthenticationType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMasterCardServiceCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMasterCardServiceReplyCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMerchantAdvice(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMerchantNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePaymentAccountReferenceNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateResponseCategoryCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateResponseCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateResponseCodeSource(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateResponseDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRouting(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSalesSlipNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSystemTraceAuditNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTransactionID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTransactionIntegrityCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformation) validateAchVerification(formats strfmt.Registry) error {

	if swag.IsZero(o.AchVerification) { // not required
		return nil
	}

	if o.AchVerification != nil {
		if err := o.AchVerification.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "processorInformation" + "." + "achVerification")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformation) validateAmexVerbalAuthReferenceNumber(formats strfmt.Registry) error {

	if swag.IsZero(o.AmexVerbalAuthReferenceNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"amexVerbalAuthReferenceNumber", "body", string(o.AmexVerbalAuthReferenceNumber), 6); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformation) validateAuthIndicator(formats strfmt.Registry) error {

	if swag.IsZero(o.AuthIndicator) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"authIndicator", "body", string(o.AuthIndicator), 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformation) validateAvs(formats strfmt.Registry) error {

	if swag.IsZero(o.Avs) { // not required
		return nil
	}

	if o.Avs != nil {
		if err := o.Avs.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "processorInformation" + "." + "avs")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformation) validateCardVerification(formats strfmt.Registry) error {

	if swag.IsZero(o.CardVerification) { // not required
		return nil
	}

	if o.CardVerification != nil {
		if err := o.CardVerification.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "processorInformation" + "." + "cardVerification")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformation) validateConsumerAuthenticationResponse(formats strfmt.Registry) error {

	if swag.IsZero(o.ConsumerAuthenticationResponse) { // not required
		return nil
	}

	if o.ConsumerAuthenticationResponse != nil {
		if err := o.ConsumerAuthenticationResponse.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "processorInformation" + "." + "consumerAuthenticationResponse")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformation) validateCustomer(formats strfmt.Registry) error {

	if swag.IsZero(o.Customer) { // not required
		return nil
	}

	if o.Customer != nil {
		if err := o.Customer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "processorInformation" + "." + "customer")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformation) validateElectronicVerificationResults(formats strfmt.Registry) error {

	if swag.IsZero(o.ElectronicVerificationResults) { // not required
		return nil
	}

	if o.ElectronicVerificationResults != nil {
		if err := o.ElectronicVerificationResults.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "processorInformation" + "." + "electronicVerificationResults")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformation) validateForwardedAcquirerCode(formats strfmt.Registry) error {

	if swag.IsZero(o.ForwardedAcquirerCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"forwardedAcquirerCode", "body", string(o.ForwardedAcquirerCode), 32); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformation) validateMasterCardAuthenticationType(formats strfmt.Registry) error {

	if swag.IsZero(o.MasterCardAuthenticationType) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"masterCardAuthenticationType", "body", string(o.MasterCardAuthenticationType), 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformation) validateMasterCardServiceCode(formats strfmt.Registry) error {

	if swag.IsZero(o.MasterCardServiceCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"masterCardServiceCode", "body", string(o.MasterCardServiceCode), 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformation) validateMasterCardServiceReplyCode(formats strfmt.Registry) error {

	if swag.IsZero(o.MasterCardServiceReplyCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"masterCardServiceReplyCode", "body", string(o.MasterCardServiceReplyCode), 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformation) validateMerchantAdvice(formats strfmt.Registry) error {

	if swag.IsZero(o.MerchantAdvice) { // not required
		return nil
	}

	if o.MerchantAdvice != nil {
		if err := o.MerchantAdvice.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "processorInformation" + "." + "merchantAdvice")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformation) validateMerchantNumber(formats strfmt.Registry) error {

	if swag.IsZero(o.MerchantNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"merchantNumber", "body", string(o.MerchantNumber), 15); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformation) validateName(formats strfmt.Registry) error {

	if swag.IsZero(o.Name) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"name", "body", string(o.Name), 30); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformation) validatePaymentAccountReferenceNumber(formats strfmt.Registry) error {

	if swag.IsZero(o.PaymentAccountReferenceNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"paymentAccountReferenceNumber", "body", string(o.PaymentAccountReferenceNumber), 32); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformation) validateResponseCategoryCode(formats strfmt.Registry) error {

	if swag.IsZero(o.ResponseCategoryCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"responseCategoryCode", "body", string(o.ResponseCategoryCode), 32); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformation) validateResponseCode(formats strfmt.Registry) error {

	if swag.IsZero(o.ResponseCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"responseCode", "body", string(o.ResponseCode), 10); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformation) validateResponseCodeSource(formats strfmt.Registry) error {

	if swag.IsZero(o.ResponseCodeSource) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"responseCodeSource", "body", string(o.ResponseCodeSource), 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformation) validateResponseDetails(formats strfmt.Registry) error {

	if swag.IsZero(o.ResponseDetails) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"responseDetails", "body", string(o.ResponseDetails), 255); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformation) validateRouting(formats strfmt.Registry) error {

	if swag.IsZero(o.Routing) { // not required
		return nil
	}

	if o.Routing != nil {
		if err := o.Routing.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentCreated" + "." + "processorInformation" + "." + "routing")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformation) validateSalesSlipNumber(formats strfmt.Registry) error {

	if swag.IsZero(o.SalesSlipNumber) { // not required
		return nil
	}

	if err := validate.MaximumInt("createPaymentCreated"+"."+"processorInformation"+"."+"salesSlipNumber", "body", int64(o.SalesSlipNumber), 99999, false); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformation) validateSystemTraceAuditNumber(formats strfmt.Registry) error {

	if swag.IsZero(o.SystemTraceAuditNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"systemTraceAuditNumber", "body", string(o.SystemTraceAuditNumber), 6); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformation) validateTransactionID(formats strfmt.Registry) error {

	if swag.IsZero(o.TransactionID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"transactionId", "body", string(o.TransactionID), 50); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformation) validateTransactionIntegrityCode(formats strfmt.Registry) error {

	if swag.IsZero(o.TransactionIntegrityCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"transactionIntegrityCode", "body", string(o.TransactionIntegrityCode), 2); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyProcessorInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyProcessorInformation) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyProcessorInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyProcessorInformationAchVerification create payment created body processor information ach verification
swagger:model CreatePaymentCreatedBodyProcessorInformationAchVerification
*/
type CreatePaymentCreatedBodyProcessorInformationAchVerification struct {

	// Results from the ACH verification service.
	// For details about this service and the possible values for the results, see "ACH Verification" and "Verification Codes" in the [Electronic Check Services Using the SCMP API](https://apps.cybersource.com/library/documentation/dev_guides/EChecks_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm).
	//
	// Max Length: 2
	ResultCode string `json:"resultCode,omitempty"`

	// Raw results from the ACH verification service.
	// For details about this service and the possible values for the raw results, see "ACH Verification" and "Verification Codes" in the [Electronic Check Services Using the SCMP API](https://apps.cybersource.com/library/documentation/dev_guides/EChecks_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm).
	//
	// Max Length: 10
	ResultCodeRaw string `json:"resultCodeRaw,omitempty"`
}

// Validate validates this create payment created body processor information ach verification
func (o *CreatePaymentCreatedBodyProcessorInformationAchVerification) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateResultCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateResultCodeRaw(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformationAchVerification) validateResultCode(formats strfmt.Registry) error {

	if swag.IsZero(o.ResultCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"achVerification"+"."+"resultCode", "body", string(o.ResultCode), 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformationAchVerification) validateResultCodeRaw(formats strfmt.Registry) error {

	if swag.IsZero(o.ResultCodeRaw) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"achVerification"+"."+"resultCodeRaw", "body", string(o.ResultCodeRaw), 10); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyProcessorInformationAchVerification) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyProcessorInformationAchVerification) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyProcessorInformationAchVerification
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyProcessorInformationAvs create payment created body processor information avs
swagger:model CreatePaymentCreatedBodyProcessorInformationAvs
*/
type CreatePaymentCreatedBodyProcessorInformationAvs struct {

	// AVS result code.
	//
	// Max Length: 1
	Code string `json:"code,omitempty"`

	// AVS result code sent directly from the processor. Returned only when the processor returns this value.
	// Important Do not use this field to evaluate the result of AVS. Use for debugging purposes only.
	//
	// Max Length: 10
	CodeRaw string `json:"codeRaw,omitempty"`
}

// Validate validates this create payment created body processor information avs
func (o *CreatePaymentCreatedBodyProcessorInformationAvs) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCodeRaw(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformationAvs) validateCode(formats strfmt.Registry) error {

	if swag.IsZero(o.Code) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"avs"+"."+"code", "body", string(o.Code), 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformationAvs) validateCodeRaw(formats strfmt.Registry) error {

	if swag.IsZero(o.CodeRaw) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"avs"+"."+"codeRaw", "body", string(o.CodeRaw), 10); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyProcessorInformationAvs) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyProcessorInformationAvs) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyProcessorInformationAvs
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyProcessorInformationCardVerification create payment created body processor information card verification
swagger:model CreatePaymentCreatedBodyProcessorInformationCardVerification
*/
type CreatePaymentCreatedBodyProcessorInformationCardVerification struct {

	// CVN result code.
	//
	// For details, see the `auth_cv_result` reply field description in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 1
	ResultCode string `json:"resultCode,omitempty"`

	// CVN result code sent directly from the processor. Returned only when the processor returns this value.
	//
	// **Important** Do not use this field to evaluate the result of card verification. Use for debugging purposes only.
	//
	// Max Length: 10
	ResultCodeRaw string `json:"resultCodeRaw,omitempty"`
}

// Validate validates this create payment created body processor information card verification
func (o *CreatePaymentCreatedBodyProcessorInformationCardVerification) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateResultCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateResultCodeRaw(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformationCardVerification) validateResultCode(formats strfmt.Registry) error {

	if swag.IsZero(o.ResultCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"cardVerification"+"."+"resultCode", "body", string(o.ResultCode), 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformationCardVerification) validateResultCodeRaw(formats strfmt.Registry) error {

	if swag.IsZero(o.ResultCodeRaw) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"cardVerification"+"."+"resultCodeRaw", "body", string(o.ResultCodeRaw), 10); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyProcessorInformationCardVerification) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyProcessorInformationCardVerification) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyProcessorInformationCardVerification
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyProcessorInformationConsumerAuthenticationResponse create payment created body processor information consumer authentication response
swagger:model CreatePaymentCreatedBodyProcessorInformationConsumerAuthenticationResponse
*/
type CreatePaymentCreatedBodyProcessorInformationConsumerAuthenticationResponse struct {

	// Mapped response code for Visa Secure and American Express SafeKey.
	//
	// For processor-specific details, see `auth_cavv_response_code` field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 3
	Code string `json:"code,omitempty"`

	// Raw response code sent directly from the processor for Visa Secure and American Express SafeKey:
	//
	// For processor-specific details, see `auth_cavv_response_code_raw` field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 3
	CodeRaw string `json:"codeRaw,omitempty"`
}

// Validate validates this create payment created body processor information consumer authentication response
func (o *CreatePaymentCreatedBodyProcessorInformationConsumerAuthenticationResponse) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCodeRaw(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformationConsumerAuthenticationResponse) validateCode(formats strfmt.Registry) error {

	if swag.IsZero(o.Code) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"consumerAuthenticationResponse"+"."+"code", "body", string(o.Code), 3); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformationConsumerAuthenticationResponse) validateCodeRaw(formats strfmt.Registry) error {

	if swag.IsZero(o.CodeRaw) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"consumerAuthenticationResponse"+"."+"codeRaw", "body", string(o.CodeRaw), 3); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyProcessorInformationConsumerAuthenticationResponse) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyProcessorInformationConsumerAuthenticationResponse) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyProcessorInformationConsumerAuthenticationResponse
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyProcessorInformationCustomer create payment created body processor information customer
swagger:model CreatePaymentCreatedBodyProcessorInformationCustomer
*/
type CreatePaymentCreatedBodyProcessorInformationCustomer struct {

	// Personal identifier result. This field is supported only for Redecard in Brazil for CyberSource Latin
	// American Processing. If you included `buyerInformation.personalIdentification[].ID` in the request, this
	// value indicates whether or not `buyerInformation.personalIdentification[].ID` matched a value in a record
	// on file. Returned only when the personal ID result is returned by the processor.
	//
	// Possible values:
	//
	//  - **Y**: Match
	//  - **N**: No match
	//  - **K**: Not supported
	//  - **U**: Unknown
	//  - **Z**: No response returned
	// **Note** CyberSource Latin American Processing is the name of a specific processing connection that CyberSource supports. In the CyberSource API documentation, CyberSource Latin American Processing does not refer to the general topic of processing in Latin America.The information in this field description is for the specific processing
	// connection called CyberSource Latin American Processing. It is not for any other Latin American processors that CyberSource supports.
	//
	// Max Length: 1
	PersonalIDResult string `json:"personalIdResult,omitempty"`
}

// Validate validates this create payment created body processor information customer
func (o *CreatePaymentCreatedBodyProcessorInformationCustomer) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validatePersonalIDResult(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformationCustomer) validatePersonalIDResult(formats strfmt.Registry) error {

	if swag.IsZero(o.PersonalIDResult) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"customer"+"."+"personalIdResult", "body", string(o.PersonalIDResult), 1); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyProcessorInformationCustomer) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyProcessorInformationCustomer) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyProcessorInformationCustomer
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyProcessorInformationElectronicVerificationResults create payment created body processor information electronic verification results
swagger:model CreatePaymentCreatedBodyProcessorInformationElectronicVerificationResults
*/
type CreatePaymentCreatedBodyProcessorInformationElectronicVerificationResults struct {

	// Mapped Electronic Verification response code for the customers name.
	//
	// For details, see `auth_ev_name` field description in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 1
	Code string `json:"code,omitempty"`

	// Raw Electronic Verification response code from the processor for the customers last name
	// Max Length: 1
	CodeRaw string `json:"codeRaw,omitempty"`

	// Mapped Electronic Verification response code for the customers email address.
	//
	// For details, see `auth_ev_email` field description in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 1
	Email string `json:"email,omitempty"`

	// Raw Electronic Verification response code from the processor for the customers email address.
	// Max Length: 1
	EmailRaw string `json:"emailRaw,omitempty"`

	// Mapped Electronic Verification response code for the customers name.
	//
	// Max Length: 30
	Name string `json:"name,omitempty"`

	// Raw Electronic Verification response code from the processor for the customers name.
	//
	// Max Length: 30
	NameRaw string `json:"nameRaw,omitempty"`

	// Mapped Electronic Verification response code for the customers phone number.
	//
	// For details, see `auth_ev_phone_number` field description in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 1
	PhoneNumber string `json:"phoneNumber,omitempty"`

	// Raw Electronic Verification response code from the processor for the customers phone number.
	// Max Length: 1
	PhoneNumberRaw string `json:"phoneNumberRaw,omitempty"`

	// Mapped Electronic Verification response code for the customers postal code.
	//
	// For details, see `auth_ev_postal_code` field description in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 1
	PostalCode string `json:"postalCode,omitempty"`

	// Raw Electronic Verification response code from the processor for the customers postal code.
	// Max Length: 1
	PostalCodeRaw string `json:"postalCodeRaw,omitempty"`

	// Mapped Electronic Verification response code for the customers street address.
	//
	// For details, see `auth_ev_street` field description in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 1
	Street string `json:"street,omitempty"`

	// Raw Electronic Verification response code from the processor for the customers street address.
	// Max Length: 1
	StreetRaw string `json:"streetRaw,omitempty"`
}

// Validate validates this create payment created body processor information electronic verification results
func (o *CreatePaymentCreatedBodyProcessorInformationElectronicVerificationResults) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCodeRaw(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEmail(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEmailRaw(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNameRaw(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePhoneNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePhoneNumberRaw(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePostalCodeRaw(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateStreet(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateStreetRaw(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformationElectronicVerificationResults) validateCode(formats strfmt.Registry) error {

	if swag.IsZero(o.Code) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"electronicVerificationResults"+"."+"code", "body", string(o.Code), 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformationElectronicVerificationResults) validateCodeRaw(formats strfmt.Registry) error {

	if swag.IsZero(o.CodeRaw) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"electronicVerificationResults"+"."+"codeRaw", "body", string(o.CodeRaw), 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformationElectronicVerificationResults) validateEmail(formats strfmt.Registry) error {

	if swag.IsZero(o.Email) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"electronicVerificationResults"+"."+"email", "body", string(o.Email), 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformationElectronicVerificationResults) validateEmailRaw(formats strfmt.Registry) error {

	if swag.IsZero(o.EmailRaw) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"electronicVerificationResults"+"."+"emailRaw", "body", string(o.EmailRaw), 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformationElectronicVerificationResults) validateName(formats strfmt.Registry) error {

	if swag.IsZero(o.Name) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"electronicVerificationResults"+"."+"name", "body", string(o.Name), 30); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformationElectronicVerificationResults) validateNameRaw(formats strfmt.Registry) error {

	if swag.IsZero(o.NameRaw) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"electronicVerificationResults"+"."+"nameRaw", "body", string(o.NameRaw), 30); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformationElectronicVerificationResults) validatePhoneNumber(formats strfmt.Registry) error {

	if swag.IsZero(o.PhoneNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"electronicVerificationResults"+"."+"phoneNumber", "body", string(o.PhoneNumber), 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformationElectronicVerificationResults) validatePhoneNumberRaw(formats strfmt.Registry) error {

	if swag.IsZero(o.PhoneNumberRaw) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"electronicVerificationResults"+"."+"phoneNumberRaw", "body", string(o.PhoneNumberRaw), 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformationElectronicVerificationResults) validatePostalCode(formats strfmt.Registry) error {

	if swag.IsZero(o.PostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"electronicVerificationResults"+"."+"postalCode", "body", string(o.PostalCode), 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformationElectronicVerificationResults) validatePostalCodeRaw(formats strfmt.Registry) error {

	if swag.IsZero(o.PostalCodeRaw) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"electronicVerificationResults"+"."+"postalCodeRaw", "body", string(o.PostalCodeRaw), 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformationElectronicVerificationResults) validateStreet(formats strfmt.Registry) error {

	if swag.IsZero(o.Street) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"electronicVerificationResults"+"."+"street", "body", string(o.Street), 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformationElectronicVerificationResults) validateStreetRaw(formats strfmt.Registry) error {

	if swag.IsZero(o.StreetRaw) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"electronicVerificationResults"+"."+"streetRaw", "body", string(o.StreetRaw), 1); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyProcessorInformationElectronicVerificationResults) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyProcessorInformationElectronicVerificationResults) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyProcessorInformationElectronicVerificationResults
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyProcessorInformationMerchantAdvice create payment created body processor information merchant advice
swagger:model CreatePaymentCreatedBodyProcessorInformationMerchantAdvice
*/
type CreatePaymentCreatedBodyProcessorInformationMerchantAdvice struct {

	// Reason the recurring payment transaction was declined. For some processors, this field is used only for
	// Mastercard. For other processors, this field is used for Visa and Mastercard. And for other processors, this
	// field is not implemented.
	//
	// Possible values:
	//
	//  - `00`: Response not provided.
	//  - `01`: New account information is available. Obtain the new information.
	//  - `02`: Try again later.
	//  - `03`: Do not try again. Obtain another type of payment from the customer.
	//  - `04`: Problem with a token or a partial shipment indicator.
	//  - `21`: Recurring payment cancellation service.
	//  - `99`: An unknown value was returned from the processor.
	//
	// For processor-specific information, see the `auth_merchant_advice_code` field in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 2
	Code string `json:"code,omitempty"`

	// Raw merchant advice code sent directly from the processor. This field is used only for Mastercard.
	//
	// #### CyberSource through VisaNet
	// The value for this field corresponds to the following data in the TC 33 capture file1:
	// - Record: CP01 TCR7
	// - Position: 96-99
	// - Field: Response Data-Merchant Advice Code
	//
	//
	// For processor-specific information, see the `auth_merchant_advice_code_raw` field in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 2
	CodeRaw string `json:"codeRaw,omitempty"`
}

// Validate validates this create payment created body processor information merchant advice
func (o *CreatePaymentCreatedBodyProcessorInformationMerchantAdvice) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCodeRaw(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformationMerchantAdvice) validateCode(formats strfmt.Registry) error {

	if swag.IsZero(o.Code) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"merchantAdvice"+"."+"code", "body", string(o.Code), 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformationMerchantAdvice) validateCodeRaw(formats strfmt.Registry) error {

	if swag.IsZero(o.CodeRaw) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"merchantAdvice"+"."+"codeRaw", "body", string(o.CodeRaw), 2); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyProcessorInformationMerchantAdvice) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyProcessorInformationMerchantAdvice) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyProcessorInformationMerchantAdvice
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentCreatedBodyProcessorInformationRouting create payment created body processor information routing
swagger:model CreatePaymentCreatedBodyProcessorInformationRouting
*/
type CreatePaymentCreatedBodyProcessorInformationRouting struct {

	// Indicates whether you need to obtain the cardholder's signature.
	//
	// Possible values:
	// - `Y`: You need to obtain the cardholder's signature.
	// - `N`: You do not need to obtain the cardholder's signature.
	//
	// This field is supported only on FDC Nashville Global.
	//
	// For details, see the `routing_signature_cvm_required` field description in [Card-Present Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Retail_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 1
	CustomerSignatureRequired string `json:"customerSignatureRequired,omitempty"`

	// Indicates whether the transaction was routed on a credit network, a debit network, or the STAR signature debit
	// network.
	//
	// Possible values:
	// - `C`: Credit network
	// - `D`: Debit network (without signature)
	// - `S`: STAR signature debit network
	//
	// This field is supported only on FDC Nashville Global.
	//
	// For details, see the `routing_network_type` field description in [Card-Present Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Retail_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 1
	Network string `json:"network,omitempty"`

	// Name of the network on which the transaction was routed.
	//
	// This field is supported only on FDC Nashville Global.
	//
	// For details, see the `routing_network_label` field description in [Card-Present Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Retail_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 10
	NetworkName string `json:"networkName,omitempty"`
}

// Validate validates this create payment created body processor information routing
func (o *CreatePaymentCreatedBodyProcessorInformationRouting) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCustomerSignatureRequired(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNetwork(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNetworkName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformationRouting) validateCustomerSignatureRequired(formats strfmt.Registry) error {

	if swag.IsZero(o.CustomerSignatureRequired) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"routing"+"."+"customerSignatureRequired", "body", string(o.CustomerSignatureRequired), 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformationRouting) validateNetwork(formats strfmt.Registry) error {

	if swag.IsZero(o.Network) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"routing"+"."+"network", "body", string(o.Network), 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentCreatedBodyProcessorInformationRouting) validateNetworkName(formats strfmt.Registry) error {

	if swag.IsZero(o.NetworkName) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentCreated"+"."+"processorInformation"+"."+"routing"+"."+"networkName", "body", string(o.NetworkName), 10); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyProcessorInformationRouting) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentCreatedBodyProcessorInformationRouting) UnmarshalBinary(b []byte) error {
	var res CreatePaymentCreatedBodyProcessorInformationRouting
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyAggregatorInformation create payment params body aggregator information
swagger:model CreatePaymentParamsBodyAggregatorInformation
*/
type CreatePaymentParamsBodyAggregatorInformation struct {

	// Value that identifies you as a payment aggregator. Get this value from the
	// processor.
	//
	// #### CyberSource through VisaNet
	// The value for this field corresponds to the following data in the TC 33 capture file5:
	// - Record: CP01 TCR6
	// - Position: 95-105
	// - Field: MasterCard Payment Facilitator ID
	//
	// **FDC Compass**\
	// This value must consist of uppercase characters.
	//
	// For processor-specific information, see the `aggregator_id` field in [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 20
	AggregatorID string `json:"aggregatorId,omitempty"`

	// Your payment aggregator business name.
	//
	// **American Express Direct**\
	// The maximum length of the aggregator name depends on the length of the sub-merchant name. The combined length for both values must not exceed 36 characters.\
	//
	// #### CyberSource through VisaNet
	// With American Express, the maximum length of the aggregator name depends on the length of the sub-merchant name. The combined length for both values must not exceed 36 characters. The value for this field does not map to the TC 33 capture file5.
	//
	// **FDC Compass**\
	// This value must consist of uppercase characters.
	//
	// For processor-specific information, see the aggregator_name field in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 37
	Name string `json:"name,omitempty"`

	// sub merchant
	SubMerchant *CreatePaymentParamsBodyAggregatorInformationSubMerchant `json:"subMerchant,omitempty"`
}

// Validate validates this create payment params body aggregator information
func (o *CreatePaymentParamsBodyAggregatorInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAggregatorID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSubMerchant(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyAggregatorInformation) validateAggregatorID(formats strfmt.Registry) error {

	if swag.IsZero(o.AggregatorID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"aggregatorInformation"+"."+"aggregatorId", "body", string(o.AggregatorID), 20); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyAggregatorInformation) validateName(formats strfmt.Registry) error {

	if swag.IsZero(o.Name) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"aggregatorInformation"+"."+"name", "body", string(o.Name), 37); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyAggregatorInformation) validateSubMerchant(formats strfmt.Registry) error {

	if swag.IsZero(o.SubMerchant) { // not required
		return nil
	}

	if o.SubMerchant != nil {
		if err := o.SubMerchant.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "aggregatorInformation" + "." + "subMerchant")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyAggregatorInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyAggregatorInformation) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyAggregatorInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyAggregatorInformationSubMerchant create payment params body aggregator information sub merchant
swagger:model CreatePaymentParamsBodyAggregatorInformationSubMerchant
*/
type CreatePaymentParamsBodyAggregatorInformationSubMerchant struct {

	// First line of the sub-merchants street address.
	//
	// For processor-specific details, see `submerchant_street` field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// #### CyberSource through VisaNet
	// The value for this field does not map to the TC 33 capture file5.
	//
	// #### FDC Compass
	// This value must consist of uppercase characters.
	//
	// Max Length: 38
	Address1 string `json:"address1,omitempty"`

	// Sub-merchants state or province.
	//
	// For possible values and also aggregator support, see `submerchant_state` request field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// #### CyberSource through VisaNet
	// The value for this field does not map to the TC 33 capture file5.
	//
	// #### FDC Compass
	// This value must consist of uppercase characters.
	//
	// Max Length: 3
	AdministrativeArea string `json:"administrativeArea,omitempty"`

	// Unique identifier assigned by the payment card company to the sub-merchant.
	// Max Length: 15
	CardAcceptorID string `json:"cardAcceptorId,omitempty"`

	// Sub-merchants country. Use the two-character ISO Standard Country Codes.
	//
	// #### CyberSource through VisaNet
	// The value for this field does not map to the TC 33 capture file.
	//
	// #### FDC Compass
	// This value must consist of uppercase characters.
	//
	// See "Aggregator Support," page 101.
	//
	// Max Length: 3
	Country string `json:"country,omitempty"`

	// Sub-merchants email address.
	//
	// **Maximum length for processors**
	//
	//  - American Express Direct: 40
	//  - CyberSource through VisaNet: 40
	//  - FDC Compass: 40
	//  - FDC Nashville Global: 19
	//
	// #### CyberSource through VisaNet
	// With American Express, the value for this field corresponds to the following data in the TC 33 capture file:
	// - Record: CP01 TCRB
	// - Position: 25-64
	// - Field: American Express Seller E-mail Address
	//
	// **Note** The TC 33 Capture file contains information about the purchases and refunds that a merchant submits to CyberSource. CyberSource through VisaNet creates the TC 33 Capture file at the end of the day and sends it to the merchants acquirer, who uses this information to facilitate end-of-day clearing processing with payment card companies.
	//
	// Max Length: 40
	Email string `json:"email,omitempty"`

	// Sub-merchants city.
	//
	// For processor-specific details, see `submerchant_city` request field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// #### CyberSource through VisaNet
	// The value for this field does not map to the TC 33 capture file5.
	//
	// #### FDC Compass
	// This value must consist of uppercase characters.
	//
	// Max Length: 21
	Locality string `json:"locality,omitempty"`

	// Sub-merchants business name.
	//
	// #### American Express Direct
	// The maximum length of the sub-merchant name depends on the length of the aggregator name. The combined length for both values must not exceed 36 characters.
	//
	// #### CyberSource through VisaNet
	// With American Express, the maximum length of the sub-merchant name depends on the length of the aggregator name. The combined length for both values must not exceed 36 characters. The value for this field does not map to the TC 33 capture file5.
	//
	// #### FDC Compass
	// This value must consist of uppercase characters.
	//
	// #### FDC Nashville Global
	// With Mastercard, the maximum length of the sub-merchant name depends on the length of the aggregator name:
	// - If aggregator name length is 1 through 3, maximum sub-merchant name length is 21.
	// - If aggregator name length is 4 through 7, maximum sub-merchant name length is 17.
	// - If aggregator name length is 8 through 12, maximum sub-merchant name length is 12.
	//
	// Max Length: 37
	Name string `json:"name,omitempty"`

	// Sub-merchants telephone number.
	//
	// **Maximum length for procesors**
	//
	//  - American Express Direct: 20
	//  - CyberSource through VisaNet: 20
	//  - FDC Compass: 13
	//  - FDC Nashville Global: 10
	//
	// #### CyberSource through VisaNet
	// With American Express, the value for this field corresponds to the following data in the TC 33 capture file5:
	// - Record: CP01 TCRB
	// - Position: 5-24
	// - Field: American Express Seller Telephone Number
	//
	// **FDC Compass**\
	// This value must consist of uppercase characters. Use one of these recommended formats:\
	// `NNN-NNN-NNNN`\
	// `NNN-AAAAAAA`
	//
	// Max Length: 20
	PhoneNumber string `json:"phoneNumber,omitempty"`

	// Partial postal code for the sub-merchants address.
	//
	// For processor-specific details, see `submerchant_postal_code` request field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// #### CyberSource through VisaNet
	// The value for this field does not map to the TC 33 capture file5.
	//
	// #### FDC Compass
	// This value must consist of uppercase characters.
	//
	// Max Length: 15
	PostalCode string `json:"postalCode,omitempty"`

	// Sub-merchants region.
	//
	// **Example**\
	// `NE` indicates that the sub-merchant is in the northeast region.
	//
	// For processor-specific details, see `submerchant_region` request field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 3
	Region string `json:"region,omitempty"`
}

// Validate validates this create payment params body aggregator information sub merchant
func (o *CreatePaymentParamsBodyAggregatorInformationSubMerchant) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAddress1(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAdministrativeArea(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCardAcceptorID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEmail(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocality(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePhoneNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRegion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyAggregatorInformationSubMerchant) validateAddress1(formats strfmt.Registry) error {

	if swag.IsZero(o.Address1) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"aggregatorInformation"+"."+"subMerchant"+"."+"address1", "body", string(o.Address1), 38); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyAggregatorInformationSubMerchant) validateAdministrativeArea(formats strfmt.Registry) error {

	if swag.IsZero(o.AdministrativeArea) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"aggregatorInformation"+"."+"subMerchant"+"."+"administrativeArea", "body", string(o.AdministrativeArea), 3); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyAggregatorInformationSubMerchant) validateCardAcceptorID(formats strfmt.Registry) error {

	if swag.IsZero(o.CardAcceptorID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"aggregatorInformation"+"."+"subMerchant"+"."+"cardAcceptorId", "body", string(o.CardAcceptorID), 15); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyAggregatorInformationSubMerchant) validateCountry(formats strfmt.Registry) error {

	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"aggregatorInformation"+"."+"subMerchant"+"."+"country", "body", string(o.Country), 3); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyAggregatorInformationSubMerchant) validateEmail(formats strfmt.Registry) error {

	if swag.IsZero(o.Email) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"aggregatorInformation"+"."+"subMerchant"+"."+"email", "body", string(o.Email), 40); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyAggregatorInformationSubMerchant) validateLocality(formats strfmt.Registry) error {

	if swag.IsZero(o.Locality) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"aggregatorInformation"+"."+"subMerchant"+"."+"locality", "body", string(o.Locality), 21); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyAggregatorInformationSubMerchant) validateName(formats strfmt.Registry) error {

	if swag.IsZero(o.Name) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"aggregatorInformation"+"."+"subMerchant"+"."+"name", "body", string(o.Name), 37); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyAggregatorInformationSubMerchant) validatePhoneNumber(formats strfmt.Registry) error {

	if swag.IsZero(o.PhoneNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"aggregatorInformation"+"."+"subMerchant"+"."+"phoneNumber", "body", string(o.PhoneNumber), 20); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyAggregatorInformationSubMerchant) validatePostalCode(formats strfmt.Registry) error {

	if swag.IsZero(o.PostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"aggregatorInformation"+"."+"subMerchant"+"."+"postalCode", "body", string(o.PostalCode), 15); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyAggregatorInformationSubMerchant) validateRegion(formats strfmt.Registry) error {

	if swag.IsZero(o.Region) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"aggregatorInformation"+"."+"subMerchant"+"."+"region", "body", string(o.Region), 3); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyAggregatorInformationSubMerchant) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyAggregatorInformationSubMerchant) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyAggregatorInformationSubMerchant
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyBuyerInformation create payment params body buyer information
swagger:model CreatePaymentParamsBodyBuyerInformation
*/
type CreatePaymentParamsBodyBuyerInformation struct {

	// Companys tax identifier. This is only used for eCheck service.
	//
	// ** TeleCheck **
	// Contact your TeleCheck representative to find out whether this field is required or optional.
	//
	// ** All Other Processors **
	// Not used.
	//
	// Max Length: 9
	CompanyTaxID string `json:"companyTaxId,omitempty"`

	// Recipients date of birth. **Format**: `YYYYMMDD`.
	//
	// This field is a `pass-through`, which means that CyberSource ensures that the value is eight numeric characters
	// but otherwise does not verify the value or modify it in any way before sending it to the processor. If the field
	// is not required for the transaction, CyberSource does not forward it to the processor.
	//
	// For more details, see `recipient_date_of_birth` field description in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 8
	DateOfBirth string `json:"dateOfBirth,omitempty"`

	// The merchant's password that CyberSource hashes and stores as a hashed password.
	//
	// For details about this field, see the `customer_password` field description in [Decision Manager Developer Guide Using the SCMP API.](https://www.cybersource.com/developers/documentation/fraud_management/)
	//
	// Max Length: 100
	HashedPassword string `json:"hashedPassword,omitempty"`

	// Your identifier for the customer.
	//
	// When a subscription or customer profile is being created, the maximum length for this field for most processors is 30. Otherwise, the maximum length is 100.
	//
	// #### Comercio Latino
	// For recurring payments in Mexico, the value is the customers contract number.
	// Note Before you request the authorization, you must inform the issuer of the customer contract numbers that will be used for recurring transactions.
	//
	// #### Worldpay VAP
	// For a follow-on credit with Worldpay VAP, CyberSource checks the following locations, in the order
	// given, for a customer account ID value and uses the first value it finds:
	// 1. `customer_account_id` value in the follow-on credit request
	// 2. Customer account ID value that was used for the capture that is being credited
	// 3. Customer account ID value that was used for the original authorization
	// If a customer account ID value cannot be found in any of these locations, then no value is used.
	//
	// For processor-specific information, see the `customer_account_id` field description in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 100
	MerchantCustomerID string `json:"merchantCustomerId,omitempty"`

	// personal identification
	PersonalIdentification []*CreatePaymentParamsBodyBuyerInformationPersonalIdentificationItems0 `json:"personalIdentification"`

	// Customers government-assigned tax identification number.
	//
	// For processor-specific information, see the purchaser_vat_registration_number field in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 20
	VatRegistrationNumber string `json:"vatRegistrationNumber,omitempty"`
}

// Validate validates this create payment params body buyer information
func (o *CreatePaymentParamsBodyBuyerInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCompanyTaxID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDateOfBirth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateHashedPassword(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMerchantCustomerID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePersonalIdentification(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateVatRegistrationNumber(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyBuyerInformation) validateCompanyTaxID(formats strfmt.Registry) error {

	if swag.IsZero(o.CompanyTaxID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"buyerInformation"+"."+"companyTaxId", "body", string(o.CompanyTaxID), 9); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyBuyerInformation) validateDateOfBirth(formats strfmt.Registry) error {

	if swag.IsZero(o.DateOfBirth) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"buyerInformation"+"."+"dateOfBirth", "body", string(o.DateOfBirth), 8); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyBuyerInformation) validateHashedPassword(formats strfmt.Registry) error {

	if swag.IsZero(o.HashedPassword) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"buyerInformation"+"."+"hashedPassword", "body", string(o.HashedPassword), 100); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyBuyerInformation) validateMerchantCustomerID(formats strfmt.Registry) error {

	if swag.IsZero(o.MerchantCustomerID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"buyerInformation"+"."+"merchantCustomerId", "body", string(o.MerchantCustomerID), 100); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyBuyerInformation) validatePersonalIdentification(formats strfmt.Registry) error {

	if swag.IsZero(o.PersonalIdentification) { // not required
		return nil
	}

	for i := 0; i < len(o.PersonalIdentification); i++ {
		if swag.IsZero(o.PersonalIdentification[i]) { // not required
			continue
		}

		if o.PersonalIdentification[i] != nil {
			if err := o.PersonalIdentification[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("createPaymentRequest" + "." + "buyerInformation" + "." + "personalIdentification" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CreatePaymentParamsBodyBuyerInformation) validateVatRegistrationNumber(formats strfmt.Registry) error {

	if swag.IsZero(o.VatRegistrationNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"buyerInformation"+"."+"vatRegistrationNumber", "body", string(o.VatRegistrationNumber), 20); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyBuyerInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyBuyerInformation) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyBuyerInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyBuyerInformationPersonalIdentificationItems0 create payment params body buyer information personal identification items0
swagger:model CreatePaymentParamsBodyBuyerInformationPersonalIdentificationItems0
*/
type CreatePaymentParamsBodyBuyerInformationPersonalIdentificationItems0 struct {

	// The value of the identification type. This field is supported only on the following processors.
	//
	// #### ComercioLatino
	// Set this field to the Cadastro de Pessoas Fisicas (CPF).
	//
	// #### CyberSource Latin American Processing
	// Supported for Redecard in Brazil. Set this field to the Cadastro de Pessoas Fisicas (CPF), which is required for AVS for Redecard in Brazil.
	// **Note** CyberSource Latin American Processing is the name of a specific processing connection that CyberSource supports. In the CyberSource API documentation, CyberSource Latin American Processing does not refer to the general topic of processing in Latin America. The information in this field description is for the specific processing connection called CyberSource Latin American Processing. It is not for any other Latin American processors that CyberSource supports.
	//
	// For processor-specific information, see the `personal_id` field in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// If `type = PASSPORT`, this is the cardholder's passport number.
	// Recommended for Discover ProtectBuy.
	//
	// Max Length: 26
	ID string `json:"id,omitempty"`

	// The government agency that issued the driver's license or passport.
	//
	// If **type**` = DRIVER_LICENSE`, this is the State or province where the customers drivers license was issued.
	//
	// If **type**` = PASSPORT`, this is the Issuing country for the cardholders passport. Recommended for Discover ProtectBuy.
	//
	// Use the two-character State, Province, and Territory Codes for the United States and Canada.
	//
	// #### TeleCheck
	// Contact your TeleCheck representative to find out whether this field is required or optional.
	//
	// #### All Other Processors
	// Not used.
	//
	// For details about the country that issued the passport, see `customer_passport_country` field description in [CyberSource Payer Authentication Using the SCMP API]
	// (https://apps.cybersource.com/library/documentation/dev_guides/Payer_Authentication_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// For details about the state or province that issued the passport, see `driver_license_state` field description in [Electronic Check Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/EChecks_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	IssuedBy string `json:"issuedBy,omitempty"`

	// The type of the identification.
	//
	// Possible values:
	//   - `NATIONAL`
	//   - `CPF`
	//   - `CPNJ`
	//   - `CURP`
	//   - `SSN`
	//   - `DRIVER_LICENSE`
	//
	// This field is supported only on the following processors.
	//
	// #### ComercioLatino
	// Set this field to the Cadastro de Pessoas Fisicas (CPF).
	//
	// #### CyberSource Latin American Processing
	// Supported for Redecard in Brazil. Set this field to the Cadastro de Pessoas Fisicas (CPF), which is required for AVS for Redecard in Brazil.
	// **Note** CyberSource Latin American Processing is the name of a specific processing connection that CyberSource supports. In the CyberSource API documentation, CyberSource Latin American Processing does not refer to the general topic of processing in Latin America. The information in this field description is for the specific processing connection called CyberSource Latin American Processing. It is not for any other Latin American processors that CyberSource supports.
	//
	// For processor-specific information, see the `personal_id` field in [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	Type string `json:"type,omitempty"`
}

// Validate validates this create payment params body buyer information personal identification items0
func (o *CreatePaymentParamsBodyBuyerInformationPersonalIdentificationItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyBuyerInformationPersonalIdentificationItems0) validateID(formats strfmt.Registry) error {

	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MaxLength("id", "body", string(o.ID), 26); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyBuyerInformationPersonalIdentificationItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyBuyerInformationPersonalIdentificationItems0) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyBuyerInformationPersonalIdentificationItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyClientReferenceInformation create payment params body client reference information
swagger:model CreatePaymentParamsBodyClientReferenceInformation
*/
type CreatePaymentParamsBodyClientReferenceInformation struct {

	// Client-generated order reference or tracking number. CyberSource recommends that you send a unique value for each
	// transaction so that you can perform meaningful searches for the transaction.
	//
	// For information about tracking orders, see "Tracking and Reconciling Your Orders" in [Getting Started with CyberSource Advanced for the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Getting_Started_SCMP/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// #### FDC Nashville Global
	// Certain circumstances can cause the processor to truncate this value to 15 or 17 characters for Level II and Level III processing, which can cause a discrepancy between the value you submit and the value included in some processor reports.
	//
	// Max Length: 50
	Code string `json:"code,omitempty"`

	// Comments
	Comments string `json:"comments,omitempty"`

	// partner
	Partner *CreatePaymentParamsBodyClientReferenceInformationPartner `json:"partner,omitempty"`

	// Identifier that you assign to the transaction.
	//
	// **Note** Use this field only if you want to support merchant-initiated reversal and void operations.
	//
	// For details, see "Merchant-Initiated Reversals and Voids" in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	TransactionID string `json:"transactionId,omitempty"`
}

// Validate validates this create payment params body client reference information
func (o *CreatePaymentParamsBodyClientReferenceInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePartner(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyClientReferenceInformation) validateCode(formats strfmt.Registry) error {

	if swag.IsZero(o.Code) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"clientReferenceInformation"+"."+"code", "body", string(o.Code), 50); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyClientReferenceInformation) validatePartner(formats strfmt.Registry) error {

	if swag.IsZero(o.Partner) { // not required
		return nil
	}

	if o.Partner != nil {
		if err := o.Partner.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "clientReferenceInformation" + "." + "partner")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyClientReferenceInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyClientReferenceInformation) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyClientReferenceInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyClientReferenceInformationPartner create payment params body client reference information partner
swagger:model CreatePaymentParamsBodyClientReferenceInformationPartner
*/
type CreatePaymentParamsBodyClientReferenceInformationPartner struct {

	// Identifier for the developer that helped integrate a partner solution to CyberSource.
	//
	// Send this value in all requests that are sent through the partner solutions built by that developer.
	// CyberSource assigns the ID to the developer.
	//
	// **Note** When you see a developer ID of 999 in reports, the developer ID that was submitted is incorrect.
	//
	// Max Length: 8
	DeveloperID string `json:"developerId,omitempty"`

	// Value that links the previous transaction to the current follow-on request. This value is assigned by the client
	// software that is installed on the POS terminal, which makes it available to the terminals software and to
	// CyberSource. Therefore, you can use this value to reconcile transactions between CyberSource and the terminals
	// software.
	//
	// CyberSource does not forward this value to the processor. Instead, the value is forwarded to the CyberSource
	// reporting functionality.
	//
	// This field is supported only on American Express Direct, FDC Nashville Global, and SIX.
	//
	// Max Length: 32
	OriginalTransactionID string `json:"originalTransactionId,omitempty"`

	// Identifier for the partner that is integrated to CyberSource.
	//
	// Send this value in all requests that are sent through the partner solution. CyberSource assigns the ID to the partner.
	//
	// **Note** When you see a partner ID of 999 in reports, the partner ID that was submitted is incorrect.
	//
	// Max Length: 8
	SolutionID string `json:"solutionId,omitempty"`
}

// Validate validates this create payment params body client reference information partner
func (o *CreatePaymentParamsBodyClientReferenceInformationPartner) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDeveloperID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOriginalTransactionID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSolutionID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyClientReferenceInformationPartner) validateDeveloperID(formats strfmt.Registry) error {

	if swag.IsZero(o.DeveloperID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"clientReferenceInformation"+"."+"partner"+"."+"developerId", "body", string(o.DeveloperID), 8); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyClientReferenceInformationPartner) validateOriginalTransactionID(formats strfmt.Registry) error {

	if swag.IsZero(o.OriginalTransactionID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"clientReferenceInformation"+"."+"partner"+"."+"originalTransactionId", "body", string(o.OriginalTransactionID), 32); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyClientReferenceInformationPartner) validateSolutionID(formats strfmt.Registry) error {

	if swag.IsZero(o.SolutionID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"clientReferenceInformation"+"."+"partner"+"."+"solutionId", "body", string(o.SolutionID), 8); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyClientReferenceInformationPartner) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyClientReferenceInformationPartner) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyClientReferenceInformationPartner
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyConsumerAuthenticationInformation create payment params body consumer authentication information
swagger:model CreatePaymentParamsBodyConsumerAuthenticationInformation
*/
type CreatePaymentParamsBodyConsumerAuthenticationInformation struct {

	// Cardholder authentication verification value (CAVV).
	// Max Length: 40
	Cavv string `json:"cavv,omitempty"`

	// Algorithm used to generate the CAVV for Visa Secure or the UCAF authentication data for Mastercard Identity Check.
	//
	// Max Length: 1
	CavvAlgorithm string `json:"cavvAlgorithm,omitempty"`

	// Raw electronic commerce indicator (ECI).
	//
	// For details, see `eci_raw` request field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 2
	EciRaw string `json:"eciRaw,omitempty"`

	// Payer authentication response status.
	//
	// For details, see `pares_status` request field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 1
	ParesStatus string `json:"paresStatus,omitempty"`

	// Universal cardholder authentication field (UCAF) data.
	//
	// For details, see `ucaf_authentication_data` request field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 32
	UcafAuthenticationData string `json:"ucafAuthenticationData,omitempty"`

	// Universal cardholder authentication field (UCAF) collection indicator.
	//
	// For details, see `ucaf_collection_indicator` request field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// #### CyberSource through VisaNet
	// The value for this field corresponds to the following data in the TC 33 capture file5:
	// - Record: CP01 TCR7
	// - Position: 5
	// - Field: Mastercard Electronic Commerce IndicatorsUCAF Collection Indicator
	//
	// Max Length: 1
	UcafCollectionIndicator string `json:"ucafCollectionIndicator,omitempty"`

	// Verification response enrollment status.
	//
	// For details, see `veres_enrolled` request field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 1
	VeresEnrolled string `json:"veresEnrolled,omitempty"`

	// Transaction identifier.
	//
	// For details, see `xid` request field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 40
	Xid string `json:"xid,omitempty"`
}

// Validate validates this create payment params body consumer authentication information
func (o *CreatePaymentParamsBodyConsumerAuthenticationInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCavv(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCavvAlgorithm(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEciRaw(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateParesStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateUcafAuthenticationData(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateUcafCollectionIndicator(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateVeresEnrolled(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateXid(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyConsumerAuthenticationInformation) validateCavv(formats strfmt.Registry) error {

	if swag.IsZero(o.Cavv) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"consumerAuthenticationInformation"+"."+"cavv", "body", string(o.Cavv), 40); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyConsumerAuthenticationInformation) validateCavvAlgorithm(formats strfmt.Registry) error {

	if swag.IsZero(o.CavvAlgorithm) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"consumerAuthenticationInformation"+"."+"cavvAlgorithm", "body", string(o.CavvAlgorithm), 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyConsumerAuthenticationInformation) validateEciRaw(formats strfmt.Registry) error {

	if swag.IsZero(o.EciRaw) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"consumerAuthenticationInformation"+"."+"eciRaw", "body", string(o.EciRaw), 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyConsumerAuthenticationInformation) validateParesStatus(formats strfmt.Registry) error {

	if swag.IsZero(o.ParesStatus) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"consumerAuthenticationInformation"+"."+"paresStatus", "body", string(o.ParesStatus), 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyConsumerAuthenticationInformation) validateUcafAuthenticationData(formats strfmt.Registry) error {

	if swag.IsZero(o.UcafAuthenticationData) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"consumerAuthenticationInformation"+"."+"ucafAuthenticationData", "body", string(o.UcafAuthenticationData), 32); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyConsumerAuthenticationInformation) validateUcafCollectionIndicator(formats strfmt.Registry) error {

	if swag.IsZero(o.UcafCollectionIndicator) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"consumerAuthenticationInformation"+"."+"ucafCollectionIndicator", "body", string(o.UcafCollectionIndicator), 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyConsumerAuthenticationInformation) validateVeresEnrolled(formats strfmt.Registry) error {

	if swag.IsZero(o.VeresEnrolled) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"consumerAuthenticationInformation"+"."+"veresEnrolled", "body", string(o.VeresEnrolled), 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyConsumerAuthenticationInformation) validateXid(formats strfmt.Registry) error {

	if swag.IsZero(o.Xid) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"consumerAuthenticationInformation"+"."+"xid", "body", string(o.Xid), 40); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyConsumerAuthenticationInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyConsumerAuthenticationInformation) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyConsumerAuthenticationInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyDeviceInformation create payment params body device information
swagger:model CreatePaymentParamsBodyDeviceInformation
*/
type CreatePaymentParamsBodyDeviceInformation struct {

	// DNS resolved hostname from `ipAddress`.
	// Max Length: 60
	HostName string `json:"hostName,omitempty"`

	// IP address of the customer.
	//
	// Max Length: 48
	IPAddress string `json:"ipAddress,omitempty"`

	// Customers browser as identified from the HTTP header data. For example, `Mozilla` is the value that identifies
	// the Netscape browser.
	//
	// Max Length: 40
	UserAgent string `json:"userAgent,omitempty"`
}

// Validate validates this create payment params body device information
func (o *CreatePaymentParamsBodyDeviceInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateHostName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateIPAddress(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateUserAgent(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyDeviceInformation) validateHostName(formats strfmt.Registry) error {

	if swag.IsZero(o.HostName) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"deviceInformation"+"."+"hostName", "body", string(o.HostName), 60); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyDeviceInformation) validateIPAddress(formats strfmt.Registry) error {

	if swag.IsZero(o.IPAddress) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"deviceInformation"+"."+"ipAddress", "body", string(o.IPAddress), 48); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyDeviceInformation) validateUserAgent(formats strfmt.Registry) error {

	if swag.IsZero(o.UserAgent) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"deviceInformation"+"."+"userAgent", "body", string(o.UserAgent), 40); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyDeviceInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyDeviceInformation) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyDeviceInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyInstallmentInformation create payment params body installment information
swagger:model CreatePaymentParamsBodyInstallmentInformation
*/
type CreatePaymentParamsBodyInstallmentInformation struct {

	// Amount for the current installment payment.
	//
	// This field is supported only for CyberSource through VisaNet.
	//
	// For details, see `installment_amount` field description in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 12
	Amount string `json:"amount,omitempty"`

	// Indicates whether the authorization request is a Crediario eligibility inquiry.
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Set the value for this field to `Crediario`.
	//
	// This field is supported only for Crediario installment payments in Brazil on CyberSource through VisaNet.
	//
	// Max Length: 9
	EligibilityInquiry string `json:"eligibilityInquiry,omitempty"`

	// Date of the first installment payment. Format: YYMMDD. When you do not include this field, CyberSource sends a
	// string of six zeros (000000) to the processor.
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// This field is supported only for Crediario installment payments in Brazil on CyberSource through VisaNet.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file5:
	// - Record: CP01 TCR9
	// - Position: 42-47
	// - Field: Date of First Installment
	//
	// Max Length: 6
	FirstInstallmentDate string `json:"firstInstallmentDate,omitempty"`

	// Frequency of the installment payments. When you do not include this field in a request for a
	// Crediario installment payment, CyberSource sends a space character to the processor.
	//
	// For details, see `installment_frequency` field description in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// This field is supported only for CyberSource through VisaNet. Possible values:
	// - `B`: Biweekly
	// - `M`: Monthly
	// - `W`: Weekly
	//
	// For Crediario installment payments, the value for this field corresponds to the following data in the TC 33 capture file5:
	// - Record: CP01 TCR9
	// - Position: 41
	// - Field: Installment Frequency
	//
	// For details, see "Installment Payments" in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 1
	Frequency string `json:"frequency,omitempty"`

	// Invoice information that you want to provide to the issuer. This value is similar to a tracking number and is
	// the same for all installment payments for one purchase.
	//
	// This field is supported only for installment payments with Mastercard on CyberSource through VisaNet in Brazil.
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// The value for this field corresponds to the following data in the TC 33 capture file5:
	// - Record: CP07 TCR4
	// - Position: 51-70
	// - Field: Purchase Identification
	//
	// Max Length: 20
	InvoiceData string `json:"invoiceData,omitempty"`

	// Payment plan for the installments.
	//
	// Possible values:
	// - 0 (default): Regular installment. This value is not allowed for airline transactions.
	// - 1: Installment payment with down payment.
	// - 2: Installment payment without down payment. This value is supported only for airline transactions.
	// - 3: Installment payment; down payment and boarding fee will follow. This value is supported only for airline transactions.
	// - 4: Down payment only; regular installment payment will follow.
	// - 5: Boarding fee only. This value is supported only for airline transactions.
	//
	// This field is supported only for installment payments with Visa on CyberSource through VisaNet in Brazil.
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// The value for this field corresponds to the following data in the TC 33 capture file5:
	// - Record: CP07 TCR1
	// - Position: 9
	// - Field: Merchant Installment Supporting Information
	//
	// Max Length: 1
	PaymentType string `json:"paymentType,omitempty"`

	// #### American Express Direct, Cielo, and CyberSource Latin American Processing
	// Flag that indicates the type of funding for the installment plan associated with the payment.
	//
	// Possible values:
	// - `1`: Merchant-funded installment plan
	// - `2`: Issuer-funded installment plan
	// If you do not include this field in the request, CyberSource uses the value in your CyberSource account.
	//
	// To change the value in your CyberSource account, contact CyberSource Customer Service.
	// For details, see `installment_plan_type` field description in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// #### CyberSource through VisaNet and American Express
	// Defined code that indicates the type of installment plan for this transaction.
	//
	// Contact American Express for:
	// - Information about the kinds of installment plans that American Express provides
	// - Values for this field
	//
	// For installment payments with American Express in Brazil, the value for this field corresponds to the following data in the TC 33 capture file*:
	// - Record: CP07 TCR3
	// - Position: 5-6
	// - Field: Plan Type
	//
	// * The TC 33 Capture file contains information about the purchases and refunds that a merchant submits to CyberSource. CyberSource through VisaNet creates the TC 33 Capture file at the end of the day and sends it to the merchants acquirer, who uses this information to facilitate end-of-day clearing processing with payment card companies.
	//
	// #### CyberSource through VisaNet with Visa or Mastercard
	// Flag indicating the type of funding for the installment plan associated with the payment.
	// Possible values:
	// - 1 or 01: Merchant-funded installment plan
	// - 2 or 02: Issuer-funded installment plan
	// - 43: Crediario installment planonly with Visa in Brazil
	// For details, see "Installment Payments on CyberSource through VisaNet" in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// For installment payments with Visa in Brazil, the value for this field corresponds to the following data in the TC 33 capture file5:
	// - Record: CP07 TCR1
	// - Position: 5-6
	// - Field: Installment Type
	//
	// For all other kinds of installment payments, the value for this field corresponds to the following data in the TC 33 capture file5:
	// - Record: CP01 TCR5
	// - Position: 39-40
	// - Field: Installment Plan Type (Issuer or Merchant)
	//
	// Max Length: 1
	PlanType string `json:"planType,omitempty"`

	// Installment number when making payments in installments. Used along with `totalCount` to track which payment is being processed.
	//
	// For example, the second of 5 payments would be passed to CyberSource as `sequence` = 2 and `totalCount` = 5.
	//
	// For details, see "Installment Payments" in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// #### Chase Paymentech Solutions and FDC Compass
	// This field is optional because this value is required in the merchant descriptors.
	// For details, see "Chase Paymentech Solutions Merchant Descriptors" and "FDC Compass Merchant Descriptors" in the [Merchant Descriptors Using the SCMP API]
	// (https://apps.cybersource.com/library/documentation/dev_guides/Merchant_Descriptors_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// #### CyberSource through VisaNet
	// When you do not include this field in a request for a Crediario installment payment, CyberSource sends a value of 0 to the processor.
	//
	// For Crediario installment payments, the value for this field corresponds to the following data in the TC 33 capture file*:
	// - Record: CP01 TCR9
	// - Position: 38-40
	// - Field: Installment Payment Number
	//
	// * The TC 33 Capture file contains information about the purchases and refunds that a merchant submits to CyberSource. CyberSource through VisaNet creates the TC 33 Capture file at the end of the day and sends it to the merchants acquirer, who uses this information to facilitate end-of-day clearing processing with payment card companies.
	//
	// Maximum: 99
	Sequence int64 `json:"sequence,omitempty"`

	// Total amount of the loan that is being paid in installments. This field is supported only for CyberSource
	// through VisaNet.
	//
	// For details, see "Installment Payments" in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 12
	TotalAmount string `json:"totalAmount,omitempty"`

	// Total number of installments when making payments in installments.
	//
	// For details, see "Installment Payments" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// #### Chase Paymentech Solutions and FDC Compass
	// This field is optional because this value is required in the merchant descriptors.
	//
	// For details, see "Chase Paymentech Solutions Merchant Descriptors" and "FDC Compass Merchant Descriptors" in the [Merchant Descriptors Using the SCMP API.]
	// (https://apps.cybersource.com/library/documentation/dev_guides/Merchant_Descriptors_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// #### American Express Direct, Cielo, and Comercio Latino
	// This value is the total number of installments you approved.
	//
	// #### CyberSource Latin American Processing in Brazil
	// This value is the total number of installments that you approved. The default is 1.
	//
	// #### All Other Processors
	// This value is used along with _sequence_ to track which payment is being processed.
	//
	// For example, the second of 5 payments would be passed to CyberSource as _sequence_ = 2 and _totalCount_ = 5.
	//
	// #### CyberSource through VisaNet
	// For Crediario installment payments, the value for this field corresponds to the following data in the TC 33 capture file*:
	// - Record: CP01 TCR9
	// - Position: 23-25
	// - Field: Number of Installments
	//
	// For installment payments with American Express in Brazil, the value for this field corresponds to the following data in the TC 33 capture file*:
	// - Record: CP07 TCR3
	// - Position: 7-8
	// - Field: Number of Installments
	//
	// For installment payments with Visa in Brazil, the value for this field corresponds to the following data in the TC 33 capture file*:
	// - Record: CP07 TCR1
	// - Position: 7-8
	// - Field: Number of Installments
	//
	// For all other kinds of installment payments, the value for this field corresponds to the following data in the TC 33 capture file*:
	// - Record: CP01 TCR5
	// - Position: 20-22
	// - Field: Installment Total Count
	//
	// **Note** The TC 33 Capture file contains information about the purchases and refunds that a merchant submits to CyberSource. CyberSource through VisaNet creates the TC 33 Capture file at the end of the day and sends it to the merchants acquirer, who uses this information to facilitate end-of-day clearing processing with payment card companies.
	//
	// Maximum: 99
	TotalCount int64 `json:"totalCount,omitempty"`
}

// Validate validates this create payment params body installment information
func (o *CreatePaymentParamsBodyInstallmentInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEligibilityInquiry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFirstInstallmentDate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFrequency(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateInvoiceData(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePaymentType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePlanType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSequence(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTotalAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTotalCount(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyInstallmentInformation) validateAmount(formats strfmt.Registry) error {

	if swag.IsZero(o.Amount) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"installmentInformation"+"."+"amount", "body", string(o.Amount), 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyInstallmentInformation) validateEligibilityInquiry(formats strfmt.Registry) error {

	if swag.IsZero(o.EligibilityInquiry) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"installmentInformation"+"."+"eligibilityInquiry", "body", string(o.EligibilityInquiry), 9); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyInstallmentInformation) validateFirstInstallmentDate(formats strfmt.Registry) error {

	if swag.IsZero(o.FirstInstallmentDate) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"installmentInformation"+"."+"firstInstallmentDate", "body", string(o.FirstInstallmentDate), 6); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyInstallmentInformation) validateFrequency(formats strfmt.Registry) error {

	if swag.IsZero(o.Frequency) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"installmentInformation"+"."+"frequency", "body", string(o.Frequency), 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyInstallmentInformation) validateInvoiceData(formats strfmt.Registry) error {

	if swag.IsZero(o.InvoiceData) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"installmentInformation"+"."+"invoiceData", "body", string(o.InvoiceData), 20); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyInstallmentInformation) validatePaymentType(formats strfmt.Registry) error {

	if swag.IsZero(o.PaymentType) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"installmentInformation"+"."+"paymentType", "body", string(o.PaymentType), 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyInstallmentInformation) validatePlanType(formats strfmt.Registry) error {

	if swag.IsZero(o.PlanType) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"installmentInformation"+"."+"planType", "body", string(o.PlanType), 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyInstallmentInformation) validateSequence(formats strfmt.Registry) error {

	if swag.IsZero(o.Sequence) { // not required
		return nil
	}

	if err := validate.MaximumInt("createPaymentRequest"+"."+"installmentInformation"+"."+"sequence", "body", int64(o.Sequence), 99, false); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyInstallmentInformation) validateTotalAmount(formats strfmt.Registry) error {

	if swag.IsZero(o.TotalAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"installmentInformation"+"."+"totalAmount", "body", string(o.TotalAmount), 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyInstallmentInformation) validateTotalCount(formats strfmt.Registry) error {

	if swag.IsZero(o.TotalCount) { // not required
		return nil
	}

	if err := validate.MaximumInt("createPaymentRequest"+"."+"installmentInformation"+"."+"totalCount", "body", int64(o.TotalCount), 99, false); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyInstallmentInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyInstallmentInformation) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyInstallmentInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyIssuerInformation create payment params body issuer information
swagger:model CreatePaymentParamsBodyIssuerInformation
*/
type CreatePaymentParamsBodyIssuerInformation struct {

	// Data defined by the issuer.
	//
	// The value for this reply field will probably be the same as the value that you submitted in the authorization request, but it is possible for the processor, issuer, or acquirer to modify the value.
	//
	// This field is supported only for Visa transactions on **CyberSource through VisaNet**.
	//
	// For details, see `issuer_additional_data` field description in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 255
	DiscretionaryData string `json:"discretionaryData,omitempty"`
}

// Validate validates this create payment params body issuer information
func (o *CreatePaymentParamsBodyIssuerInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDiscretionaryData(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyIssuerInformation) validateDiscretionaryData(formats strfmt.Registry) error {

	if swag.IsZero(o.DiscretionaryData) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"issuerInformation"+"."+"discretionaryData", "body", string(o.DiscretionaryData), 255); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyIssuerInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyIssuerInformation) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyIssuerInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyMerchantInformation create payment params body merchant information
swagger:model CreatePaymentParamsBodyMerchantInformation
*/
type CreatePaymentParamsBodyMerchantInformation struct {

	// Reference number that facilitates card acceptor/corporation communication and record keeping.
	//
	// For processor-specific information, see the `card_acceptor_ref_number` field description in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 25
	CardAcceptorReferenceNumber string `json:"cardAcceptorReferenceNumber,omitempty"`

	// The value for this field is a four-digit number that the payment card industry uses to classify
	// merchants into market segments. A payment card company assigned one or more of these values to your business when you started
	// accepting the payment card companys cards. When you do not include this field in your request, CyberSource uses the value in your
	// CyberSource account.
	//
	// For processor-specific information, see the `merchant_category_code` field description in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// #### CyberSource through VisaNet
	// The value for this field corresponds to the following data in the TC 33 capture file5:
	// - Record: CP01 TCR4
	// - Position: 150-153
	// - Field: Merchant Category Code
	//
	// Maximum: 9999
	CategoryCode int64 `json:"categoryCode,omitempty"`

	// Merchant category code for domestic transactions. The value for this field is a four-digit number that the payment
	// card industry uses to classify merchants into market segments. A payment card company assigned one or more of these
	// values to your business when you started accepting the payment card companys cards. Including this field in a request
	// for a domestic transaction might reduce interchange fees.
	//
	// When you include this field in a request:
	// - Do not include the `merchant_category_code` field.
	// - The value for this field overrides the value in your CyberSource account.
	//
	// This field is supported only for:
	// - Domestic transactions with Mastercard in Spain. Domestic means that you and the cardholder are in the same country.
	// - Merchants enrolled in the OmniPay Direct interchange program.
	// - First Data Merchant Solutions (Europe) on OmniPay Direct.
	//
	// Maximum: 9999
	CategoryCodeDomestic int64 `json:"categoryCodeDomestic,omitempty"`

	// merchant descriptor
	MerchantDescriptor *CreatePaymentParamsBodyMerchantInformationMerchantDescriptor `json:"merchantDescriptor,omitempty"`

	// Company ID assigned to an independent sales organization. Get this value from Mastercard.
	//
	// #### CyberSource through VisaNet
	// The value for this field corresponds to the following data in the TC 33 capture file:
	// - Record: CP01 TCR6
	// - Position: 106-116
	// - Field: Mastercard Independent Sales Organization ID
	//
	// **Note** The TC 33 Capture file contains information about the purchases and refunds that a merchant submits to CyberSource. CyberSource through VisaNet creates the TC 33 Capture file at the end of the day and sends it to the merchants acquirer, who uses this information to facilitate end-of-day clearing processing with payment card companies.
	//
	// For processor-specific information, see the `sales_organization_ID` field description in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 11
	SalesOrganizationID string `json:"salesOrganizationId,omitempty"`

	// service fee descriptor
	ServiceFeeDescriptor *CreatePaymentParamsBodyMerchantInformationServiceFeeDescriptor `json:"serviceFeeDescriptor,omitempty"`

	// Your Cadastro Nacional da Pessoa Jurdica (CNPJ) number.
	//
	// This field is supported only for BNDES transactions on CyberSource through VisaNet.
	//
	// The value for this field corresponds to the following data in the TC 33 capture file5:
	// - Record: CP07 TCR6
	// - Position: 40-59
	// - Field: BNDES Reference Field 1
	//
	// For details, see `bill_merchant_tax_id` field description in the [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 15
	TaxID string `json:"taxId,omitempty"`

	// Local date and time at your physical location. Include both the date and time in this field or leave it blank.
	// This field is supported only for **CyberSource through VisaNet**.
	//
	// For processor-specific information, see the `transaction_local_date_time` field description in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Format: `YYYYMMDDhhmmss`, where:
	//
	//  - YYYY = year
	//  - MM = month
	//  - DD = day
	//  - hh = hour
	//  - mm = minutes
	//  - ss = seconds
	//
	//  For processor-specific information, see the `transaction_local_date_time` field description in [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 14
	TransactionLocalDateTime string `json:"transactionLocalDateTime,omitempty"`

	// Your government-assigned tax identification number.
	//
	// For CtV processors, the maximum length is 20.
	//
	// For other processor-specific information, see the `merchant_vat_registration_number` field description in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 21
	VatRegistrationNumber string `json:"vatRegistrationNumber,omitempty"`
}

// Validate validates this create payment params body merchant information
func (o *CreatePaymentParamsBodyMerchantInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCardAcceptorReferenceNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCategoryCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCategoryCodeDomestic(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMerchantDescriptor(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSalesOrganizationID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateServiceFeeDescriptor(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTransactionLocalDateTime(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateVatRegistrationNumber(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyMerchantInformation) validateCardAcceptorReferenceNumber(formats strfmt.Registry) error {

	if swag.IsZero(o.CardAcceptorReferenceNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"merchantInformation"+"."+"cardAcceptorReferenceNumber", "body", string(o.CardAcceptorReferenceNumber), 25); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyMerchantInformation) validateCategoryCode(formats strfmt.Registry) error {

	if swag.IsZero(o.CategoryCode) { // not required
		return nil
	}

	if err := validate.MaximumInt("createPaymentRequest"+"."+"merchantInformation"+"."+"categoryCode", "body", int64(o.CategoryCode), 9999, false); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyMerchantInformation) validateCategoryCodeDomestic(formats strfmt.Registry) error {

	if swag.IsZero(o.CategoryCodeDomestic) { // not required
		return nil
	}

	if err := validate.MaximumInt("createPaymentRequest"+"."+"merchantInformation"+"."+"categoryCodeDomestic", "body", int64(o.CategoryCodeDomestic), 9999, false); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyMerchantInformation) validateMerchantDescriptor(formats strfmt.Registry) error {

	if swag.IsZero(o.MerchantDescriptor) { // not required
		return nil
	}

	if o.MerchantDescriptor != nil {
		if err := o.MerchantDescriptor.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "merchantInformation" + "." + "merchantDescriptor")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyMerchantInformation) validateSalesOrganizationID(formats strfmt.Registry) error {

	if swag.IsZero(o.SalesOrganizationID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"merchantInformation"+"."+"salesOrganizationId", "body", string(o.SalesOrganizationID), 11); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyMerchantInformation) validateServiceFeeDescriptor(formats strfmt.Registry) error {

	if swag.IsZero(o.ServiceFeeDescriptor) { // not required
		return nil
	}

	if o.ServiceFeeDescriptor != nil {
		if err := o.ServiceFeeDescriptor.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "merchantInformation" + "." + "serviceFeeDescriptor")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyMerchantInformation) validateTaxID(formats strfmt.Registry) error {

	if swag.IsZero(o.TaxID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"merchantInformation"+"."+"taxId", "body", string(o.TaxID), 15); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyMerchantInformation) validateTransactionLocalDateTime(formats strfmt.Registry) error {

	if swag.IsZero(o.TransactionLocalDateTime) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"merchantInformation"+"."+"transactionLocalDateTime", "body", string(o.TransactionLocalDateTime), 14); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyMerchantInformation) validateVatRegistrationNumber(formats strfmt.Registry) error {

	if swag.IsZero(o.VatRegistrationNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"merchantInformation"+"."+"vatRegistrationNumber", "body", string(o.VatRegistrationNumber), 21); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyMerchantInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyMerchantInformation) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyMerchantInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyMerchantInformationMerchantDescriptor create payment params body merchant information merchant descriptor
swagger:model CreatePaymentParamsBodyMerchantInformationMerchantDescriptor
*/
type CreatePaymentParamsBodyMerchantInformationMerchantDescriptor struct {

	// First line of merchant's address. For the descriptions, used-by information, data types, and lengths for these fields, see `merchant_descriptor_street` field description
	// in [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 60
	Address1 string `json:"address1,omitempty"`

	// The state where the merchant is located.
	//
	// For the descriptions, used-by information, data types, and lengths for these fields, see the `merchant_descriptor_state` field description
	// in [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Merchant State. For the descriptions, used-by information, data types, and lengths for these fields, see Merchant Descriptors
	// in [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 3
	AdministrativeArea string `json:"administrativeArea,omitempty"`

	// An alternate name for the merchant.
	//
	// For the descriptions, used-by information, data types, and lengths for these fields, see the `merchant_descriptor_alternate` field description
	// in [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)-->
	//
	// Max Length: 13
	AlternateName string `json:"alternateName,omitempty"`

	// For the descriptions, used-by information, data types, and lengths for these fields, see `merchant_descriptor_contact` field description
	// in [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)-->
	// Contact information for the merchant.
	//
	// **Note** These are the maximum data lengths for the following payment processors:
	// - FDCCompass (13)
	// - Paymentech (13)
	//
	// Max Length: 14
	Contact string `json:"contact,omitempty"`

	// Merchant's country.
	//
	// For the descriptions, used-by information, data types, and lengths for these fields, see the `merchant_descriptor_country` field description
	// in [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 2
	Country string `json:"country,omitempty"`

	// Merchant's City.
	//
	// For the descriptions, used-by information, data types, and lengths for these fields, see the `merchant_descriptor_city` field description
	// in [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 13
	Locality string `json:"locality,omitempty"`

	// Merchant's name.
	//
	// For more details about the merchant-related fields, see the `merchant_descriptor` field description in [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// **Note** For Paymentech processor using Cybersource Payouts, the maximum data length is 22.
	//
	Name string `json:"name,omitempty"`

	// Merchant's postal code.
	//
	// For the descriptions, used-by information, data types, and lengths for these fields, see the `merchant_descriptor_postal_code` field description
	// in [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 14
	PostalCode string `json:"postalCode,omitempty"`
}

// Validate validates this create payment params body merchant information merchant descriptor
func (o *CreatePaymentParamsBodyMerchantInformationMerchantDescriptor) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAddress1(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAdministrativeArea(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAlternateName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateContact(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocality(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyMerchantInformationMerchantDescriptor) validateAddress1(formats strfmt.Registry) error {

	if swag.IsZero(o.Address1) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"merchantInformation"+"."+"merchantDescriptor"+"."+"address1", "body", string(o.Address1), 60); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyMerchantInformationMerchantDescriptor) validateAdministrativeArea(formats strfmt.Registry) error {

	if swag.IsZero(o.AdministrativeArea) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"merchantInformation"+"."+"merchantDescriptor"+"."+"administrativeArea", "body", string(o.AdministrativeArea), 3); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyMerchantInformationMerchantDescriptor) validateAlternateName(formats strfmt.Registry) error {

	if swag.IsZero(o.AlternateName) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"merchantInformation"+"."+"merchantDescriptor"+"."+"alternateName", "body", string(o.AlternateName), 13); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyMerchantInformationMerchantDescriptor) validateContact(formats strfmt.Registry) error {

	if swag.IsZero(o.Contact) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"merchantInformation"+"."+"merchantDescriptor"+"."+"contact", "body", string(o.Contact), 14); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyMerchantInformationMerchantDescriptor) validateCountry(formats strfmt.Registry) error {

	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"merchantInformation"+"."+"merchantDescriptor"+"."+"country", "body", string(o.Country), 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyMerchantInformationMerchantDescriptor) validateLocality(formats strfmt.Registry) error {

	if swag.IsZero(o.Locality) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"merchantInformation"+"."+"merchantDescriptor"+"."+"locality", "body", string(o.Locality), 13); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyMerchantInformationMerchantDescriptor) validatePostalCode(formats strfmt.Registry) error {

	if swag.IsZero(o.PostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"merchantInformation"+"."+"merchantDescriptor"+"."+"postalCode", "body", string(o.PostalCode), 14); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyMerchantInformationMerchantDescriptor) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyMerchantInformationMerchantDescriptor) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyMerchantInformationMerchantDescriptor
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyMerchantInformationServiceFeeDescriptor create payment params body merchant information service fee descriptor
swagger:model CreatePaymentParamsBodyMerchantInformationServiceFeeDescriptor
*/
type CreatePaymentParamsBodyMerchantInformationServiceFeeDescriptor struct {

	// Contact information for the service provider that is collecting the service fee. when you include more than one
	// consecutive space, extra spaces are removed.
	//
	// When you do not include this value in your request, CyberSource uses the value that is in your CyberSource account.
	//
	// This value might be displayed on the cardholders statement.
	//
	// Max Length: 11
	Contact string `json:"contact,omitempty"`

	// Name of the service provider that is collecting the service fee. The service provider name must consist of
	// 3, 7, or 12 characters followed by an asterisk (*). This value must also include the words Service Fee.
	//
	// When you include more than one consecutive space, extra spaces are removed. Use one of the following formats
	// for this value:
	// - <3-character name>*Service Fee
	// - <7-character name>*Service Fee
	// - <12-character name>*Service Fee
	//
	// When payments are made in installments, this value must also include installment information such as
	// 1 of 5 or 3 of 7. For installment payments, use one of the following formats for this value:
	// - <3-character name>*Service Fee*<N> of <M>
	// - <7-character name>*Service Fee*<N> of <M>
	// - <12-character name>*Service Fee*<N> of <M>
	//
	// where <N> is the payment number and <M> is the total number of payments.
	//
	// When you do not include this value in your request, CyberSource uses the value that is in your CyberSource
	// account.
	//
	// This value might be displayed on the cardholders statement.
	//
	// Max Length: 22
	Name string `json:"name,omitempty"`

	// State or territory in which the service provider is located.
	//
	// When you do not include this value in your request, CyberSource uses the value that is in your CyberSource account.
	//
	// This value might be displayed on the cardholders statement.
	//
	// Max Length: 20
	State string `json:"state,omitempty"`
}

// Validate validates this create payment params body merchant information service fee descriptor
func (o *CreatePaymentParamsBodyMerchantInformationServiceFeeDescriptor) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateContact(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateState(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyMerchantInformationServiceFeeDescriptor) validateContact(formats strfmt.Registry) error {

	if swag.IsZero(o.Contact) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"merchantInformation"+"."+"serviceFeeDescriptor"+"."+"contact", "body", string(o.Contact), 11); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyMerchantInformationServiceFeeDescriptor) validateName(formats strfmt.Registry) error {

	if swag.IsZero(o.Name) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"merchantInformation"+"."+"serviceFeeDescriptor"+"."+"name", "body", string(o.Name), 22); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyMerchantInformationServiceFeeDescriptor) validateState(formats strfmt.Registry) error {

	if swag.IsZero(o.State) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"merchantInformation"+"."+"serviceFeeDescriptor"+"."+"state", "body", string(o.State), 20); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyMerchantInformationServiceFeeDescriptor) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyMerchantInformationServiceFeeDescriptor) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyMerchantInformationServiceFeeDescriptor
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyOrderInformation create payment params body order information
swagger:model CreatePaymentParamsBodyOrderInformation
*/
type CreatePaymentParamsBodyOrderInformation struct {

	// amount details
	AmountDetails *CreatePaymentParamsBodyOrderInformationAmountDetails `json:"amountDetails,omitempty"`

	// bill to
	BillTo *CreatePaymentParamsBodyOrderInformationBillTo `json:"billTo,omitempty"`

	// invoice details
	InvoiceDetails *CreatePaymentParamsBodyOrderInformationInvoiceDetails `json:"invoiceDetails,omitempty"`

	// line items
	LineItems []*CreatePaymentParamsBodyOrderInformationLineItemsItems0 `json:"lineItems"`

	// ship to
	ShipTo *CreatePaymentParamsBodyOrderInformationShipTo `json:"shipTo,omitempty"`

	// shipping details
	ShippingDetails *CreatePaymentParamsBodyOrderInformationShippingDetails `json:"shippingDetails,omitempty"`
}

// Validate validates this create payment params body order information
func (o *CreatePaymentParamsBodyOrderInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAmountDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBillTo(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateInvoiceDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLineItems(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateShipTo(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateShippingDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyOrderInformation) validateAmountDetails(formats strfmt.Registry) error {

	if swag.IsZero(o.AmountDetails) { // not required
		return nil
	}

	if o.AmountDetails != nil {
		if err := o.AmountDetails.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "orderInformation" + "." + "amountDetails")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformation) validateBillTo(formats strfmt.Registry) error {

	if swag.IsZero(o.BillTo) { // not required
		return nil
	}

	if o.BillTo != nil {
		if err := o.BillTo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "orderInformation" + "." + "billTo")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformation) validateInvoiceDetails(formats strfmt.Registry) error {

	if swag.IsZero(o.InvoiceDetails) { // not required
		return nil
	}

	if o.InvoiceDetails != nil {
		if err := o.InvoiceDetails.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "orderInformation" + "." + "invoiceDetails")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformation) validateLineItems(formats strfmt.Registry) error {

	if swag.IsZero(o.LineItems) { // not required
		return nil
	}

	for i := 0; i < len(o.LineItems); i++ {
		if swag.IsZero(o.LineItems[i]) { // not required
			continue
		}

		if o.LineItems[i] != nil {
			if err := o.LineItems[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("createPaymentRequest" + "." + "orderInformation" + "." + "lineItems" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformation) validateShipTo(formats strfmt.Registry) error {

	if swag.IsZero(o.ShipTo) { // not required
		return nil
	}

	if o.ShipTo != nil {
		if err := o.ShipTo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "orderInformation" + "." + "shipTo")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformation) validateShippingDetails(formats strfmt.Registry) error {

	if swag.IsZero(o.ShippingDetails) { // not required
		return nil
	}

	if o.ShippingDetails != nil {
		if err := o.ShippingDetails.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "orderInformation" + "." + "shippingDetails")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyOrderInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyOrderInformation) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyOrderInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyOrderInformationAmountDetails create payment params body order information amount details
swagger:model CreatePaymentParamsBodyOrderInformationAmountDetails
*/
type CreatePaymentParamsBodyOrderInformationAmountDetails struct {

	// amex additional amounts
	AmexAdditionalAmounts []*CreatePaymentParamsBodyOrderInformationAmountDetailsAmexAdditionalAmountsItems0 `json:"amexAdditionalAmounts"`

	// Currency used for the order. Use the three-character I[ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)
	//
	// For details about currency as used in partial authorizations, see "Features for Debit Cards and Prepaid Cards" in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// For an authorization reversal (`reversalInformation`) or a capture (`processingOptions.capture` is set to `true`), you must use the same currency that you used in your payment authorization request.
	//
	// #### DCC for First Data
	// Your local currency. For details, see the `currency` field description in [Dynamic Currency Conversion For First Data Using the SCMP API](http://apps.cybersource.com/library/documentation/dev_guides/DCC_FirstData_SCMP/DCC_FirstData_SCMP_API.pdf).
	//
	// Max Length: 3
	Currency string `json:"currency,omitempty"`

	// Total discount amount applied to the order.
	//
	// For processor-specific information, see the order_discount_amount field in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 15
	DiscountAmount string `json:"discountAmount,omitempty"`

	// Total charges for any import or export duties included in the order.
	//
	// For processor-specific information, see the duty_amount field in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 15
	DutyAmount string `json:"dutyAmount,omitempty"`

	// Exchange rate returned by the DCC service. Includes a decimal point and a maximum of 4 decimal places.
	//
	// For details, see `exchange_rate` request-level field description in the [Dynamic Currency Conversion For First Data Using the SCMP API](http://apps.cybersource.com/library/documentation/dev_guides/DCC_FirstData_SCMP/DCC_FirstData_SCMP_API.pdf)
	//
	// For processor-specific information, see the `exchange_rate` request-level field description in
	// [Credit Card Services Using the SCMP API Guide.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 13
	ExchangeRate string `json:"exchangeRate,omitempty"`

	// Time stamp for the exchange rate. This value is returned by the DCC service.
	//
	// Format: `YYYYMMDD~HH:MM`  where ~ denotes a space.
	//
	// For processor-specific information, see the `exchange_rate_timestamp` request-level field description in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 14
	ExchangeRateTimeStamp string `json:"exchangeRateTimeStamp,omitempty"`

	// Set this field to the converted amount that was returned by the DCC provider.
	// For processor-specific information, see the `foreign_amount` field description in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 15
	ForeignAmount string `json:"foreignAmount,omitempty"`

	// Set this field to the converted amount that was returned by the DCC provider.
	// For processor-specific information, see the `foreign_amount` field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 5
	ForeignCurrency string `json:"foreignCurrency,omitempty"`

	// Total freight or shipping and handling charges for the order. When you include this field in your request, you
	// must also include the **totalAmount** field.
	//
	// For processor-specific information, see the freight_amount field in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 13
	FreightAmount string `json:"freightAmount,omitempty"`

	// Gratuity or tip amount for restaurants when the card is present. Allowed only when `industryDatatype=restaurant`.
	// When your customer uses a debit card or prepaid card, and you receive a partial authorization, the payment networks recommend that you do not
	// submit a capture amount that is higher than the authorized amount. When the capture amount exceeds the partial amount that was approved, the
	// issuer has chargeback rights for the excess amount.
	//
	// For information about partial authorizations, see Credit Card Services Using the SCMP API.
	//
	// Restaurant data is supported only on CyberSource through VisaNet.
	//
	// Max Length: 13
	GratuityAmount string `json:"gratuityAmount,omitempty"`

	// Flag that indicates whether a national tax is included in the order total.
	//
	// Possible values:
	//
	//  - **0**: national tax not included
	//  - **1**: national tax included
	//
	// For processor-specific information, see the national_tax_indicator field in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 1
	NationalTaxIncluded string `json:"nationalTaxIncluded,omitempty"`

	// Amount in your original local pricing currency.
	//
	// This value cannot be negative. You can include a decimal point (.) in this field to denote the currency
	// exponent, but you cannot include any other special characters.
	//
	// If needed, CyberSource truncates the amount to the correct number of decimal places.
	//
	// For details, see the `original_amount` field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 15
	OriginalAmount string `json:"originalAmount,omitempty"`

	// Your local pricing currency code.
	//
	// For the possible values, see the [ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)
	//
	// For details, see `original_currency` field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// For details about converting a foreign cardholders purchase from your local pricing currency to the cardholders billing currency, see the [Dynamic Currency Conversion with a Third Party Provider Guide.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm).
	//
	// Max Length: 15
	OriginalCurrency string `json:"originalCurrency,omitempty"`

	// Service fee. Required for service fee transactions.
	//
	// Max Length: 15
	ServiceFeeAmount string `json:"serviceFeeAmount,omitempty"`

	// This is a multicurrency field. It contains the transaction amount (field 4), converted to the Currency used to bill the cardholders account.
	//
	// Max Length: 12
	SettlementAmount string `json:"settlementAmount,omitempty"`

	// This is a multicurrency-only field. It contains a 3-digit numeric code that identifies the currency used by the issuer to bill the cardholder's account.
	//
	// Max Length: 3
	SettlementCurrency string `json:"settlementCurrency,omitempty"`

	// surcharge
	Surcharge *CreatePaymentParamsBodyOrderInformationAmountDetailsSurcharge `json:"surcharge,omitempty"`

	// Total tax amount for all the items in the order.
	//
	// For processor-specific information, see the total_tax_amount field in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 12
	TaxAmount string `json:"taxAmount,omitempty"`

	// Flag that indicates how the merchant manages discounts.
	//
	// Possible values:
	//
	//  - **0**: no invoice level discount included
	//  - **1**: tax calculated on the postdiscount invoice total
	//  - **2**: tax calculated on the prediscount invoice total
	//
	// For processor-specific information, see the order_discount_management_indicator field in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 1
	TaxAppliedAfterDiscount string `json:"taxAppliedAfterDiscount,omitempty"`

	// Flag that indicates how you calculate tax.
	//
	// Possible values:
	//
	//  - **0**: net prices with tax calculated at line item level
	//  - **1**: net prices with tax calculated at invoice level
	//  - **2**: gross prices with tax provided at line item level
	//  - **3**: gross prices with tax provided at invoice level
	//  - **4**: no tax applies on the invoice for the transaction
	//
	// For processor-specific information, see the tax_management_indicator field in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 1
	TaxAppliedLevel string `json:"taxAppliedLevel,omitempty"`

	// tax details
	TaxDetails []*CreatePaymentParamsBodyOrderInformationAmountDetailsTaxDetailsItems0 `json:"taxDetails"`

	// For tax amounts that can be categorized as one tax type.
	//
	// This field contains the tax type code that corresponds to the entry in the _lineItems.taxAmount_ field.
	//
	// Possible values:
	//
	//  - **056**: sales tax (U.S only)
	//  - **TX~**: all taxes (Canada only)   Note ~ = space.
	//
	// For processor-specific information, see the total_tax_type_code field in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 3
	TaxTypeCode string `json:"taxTypeCode,omitempty"`

	// Grand total for the order. This value cannot be negative. You can include a decimal point (.), but no other special characters. CyberSource truncates the amount to the correct number of decimal places.
	//
	// **Note** For CTV, FDCCompass, Paymentech processors, the maximum length for this field is 12.
	//
	// **Important** Some processors have specific requirements and limitations, such as maximum amounts and maximum field lengths. For details, see:
	// - "Authorization Information for Specific Processors" in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm).
	// - "Capture Information for Specific Processors" in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm).
	// - "Credit Information for Specific Processors" in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm).
	//
	// If your processor supports zero amount authorizations, you can set this field to 0 for the authorization to check if the card is lost or stolen. For details, see "Zero Amount Authorizations," "Credit Information for Specific Processors" in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// #### DCC with a Third-Party Provider
	// Set this field to the converted amount that was returned by the DCC provider. You must include either this field or the 1st line item in the order and the specific line-order amount in your request. For details, see `grand_total_amount` field description in [Dynamic Currency Conversion For First Data Using the SCMP API](http://apps.cybersource.com/library/documentation/dev_guides/DCC_FirstData_SCMP/DCC_FirstData_SCMP_API.pdf).
	//
	// #### FDMS South
	// If you accept IDR or CLP currencies, see the entry for FDMS South in "Authorization Information for Specific Processors" of the [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// #### DCC for First Data
	// Not used.
	//
	// #### Invoicing
	// Grand total for the order, this is required for creating a new invoice.
	//
	// Max Length: 19
	TotalAmount string `json:"totalAmount,omitempty"`
}

// Validate validates this create payment params body order information amount details
func (o *CreatePaymentParamsBodyOrderInformationAmountDetails) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAmexAdditionalAmounts(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCurrency(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDiscountAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDutyAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExchangeRate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExchangeRateTimeStamp(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateForeignAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateForeignCurrency(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFreightAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateGratuityAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNationalTaxIncluded(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOriginalAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOriginalCurrency(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateServiceFeeAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSettlementAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSettlementCurrency(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSurcharge(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxAppliedAfterDiscount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxAppliedLevel(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxTypeCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTotalAmount(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationAmountDetails) validateAmexAdditionalAmounts(formats strfmt.Registry) error {

	if swag.IsZero(o.AmexAdditionalAmounts) { // not required
		return nil
	}

	for i := 0; i < len(o.AmexAdditionalAmounts); i++ {
		if swag.IsZero(o.AmexAdditionalAmounts[i]) { // not required
			continue
		}

		if o.AmexAdditionalAmounts[i] != nil {
			if err := o.AmexAdditionalAmounts[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("createPaymentRequest" + "." + "orderInformation" + "." + "amountDetails" + "." + "amexAdditionalAmounts" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationAmountDetails) validateCurrency(formats strfmt.Registry) error {

	if swag.IsZero(o.Currency) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"currency", "body", string(o.Currency), 3); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationAmountDetails) validateDiscountAmount(formats strfmt.Registry) error {

	if swag.IsZero(o.DiscountAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"discountAmount", "body", string(o.DiscountAmount), 15); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationAmountDetails) validateDutyAmount(formats strfmt.Registry) error {

	if swag.IsZero(o.DutyAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"dutyAmount", "body", string(o.DutyAmount), 15); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationAmountDetails) validateExchangeRate(formats strfmt.Registry) error {

	if swag.IsZero(o.ExchangeRate) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"exchangeRate", "body", string(o.ExchangeRate), 13); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationAmountDetails) validateExchangeRateTimeStamp(formats strfmt.Registry) error {

	if swag.IsZero(o.ExchangeRateTimeStamp) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"exchangeRateTimeStamp", "body", string(o.ExchangeRateTimeStamp), 14); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationAmountDetails) validateForeignAmount(formats strfmt.Registry) error {

	if swag.IsZero(o.ForeignAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"foreignAmount", "body", string(o.ForeignAmount), 15); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationAmountDetails) validateForeignCurrency(formats strfmt.Registry) error {

	if swag.IsZero(o.ForeignCurrency) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"foreignCurrency", "body", string(o.ForeignCurrency), 5); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationAmountDetails) validateFreightAmount(formats strfmt.Registry) error {

	if swag.IsZero(o.FreightAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"freightAmount", "body", string(o.FreightAmount), 13); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationAmountDetails) validateGratuityAmount(formats strfmt.Registry) error {

	if swag.IsZero(o.GratuityAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"gratuityAmount", "body", string(o.GratuityAmount), 13); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationAmountDetails) validateNationalTaxIncluded(formats strfmt.Registry) error {

	if swag.IsZero(o.NationalTaxIncluded) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"nationalTaxIncluded", "body", string(o.NationalTaxIncluded), 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationAmountDetails) validateOriginalAmount(formats strfmt.Registry) error {

	if swag.IsZero(o.OriginalAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"originalAmount", "body", string(o.OriginalAmount), 15); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationAmountDetails) validateOriginalCurrency(formats strfmt.Registry) error {

	if swag.IsZero(o.OriginalCurrency) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"originalCurrency", "body", string(o.OriginalCurrency), 15); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationAmountDetails) validateServiceFeeAmount(formats strfmt.Registry) error {

	if swag.IsZero(o.ServiceFeeAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"serviceFeeAmount", "body", string(o.ServiceFeeAmount), 15); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationAmountDetails) validateSettlementAmount(formats strfmt.Registry) error {

	if swag.IsZero(o.SettlementAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"settlementAmount", "body", string(o.SettlementAmount), 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationAmountDetails) validateSettlementCurrency(formats strfmt.Registry) error {

	if swag.IsZero(o.SettlementCurrency) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"settlementCurrency", "body", string(o.SettlementCurrency), 3); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationAmountDetails) validateSurcharge(formats strfmt.Registry) error {

	if swag.IsZero(o.Surcharge) { // not required
		return nil
	}

	if o.Surcharge != nil {
		if err := o.Surcharge.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "orderInformation" + "." + "amountDetails" + "." + "surcharge")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationAmountDetails) validateTaxAmount(formats strfmt.Registry) error {

	if swag.IsZero(o.TaxAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"taxAmount", "body", string(o.TaxAmount), 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationAmountDetails) validateTaxAppliedAfterDiscount(formats strfmt.Registry) error {

	if swag.IsZero(o.TaxAppliedAfterDiscount) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"taxAppliedAfterDiscount", "body", string(o.TaxAppliedAfterDiscount), 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationAmountDetails) validateTaxAppliedLevel(formats strfmt.Registry) error {

	if swag.IsZero(o.TaxAppliedLevel) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"taxAppliedLevel", "body", string(o.TaxAppliedLevel), 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationAmountDetails) validateTaxDetails(formats strfmt.Registry) error {

	if swag.IsZero(o.TaxDetails) { // not required
		return nil
	}

	for i := 0; i < len(o.TaxDetails); i++ {
		if swag.IsZero(o.TaxDetails[i]) { // not required
			continue
		}

		if o.TaxDetails[i] != nil {
			if err := o.TaxDetails[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("createPaymentRequest" + "." + "orderInformation" + "." + "amountDetails" + "." + "taxDetails" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationAmountDetails) validateTaxTypeCode(formats strfmt.Registry) error {

	if swag.IsZero(o.TaxTypeCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"taxTypeCode", "body", string(o.TaxTypeCode), 3); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationAmountDetails) validateTotalAmount(formats strfmt.Registry) error {

	if swag.IsZero(o.TotalAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"totalAmount", "body", string(o.TotalAmount), 19); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyOrderInformationAmountDetails) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyOrderInformationAmountDetails) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyOrderInformationAmountDetails
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyOrderInformationAmountDetailsAmexAdditionalAmountsItems0 create payment params body order information amount details amex additional amounts items0
swagger:model CreatePaymentParamsBodyOrderInformationAmountDetailsAmexAdditionalAmountsItems0
*/
type CreatePaymentParamsBodyOrderInformationAmountDetailsAmexAdditionalAmountsItems0 struct {

	// Additional amount. This field is supported only for **American Express Direct**.
	//
	// For processor-specific information, see the additional_amount field in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 12
	Amount string `json:"amount,omitempty"`

	// Additional amount type. This field is supported only for **American Express Direct**.
	//
	// For processor-specific information, see the `additional_amount_type0` request-level field description in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 3
	Code string `json:"code,omitempty"`
}

// Validate validates this create payment params body order information amount details amex additional amounts items0
func (o *CreatePaymentParamsBodyOrderInformationAmountDetailsAmexAdditionalAmountsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationAmountDetailsAmexAdditionalAmountsItems0) validateAmount(formats strfmt.Registry) error {

	if swag.IsZero(o.Amount) { // not required
		return nil
	}

	if err := validate.MaxLength("amount", "body", string(o.Amount), 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationAmountDetailsAmexAdditionalAmountsItems0) validateCode(formats strfmt.Registry) error {

	if swag.IsZero(o.Code) { // not required
		return nil
	}

	if err := validate.MaxLength("code", "body", string(o.Code), 3); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyOrderInformationAmountDetailsAmexAdditionalAmountsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyOrderInformationAmountDetailsAmexAdditionalAmountsItems0) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyOrderInformationAmountDetailsAmexAdditionalAmountsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyOrderInformationAmountDetailsSurcharge create payment params body order information amount details surcharge
swagger:model CreatePaymentParamsBodyOrderInformationAmountDetailsSurcharge
*/
type CreatePaymentParamsBodyOrderInformationAmountDetailsSurcharge struct {

	// The surcharge amount is included in the total transaction amount but is passed in a separate field to the issuer and acquirer for tracking. The issuer can provide information about the surcharge amount to the customer.
	//
	// If the amount is positive, then it is a debit for the customer.\
	// If the amount is negative, then it is a credit for the customer.
	//
	// **NOTE**: This field is supported only for CyberSource through VisaNet (CtV) for Payouts. For CtV, the maximum string length is 8.
	//
	// For processor-specific information, see the surcharge_amount field in [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 15
	Amount string `json:"amount,omitempty"`

	// Merchant-defined field for describing the surcharge amount.
	Description string `json:"description,omitempty"`
}

// Validate validates this create payment params body order information amount details surcharge
func (o *CreatePaymentParamsBodyOrderInformationAmountDetailsSurcharge) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAmount(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationAmountDetailsSurcharge) validateAmount(formats strfmt.Registry) error {

	if swag.IsZero(o.Amount) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"amountDetails"+"."+"surcharge"+"."+"amount", "body", string(o.Amount), 15); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyOrderInformationAmountDetailsSurcharge) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyOrderInformationAmountDetailsSurcharge) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyOrderInformationAmountDetailsSurcharge
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyOrderInformationAmountDetailsTaxDetailsItems0 create payment params body order information amount details tax details items0
swagger:model CreatePaymentParamsBodyOrderInformationAmountDetailsTaxDetailsItems0
*/
type CreatePaymentParamsBodyOrderInformationAmountDetailsTaxDetailsItems0 struct {

	// Indicates the amount of tax based on the `type` field as described in the table below:
	//
	// | type      | type description |
	// |-----------|--------------------|
	// | `alternate` | Total amount of alternate tax for the order. |
	// | `local`     | Sales tax for the order. |
	// | `national`  | National tax for the order. |
	// | `vat`       | Total amount of Value Added Tax (VAT) included in the order. |
	// | `other`     | Other tax. |
	//
	// For processor-specific details, see the `alternate_tax_amount`, `local_tax`, `national_tax`, `vat_tax_amount` or `other_tax#_amount` field descriptions in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 13
	Amount string `json:"amount,omitempty"`

	// Flag that indicates whether the alternate tax amount (`orderInformation.amountDetails.taxDetails[].amount`) is
	// included in the request.
	//
	// Possible values:
	// - `false`: alternate tax amount is not included in the request.
	// - `true`: alternate tax amount is included in the request.
	//
	// For processor-specific details, see `alternate_tax_amount_indicator` field description in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	Applied bool `json:"applied,omitempty"`

	// Type of tax being applied to the item.
	//
	// For possible values, see the processor-specific field descriptions in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm):
	//
	// #### FDC Nashville Global
	// - `alternate_tax_type_applied`
	// - `alternate_tax_type_identifier`
	//
	// #### Worldpay VAP
	// - `alternate_tax_type_identifier`
	//
	// #### RBS WorldPay Atlanta
	// - `tax_type_applied`
	//
	// #### TSYS Acquiring Solutions
	// - `tax_type_applied`
	// - `local_tax_indicator`
	//
	// #### Chase Paymentech Solutions
	// - `tax_type_applied`
	//
	// #### Elavon Americas
	// - `local_tax_indicator`
	//
	// #### FDC Compass
	// - `tax_type_applied`
	//
	// #### OmniPay Direct
	// - `local_tax_indicator`
	//
	// Max Length: 4
	Code string `json:"code,omitempty"`

	// Status code for exemption from sales and use tax. This field is a pass-through, which means that
	// CyberSource does not verify the value or modify it in any way before sending it to the processor.
	//
	// For possible values and important information for using this field, see _Appendix B, "Exemption
	// Status Values_ and _Offer-Level Tax Fields_ in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 1
	ExemptionCode string `json:"exemptionCode,omitempty"`

	// Rate of VAT or other tax for the order.
	//
	// Example 0.040 (=4%)
	//
	// Valid range: 0.01 to 0.99 (1% to 99%, with only whole percentage values accepted; values with additional
	// decimal places will be truncated)
	//
	// For processor-specific details, see the `alternate_tax_amount`, `vat_rate`, `vat_tax_rate`, `local_tax`, `national_tax`, `vat_tax_amount` or `other_tax#_rate` field descriptions in the [Level II and Level III Processing Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 6
	Rate string `json:"rate,omitempty"`

	// Your tax ID number to use for the alternate tax amount. Required if you set alternate tax amount to any value,
	// including zero. You may send this field without sending alternate tax amount.
	//
	// For processor-specific details, see `alternate_tax_id` field description in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 15
	TaxID string `json:"taxId,omitempty"`

	// Indicates the type of tax data for the _taxDetails_ object.
	//
	// Possible values:
	//
	// - `alternate`
	// - `local`
	// - `national`
	// - `vat`
	// - `other`
	//
	// For processor-specific details, see the `alternate_tax_amount`, `local_tax`, `national_tax` or `vat_tax_amount` field
	// descriptions in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	Type string `json:"type,omitempty"`
}

// Validate validates this create payment params body order information amount details tax details items0
func (o *CreatePaymentParamsBodyOrderInformationAmountDetailsTaxDetailsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExemptionCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationAmountDetailsTaxDetailsItems0) validateAmount(formats strfmt.Registry) error {

	if swag.IsZero(o.Amount) { // not required
		return nil
	}

	if err := validate.MaxLength("amount", "body", string(o.Amount), 13); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationAmountDetailsTaxDetailsItems0) validateCode(formats strfmt.Registry) error {

	if swag.IsZero(o.Code) { // not required
		return nil
	}

	if err := validate.MaxLength("code", "body", string(o.Code), 4); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationAmountDetailsTaxDetailsItems0) validateExemptionCode(formats strfmt.Registry) error {

	if swag.IsZero(o.ExemptionCode) { // not required
		return nil
	}

	if err := validate.MaxLength("exemptionCode", "body", string(o.ExemptionCode), 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationAmountDetailsTaxDetailsItems0) validateRate(formats strfmt.Registry) error {

	if swag.IsZero(o.Rate) { // not required
		return nil
	}

	if err := validate.MaxLength("rate", "body", string(o.Rate), 6); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationAmountDetailsTaxDetailsItems0) validateTaxID(formats strfmt.Registry) error {

	if swag.IsZero(o.TaxID) { // not required
		return nil
	}

	if err := validate.MaxLength("taxId", "body", string(o.TaxID), 15); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyOrderInformationAmountDetailsTaxDetailsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyOrderInformationAmountDetailsTaxDetailsItems0) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyOrderInformationAmountDetailsTaxDetailsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyOrderInformationBillTo create payment params body order information bill to
swagger:model CreatePaymentParamsBodyOrderInformationBillTo
*/
type CreatePaymentParamsBodyOrderInformationBillTo struct {

	// Payment card billing street address as it appears on the credit card issuers records.
	//
	// #### Atos
	// This field must not contain colons (:).
	//
	// #### CyberSource through VisaNet
	// **Important** When you populate billing street address 1 and billing street address 2, CyberSource through VisaNet concatenates the two values. If the concatenated value exceeds 40 characters, CyberSource through VisaNet truncates the value at 40 characters before sending it to Visa and the issuing bank. Truncating this value affects AVS results and therefore might also affect risk decisions and chargebacks.
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.
	//
	// #### For Payouts: This field may be sent only for FDC Compass.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// For processor-specific information, see the `bill_address1` request-level field description in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 60
	Address1 string `json:"address1,omitempty"`

	// Additional address information.
	//
	// For Payouts: This field may be sent only for FDC Compass.
	//
	// #### Atos
	// This field must not contain colons (:).
	//
	// #### Chase Paymentech Solutions, FDC Compass, and TSYS Acquiring Solutions
	// This value is used for AVS.
	//
	// #### CyberSource through VisaNet
	// **Important** When you populate billing street address 1 and billing street address 2, CyberSource through VisaNet concatenates the two values. If the concatenated value exceeds 40 characters, CyberSource through VisaNet truncates the value at 40 characters before sending it to Visa and the issuing bank. Truncating this value affects AVS results and therefore might also affect risk decisions and chargebacks.
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.
	//
	// For processor-specific information, see the `bill_address2` field description in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 60
	Address2 string `json:"address2,omitempty"`

	// Additional address information (third line of the billing address)
	//
	// Max Length: 60
	Address3 string `json:"address3,omitempty"`

	// Additional address information (fourth line of the billing address)
	//
	// Max Length: 60
	Address4 string `json:"address4,omitempty"`

	// State or province of the billing address. Use the State, Province, and Territory Codes for the United States
	// and Canada.
	//
	// For Payouts: This field may be sent only for FDC Compass.
	//
	// ##### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// For processor-specific information, see the `bill_state` field description in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 20
	AdministrativeArea string `json:"administrativeArea,omitempty"`

	// Building number in the street address.
	//
	// For example, if the street address is:
	// Rua da Quitanda 187
	// then the building number is 187.
	//
	// This field is supported only for:
	//  - Cielo transactions.
	//  - Redecard customer validation with CyberSource Latin American Processing.
	//
	// Max Length: 256
	BuildingNumber string `json:"buildingNumber,omitempty"`

	// Name of the customers company.
	//
	// #### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.
	// For processor-specific information, see the company_name field in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 60
	Company string `json:"company,omitempty"`

	// Payment card billing country. Use the two-character ISO Standard Country Codes.
	//
	// #### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// For processor-specific information, see the `bill_country` field description in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 2
	Country string `json:"country,omitempty"`

	// Customers neighborhood, community, or region (a barrio in Brazil) within the city or municipality. This
	// field is available only on **Cielo**.
	//
	// Max Length: 50
	District string `json:"district,omitempty"`

	// Customer's email address, including the full domain name.
	//
	// #### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// For processor-specific information, see the `customer_email` request-level field description in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// #### Invoicing
	// Email address for the customer for sending the invoice. If the invoice is in SENT status and email is updated, the old email customer payment link won't work and you must resend the invoice with the new payment link.
	//
	// Max Length: 255
	Email string `json:"email,omitempty"`

	// Customers first name. This name must be the same as the name on the card.
	//
	// #### CyberSource Latin American Processing
	// **Important** For an authorization request, CyberSource Latin American Processing concatenates `orderInformation.billTo.firstName` and `orderInformation.billTo.lastName`. If the concatenated value exceeds 30 characters, CyberSource Latin American Processing declines the authorization request.\
	// **Note** CyberSource Latin American Processing is the name of a specific processing connection that CyberSource supports. In the CyberSource API documentation, CyberSource Latin American Processing does not refer to the general topic of processing in Latin America. The information in this field description is for the specific processing connection called _CyberSource Latin American Processing_. It is not for any other Latin American processors that CyberSource supports.
	//
	// #### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.
	//
	// #### For Payouts:
	// This field may be sent only for FDC Compass.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// For processor-specific information, see the `customer_firstname` request-level field description in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 60
	FirstName string `json:"firstName,omitempty"`

	// Customers last name. This name must be the same as the name on the card.
	//
	// #### CyberSource Latin American Processing
	// **Important** For an authorization request, CyberSource Latin American Processing concatenates `orderInformation.billTo.firstName` and `orderInformation.billTo.lastName`. If the concatenated value exceeds 30 characters, CyberSource Latin American Processing declines the authorization request.\
	// **Note** CyberSource Latin American Processing is the name of a specific processing connection that CyberSource supports. In the CyberSource API documentation, CyberSource Latin American Processing does not refer to the general topic of processing in Latin America. The information in this field description is for the specific processing connection called CyberSource Latin American Processing. It is not for any other Latin American processors that CyberSource supports.
	//
	// #### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// #### For Payouts:
	// This field may be sent only for FDC Compass.
	//
	// For processor-specific information, see the `customer_lastname` request-level field description in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 60
	LastName string `json:"lastName,omitempty"`

	// Payment card billing city.
	//
	// #### Atos
	// This field must not contain colons (:).
	//
	// #### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.
	//
	// #### For Payouts:
	// This field may be sent only for FDC Compass.
	//
	// For processor-specific information, see the `bill_city` field description in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 50
	Locality string `json:"locality,omitempty"`

	// Customers middle name.
	//
	// Max Length: 60
	MiddleName string `json:"middleName,omitempty"`

	// Customers name suffix.
	//
	// Max Length: 60
	NameSuffix string `json:"nameSuffix,omitempty"`

	// Customers phone number.
	//
	// #### For Payouts:
	// This field may be sent only for FDC Compass.
	//
	// CyberSource recommends that you include the country code when the order is from outside the U.S.
	//
	// For processor-specific information, see the customer_phone field in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// #### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.
	//
	// Max Length: 15
	PhoneNumber string `json:"phoneNumber,omitempty"`

	// Customer's phone number type.
	//
	// #### For Payouts:
	// This field may be sent only for FDC Compass.
	//
	// Possible Values:
	// * day
	// * home
	// * night
	// * work
	//
	PhoneType string `json:"phoneType,omitempty"`

	// Postal code for the billing address. The postal code must consist of 5 to 9 digits.
	//
	// When the billing country is the U.S., the 9-digit postal code must follow this format:
	// [5 digits][dash][4 digits]
	//
	// **Example** `12345-6789`
	//
	// When the billing country is Canada, the 6-digit postal code must follow this format:
	// [alpha][numeric][alpha][space][numeric][alpha][numeric]
	//
	// **Example** `A1B 2C3`
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// #### For Payouts:
	//  This field may be sent only for FDC Compass.
	//
	// #### American Express Direct
	// Before sending the postal code to the processor, CyberSource removes all nonalphanumeric characters and, if the remaining value is longer than nine characters, truncates the value starting from the right side.
	//
	// #### Atos
	// This field must not contain colons (:).
	//
	// #### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.
	//
	// For processor-specific information, see the `bill_zip` request-level field description in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 10
	PostalCode string `json:"postalCode,omitempty"`

	// Title.
	//
	// Max Length: 60
	Title string `json:"title,omitempty"`
}

// Validate validates this create payment params body order information bill to
func (o *CreatePaymentParamsBodyOrderInformationBillTo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAddress1(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAddress2(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAddress3(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAddress4(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAdministrativeArea(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBuildingNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCompany(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDistrict(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEmail(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFirstName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLastName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocality(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateMiddleName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNameSuffix(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePhoneNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTitle(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationBillTo) validateAddress1(formats strfmt.Registry) error {

	if swag.IsZero(o.Address1) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"address1", "body", string(o.Address1), 60); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationBillTo) validateAddress2(formats strfmt.Registry) error {

	if swag.IsZero(o.Address2) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"address2", "body", string(o.Address2), 60); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationBillTo) validateAddress3(formats strfmt.Registry) error {

	if swag.IsZero(o.Address3) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"address3", "body", string(o.Address3), 60); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationBillTo) validateAddress4(formats strfmt.Registry) error {

	if swag.IsZero(o.Address4) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"address4", "body", string(o.Address4), 60); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationBillTo) validateAdministrativeArea(formats strfmt.Registry) error {

	if swag.IsZero(o.AdministrativeArea) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"administrativeArea", "body", string(o.AdministrativeArea), 20); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationBillTo) validateBuildingNumber(formats strfmt.Registry) error {

	if swag.IsZero(o.BuildingNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"buildingNumber", "body", string(o.BuildingNumber), 256); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationBillTo) validateCompany(formats strfmt.Registry) error {

	if swag.IsZero(o.Company) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"company", "body", string(o.Company), 60); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationBillTo) validateCountry(formats strfmt.Registry) error {

	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"country", "body", string(o.Country), 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationBillTo) validateDistrict(formats strfmt.Registry) error {

	if swag.IsZero(o.District) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"district", "body", string(o.District), 50); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationBillTo) validateEmail(formats strfmt.Registry) error {

	if swag.IsZero(o.Email) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"email", "body", string(o.Email), 255); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationBillTo) validateFirstName(formats strfmt.Registry) error {

	if swag.IsZero(o.FirstName) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"firstName", "body", string(o.FirstName), 60); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationBillTo) validateLastName(formats strfmt.Registry) error {

	if swag.IsZero(o.LastName) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"lastName", "body", string(o.LastName), 60); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationBillTo) validateLocality(formats strfmt.Registry) error {

	if swag.IsZero(o.Locality) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"locality", "body", string(o.Locality), 50); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationBillTo) validateMiddleName(formats strfmt.Registry) error {

	if swag.IsZero(o.MiddleName) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"middleName", "body", string(o.MiddleName), 60); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationBillTo) validateNameSuffix(formats strfmt.Registry) error {

	if swag.IsZero(o.NameSuffix) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"nameSuffix", "body", string(o.NameSuffix), 60); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationBillTo) validatePhoneNumber(formats strfmt.Registry) error {

	if swag.IsZero(o.PhoneNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"phoneNumber", "body", string(o.PhoneNumber), 15); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationBillTo) validatePostalCode(formats strfmt.Registry) error {

	if swag.IsZero(o.PostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"postalCode", "body", string(o.PostalCode), 10); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationBillTo) validateTitle(formats strfmt.Registry) error {

	if swag.IsZero(o.Title) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"billTo"+"."+"title", "body", string(o.Title), 60); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyOrderInformationBillTo) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyOrderInformationBillTo) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyOrderInformationBillTo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyOrderInformationInvoiceDetails create payment params body order information invoice details
swagger:model CreatePaymentParamsBodyOrderInformationInvoiceDetails
*/
type CreatePaymentParamsBodyOrderInformationInvoiceDetails struct {

	// Barcode Number.
	BarcodeNumber string `json:"barcodeNumber,omitempty"`

	// International description code of the overall orders goods or services or the Categorizes purchases for VAT
	// reporting. Contact your acquirer for a list of codes.
	//
	// For processor-specific information, see the `summary_commodity_code` field in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 4
	CommodityCode string `json:"commodityCode,omitempty"`

	// Expiration Date.
	ExpirationDate string `json:"expirationDate,omitempty"`

	// Invoice Number.
	InvoiceNumber string `json:"invoiceNumber,omitempty"`

	// Identifier for the merchandise. Possible value:
	//
	//  - 1000: Gift card
	//
	// This field is supported only for **American Express Direct**.
	//
	MerchandiseCode int64 `json:"merchandiseCode,omitempty"`

	// The name of the individual or the company contacted for company authorized purchases.
	//
	// For processor-specific information, see the `authorized_contact_name` field in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 36
	PurchaseContactName string `json:"purchaseContactName,omitempty"`

	// Date the order was processed. `Format: YYYY-MM-DD`.
	//
	// For processor-specific information, see the `purchaser_order_date` field in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 10
	PurchaseOrderDate string `json:"purchaseOrderDate,omitempty"`

	// Value used by your customer to identify the order. This value is typically a purchase order number. CyberSource
	// recommends that you do not populate the field with all zeros or nines.
	//
	// For processor-specific information, see the `user_po` field in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 25
	PurchaseOrderNumber string `json:"purchaseOrderNumber,omitempty"`

	// Code that identifies the value of the `referenceDataNumber` field.
	//
	// For the possible values, see "Reference Data Codes" in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm).
	//
	// This field is a pass-through, which means that CyberSource does not verify the value or modify it in any way
	// before sending it to the processor.
	//
	// Max Length: 3
	ReferenceDataCode string `json:"referenceDataCode,omitempty"`

	// Reference number. The meaning of this value is identified by the value of the `referenceDataCode` field.
	//
	// This field is a pass-through, which means that CyberSource does not verify the value or modify it in any way
	// before sending it to the processor.
	//
	// Max Length: 30
	ReferenceDataNumber string `json:"referenceDataNumber,omitempty"`

	// Flag that indicates whether an order is taxable. This value must be true if the sum of all _lineItems[].taxAmount_ values > 0.
	//
	// If you do not include any `lineItems[].taxAmount` values in your request, CyberSource does not include
	// `invoiceDetails.taxable` in the data it sends to the processor.
	//
	// For processor-specific information, see the `tax_indicator` field in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Possible values:
	//  - **true**
	//  - **false**
	//
	Taxable bool `json:"taxable,omitempty"`

	// transaction advice addendum
	TransactionAdviceAddendum []*CreatePaymentParamsBodyOrderInformationInvoiceDetailsTransactionAdviceAddendumItems0 `json:"transactionAdviceAddendum"`

	// VAT invoice number associated with the transaction.
	//
	// For processor-specific information, see the `vat_invoice_ref_number` field in
	// [Level II and Level III Processing Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html)
	//
	// Max Length: 15
	VatInvoiceReferenceNumber string `json:"vatInvoiceReferenceNumber,omitempty"`
}

// Validate validates this create payment params body order information invoice details
func (o *CreatePaymentParamsBodyOrderInformationInvoiceDetails) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCommodityCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePurchaseContactName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePurchaseOrderDate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePurchaseOrderNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateReferenceDataCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateReferenceDataNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTransactionAdviceAddendum(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateVatInvoiceReferenceNumber(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationInvoiceDetails) validateCommodityCode(formats strfmt.Registry) error {

	if swag.IsZero(o.CommodityCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"invoiceDetails"+"."+"commodityCode", "body", string(o.CommodityCode), 4); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationInvoiceDetails) validatePurchaseContactName(formats strfmt.Registry) error {

	if swag.IsZero(o.PurchaseContactName) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"invoiceDetails"+"."+"purchaseContactName", "body", string(o.PurchaseContactName), 36); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationInvoiceDetails) validatePurchaseOrderDate(formats strfmt.Registry) error {

	if swag.IsZero(o.PurchaseOrderDate) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"invoiceDetails"+"."+"purchaseOrderDate", "body", string(o.PurchaseOrderDate), 10); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationInvoiceDetails) validatePurchaseOrderNumber(formats strfmt.Registry) error {

	if swag.IsZero(o.PurchaseOrderNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"invoiceDetails"+"."+"purchaseOrderNumber", "body", string(o.PurchaseOrderNumber), 25); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationInvoiceDetails) validateReferenceDataCode(formats strfmt.Registry) error {

	if swag.IsZero(o.ReferenceDataCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"invoiceDetails"+"."+"referenceDataCode", "body", string(o.ReferenceDataCode), 3); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationInvoiceDetails) validateReferenceDataNumber(formats strfmt.Registry) error {

	if swag.IsZero(o.ReferenceDataNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"invoiceDetails"+"."+"referenceDataNumber", "body", string(o.ReferenceDataNumber), 30); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationInvoiceDetails) validateTransactionAdviceAddendum(formats strfmt.Registry) error {

	if swag.IsZero(o.TransactionAdviceAddendum) { // not required
		return nil
	}

	for i := 0; i < len(o.TransactionAdviceAddendum); i++ {
		if swag.IsZero(o.TransactionAdviceAddendum[i]) { // not required
			continue
		}

		if o.TransactionAdviceAddendum[i] != nil {
			if err := o.TransactionAdviceAddendum[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("createPaymentRequest" + "." + "orderInformation" + "." + "invoiceDetails" + "." + "transactionAdviceAddendum" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationInvoiceDetails) validateVatInvoiceReferenceNumber(formats strfmt.Registry) error {

	if swag.IsZero(o.VatInvoiceReferenceNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"invoiceDetails"+"."+"vatInvoiceReferenceNumber", "body", string(o.VatInvoiceReferenceNumber), 15); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyOrderInformationInvoiceDetails) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyOrderInformationInvoiceDetails) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyOrderInformationInvoiceDetails
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyOrderInformationInvoiceDetailsTransactionAdviceAddendumItems0 create payment params body order information invoice details transaction advice addendum items0
swagger:model CreatePaymentParamsBodyOrderInformationInvoiceDetailsTransactionAdviceAddendumItems0
*/
type CreatePaymentParamsBodyOrderInformationInvoiceDetailsTransactionAdviceAddendumItems0 struct {

	// Four Transaction Advice Addendum (TAA) fields. These fields are used to display descriptive information
	// about a transaction on the customers American Express card statement. When you send TAA fields, start
	// with amexdata_taa1, then ...taa2, and so on. Skipping a TAA field causes subsequent TAA fields to be
	// ignored.
	//
	// To use these fields, contact CyberSource Customer Support to have your account enabled for this feature.
	//
	// Max Length: 40
	Data string `json:"data,omitempty"`
}

// Validate validates this create payment params body order information invoice details transaction advice addendum items0
func (o *CreatePaymentParamsBodyOrderInformationInvoiceDetailsTransactionAdviceAddendumItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateData(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationInvoiceDetailsTransactionAdviceAddendumItems0) validateData(formats strfmt.Registry) error {

	if swag.IsZero(o.Data) { // not required
		return nil
	}

	if err := validate.MaxLength("data", "body", string(o.Data), 40); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyOrderInformationInvoiceDetailsTransactionAdviceAddendumItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyOrderInformationInvoiceDetailsTransactionAdviceAddendumItems0) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyOrderInformationInvoiceDetailsTransactionAdviceAddendumItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyOrderInformationLineItemsItems0 create payment params body order information line items items0
swagger:model CreatePaymentParamsBodyOrderInformationLineItemsItems0
*/
type CreatePaymentParamsBodyOrderInformationLineItemsItems0 struct {

	// Flag that indicates whether the tax amount is included in the Line Item Total.
	//
	// Possible values:
	//  - **true**
	//  - **false**
	//
	AmountIncludesTax bool `json:"amountIncludesTax,omitempty"`

	// Commodity code or International description code used to classify the item. Contact your acquirer for a list of
	// codes.
	//
	// Max Length: 15
	CommodityCode string `json:"commodityCode,omitempty"`

	// Discount applied to the item.
	// Max Length: 13
	DiscountAmount string `json:"discountAmount,omitempty"`

	// Flag that indicates whether the amount is discounted.
	//
	// If you do not provide a value but you set Discount Amount to a value greater than zero, then CyberSource sets
	// this field to **true**.
	//
	// Possible values:
	//  - **true**
	//  - **false**
	//
	DiscountApplied bool `json:"discountApplied,omitempty"`

	// Rate the item is discounted. Maximum of 2 decimal places.
	//
	// Example 5.25 (=5.25%)
	//
	// Max Length: 6
	DiscountRate string `json:"discountRate,omitempty"`

	// Information about the product code used for the line item.
	// Possible values:
	// - `E`: The product code is `electronic_software`.
	// - `P`: The product code is not `electronic_software`.
	//
	// For details, see the `fulfillmentType` field description in [Business Center Reporting User Guide.]
	// (https://apps.cybersource.com/library/documentation/dev_guides/reporting_and_reconciliation/Reporting_User/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	FulfillmentType string `json:"fulfillmentType,omitempty"`

	// Field to support an invoice number for a transaction. You must specify the number of line items that will
	// include an invoice number. By default, the first line item will include an invoice number field. The invoice
	// number field can be included for up to 10 line items.
	//
	// Max Length: 23
	InvoiceNumber string `json:"invoiceNumber,omitempty"`

	// Type of product. This value is used to determine the category that the product is in: electronic, handling,
	// physical, service, or shipping. The default value is **default**.
	// If you are performing an authorization transaction (`processingOptions.capture` is set to `false`), and you set this field to a value other than default or any of the values related to
	// shipping and handling, then the fields `quantity`, `productName`, and `productSku` are required.
	// It can also have a value of "gift_card".
	//
	// For details, see the `product_code` field description in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 255
	ProductCode string `json:"productCode,omitempty"`

	// For an authorization or capture transaction (`processingOptions.capture` is set to `true` or `false`),
	// this field is required when `orderInformation.lineItems[].productCode` is not set to `default` or one of
	// the other values that are related to shipping and/or handling.
	//
	// Max Length: 255
	ProductName string `json:"productName,omitempty"`

	// Stock Keeping Unit (SKU) code for the product.
	//
	// For an authorization or capture transaction (`processingOptions.capture` is set to `true` or `false`), this field is required when _orderInformation.lineItems[].productCode_ is not set to **default** or one of the other values that are related to shipping and/or handling.
	//
	// Max Length: 255
	ProductSku string `json:"productSku,omitempty"`

	// Number of units for this order.
	//
	// The default is `1`. For an authorization or capture transaction (`processingOptions.capture` is set to `true` or `false`), this field is required when _orderInformation.lineItems[].productCode_ is not set to **default** or one of the other values that are related to shipping and/or handling.
	//
	// When orderInformation.lineItems[].productCode is "gift_card",
	// this is the total count of individual prepaid gift cards purchased.
	//
	// Maximum: 9.999999999e+09
	// Minimum: 1
	Quantity float64 `json:"quantity,omitempty"`

	// Code that identifies the value of the corresponding item_#_referenceData_#_number field. See Numbered Elements.
	//
	// Possible values:
	// - AN: Client-defined asset code
	// - MG: Manufacturer's part number
	// - PO: Purchase order number
	// - SK: Supplier stock keeping unit number
	// - UP: Universal product code
	// - VC: Supplier catalog number
	// - VP: Vendor part number
	//
	// This field is a pass-through, which means that CyberSource does not verify the value or modify it in any way
	// before sending it to the processor.
	//
	// Max Length: 2
	ReferenceDataCode string `json:"referenceDataCode,omitempty"`

	// Reference number.
	//
	// The meaning of this value is identified by the value of the corresponding `referenceDataCode` field.
	// See Numbered Elements.
	//
	// The maximum length for this field depends on the value of the corresponding `referenceDataCode` field:
	// - When the code is `PO`, the maximum length for the reference number is 22.
	// - When the code is `VC`, the maximum length for the reference number is 20.
	// - For all other codes, the maximum length for the reference number is 30.
	//
	// This field is a pass-through, which means that CyberSource does not verify the value or modify it in any way
	// before sending it to the processor.
	//
	// Max Length: 30
	ReferenceDataNumber string `json:"referenceDataNumber,omitempty"`

	// Total tax to apply to the product. This value cannot be negative. The tax amount and the offer amount must
	// be in the same currency. The tax amount field is additive.
	//
	// The following example uses a two-exponent currency such as USD:
	//
	//  1. You include each line item in your request.
	//  ..- 1st line item has amount=10.00, quantity=1, and taxAmount=0.80
	//  ..- 2nd line item has amount=20.00, quantity=1, and taxAmount=1.60
	//  2. The total amount authorized will be 32.40, not 30.00 with 2.40 of tax included.
	//
	// If you want to include the tax amount and also request the ics_tax service, see Tax Calculation Service Using the SCMP API.
	//
	// This field is frequently used for Level II and Level III transactions. For details, see `tax_amount` field description in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 15
	TaxAmount string `json:"taxAmount,omitempty"`

	// Flag to indicate how you handle discount at the line item level.
	//
	//  - 0: no line level discount provided
	//  - 1: tax was calculated on the post-discount line item total
	//  - 2: tax was calculated on the pre-discount line item total
	//
	// `Note` Visa will inset 0 (zero) if an invalid value is included in this field.
	//
	// This field relates to the value in the _lineItems[].discountAmount_ field.
	//
	// Max Length: 1
	TaxAppliedAfterDiscount string `json:"taxAppliedAfterDiscount,omitempty"`

	// tax details
	TaxDetails []*CreatePaymentParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0 `json:"taxDetails"`

	// Tax rate applied to the item.
	//
	// For details, see `tax_rate` field description in the [Level II and Level III Processing Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// **Visa**: Valid range is 0.01 to 0.99 (1% to 99%, with only whole percentage values accepted; values with additional
	// decimal places will be truncated).
	//
	// **Mastercard**: Valid range is 0.00001 to 0.99999 (0.001% to 99.999%).
	//
	// Max Length: 7
	TaxRate string `json:"taxRate,omitempty"`

	// Flag to indicate whether tax is exempted or not included.
	//
	//  - 0: tax not included
	//  - 1: tax included
	//  - 2: transaction is not subject to tax
	//
	// Max Length: 1
	TaxStatusIndicator string `json:"taxStatusIndicator,omitempty"`

	// Type of tax being applied to the item.
	//
	// For possible values, see the processor-specific field descriptions in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm):
	//
	// #### FDC Nashville Global
	// - `alternate_tax_type_applied`
	// - `alternate_tax_type_identifier`
	//
	// #### Worldpay VAP
	// - `alternate_tax_type_identifier`
	//
	// #### RBS WorldPay Atlanta
	// - `tax_type_applied`
	//
	// #### TSYS Acquiring Solutions
	// - `tax_type_applied`
	// - `local_tax_indicator`
	//
	// #### Chase Paymentech Solutions
	// - `tax_type_applied`
	//
	// #### Elavon Americas
	// - `local_tax_indicator`
	//
	// #### FDC Compass
	// - `tax_type_applied`
	//
	// #### OmniPay Direct
	// - `local_tax_indicator`
	//
	// Max Length: 4
	TaxTypeCode string `json:"taxTypeCode,omitempty"`

	// Total amount for the item. Normally calculated as the unit price times quantity.
	//
	// When `orderInformation.lineItems[].productCode` is "gift_card", this is the purchase amount total
	// for prepaid gift cards in major units.
	//
	// Example: 123.45 USD = 123
	//
	// Max Length: 13
	TotalAmount string `json:"totalAmount,omitempty"`

	// Flag to indicate whether the purchase is categorized as goods or services.
	// Possible values:
	//
	//  - 00: goods
	//  - 01: services
	//
	// Max Length: 2
	TypeOfSupply string `json:"typeOfSupply,omitempty"`

	// Unit of measure, or unit of measure code, for the item.
	//
	// Max Length: 12
	UnitOfMeasure string `json:"unitOfMeasure,omitempty"`

	// Per-item price of the product. This value cannot be negative. You can include a decimal point (.), but you
	// cannot include any other special characters. CyberSource truncates the amount to the correct number of decimal
	// places.
	//
	// For processor-specific information, see the `amount` field description in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// **Important** Some processors have specific requirements and limitations, such as maximum
	// amounts and maximum field lengths. See these guides for details:
	// - [Merchant Descriptors Using the SCMP API Guide]
	// (https://apps.cybersource.com/library/documentation/dev_guides/Merchant_Descriptors_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	// - "Capture Information for Specific Processors" section in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// #### DCC with a Third-Party Provider
	// Set this field to the converted amount that was returned by the DCC provider. You must include either
	// the 1st line item in the order and this field, or the request-level field `orderInformation.amountDetails.totalAmount` in your request. For details, see "Dynamic Currency Conversion with a Third Party
	// Provider" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// #### FDMS South
	// If you accept IDR or CLP currencies, see the entry for FDMS South in the [Merchant Descriptors Using the SCMP API Guide.]
	// (https://apps.cybersource.com/library/documentation/dev_guides/Merchant_Descriptors_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// #### Zero Amount Authorizations
	// If your processor supports zero amount authorizations, you can set this field to 0 for the
	// authorization to check if the card is lost or stolen. See "Zero Amount Authorizations" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 15
	UnitPrice string `json:"unitPrice,omitempty"`

	// Weight of the item. See Numbered Elements.
	// Max Length: 9
	Weight string `json:"weight,omitempty"`

	// Type of weight. See Numbered Elements.
	//
	// Possible values:
	// - B: Billed weight
	// - N: Actual net weight
	//
	// Max Length: 1
	WeightIdentifier string `json:"weightIdentifier,omitempty"`

	// Code that specifies the unit of measurement for the weight amount. For example, OZ specifies ounce and LB
	// specifies pound. The possible values are defined by the ANSI Accredited Standards Committee (ASC).
	//
	// See Numbered Elements.
	//
	// Max Length: 2
	WeightUnit string `json:"weightUnit,omitempty"`
}

// Validate validates this create payment params body order information line items items0
func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCommodityCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDiscountAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDiscountRate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateInvoiceNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProductCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProductName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProductSku(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateQuantity(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateReferenceDataCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateReferenceDataNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxAppliedAfterDiscount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxRate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxStatusIndicator(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxTypeCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTotalAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTypeOfSupply(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateUnitOfMeasure(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateUnitPrice(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateWeight(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateWeightIdentifier(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateWeightUnit(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0) validateCommodityCode(formats strfmt.Registry) error {

	if swag.IsZero(o.CommodityCode) { // not required
		return nil
	}

	if err := validate.MaxLength("commodityCode", "body", string(o.CommodityCode), 15); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0) validateDiscountAmount(formats strfmt.Registry) error {

	if swag.IsZero(o.DiscountAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("discountAmount", "body", string(o.DiscountAmount), 13); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0) validateDiscountRate(formats strfmt.Registry) error {

	if swag.IsZero(o.DiscountRate) { // not required
		return nil
	}

	if err := validate.MaxLength("discountRate", "body", string(o.DiscountRate), 6); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0) validateInvoiceNumber(formats strfmt.Registry) error {

	if swag.IsZero(o.InvoiceNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("invoiceNumber", "body", string(o.InvoiceNumber), 23); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0) validateProductCode(formats strfmt.Registry) error {

	if swag.IsZero(o.ProductCode) { // not required
		return nil
	}

	if err := validate.MaxLength("productCode", "body", string(o.ProductCode), 255); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0) validateProductName(formats strfmt.Registry) error {

	if swag.IsZero(o.ProductName) { // not required
		return nil
	}

	if err := validate.MaxLength("productName", "body", string(o.ProductName), 255); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0) validateProductSku(formats strfmt.Registry) error {

	if swag.IsZero(o.ProductSku) { // not required
		return nil
	}

	if err := validate.MaxLength("productSku", "body", string(o.ProductSku), 255); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0) validateQuantity(formats strfmt.Registry) error {

	if swag.IsZero(o.Quantity) { // not required
		return nil
	}

	if err := validate.Minimum("quantity", "body", float64(o.Quantity), 1, false); err != nil {
		return err
	}

	if err := validate.Maximum("quantity", "body", float64(o.Quantity), 9.999999999e+09, false); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0) validateReferenceDataCode(formats strfmt.Registry) error {

	if swag.IsZero(o.ReferenceDataCode) { // not required
		return nil
	}

	if err := validate.MaxLength("referenceDataCode", "body", string(o.ReferenceDataCode), 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0) validateReferenceDataNumber(formats strfmt.Registry) error {

	if swag.IsZero(o.ReferenceDataNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("referenceDataNumber", "body", string(o.ReferenceDataNumber), 30); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0) validateTaxAmount(formats strfmt.Registry) error {

	if swag.IsZero(o.TaxAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("taxAmount", "body", string(o.TaxAmount), 15); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0) validateTaxAppliedAfterDiscount(formats strfmt.Registry) error {

	if swag.IsZero(o.TaxAppliedAfterDiscount) { // not required
		return nil
	}

	if err := validate.MaxLength("taxAppliedAfterDiscount", "body", string(o.TaxAppliedAfterDiscount), 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0) validateTaxDetails(formats strfmt.Registry) error {

	if swag.IsZero(o.TaxDetails) { // not required
		return nil
	}

	for i := 0; i < len(o.TaxDetails); i++ {
		if swag.IsZero(o.TaxDetails[i]) { // not required
			continue
		}

		if o.TaxDetails[i] != nil {
			if err := o.TaxDetails[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("taxDetails" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0) validateTaxRate(formats strfmt.Registry) error {

	if swag.IsZero(o.TaxRate) { // not required
		return nil
	}

	if err := validate.MaxLength("taxRate", "body", string(o.TaxRate), 7); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0) validateTaxStatusIndicator(formats strfmt.Registry) error {

	if swag.IsZero(o.TaxStatusIndicator) { // not required
		return nil
	}

	if err := validate.MaxLength("taxStatusIndicator", "body", string(o.TaxStatusIndicator), 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0) validateTaxTypeCode(formats strfmt.Registry) error {

	if swag.IsZero(o.TaxTypeCode) { // not required
		return nil
	}

	if err := validate.MaxLength("taxTypeCode", "body", string(o.TaxTypeCode), 4); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0) validateTotalAmount(formats strfmt.Registry) error {

	if swag.IsZero(o.TotalAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("totalAmount", "body", string(o.TotalAmount), 13); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0) validateTypeOfSupply(formats strfmt.Registry) error {

	if swag.IsZero(o.TypeOfSupply) { // not required
		return nil
	}

	if err := validate.MaxLength("typeOfSupply", "body", string(o.TypeOfSupply), 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0) validateUnitOfMeasure(formats strfmt.Registry) error {

	if swag.IsZero(o.UnitOfMeasure) { // not required
		return nil
	}

	if err := validate.MaxLength("unitOfMeasure", "body", string(o.UnitOfMeasure), 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0) validateUnitPrice(formats strfmt.Registry) error {

	if swag.IsZero(o.UnitPrice) { // not required
		return nil
	}

	if err := validate.MaxLength("unitPrice", "body", string(o.UnitPrice), 15); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0) validateWeight(formats strfmt.Registry) error {

	if swag.IsZero(o.Weight) { // not required
		return nil
	}

	if err := validate.MaxLength("weight", "body", string(o.Weight), 9); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0) validateWeightIdentifier(formats strfmt.Registry) error {

	if swag.IsZero(o.WeightIdentifier) { // not required
		return nil
	}

	if err := validate.MaxLength("weightIdentifier", "body", string(o.WeightIdentifier), 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0) validateWeightUnit(formats strfmt.Registry) error {

	if swag.IsZero(o.WeightUnit) { // not required
		return nil
	}

	if err := validate.MaxLength("weightUnit", "body", string(o.WeightUnit), 2); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyOrderInformationLineItemsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0 create payment params body order information line items items0 tax details items0
swagger:model CreatePaymentParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0
*/
type CreatePaymentParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0 struct {

	// Indicates the amount of tax based on the `type` field as described in the table below:
	//
	// | type      | type description |
	// |-----------|--------------------|
	// | `alternate` | Total amount of alternate tax for the order. |
	// | `local`     | Sales tax for the order. |
	// | `national`  | National tax for the order. |
	// | `vat`       | Total amount of Value Added Tax (VAT) included in the order. |
	// | `other`     | Other tax. |
	//
	// For processor-specific details, see the `alternate_tax_amount`, `local_tax`, `national_tax`, `vat_tax_amount` or `other_tax#_amount` field descriptions in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 13
	Amount string `json:"amount,omitempty"`

	// Flag that indicates whether the alternate tax amount (`orderInformation.amountDetails.taxDetails[].amount`) is
	// included in the request.
	//
	// Possible values:
	// - `false`: alternate tax amount is not included in the request.
	// - `true`: alternate tax amount is included in the request.
	//
	// For processor-specific details, see `alternate_tax_amount_indicator` field description in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	Applied bool `json:"applied,omitempty"`

	// Type of tax being applied to the item.
	//
	// For possible values, see the processor-specific field descriptions in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm):
	//
	// #### FDC Nashville Global
	// - `alternate_tax_type_applied`
	// - `alternate_tax_type_identifier`
	//
	// #### Worldpay VAP
	// - `alternate_tax_type_identifier`
	//
	// #### RBS WorldPay Atlanta
	// - `tax_type_applied`
	//
	// #### TSYS Acquiring Solutions
	// - `tax_type_applied`
	// - `local_tax_indicator`
	//
	// #### Chase Paymentech Solutions
	// - `tax_type_applied`
	//
	// #### Elavon Americas
	// - `local_tax_indicator`
	//
	// #### FDC Compass
	// - `tax_type_applied`
	//
	// #### OmniPay Direct
	// - `local_tax_indicator`
	//
	// Max Length: 4
	Code string `json:"code,omitempty"`

	// Status code for exemption from sales and use tax. This field is a pass-through, which means that
	// CyberSource does not verify the value or modify it in any way before sending it to the processor.
	//
	// For possible values and important information for using this field, see _Appendix B, "Exemption
	// Status Values_ and _Offer-Level Tax Fields_ in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 1
	ExemptionCode string `json:"exemptionCode,omitempty"`

	// Rate of VAT or other tax for the order.
	//
	// Example 0.040 (=4%)
	//
	// Valid range: 0.01 to 0.99 (1% to 99%, with only whole percentage values accepted; values with additional
	// decimal places will be truncated)
	//
	// For processor-specific details, see the `alternate_tax_amount`, `vat_rate`, `vat_tax_rate`, `local_tax`, `national_tax`, `vat_tax_amount` or `other_tax#_rate` field descriptions in the [Level II and Level III Processing Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 6
	Rate string `json:"rate,omitempty"`

	// Your tax ID number to use for the alternate tax amount. Required if you set alternate tax amount to any value,
	// including zero. You may send this field without sending alternate tax amount.
	//
	// For processor-specific details, see `alternate_tax_id` field description in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 15
	TaxID string `json:"taxId,omitempty"`

	// Indicates the type of tax data for the _taxDetails_ object.
	//
	// Possible values:
	//
	// - `alternate`
	// - `local`
	// - `national`
	// - `vat`
	// - `other`
	//
	// For processor-specific details, see the `alternate_tax_amount`, `local_tax`, `national_tax` or `vat_tax_amount` field
	// descriptions in [Level II and Level III Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Level_2_3_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	Type string `json:"type,omitempty"`
}

// Validate validates this create payment params body order information line items items0 tax details items0
func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExemptionCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTaxID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0) validateAmount(formats strfmt.Registry) error {

	if swag.IsZero(o.Amount) { // not required
		return nil
	}

	if err := validate.MaxLength("amount", "body", string(o.Amount), 13); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0) validateCode(formats strfmt.Registry) error {

	if swag.IsZero(o.Code) { // not required
		return nil
	}

	if err := validate.MaxLength("code", "body", string(o.Code), 4); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0) validateExemptionCode(formats strfmt.Registry) error {

	if swag.IsZero(o.ExemptionCode) { // not required
		return nil
	}

	if err := validate.MaxLength("exemptionCode", "body", string(o.ExemptionCode), 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0) validateRate(formats strfmt.Registry) error {

	if swag.IsZero(o.Rate) { // not required
		return nil
	}

	if err := validate.MaxLength("rate", "body", string(o.Rate), 6); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0) validateTaxID(formats strfmt.Registry) error {

	if swag.IsZero(o.TaxID) { // not required
		return nil
	}

	if err := validate.MaxLength("taxId", "body", string(o.TaxID), 15); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyOrderInformationLineItemsItems0TaxDetailsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyOrderInformationShipTo create payment params body order information ship to
swagger:model CreatePaymentParamsBodyOrderInformationShipTo
*/
type CreatePaymentParamsBodyOrderInformationShipTo struct {

	// First line of the shipping address.
	// Max Length: 60
	Address1 string `json:"address1,omitempty"`

	// Second line of the shipping address.
	// Max Length: 60
	Address2 string `json:"address2,omitempty"`

	// State or province of the shipping address. Use the State, Province, and Territory Codes for the United States
	// and Canada.
	//
	// Max Length: 2
	AdministrativeArea string `json:"administrativeArea,omitempty"`

	// Building number in the street address. For example, the building number is 187 in the following address:
	//
	// Rua da Quitanda 187
	//
	// Max Length: 15
	BuildingNumber string `json:"buildingNumber,omitempty"`

	// Name of the customers company.
	//
	// For processor-specific information, see the company_name field in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 60
	Company string `json:"company,omitempty"`

	// Country of the shipping address. Use the two-character ISO Standard Country Codes.
	// Max Length: 2
	Country string `json:"country,omitempty"`

	// Neighborhood, community, or region within a city or municipality.
	// Max Length: 50
	District string `json:"district,omitempty"`

	// First name of the recipient.
	//
	// **Processor specific maximum length**
	//
	// - Litle: 25
	// - All other processors: 60
	//
	// Max Length: 60
	FirstName string `json:"firstName,omitempty"`

	// Last name of the recipient.
	//
	// **Processor-specific maximum length**
	//
	// - Litle: 25
	// - All other processors: 60
	//
	// Max Length: 60
	LastName string `json:"lastName,omitempty"`

	// City of the shipping address.
	// Max Length: 50
	Locality string `json:"locality,omitempty"`

	// Phone number associated with the shipping address.
	// Max Length: 15
	PhoneNumber string `json:"phoneNumber,omitempty"`

	// Postal code for the shipping address. The postal code must consist of 5 to 9 digits.
	//
	// When the billing country is the U.S., the 9-digit postal code must follow this format:
	// [5 digits][dash][4 digits]
	//
	// Example 12345-6789
	//
	// When the billing country is Canada, the 6-digit postal code must follow this format:
	// [alpha][numeric][alpha][space][numeric][alpha][numeric]
	//
	// Example A1B 2C3
	//
	// **American Express Direct**\
	// Before sending the postal code to the processor, CyberSource removes all nonalphanumeric characters and, if the
	// remaining value is longer than nine characters, truncates the value starting from the right side.
	//
	// Max Length: 10
	PostalCode string `json:"postalCode,omitempty"`
}

// Validate validates this create payment params body order information ship to
func (o *CreatePaymentParamsBodyOrderInformationShipTo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAddress1(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAddress2(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAdministrativeArea(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBuildingNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCompany(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDistrict(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFirstName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLastName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocality(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePhoneNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationShipTo) validateAddress1(formats strfmt.Registry) error {

	if swag.IsZero(o.Address1) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"shipTo"+"."+"address1", "body", string(o.Address1), 60); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationShipTo) validateAddress2(formats strfmt.Registry) error {

	if swag.IsZero(o.Address2) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"shipTo"+"."+"address2", "body", string(o.Address2), 60); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationShipTo) validateAdministrativeArea(formats strfmt.Registry) error {

	if swag.IsZero(o.AdministrativeArea) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"shipTo"+"."+"administrativeArea", "body", string(o.AdministrativeArea), 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationShipTo) validateBuildingNumber(formats strfmt.Registry) error {

	if swag.IsZero(o.BuildingNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"shipTo"+"."+"buildingNumber", "body", string(o.BuildingNumber), 15); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationShipTo) validateCompany(formats strfmt.Registry) error {

	if swag.IsZero(o.Company) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"shipTo"+"."+"company", "body", string(o.Company), 60); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationShipTo) validateCountry(formats strfmt.Registry) error {

	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"shipTo"+"."+"country", "body", string(o.Country), 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationShipTo) validateDistrict(formats strfmt.Registry) error {

	if swag.IsZero(o.District) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"shipTo"+"."+"district", "body", string(o.District), 50); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationShipTo) validateFirstName(formats strfmt.Registry) error {

	if swag.IsZero(o.FirstName) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"shipTo"+"."+"firstName", "body", string(o.FirstName), 60); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationShipTo) validateLastName(formats strfmt.Registry) error {

	if swag.IsZero(o.LastName) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"shipTo"+"."+"lastName", "body", string(o.LastName), 60); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationShipTo) validateLocality(formats strfmt.Registry) error {

	if swag.IsZero(o.Locality) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"shipTo"+"."+"locality", "body", string(o.Locality), 50); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationShipTo) validatePhoneNumber(formats strfmt.Registry) error {

	if swag.IsZero(o.PhoneNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"shipTo"+"."+"phoneNumber", "body", string(o.PhoneNumber), 15); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationShipTo) validatePostalCode(formats strfmt.Registry) error {

	if swag.IsZero(o.PostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"shipTo"+"."+"postalCode", "body", string(o.PostalCode), 10); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyOrderInformationShipTo) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyOrderInformationShipTo) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyOrderInformationShipTo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyOrderInformationShippingDetails Contains shipping information not related to address.
swagger:model CreatePaymentParamsBodyOrderInformationShippingDetails
*/
type CreatePaymentParamsBodyOrderInformationShippingDetails struct {

	// Boolean that indicates whether the customer requested gift wrapping for this
	// purchase. This field can contain one of the following
	// values:
	// - true: The customer requested gift wrapping.
	// - false: The customer did not request gift wrapping.
	//
	GiftWrap bool `json:"giftWrap,omitempty"`

	// Postal code for the address from which the goods are shipped, which is used to establish nexus. The default is
	// the postal code associated with your CyberSource account.
	//
	// The postal code must consist of 5 to 9 digits. When the billing country is the U.S., the 9-digit postal code
	// must follow this format:
	//
	// `[5 digits][dash][4 digits]`
	//
	// Example 12345-6789
	//
	// When the billing country is Canada, the 6-digit postal code must follow this format:
	//
	// `[alpha][numeric][alpha][space] [numeric][alpha][numeric]`
	//
	// Example A1B 2C3
	//
	// This field is frequently used for Level II and Level III transactions.
	//
	// Max Length: 10
	ShipFromPostalCode string `json:"shipFromPostalCode,omitempty"`

	// Shipping method for the product. Possible values:
	//
	//  - `lowcost`: Lowest-cost service
	//  - `sameday`: Courier or same-day service
	//  - `oneday`: Next-day or overnight service
	//  - `twoday`: Two-day service
	//  - `threeday`: Three-day service
	//  - `pickup`: Store pick-up
	//  - `other`: Other shipping method
	//  - `none`: No shipping method because product is a service or subscription
	//
	// Max Length: 10
	ShippingMethod string `json:"shippingMethod,omitempty"`
}

// Validate validates this create payment params body order information shipping details
func (o *CreatePaymentParamsBodyOrderInformationShippingDetails) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateShipFromPostalCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateShippingMethod(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationShippingDetails) validateShipFromPostalCode(formats strfmt.Registry) error {

	if swag.IsZero(o.ShipFromPostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"shippingDetails"+"."+"shipFromPostalCode", "body", string(o.ShipFromPostalCode), 10); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyOrderInformationShippingDetails) validateShippingMethod(formats strfmt.Registry) error {

	if swag.IsZero(o.ShippingMethod) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"orderInformation"+"."+"shippingDetails"+"."+"shippingMethod", "body", string(o.ShippingMethod), 10); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyOrderInformationShippingDetails) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyOrderInformationShippingDetails) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyOrderInformationShippingDetails
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyPaymentInformation create payment params body payment information
swagger:model CreatePaymentParamsBodyPaymentInformation
*/
type CreatePaymentParamsBodyPaymentInformation struct {

	// bank
	Bank *CreatePaymentParamsBodyPaymentInformationBank `json:"bank,omitempty"`

	// card
	Card *CreatePaymentParamsBodyPaymentInformationCard `json:"card,omitempty"`

	// customer
	Customer *CreatePaymentParamsBodyPaymentInformationCustomer `json:"customer,omitempty"`

	// fluid data
	FluidData *CreatePaymentParamsBodyPaymentInformationFluidData `json:"fluidData,omitempty"`

	// tokenized card
	TokenizedCard *CreatePaymentParamsBodyPaymentInformationTokenizedCard `json:"tokenizedCard,omitempty"`
}

// Validate validates this create payment params body payment information
func (o *CreatePaymentParamsBodyPaymentInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateBank(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCard(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCustomer(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFluidData(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTokenizedCard(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformation) validateBank(formats strfmt.Registry) error {

	if swag.IsZero(o.Bank) { // not required
		return nil
	}

	if o.Bank != nil {
		if err := o.Bank.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "paymentInformation" + "." + "bank")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformation) validateCard(formats strfmt.Registry) error {

	if swag.IsZero(o.Card) { // not required
		return nil
	}

	if o.Card != nil {
		if err := o.Card.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "paymentInformation" + "." + "card")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformation) validateCustomer(formats strfmt.Registry) error {

	if swag.IsZero(o.Customer) { // not required
		return nil
	}

	if o.Customer != nil {
		if err := o.Customer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "paymentInformation" + "." + "customer")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformation) validateFluidData(formats strfmt.Registry) error {

	if swag.IsZero(o.FluidData) { // not required
		return nil
	}

	if o.FluidData != nil {
		if err := o.FluidData.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "paymentInformation" + "." + "fluidData")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformation) validateTokenizedCard(formats strfmt.Registry) error {

	if swag.IsZero(o.TokenizedCard) { // not required
		return nil
	}

	if o.TokenizedCard != nil {
		if err := o.TokenizedCard.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "paymentInformation" + "." + "tokenizedCard")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyPaymentInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyPaymentInformation) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyPaymentInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyPaymentInformationBank create payment params body payment information bank
swagger:model CreatePaymentParamsBodyPaymentInformationBank
*/
type CreatePaymentParamsBodyPaymentInformationBank struct {

	// account
	Account *CreatePaymentParamsBodyPaymentInformationBankAccount `json:"account,omitempty"`

	// Bank routing number. This is also called the _transit number_.
	//
	// For details, see `ecp_rdfi` request field description in the [Electronic Check Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/EChecks_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 9
	RoutingNumber string `json:"routingNumber,omitempty"`
}

// Validate validates this create payment params body payment information bank
func (o *CreatePaymentParamsBodyPaymentInformationBank) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAccount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRoutingNumber(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformationBank) validateAccount(formats strfmt.Registry) error {

	if swag.IsZero(o.Account) { // not required
		return nil
	}

	if o.Account != nil {
		if err := o.Account.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "paymentInformation" + "." + "bank" + "." + "account")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformationBank) validateRoutingNumber(formats strfmt.Registry) error {

	if swag.IsZero(o.RoutingNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"paymentInformation"+"."+"bank"+"."+"routingNumber", "body", string(o.RoutingNumber), 9); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyPaymentInformationBank) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyPaymentInformationBank) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyPaymentInformationBank
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyPaymentInformationBankAccount create payment params body payment information bank account
swagger:model CreatePaymentParamsBodyPaymentInformationBankAccount
*/
type CreatePaymentParamsBodyPaymentInformationBankAccount struct {

	// Image reference number associated with the check. You cannot include any special characters.
	//
	// Max Length: 32
	CheckImageReferenceNumber string `json:"checkImageReferenceNumber,omitempty"`

	// Check number.
	//
	// Chase Paymentech Solutions - Optional.
	// CyberSource ACH Service - Not used.
	// RBS WorldPay Atlanta - Optional on debits. Required on credits.
	// TeleCheck - Strongly recommended on debit requests. Optional on credits.
	//
	// Max Length: 8
	CheckNumber string `json:"checkNumber,omitempty"`

	// Identifier for the bank that provided the customers encoded account number.
	//
	// To obtain the bank identifier, contact your processor.
	//
	// For details, see `account_encoder_id` request-level field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 3
	EncoderID string `json:"encoderId,omitempty"`

	// Account number.
	//
	// When processing encoded account numbers, use this field for the encoded account number.
	//
	// Max Length: 17
	Number string `json:"number,omitempty"`

	// Account type.
	//
	// Possible values:
	//  - **C**: Checking.
	//  - **G**: General ledger. This value is supported only on Wells Fargo ACH.
	//  - **S**: Savings (U.S. dollars only).
	//  - **X**: Corporate checking (U.S. dollars only).
	//
	// Max Length: 1
	Type string `json:"type,omitempty"`
}

// Validate validates this create payment params body payment information bank account
func (o *CreatePaymentParamsBodyPaymentInformationBankAccount) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCheckImageReferenceNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCheckNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEncoderID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformationBankAccount) validateCheckImageReferenceNumber(formats strfmt.Registry) error {

	if swag.IsZero(o.CheckImageReferenceNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"paymentInformation"+"."+"bank"+"."+"account"+"."+"checkImageReferenceNumber", "body", string(o.CheckImageReferenceNumber), 32); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformationBankAccount) validateCheckNumber(formats strfmt.Registry) error {

	if swag.IsZero(o.CheckNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"paymentInformation"+"."+"bank"+"."+"account"+"."+"checkNumber", "body", string(o.CheckNumber), 8); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformationBankAccount) validateEncoderID(formats strfmt.Registry) error {

	if swag.IsZero(o.EncoderID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"paymentInformation"+"."+"bank"+"."+"account"+"."+"encoderId", "body", string(o.EncoderID), 3); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformationBankAccount) validateNumber(formats strfmt.Registry) error {

	if swag.IsZero(o.Number) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"paymentInformation"+"."+"bank"+"."+"account"+"."+"number", "body", string(o.Number), 17); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformationBankAccount) validateType(formats strfmt.Registry) error {

	if swag.IsZero(o.Type) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"paymentInformation"+"."+"bank"+"."+"account"+"."+"type", "body", string(o.Type), 1); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyPaymentInformationBankAccount) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyPaymentInformationBankAccount) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyPaymentInformationBankAccount
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyPaymentInformationCard create payment params body payment information card
swagger:model CreatePaymentParamsBodyPaymentInformationCard
*/
type CreatePaymentParamsBodyPaymentInformationCard struct {

	// Identifier for the issuing bank that provided the customers encoded account number. Contact your processor for the banks ID.
	//
	// Max Length: 3
	AccountEncoderID string `json:"accountEncoderId,omitempty"`

	// Two-digit month in which the payment card expires.
	//
	// Format: `MM`.
	//
	// Valid values: `01` through `12`.
	//
	// #### Barclays and Streamline
	// For Maestro (UK Domestic) and Maestro (International) cards on Barclays and Streamline, this must be a valid value (`01` through `12`) but is not required to be a valid expiration date. In other words, an expiration date that is in the past does not cause CyberSource to reject your request. However, an invalid expiration date might cause the issuer to reject your request.
	//
	// #### Encoded Account Numbers
	// For encoded account numbers (_type_=039), if there is no expiration date on the card, use `12`.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// For processor-specific information, see the `customer_cc_expmo` field description in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 2
	ExpirationMonth string `json:"expirationMonth,omitempty"`

	// Four-digit year in which the credit card expires.
	//
	// Format: `YYYY`.
	//
	// #### Barclays and Streamline
	// For Maestro (UK Domestic) and Maestro (International) cards on Barclays and Streamline, this must be a valid value (`1900` through `3000`) but is not required to be a valid expiration date. In other words, an expiration date that is in the past does not cause CyberSource to reject your request. However, an invalid expiration date might cause the issuer to reject your request.
	//
	// #### Encoded Account Numbers
	// For encoded account numbers (**_type_**`=039`), if there is no expiration date on the card, use `2021`.
	//
	// #### FDC Nashville Global and FDMS South
	// You can send in 2 digits or 4 digits. If you send in 2 digits, they must be the last 2 digits of the year.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// For processor-specific information, see the `customer_cc_expyr` field description in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 4
	ExpirationYear string `json:"expirationYear,omitempty"`

	// Number of times a Maestro (UK Domestic) card has been issued to the account holder. The card might or might not have an issue number. The number can consist of one or two digits, and the first digit might be a zero. When you include this value in your request, include exactly what is printed on the card. A value of 2 is different than a value of 02. Do not include the field, even with a blank value, if the card is not a Maestro (UK Domestic) card.
	//
	// **Note** The issue number is not required for Maestro (UK Domestic) transactions.
	//
	// Max Length: 5
	IssueNumber string `json:"issueNumber,omitempty"`

	// The customers payment card number, also knows as the Primary Account Nunmber (PAN). You can also use this field
	// for encoded account numbers.
	//
	// For processor-specific information, see the `customer_cc_number` field description in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 20
	Number string `json:"number,omitempty"`

	// Name of the card product.
	//
	// Possible value:
	// - BNDES
	//
	// This field is supported only for BNDES transactions on CyberSource through VisaNet. For details, see `card_product_name` field description in the [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm).
	//
	// The value for this field corresponds to the following data in the TC 33 capture file5:
	// - Record: CP07 TCR4
	// - Position: 115-120
	// - Field: Brazil Country Data
	//
	// Max Length: 15
	ProductName string `json:"productName,omitempty"`

	// Card Verification Number.
	//
	// #### Ingenico ePayments
	// Do not include this field when **commerceIndicator**`=recurring`.
	// **Note** Ingenico ePayments was previously called _Global Collect_.
	//
	// Max Length: 4
	SecurityCode string `json:"securityCode,omitempty"`

	// Flag that indicates whether a CVN code was sent. Possible values:
	//
	//  - 0 (default): CVN service not requested. CyberSource uses this default value when you do not include
	//      _securityCode_ field in the request.
	//  - 1 (default): CVN service requested and supported. CyberSource uses this default value when you include
	//      _securityCode_ field in the request.
	//  - 2: CVN on credit card is illegible.
	//  - 9: CVN was not imprinted on credit card.
	//
	// Max Length: 1
	SecurityCodeIndicator string `json:"securityCodeIndicator,omitempty"`

	// Flag that specifies the type of account associated with the card. The cardholder provides this information
	// during the payment process.
	//
	// This field is required in the following cases:
	//   - Debit transactions on Cielo and Comercio Latino.
	//   - Transactions with Brazilian-issued cards on CyberSource through VisaNet.
	//   - Applicable only for CyberSource through VisaNet (CtV).
	//
	// **Note** Combo cards in Brazil contain credit and debit functionality in a single card. Visa systems use a credit bank
	// identification number (BIN) for this type of card. Using the BIN to determine whether a card is debit or
	// credit can cause transactions with these cards to be processed incorrectly. CyberSource strongly recommends
	// that you include this field for combo card transactions.
	//
	// Possible values include the following.
	//
	//  - `CHECKING`: Checking account
	//  - `CREDIT`: Credit card account
	//  - `SAVING`: Saving account
	//  - `LINE_OF_CREDIT`: Line of credit or credit portion of combo card
	//  - `PREPAID`: Prepaid card account or prepaid portion of combo card
	//  - `UNIVERSAL`: Universal account
	//
	// Max Length: 20
	SourceAccountType string `json:"sourceAccountType,omitempty"`

	// Month of the start of the Maestro (UK Domestic) card validity period. Do not include the field, even with a blank value, if the card is not a Maestro (UK Domestic) card. `Format: MM`. Possible values: 01 through 12.
	//
	// **Note** The start date is not required for Maestro (UK Domestic) transactions.
	//
	// Max Length: 2
	StartMonth string `json:"startMonth,omitempty"`

	// Year of the start of the Maestro (UK Domestic) card validity period. Do not include the field, even with a blank value, if the card is not a Maestro (UK Domestic) card. `Format: YYYY`.
	//
	// **Note** The start date is not required for Maestro (UK Domestic) transactions.
	//
	// Max Length: 4
	StartYear string `json:"startYear,omitempty"`

	// Three-digit value that indicates the card type.
	//
	// Type of card to authorize.
	// - 001 Visa
	// - 002 Mastercard
	// - 003 Amex
	// - 004 Discover
	// - 005: Diners Club
	// - 007: JCB
	// - 024: Maestro (UK Domestic)
	// - 039 Encoded account number
	// - 042: Maestro (International)
	//
	// For the complete list of possible values, see `card_type` field description in the [Credit Card Services Using the SCMP API Guide.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	Type string `json:"type,omitempty"`

	// Flag that specifies the type of account associated with the card. The cardholder provides this information
	// during the payment process.
	//
	// #### Cielo and Comercio Latino
	//
	// Possible values:
	//
	//  - CREDIT: Credit card
	//  - DEBIT: Debit card
	//
	// This field is required for:
	//  - Debit transactions on Cielo and Comercio Latino.
	//  - Transactions with Brazilian-issued cards on CyberSource through VisaNet.
	//
	// **Note** The value for this field corresponds to the following data in the TC 33 capture file5:
	// - Record: CP07 TCR0
	// - Position: 51
	// - Field: Combination Card Transaction Identifier
	//
	// This field is supported only for Mastercard transactions in Brazil on CyberSource through VisaNet.
	//
	// Max Length: 20
	UseAs string `json:"useAs,omitempty"`
}

// Validate validates this create payment params body payment information card
func (o *CreatePaymentParamsBodyPaymentInformationCard) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAccountEncoderID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpirationMonth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpirationYear(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateIssueNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProductName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSecurityCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSecurityCodeIndicator(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSourceAccountType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateStartMonth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateStartYear(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateUseAs(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformationCard) validateAccountEncoderID(formats strfmt.Registry) error {

	if swag.IsZero(o.AccountEncoderID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"paymentInformation"+"."+"card"+"."+"accountEncoderId", "body", string(o.AccountEncoderID), 3); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformationCard) validateExpirationMonth(formats strfmt.Registry) error {

	if swag.IsZero(o.ExpirationMonth) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"paymentInformation"+"."+"card"+"."+"expirationMonth", "body", string(o.ExpirationMonth), 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformationCard) validateExpirationYear(formats strfmt.Registry) error {

	if swag.IsZero(o.ExpirationYear) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"paymentInformation"+"."+"card"+"."+"expirationYear", "body", string(o.ExpirationYear), 4); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformationCard) validateIssueNumber(formats strfmt.Registry) error {

	if swag.IsZero(o.IssueNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"paymentInformation"+"."+"card"+"."+"issueNumber", "body", string(o.IssueNumber), 5); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformationCard) validateNumber(formats strfmt.Registry) error {

	if swag.IsZero(o.Number) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"paymentInformation"+"."+"card"+"."+"number", "body", string(o.Number), 20); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformationCard) validateProductName(formats strfmt.Registry) error {

	if swag.IsZero(o.ProductName) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"paymentInformation"+"."+"card"+"."+"productName", "body", string(o.ProductName), 15); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformationCard) validateSecurityCode(formats strfmt.Registry) error {

	if swag.IsZero(o.SecurityCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"paymentInformation"+"."+"card"+"."+"securityCode", "body", string(o.SecurityCode), 4); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformationCard) validateSecurityCodeIndicator(formats strfmt.Registry) error {

	if swag.IsZero(o.SecurityCodeIndicator) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"paymentInformation"+"."+"card"+"."+"securityCodeIndicator", "body", string(o.SecurityCodeIndicator), 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformationCard) validateSourceAccountType(formats strfmt.Registry) error {

	if swag.IsZero(o.SourceAccountType) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"paymentInformation"+"."+"card"+"."+"sourceAccountType", "body", string(o.SourceAccountType), 20); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformationCard) validateStartMonth(formats strfmt.Registry) error {

	if swag.IsZero(o.StartMonth) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"paymentInformation"+"."+"card"+"."+"startMonth", "body", string(o.StartMonth), 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformationCard) validateStartYear(formats strfmt.Registry) error {

	if swag.IsZero(o.StartYear) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"paymentInformation"+"."+"card"+"."+"startYear", "body", string(o.StartYear), 4); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformationCard) validateUseAs(formats strfmt.Registry) error {

	if swag.IsZero(o.UseAs) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"paymentInformation"+"."+"card"+"."+"useAs", "body", string(o.UseAs), 20); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyPaymentInformationCard) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyPaymentInformationCard) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyPaymentInformationCard
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyPaymentInformationCustomer create payment params body payment information customer
swagger:model CreatePaymentParamsBodyPaymentInformationCustomer
*/
type CreatePaymentParamsBodyPaymentInformationCustomer struct {

	// Unique identifier for the customer's card and billing information.
	//
	// When you use Payment Tokenization or Recurring Billing and you include this value in
	// your request, many of the fields that are normally required for an authorization or credit
	// become optional.
	//
	// **NOTE** When you use Payment Tokenization or Recurring Billing, the value for the Customer ID is actually the Cybersource payment token for a customer. This token stores information such as the consumers card number so it can be applied towards bill payments, recurring payments, or one-time payments. By using this token in a payment API request, the merchant doesn't need to pass in data such as the card number or expiration date in the request itself.
	//
	// For details, see the `subscription_id` field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	CustomerID string `json:"customerId,omitempty"`
}

// Validate validates this create payment params body payment information customer
func (o *CreatePaymentParamsBodyPaymentInformationCustomer) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyPaymentInformationCustomer) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyPaymentInformationCustomer) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyPaymentInformationCustomer
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyPaymentInformationFluidData create payment params body payment information fluid data
swagger:model CreatePaymentParamsBodyPaymentInformationFluidData
*/
type CreatePaymentParamsBodyPaymentInformationFluidData struct {

	// The identifier for a payment solution, which is sending the encrypted payment data to CyberSource for decryption.
	// Valid values:
	// - Samsung Pay: `RklEPUNPTU1PTi5TQU1TVU5HLklOQVBQLlBBWU1FTlQ=`
	// **NOTE**: For other payment solutions, the value may be specific to the customer's mobile device. For example, the descriptor for a Bluefin payment encryption would be a device-generated descriptor.
	//
	// For details about the list of payment solution identifiers, see [Creating an Online Authorization](https://developer.cybersource.com/api/developer-guides/dita-payments/CreatingOnlineAuth.html).
	//
	// For details about the encrypted payment data, see the `encrypted_payment_descriptor` field description in the [Card-Present Processing Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/Retail_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm).
	//
	// Max Length: 128
	Descriptor string `json:"descriptor,omitempty"`

	// Encoding method used to encrypt the payment data.
	//
	// Valid value: Base64
	//
	// Max Length: 6
	Encoding string `json:"encoding,omitempty"`

	// The encoded or encrypted value that a payment solution returns for an authorization request. For details about the valid values for a key, see [Creating an Online Authorization](https://developer.cybersource.com/api/developer-guides/dita-payments/CreatingOnlineAuth.html)
	//
	KeySerialNumber string `json:"keySerialNumber,omitempty"`

	// Represents the encrypted payment data BLOB. The entry for this field is dependent on the payment solution a merchant uses.
	//
	// For details, see [Creating an Online Authorization](https://developer.cybersource.com/api/developer-guides/dita-payments/CreatingOnlineAuth.html) for the specific payment- solution entry.
	//
	// Max Length: 3072
	Value string `json:"value,omitempty"`
}

// Validate validates this create payment params body payment information fluid data
func (o *CreatePaymentParamsBodyPaymentInformationFluidData) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDescriptor(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEncoding(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateValue(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformationFluidData) validateDescriptor(formats strfmt.Registry) error {

	if swag.IsZero(o.Descriptor) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"paymentInformation"+"."+"fluidData"+"."+"descriptor", "body", string(o.Descriptor), 128); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformationFluidData) validateEncoding(formats strfmt.Registry) error {

	if swag.IsZero(o.Encoding) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"paymentInformation"+"."+"fluidData"+"."+"encoding", "body", string(o.Encoding), 6); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformationFluidData) validateValue(formats strfmt.Registry) error {

	if swag.IsZero(o.Value) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"paymentInformation"+"."+"fluidData"+"."+"value", "body", string(o.Value), 3072); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyPaymentInformationFluidData) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyPaymentInformationFluidData) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyPaymentInformationFluidData
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyPaymentInformationTokenizedCard create payment params body payment information tokenized card
swagger:model CreatePaymentParamsBodyPaymentInformationTokenizedCard
*/
type CreatePaymentParamsBodyPaymentInformationTokenizedCard struct {

	// Confidence level of the tokenization. This value is assigned by the token service provider.
	//
	// **Note** This field is supported only for **CyberSource through VisaNet** and **FDC Nashville Global**.
	//
	// Max Length: 2
	AssuranceLevel string `json:"assuranceLevel,omitempty"`

	// This field is used internally.
	// Max Length: 40
	Cryptogram string `json:"cryptogram,omitempty"`

	// One of two possible meanings:
	// - The two-digit month in which a token expires.
	// - The two-digit month in which a card expires.
	// Format: `MM`
	// Possible values: `01` through `12`
	//
	// **NOTE** The meaning of this field is dependent on the payment processor that is returning the value in an authorization reply. Please see the processor-specific details below.
	//
	// #### Barclays and Streamline
	// For Maestro (UK Domestic) and Maestro (International) cards on Barclays and Streamline, this must be a valid value (`01` through `12`) but is not required to be a valid expiration date. In other words, an expiration date that is in the past does not cause CyberSource to reject your request. However, an invalid expiration date might cause the issuer to reject your request.
	//
	// #### Encoded Account Numbers
	// For encoded account numbers (`card_type=039`), if there is no expiration date on the card, use `12`.\
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// #### Samsung Pay and Apple Pay
	// Month in which the token expires. CyberSource includes this field in the reply message when it decrypts the payment blob for the tokenized transaction.
	//
	// For processor-specific information, see the `customer_cc_expmo` field in [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 2
	ExpirationMonth string `json:"expirationMonth,omitempty"`

	// One of two possible meanings:
	// - The four-digit year in which a token expires.
	// - The four-digit year in which a card expires.
	// Format: `YYYY`
	// Possible values: `1900` through `3000`
	// Data type: Non-negative integer
	//
	// **NOTE** The meaning of this field is dependent on the payment processor that is returning the value in an authorization reply. Please see the processor-specific details below.
	//
	// #### Barclays and Streamline
	// For Maestro (UK Domestic) and Maestro (International) cards on Barclays and Streamline, this must be a valid value (1900 through
	// 3000) but is not required to be a valid expiration date. In other words, an expiration date that is in the past does not cause CyberSource to reject your request. However, an invalid expiration date might cause the issuer to reject your request.
	//
	// #### Encoded Account Numbers
	// For encoded account numbers (`card_ type=039`), if there is no expiration date on the card, use `2021`.
	//
	// #### FDC Nashville Global and FDMS South
	// You can send in 2 digits or 4 digits. When you send in 2 digits, they must be the last 2 digits of
	// the year.
	//
	// #### Samsung Pay and Apple Pay
	// Year in which the token expires. CyberSource includes this field in the reply message when it decrypts the payment blob for the tokenized transaction.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction
	// you are requesting.
	//
	// For processor-specific information, see the `customer_cc_expyr` or `token_expiration_year` field in [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 4
	ExpirationYear string `json:"expirationYear,omitempty"`

	// Customers payment network token value.
	//
	// Max Length: 20
	Number string `json:"number,omitempty"`

	// Value that identifies your business and indicates that the cardholders account number is tokenized. This value
	// is assigned by the token service provider and is unique within the token service providers database.
	//
	// **Note** This field is supported only for **CyberSource through VisaNet** and **FDC Nashville Global**.
	//
	// Max Length: 11
	RequestorID string `json:"requestorId,omitempty"`

	// Card Verification Number (CVN).
	//
	// #### Ingenico ePayments
	// Do not include this field when **commerceIndicator=recurring**.
	// **Note** Ingenico ePayments was previously called _Global Collect_.
	//
	// For details, see `customer_cc_cv_number` field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 4
	SecurityCode string `json:"securityCode,omitempty"`

	// Type of technology used in the device to store token data. Possible values:
	//
	// - `001`: Secure Element (SE). Smart card or memory with restricted access and encryption to prevent data tampering. For storing payment
	//    credentials, a SE is tested against a set of requirements defined by the payment networks.
	//
	//    **Note** This field is supported only for _FDC Compass_.
	//
	// - 002: Host Card Emulation (HCE). Emulation of a smart card by using software to create a virtual and exact representation of the card.
	// Sensitive data is stored in a database that is hosted in the cloud. For storing payment credentials, a database
	// must meet very stringent security requirements that exceed PCI DSS.
	//
	// **Note** This field is supported only for _FDC Compass_.
	//
	// Max Length: 3
	StorageMethod string `json:"storageMethod,omitempty"`

	// Type of transaction that provided the token data. This value does not specify the token service provider; it
	// specifies the entity that provided you with information about the token.
	//
	// Set the value for this field to 1. An application on the customers mobile device provided the token data.
	//
	// Max Length: 1
	TransactionType string `json:"transactionType,omitempty"`

	// Three-digit value that indicates the card type.
	//
	// Type of card to authorize.
	// - 001 Visa
	// - 002 Mastercard
	// - 003 Amex
	// - 004 Discover
	// - 005: Diners Club
	// - 007: JCB
	// - 024: Maestro (UK Domestic)
	// - 039 Encoded account number
	// - 042: Maestro (International)
	//
	// For the complete list of possible values, see `card_type` field description in the [Credit Card Services Using the SCMP API Guide.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	Type string `json:"type,omitempty"`
}

// Validate validates this create payment params body payment information tokenized card
func (o *CreatePaymentParamsBodyPaymentInformationTokenizedCard) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAssuranceLevel(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCryptogram(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpirationMonth(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExpirationYear(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRequestorID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSecurityCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateStorageMethod(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTransactionType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformationTokenizedCard) validateAssuranceLevel(formats strfmt.Registry) error {

	if swag.IsZero(o.AssuranceLevel) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"paymentInformation"+"."+"tokenizedCard"+"."+"assuranceLevel", "body", string(o.AssuranceLevel), 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformationTokenizedCard) validateCryptogram(formats strfmt.Registry) error {

	if swag.IsZero(o.Cryptogram) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"paymentInformation"+"."+"tokenizedCard"+"."+"cryptogram", "body", string(o.Cryptogram), 40); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformationTokenizedCard) validateExpirationMonth(formats strfmt.Registry) error {

	if swag.IsZero(o.ExpirationMonth) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"paymentInformation"+"."+"tokenizedCard"+"."+"expirationMonth", "body", string(o.ExpirationMonth), 2); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformationTokenizedCard) validateExpirationYear(formats strfmt.Registry) error {

	if swag.IsZero(o.ExpirationYear) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"paymentInformation"+"."+"tokenizedCard"+"."+"expirationYear", "body", string(o.ExpirationYear), 4); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformationTokenizedCard) validateNumber(formats strfmt.Registry) error {

	if swag.IsZero(o.Number) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"paymentInformation"+"."+"tokenizedCard"+"."+"number", "body", string(o.Number), 20); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformationTokenizedCard) validateRequestorID(formats strfmt.Registry) error {

	if swag.IsZero(o.RequestorID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"paymentInformation"+"."+"tokenizedCard"+"."+"requestorId", "body", string(o.RequestorID), 11); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformationTokenizedCard) validateSecurityCode(formats strfmt.Registry) error {

	if swag.IsZero(o.SecurityCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"paymentInformation"+"."+"tokenizedCard"+"."+"securityCode", "body", string(o.SecurityCode), 4); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformationTokenizedCard) validateStorageMethod(formats strfmt.Registry) error {

	if swag.IsZero(o.StorageMethod) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"paymentInformation"+"."+"tokenizedCard"+"."+"storageMethod", "body", string(o.StorageMethod), 3); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPaymentInformationTokenizedCard) validateTransactionType(formats strfmt.Registry) error {

	if swag.IsZero(o.TransactionType) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"paymentInformation"+"."+"tokenizedCard"+"."+"transactionType", "body", string(o.TransactionType), 1); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyPaymentInformationTokenizedCard) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyPaymentInformationTokenizedCard) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyPaymentInformationTokenizedCard
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyPointOfSaleInformation create payment params body point of sale information
swagger:model CreatePaymentParamsBodyPointOfSaleInformation
*/
type CreatePaymentParamsBodyPointOfSaleInformation struct {

	// Point-of-sale details for the transaction. This value is returned only for **American Express Direct**.
	// CyberSource generates this value, which consists of a series of codes that identify terminal capability,
	// security data, and specific conditions present at the time the transaction occurred. To comply with the CAPN
	// requirements, this value must be included in all subsequent follow-on requests, such as captures and follow-on
	// credits.
	//
	// When you perform authorizations, captures, and credits through CyberSource, CyberSource passes this value from
	// the authorization service to the subsequent services for you. However, when you perform authorizations through
	// CyberSource and perform subsequent services through other financial institutions, you must ensure that your
	// requests for captures and credits include this value.
	//
	// For details, see `auth_pos_data` field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 12
	AmexCapnData string `json:"amexCapnData,omitempty"`

	// cardholder verification method
	CardholderVerificationMethod []string `json:"cardholderVerificationMethod"`

	// Type of cardholder-activated terminal. Possible values:
	//
	//  - 1: Automated dispensing machine
	//  - 2: Self-service terminal
	//  - 3: Limited amount terminal
	//  - 4: In-flight commerce (IFC) terminal
	//  - 5: Radio frequency device
	//  - 6: Mobile acceptance terminal
	//  - 7: Electronic cash register
	//  - 8: E-commerce device at your location
	//  - 9: Terminal or cash register that uses a dialup connection to connect to the transaction processing network
	//
	// #### Chase Paymentech Solutions
	// Only values 1, 2, and 3 are supported.
	//
	// #### FDC Nashville Global
	// Only values 7, 8, and 9 are supported.
	//
	// #### GPN
	// Only values 6, 7, 8, and 9 are supported.
	//
	// #### TSYS Acquiring Solutions
	// Only value 6 is supported.
	// For details, see the `cat_level` field description in [Card-Present Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Retail_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Maximum: 9
	// Minimum: 1
	CatLevel int64 `json:"catLevel,omitempty"`

	// Value created by the client software that uniquely identifies the POS device. This value is provided by the
	// client software that is installed on the POS terminal.
	//
	// CyberSource does not forward this value to the processor. Instead, the value is forwarded to the CyberSource
	// reporting functionality.
	//
	// This field is supported only on American Express Direct, FDC Nashville Global, and SIX.
	//
	// Max Length: 32
	DeviceID string `json:"deviceId,omitempty"`

	// emv
	Emv *CreatePaymentParamsBodyPointOfSaleInformationEmv `json:"emv,omitempty"`

	// This is a combination of the device's unique identifier and a transaction counter that is used in the process of
	// decrypting the encrypted PIN.
	//
	// For all terminals that are using derived unique key per transaction (DUKPT) encryption, this is generated as a
	// single number within the terminal.
	//
	// Max Length: 20
	EncryptedKeySerialNumber string `json:"encryptedKeySerialNumber,omitempty"`

	// Encrypted PIN.
	//
	// This value is provided by the client software that is installed on the POS terminal.
	//
	// In the Credit Card Guide for the auth service: This field is supported only on American Express Direct, FDC
	// Nashville Global, and SIX.
	//
	// Max Length: 16
	EncryptedPin string `json:"encryptedPin,omitempty"`

	// Method of entering credit card information into the POS terminal. Possible values:
	//
	//  - `contact`: Read from direct contact with chip card.
	//  - `contactless`: Read from a contactless interface using chip data.
	//  - `keyed`: Manually keyed into POS terminal.
	//  - `msd`: Read from a contactless interface using magnetic stripe data (MSD).
	//  - `swiped`: Read from credit card magnetic stripe.
	//
	// The contact, contactless, and msd values are supported only for EMV transactions.
	//
	// For details, see the `pos_entry_mode` field description in [Card-Present Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Retail_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 11
	EntryMode string `json:"entryMode,omitempty"`

	// Identifier for an alternate terminal at your retail location. You define the value for this field.
	//
	// This field is supported only for MasterCard transactions on FDC Nashville Global. Use the `terminalId` field to
	// identify the main terminal at your retail location. If your retail location has multiple terminals, use this
	// `laneNumber` field to identify the terminal used for the transaction.
	//
	// This field is a pass-through, which means that CyberSource does not check the value or modify the value in any
	// way before sending it to the processor.
	//
	// Max Length: 8
	LaneNumber string `json:"laneNumber,omitempty"`

	// Operating environment.
	//
	// Possible values for all card types except Mastercard:
	// - `0`: No terminal used or unknown environment.
	// - `1`: On merchant premises, attended.
	// - `2`: On merchant premises, unattended. Examples: oil, kiosks, self-checkout, mobile telephone, personal digital assistant (PDA).
	// - `3`: Off merchant premises, attended. Examples: portable POS devices at trade shows, at service calls, or in taxis.
	// - `4`: Off merchant premises, unattended. Examples: vending machines, home computer, mobile telephone, PDA.
	// - `5`: On premises of cardholder, unattended.
	// - `9`: Unknown delivery mode.
	// - `S`: Electronic delivery of product. Examples: music, software, or eTickets that are downloaded over the internet.
	// - `T`: Physical delivery of product. Examples: music or software that is delivered by mail or by a courier.
	//
	// #### Possible values for Mastercard:
	// - `2`: On merchant premises, unattended, or cardholder terminal. Examples: oil, kiosks, self-checkout, home computer, mobile telephone, personal digital assistant (PDA). Cardholder terminal is supported only for Mastercard transactions on CyberSource through VisaNet.
	// - `4`: Off merchant premises, unattended, or cardholder terminal. Examples: vending machines, home computer, mobile telephone, PDA. Cardholder terminal is supported only for Mastercard transactions on CyberSource through VisaNet.
	//
	// This field is supported only for American Express Direct and CyberSource through VisaNet.
	//
	// Max Length: 1
	OperatingEnvironment string `json:"operatingEnvironment,omitempty"`

	// Version of the software installed on the POS terminal. This value is provided by the client software that is
	// installed on the POS terminal.
	//
	// CyberSource does not forward this value to the processor. Instead, the value is forwarded to the CyberSource
	// reporting functionality.
	//
	// This field is supported only on American Express Direct, FDC Nashville Global, and SIX.
	//
	// Max Length: 32
	PartnerSdkVersion string `json:"partnerSdkVersion,omitempty"`

	// Format that is used to encode the PIN block. This value is provided by the client software that is installed on
	// the POS terminal.
	//
	// Possible values:
	// - 0: ISO 9564 format 0
	// - 1: ISO 9564 format 1
	// - 2: ISO 9564 format 2
	// - 3: ISO 9564 format 3
	//
	// In the Credit Card Guide for the auth service: This field is supported only on American Express Direct, FDC
	// Nashville Global, and SIX.
	//
	// Maximum: 9
	PinBlockEncodingFormat int64 `json:"pinBlockEncodingFormat,omitempty"`

	// A one-digit code that identifies the capability of terminal to capture PINs.
	// This code does not necessarily mean that a PIN was entered or is included in this message.
	//
	// POS terminals capability. Possible values:
	// - `1`: Terminal has a magnetic stripe reader only.
	// - `2`: Terminal has a magnetic stripe reader and manual entry capability.
	// - `3`: Terminal has manual entry capability only.
	// - `4`: Terminal can read chip cards.*
	// - `5`: Terminal can read contactless chip cards.*
	// * The values of 4 and 5 are supported only for EMV transactions.
	//
	// For Payouts: This field is applicable for CtV.
	//
	// For details, see the `terminal_capability` field description in [Card-Present Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Retail_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Maximum: 1
	// Minimum: 1
	PinEntryCapability int64 `json:"pinEntryCapability,omitempty"`

	// When connectivity is unavailable, the client software that is installed on the POS terminal can store a
	// transaction in its memory and send it for authorization when connectivity is restored. This value is provided by
	// the client software that is installed on the POS terminal.
	//
	// CyberSource does not forward this value to the processor. Instead, the value is forwarded to the CyberSource
	// reporting functionality.
	//
	// Possible values:
	// - Y: Transaction was stored and then forwarded.
	// - N (default): Transaction was not stored and then forwarded.
	//
	// This field is supported only on American Express Direct, FDC Nashville Global, and SIX.
	//
	// Max Length: 1
	StoreAndForwardIndicator string `json:"storeAndForwardIndicator,omitempty"`

	// POS terminals capability. Possible values:
	//
	//  - `1`: Terminal has a magnetic stripe reader only.
	//  - `2`: Terminal has a magnetic stripe reader and manual entry capability.
	//  - `3`: Terminal has manual entry capability only.
	//  - `4`: Terminal can read chip cards.
	//  - `5`: Terminal can read contactless chip cards.
	//
	// The values of 4 and 5 are supported only for EMV transactions.
	// * Applicable only for CTV for Payouts.
	//
	// For processor-specific details, see the `terminal_capability` field description in [Card-Present Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Retail_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Maximum: 5
	// Minimum: 1
	TerminalCapability int64 `json:"terminalCapability,omitempty"`

	// Indicates whether the terminal can capture the card.
	//
	// Possible values:
	// - 1: Terminal can capture card.
	// - 0: Terminal cannot capture card.
	//
	// This field is supported only on American Express Direct.
	//
	// Max Length: 1
	TerminalCardCaptureCapability string `json:"terminalCardCaptureCapability,omitempty"`

	// Identifier for the terminal at your retail location. You can define this value yourself, but consult the
	// processor for requirements.
	//
	// #### FDC Nashville Global
	// To have your account configured to support this field, contact CyberSource Customer Support. This value must be
	// a value that FDC Nashville Global issued to you.
	//
	// For details, see the `terminal_id` field description in [Card-Present Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Retail_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// **For Payouts**: This field is applicable for CtV.
	//
	// Max Length: 8
	TerminalID string `json:"terminalId,omitempty"`

	// terminal input capability
	TerminalInputCapability []string `json:"terminalInputCapability"`

	// Indicates whether the terminal can print or display messages.
	//
	// Possible values:
	// - 1: Neither
	// - 2: Print only
	// - 3: Display only
	// - 4: Print and display
	//
	// This field is supported only on American Express Direct.
	//
	// Max Length: 1
	TerminalOutputCapability string `json:"terminalOutputCapability,omitempty"`

	// Maximum PIN length that the terminal can capture.
	//
	// Possible values:
	// -  0: No PIN capture capability
	// -  1: PIN capture capability unknown
	// -  4: Four characters
	// -  5: Five characters
	// -  6: Six characters
	// -  7: Seven characters
	// -  8: Eight characters
	// -  9: Nine characters
	// - 10: Ten characters
	// - 11: Eleven characters
	// - 12: Twelve characters
	//
	// This field is supported only on American Express Direct and SIX.
	//
	TerminalPinCapability int64 `json:"terminalPinCapability,omitempty"`

	// Terminal serial number assigned by the hardware manufacturer. This value is provided by the client software that
	// is installed on the POS terminal.
	//
	// CyberSource does not forward this value to the processor. Instead, the value is forwarded to the CyberSource
	// reporting functionality.
	//
	// This field is supported only on American Express Direct, FDC Nashville Global, and SIX.
	//
	// For details, see the `terminal_serial_number` field description in [Card-Present Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Retail_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 32
	TerminalSerialNumber string `json:"terminalSerialNumber,omitempty"`

	// Cards track 1 and 2 data. For all processors except FDMS Nashville, this value consists of
	// one of the following:
	//
	//  - Track 1 data
	//  - Track 2 data
	//  - Data for both tracks 1 and 2
	//
	// For FDMS Nashville, this value consists of one of the following:
	//  - Track 1 data
	//  - Data for both tracks 1 and 2
	//
	// Example: %B4111111111111111^SMITH/JOHN ^1612101976110000868000000?;4111111111111111=16121019761186800000?
	//
	TrackData string `json:"trackData,omitempty"`
}

// Validate validates this create payment params body point of sale information
func (o *CreatePaymentParamsBodyPointOfSaleInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAmexCapnData(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCatLevel(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDeviceID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEmv(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEncryptedKeySerialNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEncryptedPin(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEntryMode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLaneNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOperatingEnvironment(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePartnerSdkVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePinBlockEncodingFormat(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePinEntryCapability(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateStoreAndForwardIndicator(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTerminalCapability(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTerminalCardCaptureCapability(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTerminalID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTerminalOutputCapability(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTerminalSerialNumber(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyPointOfSaleInformation) validateAmexCapnData(formats strfmt.Registry) error {

	if swag.IsZero(o.AmexCapnData) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"pointOfSaleInformation"+"."+"amexCapnData", "body", string(o.AmexCapnData), 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPointOfSaleInformation) validateCatLevel(formats strfmt.Registry) error {

	if swag.IsZero(o.CatLevel) { // not required
		return nil
	}

	if err := validate.MinimumInt("createPaymentRequest"+"."+"pointOfSaleInformation"+"."+"catLevel", "body", int64(o.CatLevel), 1, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("createPaymentRequest"+"."+"pointOfSaleInformation"+"."+"catLevel", "body", int64(o.CatLevel), 9, false); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPointOfSaleInformation) validateDeviceID(formats strfmt.Registry) error {

	if swag.IsZero(o.DeviceID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"pointOfSaleInformation"+"."+"deviceId", "body", string(o.DeviceID), 32); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPointOfSaleInformation) validateEmv(formats strfmt.Registry) error {

	if swag.IsZero(o.Emv) { // not required
		return nil
	}

	if o.Emv != nil {
		if err := o.Emv.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "pointOfSaleInformation" + "." + "emv")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyPointOfSaleInformation) validateEncryptedKeySerialNumber(formats strfmt.Registry) error {

	if swag.IsZero(o.EncryptedKeySerialNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"pointOfSaleInformation"+"."+"encryptedKeySerialNumber", "body", string(o.EncryptedKeySerialNumber), 20); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPointOfSaleInformation) validateEncryptedPin(formats strfmt.Registry) error {

	if swag.IsZero(o.EncryptedPin) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"pointOfSaleInformation"+"."+"encryptedPin", "body", string(o.EncryptedPin), 16); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPointOfSaleInformation) validateEntryMode(formats strfmt.Registry) error {

	if swag.IsZero(o.EntryMode) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"pointOfSaleInformation"+"."+"entryMode", "body", string(o.EntryMode), 11); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPointOfSaleInformation) validateLaneNumber(formats strfmt.Registry) error {

	if swag.IsZero(o.LaneNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"pointOfSaleInformation"+"."+"laneNumber", "body", string(o.LaneNumber), 8); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPointOfSaleInformation) validateOperatingEnvironment(formats strfmt.Registry) error {

	if swag.IsZero(o.OperatingEnvironment) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"pointOfSaleInformation"+"."+"operatingEnvironment", "body", string(o.OperatingEnvironment), 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPointOfSaleInformation) validatePartnerSdkVersion(formats strfmt.Registry) error {

	if swag.IsZero(o.PartnerSdkVersion) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"pointOfSaleInformation"+"."+"partnerSdkVersion", "body", string(o.PartnerSdkVersion), 32); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPointOfSaleInformation) validatePinBlockEncodingFormat(formats strfmt.Registry) error {

	if swag.IsZero(o.PinBlockEncodingFormat) { // not required
		return nil
	}

	if err := validate.MaximumInt("createPaymentRequest"+"."+"pointOfSaleInformation"+"."+"pinBlockEncodingFormat", "body", int64(o.PinBlockEncodingFormat), 9, false); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPointOfSaleInformation) validatePinEntryCapability(formats strfmt.Registry) error {

	if swag.IsZero(o.PinEntryCapability) { // not required
		return nil
	}

	if err := validate.MinimumInt("createPaymentRequest"+"."+"pointOfSaleInformation"+"."+"pinEntryCapability", "body", int64(o.PinEntryCapability), 1, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("createPaymentRequest"+"."+"pointOfSaleInformation"+"."+"pinEntryCapability", "body", int64(o.PinEntryCapability), 1, false); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPointOfSaleInformation) validateStoreAndForwardIndicator(formats strfmt.Registry) error {

	if swag.IsZero(o.StoreAndForwardIndicator) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"pointOfSaleInformation"+"."+"storeAndForwardIndicator", "body", string(o.StoreAndForwardIndicator), 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPointOfSaleInformation) validateTerminalCapability(formats strfmt.Registry) error {

	if swag.IsZero(o.TerminalCapability) { // not required
		return nil
	}

	if err := validate.MinimumInt("createPaymentRequest"+"."+"pointOfSaleInformation"+"."+"terminalCapability", "body", int64(o.TerminalCapability), 1, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("createPaymentRequest"+"."+"pointOfSaleInformation"+"."+"terminalCapability", "body", int64(o.TerminalCapability), 5, false); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPointOfSaleInformation) validateTerminalCardCaptureCapability(formats strfmt.Registry) error {

	if swag.IsZero(o.TerminalCardCaptureCapability) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"pointOfSaleInformation"+"."+"terminalCardCaptureCapability", "body", string(o.TerminalCardCaptureCapability), 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPointOfSaleInformation) validateTerminalID(formats strfmt.Registry) error {

	if swag.IsZero(o.TerminalID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"pointOfSaleInformation"+"."+"terminalId", "body", string(o.TerminalID), 8); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPointOfSaleInformation) validateTerminalOutputCapability(formats strfmt.Registry) error {

	if swag.IsZero(o.TerminalOutputCapability) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"pointOfSaleInformation"+"."+"terminalOutputCapability", "body", string(o.TerminalOutputCapability), 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPointOfSaleInformation) validateTerminalSerialNumber(formats strfmt.Registry) error {

	if swag.IsZero(o.TerminalSerialNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"pointOfSaleInformation"+"."+"terminalSerialNumber", "body", string(o.TerminalSerialNumber), 32); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyPointOfSaleInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyPointOfSaleInformation) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyPointOfSaleInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyPointOfSaleInformationEmv create payment params body point of sale information emv
swagger:model CreatePaymentParamsBodyPointOfSaleInformationEmv
*/
type CreatePaymentParamsBodyPointOfSaleInformationEmv struct {

	// Number assigned to a specific card when two or more cards are associated with the same primary account number.
	// This value enables issuers to distinguish among multiple cards that are linked to the same account. This value
	// can also act as a tracking tool when reissuing cards. When this value is available, it is provided by the chip
	// reader. When the chip reader does not provide this value, do not include this field in your request.
	//
	// For details, see `emv_request_card_sequence_number` field description in the [Card-Present Processing Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/Retail_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 3
	CardSequenceNumber string `json:"cardSequenceNumber,omitempty"`

	// Method that was used to verify the cardholder's identity.
	//
	// Possible values:
	//  - **0**: No verification
	//  - **1**: Signature
	//
	// This field is supported only on **American Express Direct**.
	//
	CardholderVerificationMethodUsed int64 `json:"cardholderVerificationMethodUsed,omitempty"`

	// Indicates whether a fallback method was used to enter credit card information into the POS terminal. When a
	// technical problem prevents a successful exchange of information between a chip card and a chip-capable terminal:
	//
	//  1. Swipe the card or key the credit card information into the POS terminal.
	//  2. Use the pointOfSaleInformation.entryMode field to indicate whether the information was swiped or keyed.
	//
	// Possible values:
	//  - **true**
	//  - **false** (default)
	//
	// This field is supported only on **Chase Paymentech Solutions** and **GPN**.
	//
	// Max Length: 5
	Fallback *bool `json:"fallback,omitempty"`

	// Reason for the EMV fallback transaction. An EMV fallback transaction occurs when an EMV transaction fails for
	// one of these reasons:
	//
	//  - Technical failure: the EMV terminal or EMV card cannot read and process chip data.
	//  - Empty candidate list failure: the EMV terminal does not have any applications in common with the EMV card.
	//    EMV terminals are coded to determine whether the terminal and EMV card have any applications in common.
	//    EMV terminals provide this information to you.
	//
	// Possible values:
	//
	//  - **1**: Transaction was initiated with information from a magnetic stripe, and the previous transaction at the
	//       EMV terminal either used information from a successful chip read or it was not a chip transaction.
	//  - **2**: Transaction was initiated with information from a magnetic stripe, and the previous transaction at the
	//       EMV terminal was an EMV fallback transaction because the attempted chip read was unsuccessful.
	//
	// This field is supported only on **GPN**.
	//
	// **NOTE**: This field is required when an EMV transaction fails for a technical reason. Do not include this field when the EMV terminal does not have any applications in common with the EMV card.
	//
	// For details, see the `emv_request_fallback_condition` field description in the [Card-Present Processing Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/Retail_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	FallbackCondition int64 `json:"fallbackCondition,omitempty"`

	// EMV data that is transmitted from the chip card to the issuer, and from the issuer to the chip card. The EMV
	// data is in the tag-length-value format and includes chip card tags, terminal tags, and transaction detail tags.
	//
	// For details, see the `emv_request_combined_tags` field description in [Card-Present Processing Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/Retail_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// **Note** The information about EMV applies to credit card processing and PIN debit
	// processing. All other information in this guide applies only to credit card processing. PIN debit
	// processing is available only on FDC Nashville Global.
	//
	// **Note** For information about the individual tags, see the Application Specification section in the EMV 4.3 Specifications: http://emvco.com
	//
	// **Important** The following tags contain sensitive information and **must not** be included in this field:
	//
	//  - **56**: Track 1 equivalent data
	//  - **57**: Track 2 equivalent data
	//  - **5A**: Application PAN
	//  - **5F20**: Cardholder name
	//  - **5F24**: Application expiration date (This sensitivity has been relaxed for cmcic, amexdirect, fdiglobal, opdfde, and six)
	//  - **99**: Transaction PIN
	//  - **9F0B**: Cardholder name (extended)
	//  - **9F1F**: Track 1 discretionary data
	//  - **9F20**: Track 2 discretionary data
	//
	// For captures, this field is required for contact EMV transactions. Otherwise, it is optional.
	//
	// For credits, this field is required for contact EMV stand-alone credits and contactless EMV stand-alone credits.
	// Otherwise, it is optional.
	//
	// **Important** For contact EMV captures, contact EMV stand-alone credits, and contactless EMV stand-alone credits,
	// you must include the following tags in this field. For all other types of EMV transactions, the following tags
	// are optional.
	//
	//  - **95**: Terminal verification results
	//  - **9F10**: Issuer application data
	//  - **9F26**: Application cryptogram
	//
	// Max Length: 1998
	Tags string `json:"tags,omitempty"`
}

// Validate validates this create payment params body point of sale information emv
func (o *CreatePaymentParamsBodyPointOfSaleInformationEmv) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCardSequenceNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFallback(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTags(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyPointOfSaleInformationEmv) validateCardSequenceNumber(formats strfmt.Registry) error {

	if swag.IsZero(o.CardSequenceNumber) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"pointOfSaleInformation"+"."+"emv"+"."+"cardSequenceNumber", "body", string(o.CardSequenceNumber), 3); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPointOfSaleInformationEmv) validateFallback(formats strfmt.Registry) error {

	if swag.IsZero(o.Fallback) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"pointOfSaleInformation"+"."+"emv"+"."+"fallback", "body", string(*o.Fallback), 5); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyPointOfSaleInformationEmv) validateTags(formats strfmt.Registry) error {

	if swag.IsZero(o.Tags) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"pointOfSaleInformation"+"."+"emv"+"."+"tags", "body", string(o.Tags), 1998); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyPointOfSaleInformationEmv) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyPointOfSaleInformationEmv) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyPointOfSaleInformationEmv
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyProcessingInformation create payment params body processing information
swagger:model CreatePaymentParamsBodyProcessingInformation
*/
type CreatePaymentParamsBodyProcessingInformation struct {

	// authorization options
	AuthorizationOptions *CreatePaymentParamsBodyProcessingInformationAuthorizationOptions `json:"authorizationOptions,omitempty"`

	// bank transfer options
	BankTransferOptions *CreatePaymentParamsBodyProcessingInformationBankTransferOptions `json:"bankTransferOptions,omitempty"`

	// Payouts transaction type.
	// Required for OCT transactions.
	// This field is a pass-through, which means that CyberSource does not verify the value or
	// modify it in any way before sending it to the processor.
	// **Note** When the request includes this field, this value overrides the information in your CyberSource account.
	//
	// For valid values, see the `invoiceHeader_businessApplicationID` field description in [Payouts Using the Simple Order API.](http://apps.cybersource.com/library/documentation/dev_guides/payouts_SO/Payouts_SO_API.pdf)
	//
	BusinessApplicationID string `json:"businessApplicationId,omitempty"`

	// Flag that specifies whether to also include capture service in the submitted request or not.
	//
	// Possible values:
	// - **true**
	// - **false** (default).
	//
	Capture *bool `json:"capture,omitempty"`

	// capture options
	CaptureOptions *CreatePaymentParamsBodyProcessingInformationCaptureOptions `json:"captureOptions,omitempty"`

	// Type of transaction. Some payment card companies use this information when determining discount rates. When you
	// omit this field for **Ingenico ePayments**, the processor uses the default transaction type they have on file
	// for you instead of the default value listed here.
	//
	// Max Length: 20
	CommerceIndicator string `json:"commerceIndicator,omitempty"`

	// Flag that indicates that the transaction includes airline data or restaurant data.
	//
	// This field must be set to `airline` in order for airline data to be sent to the processor.
	//
	// For example, if this field is not set to airline or is not included in the request, CyberSource does not send airline data to the processor.
	//
	// You must set this field to `restaurant` in order for restaurant data to be sent to the processor.
	//
	// When this field is not set to restaurant or is not included in the request, CyberSource does not send restaurant data to the processor.
	//
	// Possible Values:
	//
	// - **airline**
	// - **restaurant**
	//
	// Max Length: 10
	IndustryDataType string `json:"industryDataType,omitempty"`

	// Value that links the current authorization request to the original authorization request. Set this value
	// to the ID that was returned in the reply message from the original authorization request.
	//
	// This value is used for:
	//
	// - Partial authorizations
	// - Split shipments
	//
	// For details, see `link_to_request` field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 26
	LinkID string `json:"linkId,omitempty"`

	// Type of digital payment solution for the transaction. Possible Values:
	//
	//  - `visacheckout`: Visa Checkout. This value is required for Visa Checkout transactions. For details, see `payment_solution` field description in [Visa Checkout Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/VCO_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//  - `001`: Apple Pay.
	//  - `004`: Cybersource In-App Solution.
	//  - `005`: Masterpass. This value is required for Masterpass transactions on OmniPay Direct. For details, see "Masterpass" in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//  - `006`: Android Pay.
	//  - `007`: Chase Pay.
	//  - `008`: Samsung Pay.
	//  - `012`: Google Pay.
	//
	// Max Length: 12
	PaymentSolution string `json:"paymentSolution,omitempty"`

	// Value that identifies the processor/acquirer to use for the transaction. This value is supported only for
	// **CyberSource through VisaNet**.
	//
	// Contact CyberSource Customer Support to get the value for this field.
	//
	// Max Length: 3
	ProcessorID string `json:"processorId,omitempty"`

	// Set this field to 3 to indicate that the request includes Level III data.
	// Max Length: 1
	PurchaseLevel string `json:"purchaseLevel,omitempty"`

	// Please check with Cybersource customer support to see if your merchant account is configured correctly so you
	// can include this field in your request.
	// * For Payouts: max length for FDCCompass is String (22).
	//
	// Max Length: 60
	ReconciliationID string `json:"reconciliationId,omitempty"`

	// recurring options
	RecurringOptions *CreatePaymentParamsBodyProcessingInformationRecurringOptions `json:"recurringOptions,omitempty"`

	// Attribute that lets you define custom grouping for your processor reports. This field is supported only for **Worldpay VAP**.
	//
	// For details, see `report_group` field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 25
	ReportGroup string `json:"reportGroup,omitempty"`

	// Identifier for the **Visa Checkout** order. Visa Checkout provides a unique order ID for every transaction in
	// the Visa Checkout **callID** field.
	//
	// For details, see the `vc_order_id` field description in [Visa Checkout Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/VCO_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 48
	VisaCheckoutID string `json:"visaCheckoutId,omitempty"`
}

// Validate validates this create payment params body processing information
func (o *CreatePaymentParamsBodyProcessingInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAuthorizationOptions(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateBankTransferOptions(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCaptureOptions(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCommerceIndicator(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateIndustryDataType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLinkID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePaymentSolution(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProcessorID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePurchaseLevel(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateReconciliationID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateRecurringOptions(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateReportGroup(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateVisaCheckoutID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformation) validateAuthorizationOptions(formats strfmt.Registry) error {

	if swag.IsZero(o.AuthorizationOptions) { // not required
		return nil
	}

	if o.AuthorizationOptions != nil {
		if err := o.AuthorizationOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "processingInformation" + "." + "authorizationOptions")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformation) validateBankTransferOptions(formats strfmt.Registry) error {

	if swag.IsZero(o.BankTransferOptions) { // not required
		return nil
	}

	if o.BankTransferOptions != nil {
		if err := o.BankTransferOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "processingInformation" + "." + "bankTransferOptions")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformation) validateCaptureOptions(formats strfmt.Registry) error {

	if swag.IsZero(o.CaptureOptions) { // not required
		return nil
	}

	if o.CaptureOptions != nil {
		if err := o.CaptureOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "processingInformation" + "." + "captureOptions")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformation) validateCommerceIndicator(formats strfmt.Registry) error {

	if swag.IsZero(o.CommerceIndicator) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"processingInformation"+"."+"commerceIndicator", "body", string(o.CommerceIndicator), 20); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformation) validateIndustryDataType(formats strfmt.Registry) error {

	if swag.IsZero(o.IndustryDataType) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"processingInformation"+"."+"industryDataType", "body", string(o.IndustryDataType), 10); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformation) validateLinkID(formats strfmt.Registry) error {

	if swag.IsZero(o.LinkID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"processingInformation"+"."+"linkId", "body", string(o.LinkID), 26); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformation) validatePaymentSolution(formats strfmt.Registry) error {

	if swag.IsZero(o.PaymentSolution) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"processingInformation"+"."+"paymentSolution", "body", string(o.PaymentSolution), 12); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformation) validateProcessorID(formats strfmt.Registry) error {

	if swag.IsZero(o.ProcessorID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"processingInformation"+"."+"processorId", "body", string(o.ProcessorID), 3); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformation) validatePurchaseLevel(formats strfmt.Registry) error {

	if swag.IsZero(o.PurchaseLevel) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"processingInformation"+"."+"purchaseLevel", "body", string(o.PurchaseLevel), 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformation) validateReconciliationID(formats strfmt.Registry) error {

	if swag.IsZero(o.ReconciliationID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"processingInformation"+"."+"reconciliationId", "body", string(o.ReconciliationID), 60); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformation) validateRecurringOptions(formats strfmt.Registry) error {

	if swag.IsZero(o.RecurringOptions) { // not required
		return nil
	}

	if o.RecurringOptions != nil {
		if err := o.RecurringOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "processingInformation" + "." + "recurringOptions")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformation) validateReportGroup(formats strfmt.Registry) error {

	if swag.IsZero(o.ReportGroup) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"processingInformation"+"."+"reportGroup", "body", string(o.ReportGroup), 25); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformation) validateVisaCheckoutID(formats strfmt.Registry) error {

	if swag.IsZero(o.VisaCheckoutID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"processingInformation"+"."+"visaCheckoutId", "body", string(o.VisaCheckoutID), 48); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyProcessingInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyProcessingInformation) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyProcessingInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyProcessingInformationAuthorizationOptions create payment params body processing information authorization options
swagger:model CreatePaymentParamsBodyProcessingInformationAuthorizationOptions
*/
type CreatePaymentParamsBodyProcessingInformationAuthorizationOptions struct {

	// Flag that specifies the purpose of the authorization.
	//
	// Possible values:
	//  - **0**: Preauthorization
	//  - **1**: Final authorization
	//
	// To set the default for this field, contact CyberSource Customer Support.
	// For details, see "Final Authorization Indicator" in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm).
	//
	// #### Barclays and Elavon
	// The default for Barclays and Elavon is 1 (final authorization). To change the default for this field, contact CyberSource Customer Support.
	//
	// #### CyberSource through VisaNet
	// When the value for this field is 0, it corresponds to the following data in the TC 33 capture file5:
	//  - Record: CP01 TCR0
	//  - Position: 164
	//  - Field: Additional Authorization Indicators
	// When the value for this field is 1, it does not correspond to any data in the TC 33 capture file.
	//
	// For processor-specific information, see the `auth_indicator` field in
	// [Credit Card Services Using the SCMP API](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html).
	//
	// Max Length: 1
	AuthIndicator string `json:"authIndicator,omitempty"`

	// Authorization type. Possible values:
	//
	//  - `AUTOCAPTURE`: automatic capture.
	//  - `STANDARDCAPTURE`: standard capture.
	//  - `VERBAL`: forced capture. Include it in the payment request for a forced capture. Include it in the capture request for a verbal payment.
	//
	// #### Asia, Middle East, and Africa Gateway; Cielo; Comercio Latino; and CyberSource Latin American Processing
	// Set this field to `AUTOCAPTURE` and include it in a bundled request to indicate that you are requesting an automatic capture. If your account is configured to enable automatic captures, set this field to `STANDARDCAPTURE` and include it in a standard authorization or bundled request to indicate that you are overriding an automatic capture. For more information, see the `auth_type` field description in [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// #### Forced Capture
	// Set this field to `VERBAL` and include it in the authorization request to indicate that you are performing a forced capture; therefore, you receive the authorization code outside the CyberSource system.
	//
	// For more information, see "Forced Captures" in [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm).
	//
	// #### Verbal Authorization
	// Set this field to `VERBAL` and include it in the capture request to indicate that the request is for a verbal authorization. For more information, see "Verbal Authorizations" in [Credit Card Services Using the SCMP API](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html).
	//
	// For processor-specific information, see the `auth_type` field in [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// Max Length: 15
	AuthType string `json:"authType,omitempty"`

	// Flag that indicates whether to return balance information.
	//
	// Possible values:
	// - **true**
	// - **false**
	//
	BalanceInquiry bool `json:"balanceInquiry,omitempty"`

	// Flag that indicates that this is a payment for a bill or for an existing contractual loan.
	// For processor-specific details, see the `bill_payment` field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Possible values:
	// - `true`: Bill payment or loan payment.
	// - `false` (default): Not a bill payment or loan payment.
	//
	BillPayment bool `json:"billPayment,omitempty"`

	// Reason for the payment.
	//
	// Possible values:
	// - 001: Utility payment
	// - 002: Government services
	// - 003: Mobile phone top-up
	// - 004: Coupon payment
	//
	// The value for this field corresponds to the following data in the TC 33 capture file5:
	// - Record: CP07 TCR0
	// - Position: 48-50
	// - Field: Bill Payment Transaction Type Identifier
	//
	// This field is supported only for bill payments in Brazil with Mastercard on CyberSource through VisaNet.
	//
	// **Note** For details about Mastercard bill payments or bill payments with Visa, see `bill_payment_type` field description in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	BillPaymentType string `json:"billPaymentType,omitempty"`

	// Comma-separated list of AVS flags that cause the reply flag `DAVSNO` to be returned.
	//
	// **Important** To receive declines for the AVS code `N`, you must include the value `N` in the comma-separated
	// list.
	//
	// ### AVS Codes for Cielo 3.0 and CyberSource Latin American Processing
	//
	// **Note** CyberSource Latin American Processing is the name of a specific processing connection that CyberSource supports. In the CyberSource API documentation, CyberSource Latin American Processing does not refer to the general topic of processing in Latin America. The information in this section is for the specific processing connection called CyberSource Latin American Processing. It is not for any other Latin American processors that CyberSource supports.
	//
	// |AVS Code|Description|
	// |--- |--- |
	// |D|Partial match: postal code and address match.|
	// |E|Not supported: AVS is not supported for this card type. _or_ Invalid: the acquirer returned an unrecognized value for the AVS response.|
	// |F|Partial match: postal code matches, but CPF and address do not match.*|
	// |G|Not supported: AVS not supported or not verified.|
	// |I|No match: AVS information is not available.|
	// |K|Partial match: CPF matches, but postal code and address do not match.*|
	// |L|Partial match: postal code and CPF match, but address does not match.*|
	// |N|No match: postal code, CPF, and address do not match.*|
	// |O|Partial match: CPF and address match, but postal code does not match.*|
	// |R|Not supported: your implementation does not support AVS _or_ System unavailable.|
	// |T|Partial match: address matches, but postal code and CPF do not match.*|
	// |V|Match: postal code, CPF, and address match.*|
	// |* CPF (Cadastro de Pessoas Fisicas) is required only for Redecard in Brazil.||
	//
	// ### AVS Codes for All Other Processors
	//
	// **Note** The list of AVS codes for all other processors follows these descriptions of the processor-specific information for these codes.
	//
	// #### American Express Cards
	// For American Express cards only, you can receive Visa and CyberSource
	// AVS codes in addition to the American Express AVS codes.
	//
	// **Note** For CyberSource through VisaNet, the American Express AVS codes are converted to Visa
	// AVS codes before they are returned to you. As a result, you will not receive American Express AVS codes for
	// the American Express card type.<br/><br/>
	//
	// _American Express Card codes_: `F`, `H`, `K`, `L`, `O`, `T`, `V`
	//
	// #### Domestic and International Visa Cards
	// The international and domestic alphabetic AVS codes are the Visa standard AVS codes. CyberSource maps
	// the standard AVS return codes for other types of payment cards, including American Express cards, to
	// the Visa standard AVS codes.
	//
	// AVS is considered either domestic or international, depending on the location of the bank that issued the
	// customer's payment card:
	// - When the bank is in the U.S., the AVS is domestic.
	// - When the bank is outside the U.S., the AVS is international.
	//
	// You should be prepared to handle both domestic and international AVS result codes:
	// - For international cards, you can receive domestic AVS codes in addition to the international AVS codes.
	// - For domestic cards, you can receive international AVS codes in addition to the domestic AVS codes.
	//
	// _International Visa Codes_: `B`, `C`, `D`, `G`, `I`, `M`, `P`
	//
	// _Domestic Visa Codes_: `A`, `E`,`N`, `R`, `S`, `U`, `W`, `X`, `Y`, `Z`
	//
	// #### CyberSource Codes
	// The numeric AVS codes are created by CyberSource
	// and are not standard Visa codes. These AVS codes
	// can be returned for any card type.
	//
	// _CyberSource Codes_: `1`, `2`, `3`, `4`
	//
	// ### Table of AVS Codes for All Other Processors
	//
	// |AVS Code|Description|
	// |--- |--- |
	// |A|Partial match: street address matches, but 5-digit and 9-digit postal codes do not match.|
	// |B|Partial match: street address matches, but postal code is not verified. Returned only for Visa cards not issued in the U.S.|
	// |C|No match: street address and postal code do not match. Returned only for Visa cards not issued in the U.S.|
	// |D & M|Match: street address and postal code match. Returned only for Visa cards not issued in the U.S.|
	// |E|Invalid: AVS data is invalid or AVS is not allowed for this card type.|
	// |F|Partial match: card members name does not match, but billing postal code matches.|
	// |G|Not supported: issuing bank outside the U.S. does not support AVS.|
	// |H|Partial match: card members name does not match, but street address and postal code match. Returned only for the American Express card type.|
	// |I|No match: address not verified. Returned only for Visa cards not issued in the U.S.|
	// |K|Partial match: card members name matches, but billing address and billing postal code do not match. Returned only for the American Express card type.|
	// |L|Partial match: card members name and billing postal code match, but billing address does not match. Returned only for the American Express card type.|
	// |M|See the entry for D & M.|
	// |N|No match: one of the following: street address and postal code do not match _or_ (American Express card type only) card members name, street address, and postal code do not match.|
	// |O|Partial match: card members name and billing address match, but billing postal code does not match. Returned only for the American Express card type.|
	// |P|Partial match: postal code matches, but street address not verified. Returned only for Visa cards not issued in the U.S.|
	// |R|System unavailable.|
	// |S|Not supported: issuing bank in the U.S. does not support AVS.|
	// |T|Partial match: card members name does not match, but street address matches. Returned only for the American Express card type.|
	// |U|System unavailable: address information unavailable for one of these reasons: The U.S. bank does not support AVS outside the U.S. _or_ The AVS in a U.S. bank is not functioning properly.|
	// |V|Match: card members name, billing address, and billing postal code match. Returned only for the American Express card type.|
	// |W|Partial match: street address does not match, but 9-digit postal code matches.|
	// |X|Match: street address and 9-digit postal code match.|
	// |Y|Match: street address and 5-digit postal code match.|
	// |Z|Partial match: street address does not match, but 5-digit postal code matches.|
	// |1|Not supported: one of the following: AVS is not supported for this processor or card type _or_ AVS is disabled for your CyberSource account. To enable AVS, contact CyberSource Customer Support.|
	// |2|Unrecognized: the processor returned an unrecognized value for the AVS response.|
	// |3|Match: address is confirmed. Returned only for PayPal Express Checkout.|
	// |4|No match: address is not confirmed. Returned only for PayPal Express Checkout.|
	// |5|No match: no AVS code was returned by the processor.|
	//
	DeclineAvsFlags []string `json:"declineAvsFlags"`

	// Flag that indicates whether to allow the capture service to run, even when the payment
	// receives an AVS decline.
	//
	// Possible values:
	// - **true**  Ignore the results of AVS checking and run the capture service.
	// - **false**  (default): If the authorization receives an AVS decline, do not run the capture service.
	//
	IgnoreAvsResult *bool `json:"ignoreAvsResult,omitempty"`

	// Flag that indicates whether to allow the capture service to run even when
	// the payment receives a CVN decline.
	//
	// Possible values:
	// - **true**  Ignore the results of CVN checking and run the capture service.
	// - **false**  (default) If the authorization receives a CVN decline, do not run the capture service.
	//
	IgnoreCvResult *bool `json:"ignoreCvResult,omitempty"`

	// initiator
	Initiator *CreatePaymentParamsBodyProcessingInformationAuthorizationOptionsInitiator `json:"initiator,omitempty"`

	// Flag that indicates whether the transaction is enabled for partial authorization or not. When your request
	// includes this field, this value overrides the information in your CyberSource account.  For processor-specific
	// information, see the `auth_partial_auth_indicator` field in [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// #### CyberSource through VisaNet
	// To set the default for this field, contact CyberSource Customer Support.
	// The value for this field corresponds to the following data in the TC 33 capture file5:
	// - Record: CP01 TCR0
	// - Position: 164
	// - Field: Additional Authorization Indicators
	//
	// Possible values:
	// - **true** Enable the transaction for partial authorization.
	// - **false** Do not enable the transaction for partial authorization.
	//
	PartialAuthIndicator bool `json:"partialAuthIndicator,omitempty"`

	// Authorization code.
	//
	// #### Forced Capture
	// Use this field to send the authorization code you received from a payment that you authorized
	// outside the CyberSource system.
	//
	// #### Verbal Authorization
	// Use this field in CAPTURE API to send the verbally received authorization code.
	//
	// For processor-specific information, see the `auth_code` field description in [Credit Card Services Using the SCMP API](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html).
	//
	// Max Length: 7
	VerbalAuthCode string `json:"verbalAuthCode,omitempty"`

	// Transaction ID (TID).
	//
	// #### FDMS South
	// This field is required for verbal authorizations
	// and forced captures with the American
	// Express card type to comply with the CAPN
	// requirements:
	// - Forced capture: Obtain the value for this
	// field from the authorization response.
	// - Verbal authorization: You cannot obtain a
	// value for this field so CyberSource uses the
	// default value of `000000000000000` (15
	// zeros).
	//
	// For more information about using this default value, see "Verbal Authorizations" in [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 15
	VerbalAuthTransactionID string `json:"verbalAuthTransactionId,omitempty"`
}

// Validate validates this create payment params body processing information authorization options
func (o *CreatePaymentParamsBodyProcessingInformationAuthorizationOptions) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAuthIndicator(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAuthType(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateInitiator(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateVerbalAuthCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateVerbalAuthTransactionID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformationAuthorizationOptions) validateAuthIndicator(formats strfmt.Registry) error {

	if swag.IsZero(o.AuthIndicator) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"processingInformation"+"."+"authorizationOptions"+"."+"authIndicator", "body", string(o.AuthIndicator), 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformationAuthorizationOptions) validateAuthType(formats strfmt.Registry) error {

	if swag.IsZero(o.AuthType) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"processingInformation"+"."+"authorizationOptions"+"."+"authType", "body", string(o.AuthType), 15); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformationAuthorizationOptions) validateInitiator(formats strfmt.Registry) error {

	if swag.IsZero(o.Initiator) { // not required
		return nil
	}

	if o.Initiator != nil {
		if err := o.Initiator.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator")
			}
			return err
		}
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformationAuthorizationOptions) validateVerbalAuthCode(formats strfmt.Registry) error {

	if swag.IsZero(o.VerbalAuthCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"processingInformation"+"."+"authorizationOptions"+"."+"verbalAuthCode", "body", string(o.VerbalAuthCode), 7); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformationAuthorizationOptions) validateVerbalAuthTransactionID(formats strfmt.Registry) error {

	if swag.IsZero(o.VerbalAuthTransactionID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"processingInformation"+"."+"authorizationOptions"+"."+"verbalAuthTransactionId", "body", string(o.VerbalAuthTransactionID), 15); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyProcessingInformationAuthorizationOptions) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyProcessingInformationAuthorizationOptions) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyProcessingInformationAuthorizationOptions
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyProcessingInformationAuthorizationOptionsInitiator create payment params body processing information authorization options initiator
swagger:model CreatePaymentParamsBodyProcessingInformationAuthorizationOptionsInitiator
*/
type CreatePaymentParamsBodyProcessingInformationAuthorizationOptionsInitiator struct {

	// Indicates to the issuing bank two things:
	// - The merchant has received consent from the cardholder to store their card details on file
	// - The merchant wants the issuing bank to check out the card details before the merchant initiates their first transaction for this cardholder.
	// The purpose of the merchant-initiated transaction is to ensure that the cardholders credentials are valid (that the card is not stolen or has restrictions) and that the card details are good to be stored on the merchants file for future transactions.
	//
	// Valid values:
	// - `true` means merchant will use this transaction to store payment credentials for follow-up merchant-initiated transactions.
	// - `false` means merchant will not use this transaction to store payment credentials for follow-up merchant-initiated transactions.
	//
	// For details, see `subsequent_auth_first` field description in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// **NOTE:** The value for this field does not correspond to any data in the TC 33 capture file5.
	//
	// This field is supported only for Visa transactions on CyberSource through VisaNet.
	//
	CredentialStoredOnFile bool `json:"credentialStoredOnFile,omitempty"`

	// merchant initiated transaction
	MerchantInitiatedTransaction *CreatePaymentParamsBodyProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction `json:"merchantInitiatedTransaction,omitempty"`

	// Indicates to an issuing bank whether a merchant-initiated transaction came from a card that was already stored on file.
	//
	// Possible values:
	// - **true** means the merchant-initiated transaction came from a card that was already stored on file.
	// - **false**  means the merchant-initiated transaction came from a card that was not stored on file.
	//
	StoredCredentialUsed bool `json:"storedCredentialUsed,omitempty"`

	// This field indicates whether the transaction is a merchant-initiated transaction or customer-initiated transaction.
	//
	// Valid values:
	// - **customer**
	// - **merchant**
	//
	Type string `json:"type,omitempty"`
}

// Validate validates this create payment params body processing information authorization options initiator
func (o *CreatePaymentParamsBodyProcessingInformationAuthorizationOptionsInitiator) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateMerchantInitiatedTransaction(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformationAuthorizationOptionsInitiator) validateMerchantInitiatedTransaction(formats strfmt.Registry) error {

	if swag.IsZero(o.MerchantInitiatedTransaction) { // not required
		return nil
	}

	if o.MerchantInitiatedTransaction != nil {
		if err := o.MerchantInitiatedTransaction.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("createPaymentRequest" + "." + "processingInformation" + "." + "authorizationOptions" + "." + "initiator" + "." + "merchantInitiatedTransaction")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyProcessingInformationAuthorizationOptionsInitiator) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyProcessingInformationAuthorizationOptionsInitiator) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyProcessingInformationAuthorizationOptionsInitiator
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction create payment params body processing information authorization options initiator merchant initiated transaction
swagger:model CreatePaymentParamsBodyProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction
*/
type CreatePaymentParamsBodyProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction struct {

	// Amount of the original authorization.
	//
	// This field is supported only for Apple Pay, Google Pay, and Samsung Pay transactions with Discover on FDC Nashville Global and Chase Paymentech.
	//
	// See "Recurring Payments," and "Subsequent Authorizations," field description in the [Payment Network Tokenization
	// Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/tokenization_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 61
	OriginalAuthorizedAmount string `json:"originalAuthorizedAmount,omitempty"`

	// Network transaction identifier that was returned in the payment response field _processorInformation.transactionID_
	// in the reply message for either the original merchant-initiated payment in the series or the previous
	// merchant-initiated payment in the series.
	//
	// If the current payment request includes a token instead of an account number, the following time limits apply for the value of this field:
	// - For a **resubmission**, the transaction ID must be less than 14 days old.
	// - For a **delayed charge** or **reauthorization**, the transaction ID must be less than 30 days old.
	//
	// **NOTE**: The value for this field does not correspond to any data in the TC 33 capture file5. This field is supported
	// only for Visa transactions on CyberSource through VisaNet.
	//
	// Max Length: 15
	PreviousTransactionID string `json:"previousTransactionId,omitempty"`

	// Reason for the merchant-initiated transaction or incremental authorization. Possible values:
	// - `1`: Resubmission
	// - `2`: Delayed charge
	// - `3`: Reauthorization for split shipment
	// - `4`: No show
	// - `5`: Account top up
	// This field is required only for the five kinds of transactions in the preceding list.
	// This field is supported only for merchant-initiated transactions and incremental authorizations.
	//
	// #### CyberSource through VisaNet
	// The value for this field corresponds to the following data in the TC 33 capture file5:
	// - Record: CP01 TCR0
	// - Position: 160-163
	// - Field: Message Reason Code
	//
	// #### All Processors
	// For details, see `subsequent_auth_reason` field description in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 1
	Reason string `json:"reason,omitempty"`
}

// Validate validates this create payment params body processing information authorization options initiator merchant initiated transaction
func (o *CreatePaymentParamsBodyProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateOriginalAuthorizedAmount(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePreviousTransactionID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateReason(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction) validateOriginalAuthorizedAmount(formats strfmt.Registry) error {

	if swag.IsZero(o.OriginalAuthorizedAmount) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"processingInformation"+"."+"authorizationOptions"+"."+"initiator"+"."+"merchantInitiatedTransaction"+"."+"originalAuthorizedAmount", "body", string(o.OriginalAuthorizedAmount), 61); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction) validatePreviousTransactionID(formats strfmt.Registry) error {

	if swag.IsZero(o.PreviousTransactionID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"processingInformation"+"."+"authorizationOptions"+"."+"initiator"+"."+"merchantInitiatedTransaction"+"."+"previousTransactionId", "body", string(o.PreviousTransactionID), 15); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction) validateReason(formats strfmt.Registry) error {

	if swag.IsZero(o.Reason) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"processingInformation"+"."+"authorizationOptions"+"."+"initiator"+"."+"merchantInitiatedTransaction"+"."+"reason", "body", string(o.Reason), 1); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyProcessingInformationBankTransferOptions create payment params body processing information bank transfer options
swagger:model CreatePaymentParamsBodyProcessingInformationBankTransferOptions
*/
type CreatePaymentParamsBodyProcessingInformationBankTransferOptions struct {

	// Payment related information.
	//
	// This information is included on the customers statement.
	//
	// Max Length: 80
	CustomerMemo string `json:"customerMemo,omitempty"`

	// Space-separated list of AVS flags that cause the request to be declined for AVS reasons.
	//
	// **Important** To receive declines for the AVS code `N`, you must include the value `N` in the space-separated list.
	//
	// ### AVS Codes for Cielo 3.0 and CyberSource Latin American Processing
	//
	// **Note** CyberSource Latin American Processing is the name of a specific processing connection that CyberSource supports. In the CyberSource API documentation, CyberSource Latin American Processing does not refer to the general topic of processing in Latin America. The information in this section is for the specific processing connection called CyberSource Latin American Processing. It is not for any other Latin American processors that CyberSource supports.
	//
	// |AVS Code|Description|
	// |--- |--- |
	// |D|Partial match: postal code and address match.|
	// |E|Not supported: AVS is not supported for this card type. _or_ Invalid: the acquirer returned an unrecognized value for the AVS response.|
	// |F|Partial match: postal code matches, but CPF and address do not match.*|
	// |G|Not supported: AVS not supported or not verified.|
	// |I|No match: AVS information is not available.|
	// |K|Partial match: CPF matches, but postal code and address do not match.*|
	// |L|Partial match: postal code and CPF match, but address does not match.*|
	// |N|No match: postal code, CPF, and address do not match.*|
	// |O|Partial match: CPF and address match, but postal code does not match.*|
	// |R|Not supported: your implementation does not support AVS _or_ System unavailable.|
	// |T|Partial match: address matches, but postal code and CPF do not match.*|
	// |V|Match: postal code, CPF, and address match.*|
	// |* CPF (Cadastro de Pessoas Fisicas) is required only for Redecard in Brazil.||
	//
	// ### AVS Codes for All Other Processors
	//
	// **Note** The list of AVS codes for all other processors follows these descriptions of the processor-specific information for these codes.
	//
	// #### American Express Cards
	// For American Express cards only, you can receive Visa and CyberSource AVS codes in addition to the American Express AVS codes.
	//
	// **Note** For CyberSource through VisaNet, the American Express AVS codes are converted to Visa AVS codes before they are returned to you. As a result, you will not receive American Express AVS codes for the American Express card type.
	//
	// _American Express Card codes_: `F`, `H`, `K`, `L`, `O`, `T`, `V`
	//
	// #### Domestic and International Visa Cards
	// The international and domestic alphabetic AVS codes are the Visa standard AVS codes. CyberSource maps the standard AVS return codes for other types of payment cards, including American Express cards, to the Visa standard AVS codes.
	//
	// AVS is considered either domestic or international, depending on the location of the bank that issued the customers payment card:
	// - When the bank is in the U.S., the AVS is domestic.
	// - When the bank is outside the U.S., the AVS is international.
	//
	// You should be prepared to handle both domestic and international AVS result codes:
	// - For international cards, you can receive domestic AVS codes in addition to the international AVS codes.
	// - For domestic cards, you can receive international AVS codes in addition to the domestic AVS codes.
	//
	// _International Visa Codes_: `B`, `C`, `D`, `G`, `I`, `M`, `P`
	//
	// _Domestic Visa Codes_: `A`, `E`,`N`, `R`, `S`, `U`, `W`, `X`, `Y`, `Z`
	//
	// #### CyberSource Codes
	// The numeric AVS codes are created by CyberSource and are not standard Visa codes. These AVS codes can be returned for any card type.
	//
	// _CyberSource Codes_: `1`, `2`, `3`, `4`
	//
	// ### Table of AVS Codes for All Other Processors
	//
	// |AVS Code|Description|
	// |--- |--- |
	// |A|Partial match: street address matches, but 5-digit and 9-digit postal codes do not match.|
	// |B|Partial match: street address matches, but postal code is not verified. Returned only for Visa cards not issued in the U.S.|
	// |C|No match: street address and postal code do not match. Returned only for Visa cards not issued in the U.S.|
	// |D & M|Match: street address and postal code match. Returned only for Visa cards not issued in the U.S.|
	// |E|Invalid: AVS data is invalid or AVS is not allowed for this card type.|
	// |F|Partial match: card members name does not match, but billing postal code matches.|
	// |G|Not supported: issuing bank outside the U.S. does not support AVS.|
	// |H|Partial match: card members name does not match, but street address and postal code match. Returned only for the American Express card type.|
	// |I|No match: address not verified. Returned only for Visa cards not issued in the U.S.|
	// |K|Partial match: card members name matches, but billing address and billing postal code do not match. Returned only for the American Express card type.|
	// |L|Partial match: card members name and billing postal code match, but billing address does not match. Returned only for the American Express card type.|
	// |M|See the entry for D & M.|
	// |N|No match: one of the following: street address and postal code do not match _or_ (American Express card type only) card members name, street address, and postal code do not match.|
	// |O|Partial match: card members name and billing address match, but billing postal code does not match. Returned only for the American Express card type.|
	// |P|Partial match: postal code matches, but street address not verified. Returned only for Visa cards not issued in the U.S.|
	// |R|System unavailable.|
	// |S|Not supported: issuing bank in the U.S. does not support AVS.|
	// |T|Partial match: card members name does not match, but street address matches. Returned only for the American Express card type.|
	// |U|System unavailable: address information unavailable for one of these reasons: The U.S. bank does not support AVS outside the U.S. _or_ The AVS in a U.S. bank is not functioning properly.|
	// |V|Match: card members name, billing address, and billing postal code match. Returned only for the American Express card type.|
	// |W|Partial match: street address does not match, but 9-digit postal code matches.|
	// |X|Match: street address and 9-digit postal code match.|
	// |Y|Match: street address and 5-digit postal code match.|
	// |Z|Partial match: street address does not match, but 5-digit postal code matches.|
	// |1|Not supported: one of the following: AVS is not supported for this processor or card type _or_ AVS is disabled for your CyberSource account. To enable AVS, contact CyberSource Customer Support.|
	// |2|Unrecognized: the processor returned an unrecognized value for the AVS response.|
	// |3|Match: address is confirmed. Returned only for PayPal Express Checkout.|
	// |4|No match: address is not confirmed. Returned only for PayPal Express Checkout.|
	// |5|No match: no AVS code was returned by the processor.|
	//
	// Max Length: 15
	DeclineAvsFlags string `json:"declineAvsFlags,omitempty"`

	// Effective date for the transaction. The effective date must be within 45 days of the current day. If you do not
	// include this value, CyberSource sets the effective date to the next business day.
	//
	// Format: `MMDDYYYY`
	//
	// Supported only for the CyberSource ACH Service.
	//
	// Max Length: 8
	EffectiveDate string `json:"effectiveDate,omitempty"`

	// Level of fraud screening.
	//
	// Possible values:
	// - `1`: Validation  default if the field has not already been configured for your merchant ID
	// - `2`: Verification
	//
	// For a description of this feature and a list of supported processors, see "Verification and Validation" in the [Electronic Check Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/EChecks_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm).
	//
	// Max Length: 1
	FraudScreeningLevel string `json:"fraudScreeningLevel,omitempty"`

	// Identifier for a partial payment or partial credit.
	//
	// The value for each debit request or credit request must be unique within the scope of the order.
	// For details, see `partial_payment_id` field description in the [Electronic Check Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/EChecks_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 25
	PartialPaymentID string `json:"partialPaymentId,omitempty"`

	// Flag that indicates whether to process the payment.
	//
	// Use with deferred payments.
	// For details, see `ecp_payment_mode` field description in the [Electronic Check Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/EChecks_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Possible values:
	// - `0`: Standard debit with immediate payment (default).
	// - `1`: For deferred payments, indicates that this is a deferred payment and that you will send a debit request
	// with `paymentCategoryCode = 2` in the future.
	// - `2`: For deferred payments, indicates notification to initiate payment.
	//
	// #### Chase Paymentech Solutions and TeleCheck
	// Use for deferred and partial payments.
	//
	// #### CyberSource ACH Service
	// Not used.
	//
	// #### RBS WorldPay Atlanta
	// Not used.
	//
	// Max Length: 1
	PaymentCategoryCode string `json:"paymentCategoryCode,omitempty"`

	// Specifies the authorization method for the transaction.
	//
	// #### TeleCheck
	// Accepts only the following values:
	// - `ARC`: account receivable conversion
	// - `CCD`: corporate cash disbursement
	// - `POP`: point of purchase conversion
	// - `PPD`: prearranged payment and deposit entry
	// - `TEL`: telephone-initiated entry
	// - `WEB`: internet-initiated entry
	//
	// For details, see `ecp_sec_code` field description in the [Electronic Check Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/EChecks_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 3
	SecCode string `json:"secCode,omitempty"`

	// Method used for settlement.
	//
	// Possible values:
	// - `A`: Automated Clearing House (default for credits and for transactions using Canadian dollars)
	// - `F`: Facsimile draft (U.S. dollars only)
	// - `B`: Best possible (U.S. dollars only) (default if the field has not already been configured for your
	// merchant ID)
	//
	// For details, see `ecp_settlement_method` field description for credit cars and `ecp_debit_settlement_method` for debit cards in the [Electronic Check Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/EChecks_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 1
	SettlementMethod string `json:"settlementMethod,omitempty"`

	// City in which the terminal is located. If more than four alphanumeric characters are submitted, the transaction
	// will be declined.
	//
	// You cannot include any special characters.
	//
	// Max Length: 4
	TerminalCity string `json:"terminalCity,omitempty"`

	// State in which the terminal is located. If more than two alphanumeric characters are submitted, the transaction
	// will be declined.
	//
	// You cannot include any special characters.
	//
	// Max Length: 2
	TerminalState string `json:"terminalState,omitempty"`
}

// Validate validates this create payment params body processing information bank transfer options
func (o *CreatePaymentParamsBodyProcessingInformationBankTransferOptions) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCustomerMemo(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDeclineAvsFlags(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEffectiveDate(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFraudScreeningLevel(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePartialPaymentID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePaymentCategoryCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSecCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSettlementMethod(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTerminalCity(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTerminalState(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformationBankTransferOptions) validateCustomerMemo(formats strfmt.Registry) error {

	if swag.IsZero(o.CustomerMemo) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"processingInformation"+"."+"bankTransferOptions"+"."+"customerMemo", "body", string(o.CustomerMemo), 80); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformationBankTransferOptions) validateDeclineAvsFlags(formats strfmt.Registry) error {

	if swag.IsZero(o.DeclineAvsFlags) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"processingInformation"+"."+"bankTransferOptions"+"."+"declineAvsFlags", "body", string(o.DeclineAvsFlags), 15); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformationBankTransferOptions) validateEffectiveDate(formats strfmt.Registry) error {

	if swag.IsZero(o.EffectiveDate) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"processingInformation"+"."+"bankTransferOptions"+"."+"effectiveDate", "body", string(o.EffectiveDate), 8); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformationBankTransferOptions) validateFraudScreeningLevel(formats strfmt.Registry) error {

	if swag.IsZero(o.FraudScreeningLevel) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"processingInformation"+"."+"bankTransferOptions"+"."+"fraudScreeningLevel", "body", string(o.FraudScreeningLevel), 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformationBankTransferOptions) validatePartialPaymentID(formats strfmt.Registry) error {

	if swag.IsZero(o.PartialPaymentID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"processingInformation"+"."+"bankTransferOptions"+"."+"partialPaymentId", "body", string(o.PartialPaymentID), 25); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformationBankTransferOptions) validatePaymentCategoryCode(formats strfmt.Registry) error {

	if swag.IsZero(o.PaymentCategoryCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"processingInformation"+"."+"bankTransferOptions"+"."+"paymentCategoryCode", "body", string(o.PaymentCategoryCode), 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformationBankTransferOptions) validateSecCode(formats strfmt.Registry) error {

	if swag.IsZero(o.SecCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"processingInformation"+"."+"bankTransferOptions"+"."+"secCode", "body", string(o.SecCode), 3); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformationBankTransferOptions) validateSettlementMethod(formats strfmt.Registry) error {

	if swag.IsZero(o.SettlementMethod) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"processingInformation"+"."+"bankTransferOptions"+"."+"settlementMethod", "body", string(o.SettlementMethod), 1); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformationBankTransferOptions) validateTerminalCity(formats strfmt.Registry) error {

	if swag.IsZero(o.TerminalCity) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"processingInformation"+"."+"bankTransferOptions"+"."+"terminalCity", "body", string(o.TerminalCity), 4); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformationBankTransferOptions) validateTerminalState(formats strfmt.Registry) error {

	if swag.IsZero(o.TerminalState) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"processingInformation"+"."+"bankTransferOptions"+"."+"terminalState", "body", string(o.TerminalState), 2); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyProcessingInformationBankTransferOptions) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyProcessingInformationBankTransferOptions) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyProcessingInformationBankTransferOptions
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyProcessingInformationCaptureOptions create payment params body processing information capture options
swagger:model CreatePaymentParamsBodyProcessingInformationCaptureOptions
*/
type CreatePaymentParamsBodyProcessingInformationCaptureOptions struct {

	// Capture number when requesting multiple partial captures for one authorization.
	// Used along with `totalCaptureCount` to track which capture is being processed.
	//
	// For example, the second of five captures would be passed to CyberSource as:
	//   - `captureSequenceNumber_ = 2`, and
	//   - `totalCaptureCount = 5`
	//
	// Maximum: 99
	// Minimum: 1
	CaptureSequenceNumber int64 `json:"captureSequenceNumber,omitempty"`

	// Date on which you want the capture to occur. This field is supported only for CyberSource through VisaNet.\
	// `Format: MMDD`
	//
	// Max Length: 4
	DateToCapture string `json:"dateToCapture,omitempty"`

	// Total number of captures when requesting multiple partial captures for one payment.
	// Used along with `captureSequenceNumber` field to track which capture is being processed.
	//
	// For example, the second of five captures would be passed to CyberSource as:
	//   - `captureSequenceNumber = 2`, and
	//   - `totalCaptureCount = 5`
	//
	// Maximum: 99
	// Minimum: 1
	TotalCaptureCount int64 `json:"totalCaptureCount,omitempty"`
}

// Validate validates this create payment params body processing information capture options
func (o *CreatePaymentParamsBodyProcessingInformationCaptureOptions) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCaptureSequenceNumber(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDateToCapture(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateTotalCaptureCount(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformationCaptureOptions) validateCaptureSequenceNumber(formats strfmt.Registry) error {

	if swag.IsZero(o.CaptureSequenceNumber) { // not required
		return nil
	}

	if err := validate.MinimumInt("createPaymentRequest"+"."+"processingInformation"+"."+"captureOptions"+"."+"captureSequenceNumber", "body", int64(o.CaptureSequenceNumber), 1, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("createPaymentRequest"+"."+"processingInformation"+"."+"captureOptions"+"."+"captureSequenceNumber", "body", int64(o.CaptureSequenceNumber), 99, false); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformationCaptureOptions) validateDateToCapture(formats strfmt.Registry) error {

	if swag.IsZero(o.DateToCapture) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"processingInformation"+"."+"captureOptions"+"."+"dateToCapture", "body", string(o.DateToCapture), 4); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyProcessingInformationCaptureOptions) validateTotalCaptureCount(formats strfmt.Registry) error {

	if swag.IsZero(o.TotalCaptureCount) { // not required
		return nil
	}

	if err := validate.MinimumInt("createPaymentRequest"+"."+"processingInformation"+"."+"captureOptions"+"."+"totalCaptureCount", "body", int64(o.TotalCaptureCount), 1, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("createPaymentRequest"+"."+"processingInformation"+"."+"captureOptions"+"."+"totalCaptureCount", "body", int64(o.TotalCaptureCount), 99, false); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyProcessingInformationCaptureOptions) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyProcessingInformationCaptureOptions) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyProcessingInformationCaptureOptions
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyProcessingInformationRecurringOptions create payment params body processing information recurring options
swagger:model CreatePaymentParamsBodyProcessingInformationRecurringOptions
*/
type CreatePaymentParamsBodyProcessingInformationRecurringOptions struct {

	// Flag that indicates whether this transaction is the first in a series of recurring payments.
	//
	// This field is supported only for **Atos**, **FDC Nashville Global**, and **OmniPay Direct**.
	//
	// Possible values:
	//  - `true` Indicates this is the first payment in a series of recurring payments
	//  - `false` (default) Indicates this is not the first payment in a series of recurring payments.
	//
	// For details, see `auth_first_recurring_payment` field description and "Recurring Payments" in
	// [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	FirstRecurringPayment *bool `json:"firstRecurringPayment,omitempty"`

	// Flag that indicates whether this is a payment towards an existing contractual loan.
	//
	// Possible values:
	// - `true`: Loan payment
	// - `false`: (default) Not a loan payment
	//
	// For processor-specific details, see `debt_indicator` field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	LoanPayment *bool `json:"loanPayment,omitempty"`
}

// Validate validates this create payment params body processing information recurring options
func (o *CreatePaymentParamsBodyProcessingInformationRecurringOptions) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyProcessingInformationRecurringOptions) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyProcessingInformationRecurringOptions) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyProcessingInformationRecurringOptions
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*CreatePaymentParamsBodyRecipientInformation create payment params body recipient information
swagger:model CreatePaymentParamsBodyRecipientInformation
*/
type CreatePaymentParamsBodyRecipientInformation struct {

	// Identifier for the recipients account. Use the first six digits and last four digits of the recipients account
	// number. This field is a _pass-through_, which means that CyberSource does not verify the value or modify it in
	// any way before sending it to the processor. If the field is not required for the transaction, CyberSource does
	// not forward it to the processor.
	//
	// For details, see the `recipient_account_id` field description in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 10
	AccountID string `json:"accountId,omitempty"`

	// Recipients last name. This field is a _passthrough_, which means that CyberSource does not verify the value or
	// modify it in any way before sending it to the processor. If the field is not required for the transaction,
	// CyberSource does not forward it to the processor.
	//
	// For details, see the `recipient_lastname` field description in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 6
	LastName string `json:"lastName,omitempty"`

	// Partial postal code for the recipients address. For example, if the postal code is **NN5 7SG**, the value for
	// this field should be the first part of the postal code: **NN5**. This field is a _pass-through_, which means that
	// CyberSource does not verify the value or modify it in any way before sending it to the processor. If the field
	// is not required for the transaction, CyberSource does not forward it to the processor.
	//
	// For details, see the `recipient_postal_code` field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 6
	PostalCode string `json:"postalCode,omitempty"`
}

// Validate validates this create payment params body recipient information
func (o *CreatePaymentParamsBodyRecipientInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAccountID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLastName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *CreatePaymentParamsBodyRecipientInformation) validateAccountID(formats strfmt.Registry) error {

	if swag.IsZero(o.AccountID) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"recipientInformation"+"."+"accountId", "body", string(o.AccountID), 10); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyRecipientInformation) validateLastName(formats strfmt.Registry) error {

	if swag.IsZero(o.LastName) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"recipientInformation"+"."+"lastName", "body", string(o.LastName), 6); err != nil {
		return err
	}

	return nil
}

func (o *CreatePaymentParamsBodyRecipientInformation) validatePostalCode(formats strfmt.Registry) error {

	if swag.IsZero(o.PostalCode) { // not required
		return nil
	}

	if err := validate.MaxLength("createPaymentRequest"+"."+"recipientInformation"+"."+"postalCode", "body", string(o.PostalCode), 6); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *CreatePaymentParamsBodyRecipientInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *CreatePaymentParamsBodyRecipientInformation) UnmarshalBinary(b []byte) error {
	var res CreatePaymentParamsBodyRecipientInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*DetailsItems0 details items0
swagger:model DetailsItems0
*/
type DetailsItems0 struct {

	// This is the flattened JSON object field name/path that is either missing or invalid.
	Field string `json:"field,omitempty"`

	// Possible reasons for the error.
	//
	// Possible values:
	//  - MISSING_FIELD
	//  - INVALID_DATA
	//
	Reason string `json:"reason,omitempty"`
}

// Validate validates this details items0
func (o *DetailsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *DetailsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *DetailsItems0) UnmarshalBinary(b []byte) error {
	var res DetailsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*MerchantDefinedInformationItems0 merchant defined information items0
swagger:model MerchantDefinedInformationItems0
*/
type MerchantDefinedInformationItems0 struct {

	// The number you assign for as the key for your merchant-defined data field. Valid values are 0 to 100.
	//
	// For example, to set or access the key for the 2nd merchant-defined data field in the array, you would reference `merchantDefinedInformation[1].key`.
	//
	// #### CyberSource through VisaNet
	// For installment payments with Mastercard in Brazil, use `merchantDefinedInformation[0].key` and
	// `merchantDefinedInformation[1].key` for data that you want to provide to the issuer to identify the
	// transaction.
	//
	// For details, see the `merchant_defined_data1` request-level field description in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// Max Length: 50
	Key string `json:"key,omitempty"`

	// The value you assign for your merchant-defined data field.
	//
	// For details, see `merchant_defined_data1` field description in the [Credit Card Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// **Warning** Merchant-defined data fields are not intended to and must not be used to capture personally identifying information. Accordingly, merchants are prohibited from capturing, obtaining, and/or transmitting any personally identifying information in or via the merchant-defined data fields. Personally identifying information includes, but is not
	// limited to, address, credit card number, social security number, driver's license number, state-issued identification number, passport number, and card verification numbers (CVV,
	// CVC2, CVV2, CID, CVN). In the event CyberSource discovers that a merchant is capturing and/or transmitting personally identifying information via the merchant-defined data fields, whether or not intentionally, CyberSource will immediately suspend the merchant's account, which will result in a rejection of any and all transaction requests submitted by the merchant after the point of suspension.
	//
	// #### CyberSource through VisaNet
	// For installment payments with Mastercard in Brazil, use `merchantDefinedInformation[0].value` and
	// `merchantDefinedInformation[1].value` for data that you want to provide to the issuer to identify the
	// transaction. For details, see "Installment Payments on CyberSource through VisaNet" in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// For details, see "Installment Payments on CyberSource through VisaNet" in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/wwhelp/wwhimpl/js/html/wwhelp.htm)
	//
	// For installment payments with Mastercard in Brazil:
	// - The value for merchantDefinedInformation[0].value corresponds to the following data in the TC 33 capture file5:
	//   - Record: CP07 TCR5
	//   - Position: 25-44
	//   - Field: Reference Field 2
	// - The value for merchantDefinedInformation[1].value corresponds to the following data in the TC 33 capture file5:
	//   - Record: CP07 TCR5
	//   - Position: 45-64
	//   - Field: Reference Field 3
	//
	// Max Length: 255
	Value string `json:"value,omitempty"`
}

// Validate validates this merchant defined information items0
func (o *MerchantDefinedInformationItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateKey(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateValue(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *MerchantDefinedInformationItems0) validateKey(formats strfmt.Registry) error {

	if swag.IsZero(o.Key) { // not required
		return nil
	}

	if err := validate.MaxLength("key", "body", string(o.Key), 50); err != nil {
		return err
	}

	return nil
}

func (o *MerchantDefinedInformationItems0) validateValue(formats strfmt.Registry) error {

	if swag.IsZero(o.Value) { // not required
		return nil
	}

	if err := validate.MaxLength("value", "body", string(o.Value), 255); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (o *MerchantDefinedInformationItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *MerchantDefinedInformationItems0) UnmarshalBinary(b []byte) error {
	var res MerchantDefinedInformationItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}
