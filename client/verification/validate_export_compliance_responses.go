// Code generated by go-swagger; DO NOT EDIT.

package verification

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"fmt"
	"io"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ValidateExportComplianceReader is a Reader for the ValidateExportCompliance structure.
type ValidateExportComplianceReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the received o.
func (o *ValidateExportComplianceReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
	switch response.Code() {
	case 201:
		result := NewValidateExportComplianceCreated()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil
	case 400:
		result := NewValidateExportComplianceBadRequest()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	case 502:
		result := NewValidateExportComplianceBadGateway()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result
	default:
		return nil, runtime.NewAPIError("response status code does not match any response statuses defined for this endpoint in the swagger spec", response, response.Code())
	}
}

// NewValidateExportComplianceCreated creates a ValidateExportComplianceCreated with default headers values
func NewValidateExportComplianceCreated() *ValidateExportComplianceCreated {
	return &ValidateExportComplianceCreated{}
}

/* ValidateExportComplianceCreated describes a response with status code 201, with default header values.

Successful response
*/
type ValidateExportComplianceCreated struct {
	Payload *ValidateExportComplianceCreatedBody
}

func (o *ValidateExportComplianceCreated) Error() string {
	return fmt.Sprintf("[POST /risk/v1/export-compliance-inquiries][%d] validateExportComplianceCreated  %+v", 201, o.Payload)
}
func (o *ValidateExportComplianceCreated) GetPayload() *ValidateExportComplianceCreatedBody {
	return o.Payload
}

func (o *ValidateExportComplianceCreated) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(ValidateExportComplianceCreatedBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewValidateExportComplianceBadRequest creates a ValidateExportComplianceBadRequest with default headers values
func NewValidateExportComplianceBadRequest() *ValidateExportComplianceBadRequest {
	return &ValidateExportComplianceBadRequest{}
}

/* ValidateExportComplianceBadRequest describes a response with status code 400, with default header values.

Invalid request.
*/
type ValidateExportComplianceBadRequest struct {
	Payload *ValidateExportComplianceBadRequestBody
}

func (o *ValidateExportComplianceBadRequest) Error() string {
	return fmt.Sprintf("[POST /risk/v1/export-compliance-inquiries][%d] validateExportComplianceBadRequest  %+v", 400, o.Payload)
}
func (o *ValidateExportComplianceBadRequest) GetPayload() *ValidateExportComplianceBadRequestBody {
	return o.Payload
}

func (o *ValidateExportComplianceBadRequest) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(ValidateExportComplianceBadRequestBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

// NewValidateExportComplianceBadGateway creates a ValidateExportComplianceBadGateway with default headers values
func NewValidateExportComplianceBadGateway() *ValidateExportComplianceBadGateway {
	return &ValidateExportComplianceBadGateway{}
}

/* ValidateExportComplianceBadGateway describes a response with status code 502, with default header values.

Unexpected system error or system timeout.
*/
type ValidateExportComplianceBadGateway struct {
	Payload *ValidateExportComplianceBadGatewayBody
}

func (o *ValidateExportComplianceBadGateway) Error() string {
	return fmt.Sprintf("[POST /risk/v1/export-compliance-inquiries][%d] validateExportComplianceBadGateway  %+v", 502, o.Payload)
}
func (o *ValidateExportComplianceBadGateway) GetPayload() *ValidateExportComplianceBadGatewayBody {
	return o.Payload
}

func (o *ValidateExportComplianceBadGateway) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {

	o.Payload = new(ValidateExportComplianceBadGatewayBody)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}

/*ValidateExportComplianceBadGatewayBody riskV1ExportComplianceInquiriesPost502Response
swagger:model ValidateExportComplianceBadGatewayBody
*/
type ValidateExportComplianceBadGatewayBody struct {

	// The detail message related to the status and reason listed above.
	Message string `json:"message,omitempty"`

	// The reason of the status.
	//
	// Possible values:
	//  - SYSTEM_ERROR
	//  - SERVER_TIMEOUT
	//  - SERVICE_TIMEOUT
	//
	Reason string `json:"reason,omitempty"`

	// The status of the submitted transaction.
	//
	// Possible values:
	//  - SERVER_ERROR
	//
	Status string `json:"status,omitempty"`

	// Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ`
	// **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.).
	// The `T` separates the date and the time. The `Z` indicates UTC.
	//
	// Returned by Cybersource for all services.
	//
	SubmitTimeUtc string `json:"submitTimeUtc,omitempty"`
}

// Validate validates this validate export compliance bad gateway body
func (o *ValidateExportComplianceBadGatewayBody) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this validate export compliance bad gateway body based on context it is used
func (o *ValidateExportComplianceBadGatewayBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *ValidateExportComplianceBadGatewayBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ValidateExportComplianceBadGatewayBody) UnmarshalBinary(b []byte) error {
	var res ValidateExportComplianceBadGatewayBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*ValidateExportComplianceBadRequestBody riskV1ExportComplianceInquiriesPost400Response
swagger:model ValidateExportComplianceBadRequestBody
*/
type ValidateExportComplianceBadRequestBody struct {

	// details
	Details []*ValidateExportComplianceBadRequestBodyDetailsItems0 `json:"details"`

	// The detail message related to the status and reason listed above.
	Message string `json:"message,omitempty"`

	// The reason of the status.
	//
	// Possible Values:
	// - `MISSING_FIELD`
	// - `INVALID_DATA`
	//
	Reason string `json:"reason,omitempty"`

	// The status of the submitted transaction.
	//
	// Possible values:
	//  - INVALID_REQUEST
	//
	Status string `json:"status,omitempty"`

	// Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ`
	// **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.).
	// The `T` separates the date and the time. The `Z` indicates UTC.
	//
	// Returned by Cybersource for all services.
	//
	SubmitTimeUtc string `json:"submitTimeUtc,omitempty"`
}

// Validate validates this validate export compliance bad request body
func (o *ValidateExportComplianceBadRequestBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ValidateExportComplianceBadRequestBody) validateDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.Details) { // not required
		return nil
	}

	for i := 0; i < len(o.Details); i++ {
		if swag.IsZero(o.Details[i]) { // not required
			continue
		}

		if o.Details[i] != nil {
			if err := o.Details[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("validateExportComplianceBadRequest" + "." + "details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("validateExportComplianceBadRequest" + "." + "details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this validate export compliance bad request body based on the context it is used
func (o *ValidateExportComplianceBadRequestBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ValidateExportComplianceBadRequestBody) contextValidateDetails(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.Details); i++ {

		if o.Details[i] != nil {
			if err := o.Details[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("validateExportComplianceBadRequest" + "." + "details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("validateExportComplianceBadRequest" + "." + "details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *ValidateExportComplianceBadRequestBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ValidateExportComplianceBadRequestBody) UnmarshalBinary(b []byte) error {
	var res ValidateExportComplianceBadRequestBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*ValidateExportComplianceBadRequestBodyDetailsItems0 validate export compliance bad request body details items0
swagger:model ValidateExportComplianceBadRequestBodyDetailsItems0
*/
type ValidateExportComplianceBadRequestBodyDetailsItems0 struct {

	// This is the flattened JSON object field name/path that is either missing or invalid.
	Field string `json:"field,omitempty"`

	// Possible reasons for the error.
	//
	// Possible values:
	//  - MISSING_FIELD
	//  - INVALID_DATA
	//
	Reason string `json:"reason,omitempty"`
}

// Validate validates this validate export compliance bad request body details items0
func (o *ValidateExportComplianceBadRequestBodyDetailsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this validate export compliance bad request body details items0 based on context it is used
func (o *ValidateExportComplianceBadRequestBodyDetailsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *ValidateExportComplianceBadRequestBodyDetailsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ValidateExportComplianceBadRequestBodyDetailsItems0) UnmarshalBinary(b []byte) error {
	var res ValidateExportComplianceBadRequestBodyDetailsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*ValidateExportComplianceBody validate export compliance body
swagger:model ValidateExportComplianceBody
*/
type ValidateExportComplianceBody struct {

	// buyer information
	BuyerInformation *ValidateExportComplianceParamsBodyBuyerInformation `json:"buyerInformation,omitempty"`

	// client reference information
	ClientReferenceInformation *ValidateExportComplianceParamsBodyClientReferenceInformation `json:"clientReferenceInformation,omitempty"`

	// device information
	DeviceInformation *ValidateExportComplianceParamsBodyDeviceInformation `json:"deviceInformation,omitempty"`

	// export compliance information
	ExportComplianceInformation *ValidateExportComplianceParamsBodyExportComplianceInformation `json:"exportComplianceInformation,omitempty"`

	// order information
	OrderInformation *ValidateExportComplianceParamsBodyOrderInformation `json:"orderInformation,omitempty"`
}

// Validate validates this validate export compliance body
func (o *ValidateExportComplianceBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateBuyerInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateClientReferenceInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateDeviceInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExportComplianceInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateOrderInformation(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ValidateExportComplianceBody) validateBuyerInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.BuyerInformation) { // not required
		return nil
	}

	if o.BuyerInformation != nil {
		if err := o.BuyerInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("validateExportComplianceRequest" + "." + "buyerInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("validateExportComplianceRequest" + "." + "buyerInformation")
			}
			return err
		}
	}

	return nil
}

func (o *ValidateExportComplianceBody) validateClientReferenceInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ClientReferenceInformation) { // not required
		return nil
	}

	if o.ClientReferenceInformation != nil {
		if err := o.ClientReferenceInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("validateExportComplianceRequest" + "." + "clientReferenceInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("validateExportComplianceRequest" + "." + "clientReferenceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *ValidateExportComplianceBody) validateDeviceInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.DeviceInformation) { // not required
		return nil
	}

	if o.DeviceInformation != nil {
		if err := o.DeviceInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("validateExportComplianceRequest" + "." + "deviceInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("validateExportComplianceRequest" + "." + "deviceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *ValidateExportComplianceBody) validateExportComplianceInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ExportComplianceInformation) { // not required
		return nil
	}

	if o.ExportComplianceInformation != nil {
		if err := o.ExportComplianceInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("validateExportComplianceRequest" + "." + "exportComplianceInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("validateExportComplianceRequest" + "." + "exportComplianceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *ValidateExportComplianceBody) validateOrderInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.OrderInformation) { // not required
		return nil
	}

	if o.OrderInformation != nil {
		if err := o.OrderInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("validateExportComplianceRequest" + "." + "orderInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("validateExportComplianceRequest" + "." + "orderInformation")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this validate export compliance body based on the context it is used
func (o *ValidateExportComplianceBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateBuyerInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateClientReferenceInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateDeviceInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateExportComplianceInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateOrderInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ValidateExportComplianceBody) contextValidateBuyerInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.BuyerInformation != nil {
		if err := o.BuyerInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("validateExportComplianceRequest" + "." + "buyerInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("validateExportComplianceRequest" + "." + "buyerInformation")
			}
			return err
		}
	}

	return nil
}

func (o *ValidateExportComplianceBody) contextValidateClientReferenceInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ClientReferenceInformation != nil {
		if err := o.ClientReferenceInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("validateExportComplianceRequest" + "." + "clientReferenceInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("validateExportComplianceRequest" + "." + "clientReferenceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *ValidateExportComplianceBody) contextValidateDeviceInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.DeviceInformation != nil {
		if err := o.DeviceInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("validateExportComplianceRequest" + "." + "deviceInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("validateExportComplianceRequest" + "." + "deviceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *ValidateExportComplianceBody) contextValidateExportComplianceInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ExportComplianceInformation != nil {
		if err := o.ExportComplianceInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("validateExportComplianceRequest" + "." + "exportComplianceInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("validateExportComplianceRequest" + "." + "exportComplianceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *ValidateExportComplianceBody) contextValidateOrderInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.OrderInformation != nil {
		if err := o.OrderInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("validateExportComplianceRequest" + "." + "orderInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("validateExportComplianceRequest" + "." + "orderInformation")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *ValidateExportComplianceBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ValidateExportComplianceBody) UnmarshalBinary(b []byte) error {
	var res ValidateExportComplianceBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*ValidateExportComplianceCreatedBody riskV1ExportComplianceInquiriesPost201Response
swagger:model ValidateExportComplianceCreatedBody
*/
type ValidateExportComplianceCreatedBody struct {

	// links
	Links *ValidateExportComplianceCreatedBodyLinks `json:"_links,omitempty"`

	// client reference information
	ClientReferenceInformation *ValidateExportComplianceCreatedBodyClientReferenceInformation `json:"clientReferenceInformation,omitempty"`

	// error information
	ErrorInformation *ValidateExportComplianceCreatedBodyErrorInformation `json:"errorInformation,omitempty"`

	// export compliance information
	ExportComplianceInformation *ValidateExportComplianceCreatedBodyExportComplianceInformation `json:"exportComplianceInformation,omitempty"`

	// An unique identification number generated by Cybersource to identify the submitted request. Returned by all services.
	// It is also appended to the endpoint of the resource.
	// On incremental authorizations, this value with be the same as the identification number returned in the original authorization response.
	//
	// Max Length: 26
	ID string `json:"id,omitempty"`

	// The message describing the reason of the status. Value can be
	//   - The customer matched the Denied Parties List
	//   - The Export bill_country/ship_country  match
	//   - Export email_country match
	//   - Export hostname_country/ip_country match
	//
	Message string `json:"message,omitempty"`

	// The status for the call can be:
	// - COMPLETED
	// - INVALID_REQUEST
	// - DECLINED
	//
	Status string `json:"status,omitempty"`

	// Time that the transaction was submitted in local time. Generated by Cybersource.
	SubmitTimeLocal string `json:"submitTimeLocal,omitempty"`

	// Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ`
	// **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.).
	// The `T` separates the date and the time. The `Z` indicates UTC.
	//
	// Returned by Cybersource for all services.
	//
	SubmitTimeUtc string `json:"submitTimeUtc,omitempty"`
}

// Validate validates this validate export compliance created body
func (o *ValidateExportComplianceCreatedBody) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateClientReferenceInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateErrorInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateExportComplianceInformation(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ValidateExportComplianceCreatedBody) validateLinks(formats strfmt.Registry) error {
	if swag.IsZero(o.Links) { // not required
		return nil
	}

	if o.Links != nil {
		if err := o.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("validateExportComplianceCreated" + "." + "_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("validateExportComplianceCreated" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (o *ValidateExportComplianceCreatedBody) validateClientReferenceInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ClientReferenceInformation) { // not required
		return nil
	}

	if o.ClientReferenceInformation != nil {
		if err := o.ClientReferenceInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("validateExportComplianceCreated" + "." + "clientReferenceInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("validateExportComplianceCreated" + "." + "clientReferenceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *ValidateExportComplianceCreatedBody) validateErrorInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ErrorInformation) { // not required
		return nil
	}

	if o.ErrorInformation != nil {
		if err := o.ErrorInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("validateExportComplianceCreated" + "." + "errorInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("validateExportComplianceCreated" + "." + "errorInformation")
			}
			return err
		}
	}

	return nil
}

func (o *ValidateExportComplianceCreatedBody) validateExportComplianceInformation(formats strfmt.Registry) error {
	if swag.IsZero(o.ExportComplianceInformation) { // not required
		return nil
	}

	if o.ExportComplianceInformation != nil {
		if err := o.ExportComplianceInformation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("validateExportComplianceCreated" + "." + "exportComplianceInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("validateExportComplianceCreated" + "." + "exportComplianceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *ValidateExportComplianceCreatedBody) validateID(formats strfmt.Registry) error {
	if swag.IsZero(o.ID) { // not required
		return nil
	}

	if err := validate.MaxLength("validateExportComplianceCreated"+"."+"id", "body", o.ID, 26); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this validate export compliance created body based on the context it is used
func (o *ValidateExportComplianceCreatedBody) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateClientReferenceInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateErrorInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateExportComplianceInformation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ValidateExportComplianceCreatedBody) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if o.Links != nil {
		if err := o.Links.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("validateExportComplianceCreated" + "." + "_links")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("validateExportComplianceCreated" + "." + "_links")
			}
			return err
		}
	}

	return nil
}

func (o *ValidateExportComplianceCreatedBody) contextValidateClientReferenceInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ClientReferenceInformation != nil {
		if err := o.ClientReferenceInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("validateExportComplianceCreated" + "." + "clientReferenceInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("validateExportComplianceCreated" + "." + "clientReferenceInformation")
			}
			return err
		}
	}

	return nil
}

func (o *ValidateExportComplianceCreatedBody) contextValidateErrorInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ErrorInformation != nil {
		if err := o.ErrorInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("validateExportComplianceCreated" + "." + "errorInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("validateExportComplianceCreated" + "." + "errorInformation")
			}
			return err
		}
	}

	return nil
}

func (o *ValidateExportComplianceCreatedBody) contextValidateExportComplianceInformation(ctx context.Context, formats strfmt.Registry) error {

	if o.ExportComplianceInformation != nil {
		if err := o.ExportComplianceInformation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("validateExportComplianceCreated" + "." + "exportComplianceInformation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("validateExportComplianceCreated" + "." + "exportComplianceInformation")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *ValidateExportComplianceCreatedBody) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ValidateExportComplianceCreatedBody) UnmarshalBinary(b []byte) error {
	var res ValidateExportComplianceCreatedBody
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*ValidateExportComplianceCreatedBodyClientReferenceInformation validate export compliance created body client reference information
swagger:model ValidateExportComplianceCreatedBodyClientReferenceInformation
*/
type ValidateExportComplianceCreatedBodyClientReferenceInformation struct {

	// Merchant-generated order reference or tracking number. It is recommended that you send a unique value for each
	// transaction so that you can perform meaningful searches for the transaction.
	//
	// #### Used by
	// **Authorization**
	// Required field.
	//
	// #### PIN Debit
	// Requests for PIN debit reversals need to use the same merchant reference number that was used in the transaction that is being
	// reversed.
	//
	// Required field for all PIN Debit requests (purchase, credit, and reversal).
	//
	// #### FDC Nashville Global
	// Certain circumstances can cause the processor to truncate this value to 15 or 17 characters for Level II and Level III processing, which can cause a discrepancy between the value you submit and the value included in some processor reports.
	//
	// Max Length: 50
	Code string `json:"code,omitempty"`

	// Brief description of the order or any comment you wish to add to the order.
	//
	// Max Length: 255
	Comments string `json:"comments,omitempty"`

	// partner
	Partner *ValidateExportComplianceCreatedBodyClientReferenceInformationPartner `json:"partner,omitempty"`
}

// Validate validates this validate export compliance created body client reference information
func (o *ValidateExportComplianceCreatedBodyClientReferenceInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateComments(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePartner(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ValidateExportComplianceCreatedBodyClientReferenceInformation) validateCode(formats strfmt.Registry) error {
	if swag.IsZero(o.Code) { // not required
		return nil
	}

	if err := validate.MaxLength("validateExportComplianceCreated"+"."+"clientReferenceInformation"+"."+"code", "body", o.Code, 50); err != nil {
		return err
	}

	return nil
}

func (o *ValidateExportComplianceCreatedBodyClientReferenceInformation) validateComments(formats strfmt.Registry) error {
	if swag.IsZero(o.Comments) { // not required
		return nil
	}

	if err := validate.MaxLength("validateExportComplianceCreated"+"."+"clientReferenceInformation"+"."+"comments", "body", o.Comments, 255); err != nil {
		return err
	}

	return nil
}

func (o *ValidateExportComplianceCreatedBodyClientReferenceInformation) validatePartner(formats strfmt.Registry) error {
	if swag.IsZero(o.Partner) { // not required
		return nil
	}

	if o.Partner != nil {
		if err := o.Partner.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("validateExportComplianceCreated" + "." + "clientReferenceInformation" + "." + "partner")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("validateExportComplianceCreated" + "." + "clientReferenceInformation" + "." + "partner")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this validate export compliance created body client reference information based on the context it is used
func (o *ValidateExportComplianceCreatedBodyClientReferenceInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidatePartner(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ValidateExportComplianceCreatedBodyClientReferenceInformation) contextValidatePartner(ctx context.Context, formats strfmt.Registry) error {

	if o.Partner != nil {
		if err := o.Partner.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("validateExportComplianceCreated" + "." + "clientReferenceInformation" + "." + "partner")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("validateExportComplianceCreated" + "." + "clientReferenceInformation" + "." + "partner")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *ValidateExportComplianceCreatedBodyClientReferenceInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ValidateExportComplianceCreatedBodyClientReferenceInformation) UnmarshalBinary(b []byte) error {
	var res ValidateExportComplianceCreatedBodyClientReferenceInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*ValidateExportComplianceCreatedBodyClientReferenceInformationPartner validate export compliance created body client reference information partner
swagger:model ValidateExportComplianceCreatedBodyClientReferenceInformationPartner
*/
type ValidateExportComplianceCreatedBodyClientReferenceInformationPartner struct {

	// Identifier for the developer that helped integrate a partner solution to CyberSource.
	//
	// Send this value in all requests that are sent through the partner solutions built by that developer.
	// CyberSource assigns the ID to the developer.
	//
	// **Note** When you see a developer ID of 999 in reports, the developer ID that was submitted is incorrect.
	//
	// Max Length: 8
	DeveloperID string `json:"developerId,omitempty"`

	// Identifier for the partner that is integrated to CyberSource.
	//
	// Send this value in all requests that are sent through the partner solution. CyberSource assigns the ID to the partner.
	//
	// **Note** When you see a solutionId of 999 in reports, the solutionId that was submitted is incorrect.
	//
	// Max Length: 8
	SolutionID string `json:"solutionId,omitempty"`
}

// Validate validates this validate export compliance created body client reference information partner
func (o *ValidateExportComplianceCreatedBodyClientReferenceInformationPartner) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDeveloperID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSolutionID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ValidateExportComplianceCreatedBodyClientReferenceInformationPartner) validateDeveloperID(formats strfmt.Registry) error {
	if swag.IsZero(o.DeveloperID) { // not required
		return nil
	}

	if err := validate.MaxLength("validateExportComplianceCreated"+"."+"clientReferenceInformation"+"."+"partner"+"."+"developerId", "body", o.DeveloperID, 8); err != nil {
		return err
	}

	return nil
}

func (o *ValidateExportComplianceCreatedBodyClientReferenceInformationPartner) validateSolutionID(formats strfmt.Registry) error {
	if swag.IsZero(o.SolutionID) { // not required
		return nil
	}

	if err := validate.MaxLength("validateExportComplianceCreated"+"."+"clientReferenceInformation"+"."+"partner"+"."+"solutionId", "body", o.SolutionID, 8); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this validate export compliance created body client reference information partner based on context it is used
func (o *ValidateExportComplianceCreatedBodyClientReferenceInformationPartner) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *ValidateExportComplianceCreatedBodyClientReferenceInformationPartner) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ValidateExportComplianceCreatedBodyClientReferenceInformationPartner) UnmarshalBinary(b []byte) error {
	var res ValidateExportComplianceCreatedBodyClientReferenceInformationPartner
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*ValidateExportComplianceCreatedBodyErrorInformation validate export compliance created body error information
swagger:model ValidateExportComplianceCreatedBodyErrorInformation
*/
type ValidateExportComplianceCreatedBodyErrorInformation struct {

	// details
	Details []*ValidateExportComplianceCreatedBodyErrorInformationDetailsItems0 `json:"details"`

	// The detail message related to the status and reason listed above.
	Message string `json:"message,omitempty"`

	// The reason of the status. Value can be
	//   - `CUSTOMER_WATCHLIST_MATCH`
	//   - `ADDRESS_COUNTRY_WATCHLIST_MATCH`
	//   - `EMAIL_COUNTRY_WATCHLIST_MATCH`
	//   - `IP_COUNTRY_WATCHLIST_MATCH`
	//   - `INVALID_MERCHANT_CONFIGURATION`
	//
	Reason string `json:"reason,omitempty"`
}

// Validate validates this validate export compliance created body error information
func (o *ValidateExportComplianceCreatedBodyErrorInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDetails(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ValidateExportComplianceCreatedBodyErrorInformation) validateDetails(formats strfmt.Registry) error {
	if swag.IsZero(o.Details) { // not required
		return nil
	}

	for i := 0; i < len(o.Details); i++ {
		if swag.IsZero(o.Details[i]) { // not required
			continue
		}

		if o.Details[i] != nil {
			if err := o.Details[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("validateExportComplianceCreated" + "." + "errorInformation" + "." + "details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("validateExportComplianceCreated" + "." + "errorInformation" + "." + "details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this validate export compliance created body error information based on the context it is used
func (o *ValidateExportComplianceCreatedBodyErrorInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ValidateExportComplianceCreatedBodyErrorInformation) contextValidateDetails(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.Details); i++ {

		if o.Details[i] != nil {
			if err := o.Details[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("validateExportComplianceCreated" + "." + "errorInformation" + "." + "details" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("validateExportComplianceCreated" + "." + "errorInformation" + "." + "details" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *ValidateExportComplianceCreatedBodyErrorInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ValidateExportComplianceCreatedBodyErrorInformation) UnmarshalBinary(b []byte) error {
	var res ValidateExportComplianceCreatedBodyErrorInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*ValidateExportComplianceCreatedBodyErrorInformationDetailsItems0 validate export compliance created body error information details items0
swagger:model ValidateExportComplianceCreatedBodyErrorInformationDetailsItems0
*/
type ValidateExportComplianceCreatedBodyErrorInformationDetailsItems0 struct {

	// This is the flattened JSON object field name/path that is either missing or invalid.
	Field string `json:"field,omitempty"`

	// Possible reasons for the error.
	//
	// Possible values:
	//  - MISSING_FIELD
	//  - INVALID_DATA
	//
	Reason string `json:"reason,omitempty"`
}

// Validate validates this validate export compliance created body error information details items0
func (o *ValidateExportComplianceCreatedBodyErrorInformationDetailsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this validate export compliance created body error information details items0 based on context it is used
func (o *ValidateExportComplianceCreatedBodyErrorInformationDetailsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *ValidateExportComplianceCreatedBodyErrorInformationDetailsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ValidateExportComplianceCreatedBodyErrorInformationDetailsItems0) UnmarshalBinary(b []byte) error {
	var res ValidateExportComplianceCreatedBodyErrorInformationDetailsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*ValidateExportComplianceCreatedBodyExportComplianceInformation validate export compliance created body export compliance information
swagger:model ValidateExportComplianceCreatedBodyExportComplianceInformation
*/
type ValidateExportComplianceCreatedBodyExportComplianceInformation struct {

	// Returned when the Denied Parties List check (first two codes) or the export service (all others) would have
	// declined the transaction. This field can contain one or more of these values:
	// - `MATCH-DPC`: Denied Parties List match.
	// - `UNV-DPC`: Denied Parties List unavailable.
	// - `MATCH-BCO`: Billing country restricted.
	// - `MATCH-EMCO`: Email country restricted.
	// - `MATCH-HCO`: Host name country restricted.
	// - `MATCH-IPCO`: IP country restricted.
	// - `MATCH-SCO`: Shipping country restricted.
	//
	InfoCodes []string `json:"infoCodes"`

	// Likelihood that the country associated with the customer’s IP address was identified correctly.
	// Returns a value from 1–100, where 100 indicates the highest likelihood.
	// If the country cannot be determined, the value is –1.
	//
	// Maximum: 100
	// Minimum: -1
	IPCountryConfidence *int64 `json:"ipCountryConfidence,omitempty"`

	// watch list
	WatchList *ValidateExportComplianceCreatedBodyExportComplianceInformationWatchList `json:"watchList,omitempty"`
}

// Validate validates this validate export compliance created body export compliance information
func (o *ValidateExportComplianceCreatedBodyExportComplianceInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateInfoCodes(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateIPCountryConfidence(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateWatchList(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ValidateExportComplianceCreatedBodyExportComplianceInformation) validateInfoCodes(formats strfmt.Registry) error {
	if swag.IsZero(o.InfoCodes) { // not required
		return nil
	}

	for i := 0; i < len(o.InfoCodes); i++ {

		if err := validate.MaxLength("validateExportComplianceCreated"+"."+"exportComplianceInformation"+"."+"infoCodes"+"."+strconv.Itoa(i), "body", o.InfoCodes[i], 255); err != nil {
			return err
		}

	}

	return nil
}

func (o *ValidateExportComplianceCreatedBodyExportComplianceInformation) validateIPCountryConfidence(formats strfmt.Registry) error {
	if swag.IsZero(o.IPCountryConfidence) { // not required
		return nil
	}

	if err := validate.MinimumInt("validateExportComplianceCreated"+"."+"exportComplianceInformation"+"."+"ipCountryConfidence", "body", *o.IPCountryConfidence, -1, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("validateExportComplianceCreated"+"."+"exportComplianceInformation"+"."+"ipCountryConfidence", "body", *o.IPCountryConfidence, 100, false); err != nil {
		return err
	}

	return nil
}

func (o *ValidateExportComplianceCreatedBodyExportComplianceInformation) validateWatchList(formats strfmt.Registry) error {
	if swag.IsZero(o.WatchList) { // not required
		return nil
	}

	if o.WatchList != nil {
		if err := o.WatchList.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("validateExportComplianceCreated" + "." + "exportComplianceInformation" + "." + "watchList")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("validateExportComplianceCreated" + "." + "exportComplianceInformation" + "." + "watchList")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this validate export compliance created body export compliance information based on the context it is used
func (o *ValidateExportComplianceCreatedBodyExportComplianceInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateWatchList(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ValidateExportComplianceCreatedBodyExportComplianceInformation) contextValidateWatchList(ctx context.Context, formats strfmt.Registry) error {

	if o.WatchList != nil {
		if err := o.WatchList.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("validateExportComplianceCreated" + "." + "exportComplianceInformation" + "." + "watchList")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("validateExportComplianceCreated" + "." + "exportComplianceInformation" + "." + "watchList")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *ValidateExportComplianceCreatedBodyExportComplianceInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ValidateExportComplianceCreatedBodyExportComplianceInformation) UnmarshalBinary(b []byte) error {
	var res ValidateExportComplianceCreatedBodyExportComplianceInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*ValidateExportComplianceCreatedBodyExportComplianceInformationWatchList validate export compliance created body export compliance information watch list
swagger:model ValidateExportComplianceCreatedBodyExportComplianceInformationWatchList
*/
type ValidateExportComplianceCreatedBodyExportComplianceInformationWatchList struct {

	// matches
	Matches []*ValidateExportComplianceCreatedBodyExportComplianceInformationWatchListMatchesItems0 `json:"matches"`
}

// Validate validates this validate export compliance created body export compliance information watch list
func (o *ValidateExportComplianceCreatedBodyExportComplianceInformationWatchList) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateMatches(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ValidateExportComplianceCreatedBodyExportComplianceInformationWatchList) validateMatches(formats strfmt.Registry) error {
	if swag.IsZero(o.Matches) { // not required
		return nil
	}

	for i := 0; i < len(o.Matches); i++ {
		if swag.IsZero(o.Matches[i]) { // not required
			continue
		}

		if o.Matches[i] != nil {
			if err := o.Matches[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("validateExportComplianceCreated" + "." + "exportComplianceInformation" + "." + "watchList" + "." + "matches" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("validateExportComplianceCreated" + "." + "exportComplianceInformation" + "." + "watchList" + "." + "matches" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this validate export compliance created body export compliance information watch list based on the context it is used
func (o *ValidateExportComplianceCreatedBodyExportComplianceInformationWatchList) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateMatches(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ValidateExportComplianceCreatedBodyExportComplianceInformationWatchList) contextValidateMatches(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.Matches); i++ {

		if o.Matches[i] != nil {
			if err := o.Matches[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("validateExportComplianceCreated" + "." + "exportComplianceInformation" + "." + "watchList" + "." + "matches" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("validateExportComplianceCreated" + "." + "exportComplianceInformation" + "." + "watchList" + "." + "matches" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (o *ValidateExportComplianceCreatedBodyExportComplianceInformationWatchList) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ValidateExportComplianceCreatedBodyExportComplianceInformationWatchList) UnmarshalBinary(b []byte) error {
	var res ValidateExportComplianceCreatedBodyExportComplianceInformationWatchList
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*ValidateExportComplianceCreatedBodyExportComplianceInformationWatchListMatchesItems0 validate export compliance created body export compliance information watch list matches items0
swagger:model ValidateExportComplianceCreatedBodyExportComplianceInformationWatchListMatchesItems0
*/
type ValidateExportComplianceCreatedBodyExportComplianceInformationWatchListMatchesItems0 struct {

	// Address found on the list specified in export_matchN_list
	// for the entity (name and address) in the request.
	//
	Addresses []string `json:"addresses"`

	// Name found on the list specified in export_matchN_list for the entity (name and address) in the request.
	//
	Aliases []string `json:"aliases"`

	// Sub-lists matched by the order data. List members are separated by carets (^).
	Programs []string `json:"programs"`

	// List on which the first Denied Parties List check match appears.
	// For a list of codes, see "Denied Parties List Check Codes," page 56.
	//
	// Max Length: 255
	SanctionList string `json:"sanctionList,omitempty"`
}

// Validate validates this validate export compliance created body export compliance information watch list matches items0
func (o *ValidateExportComplianceCreatedBodyExportComplianceInformationWatchListMatchesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAddresses(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAliases(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePrograms(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSanctionList(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ValidateExportComplianceCreatedBodyExportComplianceInformationWatchListMatchesItems0) validateAddresses(formats strfmt.Registry) error {
	if swag.IsZero(o.Addresses) { // not required
		return nil
	}

	for i := 0; i < len(o.Addresses); i++ {

		if err := validate.MaxLength("addresses"+"."+strconv.Itoa(i), "body", o.Addresses[i], 255); err != nil {
			return err
		}

	}

	return nil
}

func (o *ValidateExportComplianceCreatedBodyExportComplianceInformationWatchListMatchesItems0) validateAliases(formats strfmt.Registry) error {
	if swag.IsZero(o.Aliases) { // not required
		return nil
	}

	for i := 0; i < len(o.Aliases); i++ {

		if err := validate.MaxLength("aliases"+"."+strconv.Itoa(i), "body", o.Aliases[i], 255); err != nil {
			return err
		}

	}

	return nil
}

func (o *ValidateExportComplianceCreatedBodyExportComplianceInformationWatchListMatchesItems0) validatePrograms(formats strfmt.Registry) error {
	if swag.IsZero(o.Programs) { // not required
		return nil
	}

	for i := 0; i < len(o.Programs); i++ {

		if err := validate.MaxLength("programs"+"."+strconv.Itoa(i), "body", o.Programs[i], 255); err != nil {
			return err
		}

	}

	return nil
}

func (o *ValidateExportComplianceCreatedBodyExportComplianceInformationWatchListMatchesItems0) validateSanctionList(formats strfmt.Registry) error {
	if swag.IsZero(o.SanctionList) { // not required
		return nil
	}

	if err := validate.MaxLength("sanctionList", "body", o.SanctionList, 255); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this validate export compliance created body export compliance information watch list matches items0 based on context it is used
func (o *ValidateExportComplianceCreatedBodyExportComplianceInformationWatchListMatchesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *ValidateExportComplianceCreatedBodyExportComplianceInformationWatchListMatchesItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ValidateExportComplianceCreatedBodyExportComplianceInformationWatchListMatchesItems0) UnmarshalBinary(b []byte) error {
	var res ValidateExportComplianceCreatedBodyExportComplianceInformationWatchListMatchesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*ValidateExportComplianceCreatedBodyLinks validate export compliance created body links
swagger:model ValidateExportComplianceCreatedBodyLinks
*/
type ValidateExportComplianceCreatedBodyLinks struct {

	// self
	Self *ValidateExportComplianceCreatedBodyLinksSelf `json:"self,omitempty"`
}

// Validate validates this validate export compliance created body links
func (o *ValidateExportComplianceCreatedBodyLinks) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateSelf(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ValidateExportComplianceCreatedBodyLinks) validateSelf(formats strfmt.Registry) error {
	if swag.IsZero(o.Self) { // not required
		return nil
	}

	if o.Self != nil {
		if err := o.Self.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("validateExportComplianceCreated" + "." + "_links" + "." + "self")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("validateExportComplianceCreated" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this validate export compliance created body links based on the context it is used
func (o *ValidateExportComplianceCreatedBodyLinks) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateSelf(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ValidateExportComplianceCreatedBodyLinks) contextValidateSelf(ctx context.Context, formats strfmt.Registry) error {

	if o.Self != nil {
		if err := o.Self.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("validateExportComplianceCreated" + "." + "_links" + "." + "self")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("validateExportComplianceCreated" + "." + "_links" + "." + "self")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *ValidateExportComplianceCreatedBodyLinks) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ValidateExportComplianceCreatedBodyLinks) UnmarshalBinary(b []byte) error {
	var res ValidateExportComplianceCreatedBodyLinks
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*ValidateExportComplianceCreatedBodyLinksSelf validate export compliance created body links self
swagger:model ValidateExportComplianceCreatedBodyLinksSelf
*/
type ValidateExportComplianceCreatedBodyLinksSelf struct {

	// This is the endpoint of the resource that was created by the successful request.
	Href string `json:"href,omitempty"`

	// `method` refers to the HTTP method that you can send to the `self` endpoint to retrieve details of the resource.
	Method string `json:"method,omitempty"`
}

// Validate validates this validate export compliance created body links self
func (o *ValidateExportComplianceCreatedBodyLinksSelf) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this validate export compliance created body links self based on context it is used
func (o *ValidateExportComplianceCreatedBodyLinksSelf) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *ValidateExportComplianceCreatedBodyLinksSelf) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ValidateExportComplianceCreatedBodyLinksSelf) UnmarshalBinary(b []byte) error {
	var res ValidateExportComplianceCreatedBodyLinksSelf
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*ValidateExportComplianceParamsBodyBuyerInformation validate export compliance params body buyer information
swagger:model ValidateExportComplianceParamsBodyBuyerInformation
*/
type ValidateExportComplianceParamsBodyBuyerInformation struct {

	// Optional customer’s account ID, tracking number, reward number, or other unique number
	// that you assign to the customer for the purpose that you choose
	//
	// Max Length: 100
	MerchantCustomerID string `json:"merchantCustomerId,omitempty"`
}

// Validate validates this validate export compliance params body buyer information
func (o *ValidateExportComplianceParamsBodyBuyerInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateMerchantCustomerID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ValidateExportComplianceParamsBodyBuyerInformation) validateMerchantCustomerID(formats strfmt.Registry) error {
	if swag.IsZero(o.MerchantCustomerID) { // not required
		return nil
	}

	if err := validate.MaxLength("validateExportComplianceRequest"+"."+"buyerInformation"+"."+"merchantCustomerId", "body", o.MerchantCustomerID, 100); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this validate export compliance params body buyer information based on context it is used
func (o *ValidateExportComplianceParamsBodyBuyerInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *ValidateExportComplianceParamsBodyBuyerInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ValidateExportComplianceParamsBodyBuyerInformation) UnmarshalBinary(b []byte) error {
	var res ValidateExportComplianceParamsBodyBuyerInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*ValidateExportComplianceParamsBodyClientReferenceInformation validate export compliance params body client reference information
swagger:model ValidateExportComplianceParamsBodyClientReferenceInformation
*/
type ValidateExportComplianceParamsBodyClientReferenceInformation struct {

	// Merchant-generated order reference or tracking number. It is recommended that you send a unique value for each
	// transaction so that you can perform meaningful searches for the transaction.
	//
	// #### Used by
	// **Authorization**
	// Required field.
	//
	// #### PIN Debit
	// Requests for PIN debit reversals need to use the same merchant reference number that was used in the transaction that is being
	// reversed.
	//
	// Required field for all PIN Debit requests (purchase, credit, and reversal).
	//
	// #### FDC Nashville Global
	// Certain circumstances can cause the processor to truncate this value to 15 or 17 characters for Level II and Level III processing, which can cause a discrepancy between the value you submit and the value included in some processor reports.
	//
	// Required: true
	// Max Length: 50
	Code *string `json:"code"`

	// Brief description of the order or any comment you wish to add to the order.
	//
	// Max Length: 255
	Comments string `json:"comments,omitempty"`

	// partner
	Partner *ValidateExportComplianceParamsBodyClientReferenceInformationPartner `json:"partner,omitempty"`
}

// Validate validates this validate export compliance params body client reference information
func (o *ValidateExportComplianceParamsBodyClientReferenceInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateComments(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePartner(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ValidateExportComplianceParamsBodyClientReferenceInformation) validateCode(formats strfmt.Registry) error {

	if err := validate.Required("validateExportComplianceRequest"+"."+"clientReferenceInformation"+"."+"code", "body", o.Code); err != nil {
		return err
	}

	if err := validate.MaxLength("validateExportComplianceRequest"+"."+"clientReferenceInformation"+"."+"code", "body", *o.Code, 50); err != nil {
		return err
	}

	return nil
}

func (o *ValidateExportComplianceParamsBodyClientReferenceInformation) validateComments(formats strfmt.Registry) error {
	if swag.IsZero(o.Comments) { // not required
		return nil
	}

	if err := validate.MaxLength("validateExportComplianceRequest"+"."+"clientReferenceInformation"+"."+"comments", "body", o.Comments, 255); err != nil {
		return err
	}

	return nil
}

func (o *ValidateExportComplianceParamsBodyClientReferenceInformation) validatePartner(formats strfmt.Registry) error {
	if swag.IsZero(o.Partner) { // not required
		return nil
	}

	if o.Partner != nil {
		if err := o.Partner.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("validateExportComplianceRequest" + "." + "clientReferenceInformation" + "." + "partner")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("validateExportComplianceRequest" + "." + "clientReferenceInformation" + "." + "partner")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this validate export compliance params body client reference information based on the context it is used
func (o *ValidateExportComplianceParamsBodyClientReferenceInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidatePartner(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ValidateExportComplianceParamsBodyClientReferenceInformation) contextValidatePartner(ctx context.Context, formats strfmt.Registry) error {

	if o.Partner != nil {
		if err := o.Partner.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("validateExportComplianceRequest" + "." + "clientReferenceInformation" + "." + "partner")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("validateExportComplianceRequest" + "." + "clientReferenceInformation" + "." + "partner")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *ValidateExportComplianceParamsBodyClientReferenceInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ValidateExportComplianceParamsBodyClientReferenceInformation) UnmarshalBinary(b []byte) error {
	var res ValidateExportComplianceParamsBodyClientReferenceInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*ValidateExportComplianceParamsBodyClientReferenceInformationPartner validate export compliance params body client reference information partner
swagger:model ValidateExportComplianceParamsBodyClientReferenceInformationPartner
*/
type ValidateExportComplianceParamsBodyClientReferenceInformationPartner struct {

	// Identifier for the developer that helped integrate a partner solution to CyberSource.
	//
	// Send this value in all requests that are sent through the partner solutions built by that developer.
	// CyberSource assigns the ID to the developer.
	//
	// **Note** When you see a developer ID of 999 in reports, the developer ID that was submitted is incorrect.
	//
	// Max Length: 8
	DeveloperID string `json:"developerId,omitempty"`

	// Identifier for the partner that is integrated to CyberSource.
	//
	// Send this value in all requests that are sent through the partner solution. CyberSource assigns the ID to the partner.
	//
	// **Note** When you see a solutionId of 999 in reports, the solutionId that was submitted is incorrect.
	//
	// Max Length: 8
	SolutionID string `json:"solutionId,omitempty"`
}

// Validate validates this validate export compliance params body client reference information partner
func (o *ValidateExportComplianceParamsBodyClientReferenceInformationPartner) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateDeveloperID(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateSolutionID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ValidateExportComplianceParamsBodyClientReferenceInformationPartner) validateDeveloperID(formats strfmt.Registry) error {
	if swag.IsZero(o.DeveloperID) { // not required
		return nil
	}

	if err := validate.MaxLength("validateExportComplianceRequest"+"."+"clientReferenceInformation"+"."+"partner"+"."+"developerId", "body", o.DeveloperID, 8); err != nil {
		return err
	}

	return nil
}

func (o *ValidateExportComplianceParamsBodyClientReferenceInformationPartner) validateSolutionID(formats strfmt.Registry) error {
	if swag.IsZero(o.SolutionID) { // not required
		return nil
	}

	if err := validate.MaxLength("validateExportComplianceRequest"+"."+"clientReferenceInformation"+"."+"partner"+"."+"solutionId", "body", o.SolutionID, 8); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this validate export compliance params body client reference information partner based on context it is used
func (o *ValidateExportComplianceParamsBodyClientReferenceInformationPartner) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *ValidateExportComplianceParamsBodyClientReferenceInformationPartner) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ValidateExportComplianceParamsBodyClientReferenceInformationPartner) UnmarshalBinary(b []byte) error {
	var res ValidateExportComplianceParamsBodyClientReferenceInformationPartner
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*ValidateExportComplianceParamsBodyDeviceInformation validate export compliance params body device information
swagger:model ValidateExportComplianceParamsBodyDeviceInformation
*/
type ValidateExportComplianceParamsBodyDeviceInformation struct {

	// DNS resolved hostname from `ipAddress`.
	// Max Length: 60
	HostName string `json:"hostName,omitempty"`

	// IP address of the customer.
	//
	// #### Used by
	// **Authorization, Capture, and Credit**
	// Optional field.
	//
	// Max Length: 45
	IPAddress string `json:"ipAddress,omitempty"`
}

// Validate validates this validate export compliance params body device information
func (o *ValidateExportComplianceParamsBodyDeviceInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateHostName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateIPAddress(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ValidateExportComplianceParamsBodyDeviceInformation) validateHostName(formats strfmt.Registry) error {
	if swag.IsZero(o.HostName) { // not required
		return nil
	}

	if err := validate.MaxLength("validateExportComplianceRequest"+"."+"deviceInformation"+"."+"hostName", "body", o.HostName, 60); err != nil {
		return err
	}

	return nil
}

func (o *ValidateExportComplianceParamsBodyDeviceInformation) validateIPAddress(formats strfmt.Registry) error {
	if swag.IsZero(o.IPAddress) { // not required
		return nil
	}

	if err := validate.MaxLength("validateExportComplianceRequest"+"."+"deviceInformation"+"."+"ipAddress", "body", o.IPAddress, 45); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this validate export compliance params body device information based on context it is used
func (o *ValidateExportComplianceParamsBodyDeviceInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *ValidateExportComplianceParamsBodyDeviceInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ValidateExportComplianceParamsBodyDeviceInformation) UnmarshalBinary(b []byte) error {
	var res ValidateExportComplianceParamsBodyDeviceInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*ValidateExportComplianceParamsBodyExportComplianceInformation validate export compliance params body export compliance information
swagger:model ValidateExportComplianceParamsBodyExportComplianceInformation
*/
type ValidateExportComplianceParamsBodyExportComplianceInformation struct {

	// Parts of the customer’s information that must match with an entry in the DPL (denied parties list)
	// before a match occurs. This field can contain one of the following values:
	// - AND: (default) The customer’s name or company and the customer’s address must appear in the database.
	// - OR: The customer’s name must appear in the database.
	// - IGNORE: You want the service to detect a match only of the customer’s name or company but not of the address.
	//
	AddressOperator string `json:"addressOperator,omitempty"`

	// Use this field to specify which list(s) you want checked with the request.
	// The reply will include the list name as well as the response data.
	// To check against multiple lists, enter multiple list codes separated by a caret (^).
	// For more information, see "Restricted and Denied Parties List," page 68.
	//
	SanctionLists []string `json:"sanctionLists"`

	// weights
	Weights *ValidateExportComplianceParamsBodyExportComplianceInformationWeights `json:"weights,omitempty"`
}

// Validate validates this validate export compliance params body export compliance information
func (o *ValidateExportComplianceParamsBodyExportComplianceInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateSanctionLists(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateWeights(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ValidateExportComplianceParamsBodyExportComplianceInformation) validateSanctionLists(formats strfmt.Registry) error {
	if swag.IsZero(o.SanctionLists) { // not required
		return nil
	}

	for i := 0; i < len(o.SanctionLists); i++ {

		if err := validate.MaxLength("validateExportComplianceRequest"+"."+"exportComplianceInformation"+"."+"sanctionLists"+"."+strconv.Itoa(i), "body", o.SanctionLists[i], 255); err != nil {
			return err
		}

	}

	return nil
}

func (o *ValidateExportComplianceParamsBodyExportComplianceInformation) validateWeights(formats strfmt.Registry) error {
	if swag.IsZero(o.Weights) { // not required
		return nil
	}

	if o.Weights != nil {
		if err := o.Weights.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("validateExportComplianceRequest" + "." + "exportComplianceInformation" + "." + "weights")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("validateExportComplianceRequest" + "." + "exportComplianceInformation" + "." + "weights")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this validate export compliance params body export compliance information based on the context it is used
func (o *ValidateExportComplianceParamsBodyExportComplianceInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateWeights(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ValidateExportComplianceParamsBodyExportComplianceInformation) contextValidateWeights(ctx context.Context, formats strfmt.Registry) error {

	if o.Weights != nil {
		if err := o.Weights.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("validateExportComplianceRequest" + "." + "exportComplianceInformation" + "." + "weights")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("validateExportComplianceRequest" + "." + "exportComplianceInformation" + "." + "weights")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *ValidateExportComplianceParamsBodyExportComplianceInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ValidateExportComplianceParamsBodyExportComplianceInformation) UnmarshalBinary(b []byte) error {
	var res ValidateExportComplianceParamsBodyExportComplianceInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*ValidateExportComplianceParamsBodyExportComplianceInformationWeights validate export compliance params body export compliance information weights
swagger:model ValidateExportComplianceParamsBodyExportComplianceInformationWeights
*/
type ValidateExportComplianceParamsBodyExportComplianceInformationWeights struct {

	// Degree of correlation between a customer’s address and an entry in the DPL
	// before a match occurs. This field can contain one of the following values:
	// - exact: The address must be identical to the entry in the DPL.
	// - high: (default) The address cannot differ significantly from the entry in the DPL.
	// - medium: The address can differ slightly more from the entry in the DPL.
	// - low: The address can differ significantly from the entry in the DPL.
	//
	// Max Length: 6
	Address string `json:"address,omitempty"`

	// Degree of correlation between a company address and an entry in the DPL
	// before a match occurs. This field can contain one of the following values:
	// - exact: The company name must be identical to the entry in the DPL.
	// - high: (default) The company name cannot differ significantly from the entry in the DPL.
	// - medium: The company name can differ slightly more from the entry in the DPL.
	// - low: The company name can differ significantly from the entry in the DPL.
	//
	// Max Length: 6
	Company string `json:"company,omitempty"`

	// Degree of correlation between a customer’s name and an entry in the DPL
	// before a match occurs. This field can contain one of the following values:
	// - exact: The name must be identical to the entry in the DPL.
	// - high: (default) The name cannot differ significantly from the entry in the DPL.
	// - medium: The name can differ slightly more from the entry in the DPL.
	// - low: The name can differ significantly the entry in the DPL.
	//
	// Max Length: 6
	Name string `json:"name,omitempty"`
}

// Validate validates this validate export compliance params body export compliance information weights
func (o *ValidateExportComplianceParamsBodyExportComplianceInformationWeights) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAddress(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCompany(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ValidateExportComplianceParamsBodyExportComplianceInformationWeights) validateAddress(formats strfmt.Registry) error {
	if swag.IsZero(o.Address) { // not required
		return nil
	}

	if err := validate.MaxLength("validateExportComplianceRequest"+"."+"exportComplianceInformation"+"."+"weights"+"."+"address", "body", o.Address, 6); err != nil {
		return err
	}

	return nil
}

func (o *ValidateExportComplianceParamsBodyExportComplianceInformationWeights) validateCompany(formats strfmt.Registry) error {
	if swag.IsZero(o.Company) { // not required
		return nil
	}

	if err := validate.MaxLength("validateExportComplianceRequest"+"."+"exportComplianceInformation"+"."+"weights"+"."+"company", "body", o.Company, 6); err != nil {
		return err
	}

	return nil
}

func (o *ValidateExportComplianceParamsBodyExportComplianceInformationWeights) validateName(formats strfmt.Registry) error {
	if swag.IsZero(o.Name) { // not required
		return nil
	}

	if err := validate.MaxLength("validateExportComplianceRequest"+"."+"exportComplianceInformation"+"."+"weights"+"."+"name", "body", o.Name, 6); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this validate export compliance params body export compliance information weights based on context it is used
func (o *ValidateExportComplianceParamsBodyExportComplianceInformationWeights) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *ValidateExportComplianceParamsBodyExportComplianceInformationWeights) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ValidateExportComplianceParamsBodyExportComplianceInformationWeights) UnmarshalBinary(b []byte) error {
	var res ValidateExportComplianceParamsBodyExportComplianceInformationWeights
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*ValidateExportComplianceParamsBodyOrderInformation validate export compliance params body order information
swagger:model ValidateExportComplianceParamsBodyOrderInformation
*/
type ValidateExportComplianceParamsBodyOrderInformation struct {

	// bill to
	BillTo *ValidateExportComplianceParamsBodyOrderInformationBillTo `json:"billTo,omitempty"`

	// line items
	LineItems []*ValidateExportComplianceParamsBodyOrderInformationLineItemsItems0 `json:"lineItems"`

	// ship to
	ShipTo *ValidateExportComplianceParamsBodyOrderInformationShipTo `json:"shipTo,omitempty"`
}

// Validate validates this validate export compliance params body order information
func (o *ValidateExportComplianceParamsBodyOrderInformation) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateBillTo(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLineItems(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateShipTo(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ValidateExportComplianceParamsBodyOrderInformation) validateBillTo(formats strfmt.Registry) error {
	if swag.IsZero(o.BillTo) { // not required
		return nil
	}

	if o.BillTo != nil {
		if err := o.BillTo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("validateExportComplianceRequest" + "." + "orderInformation" + "." + "billTo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("validateExportComplianceRequest" + "." + "orderInformation" + "." + "billTo")
			}
			return err
		}
	}

	return nil
}

func (o *ValidateExportComplianceParamsBodyOrderInformation) validateLineItems(formats strfmt.Registry) error {
	if swag.IsZero(o.LineItems) { // not required
		return nil
	}

	for i := 0; i < len(o.LineItems); i++ {
		if swag.IsZero(o.LineItems[i]) { // not required
			continue
		}

		if o.LineItems[i] != nil {
			if err := o.LineItems[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("validateExportComplianceRequest" + "." + "orderInformation" + "." + "lineItems" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("validateExportComplianceRequest" + "." + "orderInformation" + "." + "lineItems" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *ValidateExportComplianceParamsBodyOrderInformation) validateShipTo(formats strfmt.Registry) error {
	if swag.IsZero(o.ShipTo) { // not required
		return nil
	}

	if o.ShipTo != nil {
		if err := o.ShipTo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("validateExportComplianceRequest" + "." + "orderInformation" + "." + "shipTo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("validateExportComplianceRequest" + "." + "orderInformation" + "." + "shipTo")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this validate export compliance params body order information based on the context it is used
func (o *ValidateExportComplianceParamsBodyOrderInformation) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateBillTo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateLineItems(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := o.contextValidateShipTo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ValidateExportComplianceParamsBodyOrderInformation) contextValidateBillTo(ctx context.Context, formats strfmt.Registry) error {

	if o.BillTo != nil {
		if err := o.BillTo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("validateExportComplianceRequest" + "." + "orderInformation" + "." + "billTo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("validateExportComplianceRequest" + "." + "orderInformation" + "." + "billTo")
			}
			return err
		}
	}

	return nil
}

func (o *ValidateExportComplianceParamsBodyOrderInformation) contextValidateLineItems(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(o.LineItems); i++ {

		if o.LineItems[i] != nil {
			if err := o.LineItems[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("validateExportComplianceRequest" + "." + "orderInformation" + "." + "lineItems" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("validateExportComplianceRequest" + "." + "orderInformation" + "." + "lineItems" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (o *ValidateExportComplianceParamsBodyOrderInformation) contextValidateShipTo(ctx context.Context, formats strfmt.Registry) error {

	if o.ShipTo != nil {
		if err := o.ShipTo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("validateExportComplianceRequest" + "." + "orderInformation" + "." + "shipTo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("validateExportComplianceRequest" + "." + "orderInformation" + "." + "shipTo")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *ValidateExportComplianceParamsBodyOrderInformation) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ValidateExportComplianceParamsBodyOrderInformation) UnmarshalBinary(b []byte) error {
	var res ValidateExportComplianceParamsBodyOrderInformation
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*ValidateExportComplianceParamsBodyOrderInformationBillTo validate export compliance params body order information bill to
swagger:model ValidateExportComplianceParamsBodyOrderInformationBillTo
*/
type ValidateExportComplianceParamsBodyOrderInformationBillTo struct {

	// Payment card billing street address as it appears on the credit card issuer’s records.
	//
	// #### Atos
	// This field must not contain colons (:).
	//
	// #### CyberSource through VisaNet
	// **Important** When you populate orderInformation.billTo.address1 and orderInformation.billTo.address2,
	// CyberSource through VisaNet concatenates the two values. If the concatenated value exceeds 40 characters,
	// CyberSource through VisaNet truncates the value at 40 characters before sending it to Visa and the issuing bank.
	// Truncating this value affects AVS results and therefore might also affect risk decisions and chargebacks.
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet
	// accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations
	// of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the
	// credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless
	// ASCII characters for transmission to the credit card networks.
	//
	// #### FDMS Nashville
	// When the street name is numeric, it must be sent in numeric format. For example, if the address is _One First Street_,
	// it must be sent as _1 1st Street_.
	//
	// Required if keyed; not used if swiped.
	//
	// String (20)
	//
	// #### TSYS Acquiring Solutions
	// Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.
	//
	// #### All other processors:
	// Optional.
	// String (60)
	//
	// #### For Payouts
	// This field may be sent only for FDC Compass.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// Required: true
	// Max Length: 60
	Address1 *string `json:"address1"`

	// Used for additional address information. For example: _Attention: Accounts Payable_
	// Optional field.
	//
	// For Payouts: This field may be sent only for FDC Compass.
	//
	// #### Atos
	// This field must not contain colons (:).
	//
	// #### CyberSource through VisaNet
	// **Important** When you populate `orderInformation.billTo.address1` and `orderInformation.billTo.address2`,
	// CyberSource through VisaNet concatenates the two values. If the concatenated value exceeds 40 characters,
	// CyberSource through VisaNet truncates the value at 40 characters before sending it to Visa and the issuing bank.
	// Truncating this value affects AVS results and therefore might also affect risk decisions and chargebacks.
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet
	// accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations
	// of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the
	// credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless
	// ASCII characters for transmission to the credit card networks.
	//
	// #### Chase Paymentech Solutions, FDC Compass, and TSYS Acquiring Solutions
	// This value is used for AVS.
	//
	// #### FDMS Nashville
	// `orderInformation.billTo.address1` and `orderInformation.billTo.address2` together cannot exceed 20 characters.
	// String (20)
	//
	// #### All Other Processors
	// String (60)
	//
	// Max Length: 60
	Address2 string `json:"address2,omitempty"`

	// Additional address information (third line of the billing address)
	//
	// Max Length: 60
	Address3 string `json:"address3,omitempty"`

	// Additional address information (fourth line of the billing address)
	//
	// Max Length: 60
	Address4 string `json:"address4,omitempty"`

	// State or province of the billing address. Use the [State, Province, and Territory Codes for the United States and Canada](https://developer.cybersource.com/library/documentation/sbc/quickref/states_and_provinces.pdf).
	//
	// For Payouts: This field may be sent only for FDC Compass.
	//
	// ##### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet
	// accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations
	// of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the
	// credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless
	// ASCII characters for transmission to the credit card networks.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// #### Chase Paymentech Solutions
	// Optional field.
	//
	// ####  Credit Mutuel-CIC
	// Optional field.
	//
	// #### OmniPay Direct
	// Optional field.
	//
	// #### SIX
	// Optional field.
	//
	// #### TSYS Acquiring Solutions
	// Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.
	//
	// #### Worldpay VAP
	// Optional field.
	//
	// #### All other processors
	// Not used.
	//
	// Max Length: 20
	AdministrativeArea string `json:"administrativeArea,omitempty"`

	// company
	Company *ValidateExportComplianceParamsBodyOrderInformationBillToCompany `json:"company,omitempty"`

	// Payment card billing country. Use the two-character [ISO Standard Country Codes](http://apps.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf).
	//
	// #### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet
	// accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations
	// of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the
	// credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII
	// characters for transmission to the credit card networks.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// #### Chase Paymentech Solutions
	// Optional field.
	//
	// ####  Credit Mutuel-CIC
	// Optional field.
	//
	// #### OmniPay Direct
	// Optional field.
	//
	// #### SIX
	// Optional field.
	//
	// #### TSYS Acquiring Solutions
	// Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.
	//
	// #### Worldpay VAP
	// Optional field.
	//
	// #### All other processors
	// Not used.
	//
	// Required: true
	// Max Length: 2
	Country *string `json:"country"`

	// Customer's email address, including the full domain name.
	//
	// #### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// For processor-specific information, see the `customer_email` request-level field description in
	// [Credit Card Services Using the SCMP API.](http://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html)
	//
	// #### Invoicing
	// Email address for the customer for sending the invoice. If the invoice is in SENT status and email is updated, the old email customer payment link won't work and you must resend the invoice with the new payment link.
	//
	// #### Chase Paymentech Solutions
	// Optional field.
	//
	// ####  Credit Mutuel-CIC
	// Optional field.
	//
	// #### OmniPay Direct
	// Optional field.
	//
	// #### SIX
	// Optional field.
	//
	// #### TSYS Acquiring Solutions
	// Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.
	//
	// #### Worldpay VAP
	// Optional field.
	//
	// #### All other processors
	// Not used.
	//
	// Required: true
	// Max Length: 255
	Email *string `json:"email"`

	// Customer’s first name. This name must be the same as the name on the card.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// #### CyberSource Latin American Processing
	// **Important** For an authorization request, CyberSource Latin American Processing concatenates `orderInformation.billTo.firstName` and `orderInformation.billTo.lastName`. If the concatenated value exceeds 30 characters, CyberSource Latin American Processing declines the authorization request.\
	// **Note** CyberSource Latin American Processing is the name of a specific processing connection that CyberSource supports. In the CyberSource API documentation, CyberSource Latin American Processing does not refer to the general topic of processing in Latin America. The information in this field description is for the specific processing connection called _CyberSource Latin American Processing_. It is not for any other Latin American processors that CyberSource supports.
	//
	// #### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.
	//
	// #### For Payouts:
	// This field may be sent only for FDC Compass.
	//
	// #### Chase Paymentech Solutions
	// Optional field.
	//
	// ####  Credit Mutuel-CIC
	// Optional field.
	//
	// #### OmniPay Direct
	// Optional field.
	//
	// #### SIX
	// Optional field.
	//
	// #### TSYS Acquiring Solutions
	// Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.
	//
	// #### Worldpay VAP
	// Optional field.
	//
	// #### All other processors
	// Not used.
	//
	// Max Length: 60
	FirstName string `json:"firstName,omitempty"`

	// Customer’s last name. This name must be the same as the name on the card.
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// #### Chase Paymentech Solutions
	// Optional field.
	//
	// ####  Credit Mutuel-CIC
	// Optional field.
	//
	// #### CyberSource Latin American Processing
	// **Important** For an authorization request, CyberSource Latin American Processing concatenates `orderInformation.billTo.firstName` and `orderInformation.billTo.lastName`. If the concatenated value exceeds 30 characters, CyberSource Latin American Processing declines the authorization request.\
	// **Note** CyberSource Latin American Processing is the name of a specific processing connection that CyberSource supports. In the CyberSource API documentation, CyberSource Latin American Processing does not refer to the general topic of processing in Latin America. The information in this field description is for the specific processing connection called CyberSource Latin American Processing. It is not for any other Latin American processors that CyberSource supports.
	//
	// #### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.
	//
	// #### For Payouts:
	// This field may be sent only for FDC Compass.
	//
	// #### OmniPay Direct
	// Optional field.
	//
	// #### RBS WorldPay Atlanta
	// Optional field.
	//
	// #### SIX
	// Optional field.
	//
	// #### TSYS Acquiring Solutions
	// Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.
	//
	// #### Worldpay VAP
	// Optional field.
	//
	// #### All other processors
	// Not used.
	//
	// Max Length: 60
	LastName string `json:"lastName,omitempty"`

	// Payment card billing city.
	//
	// #### Atos
	// This field must not contain colons (:).
	//
	// #### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.
	//
	// #### For Payouts:
	// This field may be sent only for FDC Compass.
	//
	// #### Chase Paymentech Solutions
	// Optional field.
	//
	// ####  Credit Mutuel-CIC
	// Optional field.
	//
	// #### OmniPay Direct
	// Optional field.
	//
	// #### SIX
	// Optional field.
	//
	// #### TSYS Acquiring Solutions
	// Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.
	//
	// #### Worldpay VAP
	// Optional field.
	//
	// #### All other processors
	// Not used.
	//
	// Required: true
	// Max Length: 50
	Locality *string `json:"locality"`

	// Postal code for the billing address. The postal code must consist of 5 to 9 digits.
	//
	// When the billing country is the U.S., the 9-digit postal code must follow this format:
	// [5 digits][dash][4 digits]
	//
	// **Example** `12345-6789`
	//
	// When the billing country is Canada, the 6-digit postal code must follow this format:
	// [alpha][numeric][alpha][space][numeric][alpha][numeric]
	//
	// **Example** `A1B 2C3`
	//
	// **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.
	//
	// #### For Payouts:
	//  This field may be sent only for FDC Compass.
	//
	// #### American Express Direct
	// Before sending the postal code to the processor, CyberSource removes all nonalphanumeric characters and, if the remaining value is longer than nine characters, truncates the value starting from the right side.
	//
	// #### Atos
	// This field must not contain colons (:).
	//
	// #### CyberSource through VisaNet
	// Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet
	// accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations
	// of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the
	// credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII
	// characters for transmission to the credit card networks.
	//
	// #### FDMS Nashville
	// Required if `pointOfSaleInformation.entryMode=keyed` and the address is in the U.S. or Canada.
	// Optional if `pointOfSaleInformation.entryMode=keyed` and the address is **not** in the U.S. or Canada.
	// Not used if swiped.
	//
	// #### RBS WorldPay Atlanta:
	// For best card-present keyed rates, send the postal code if `pointOfSaleInformation.entryMode=keyed`.
	//
	// #### TSYS Acquiring Solutions
	// Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.
	//
	// #### All other processors:
	// Optional field.
	//
	// Required: true
	// Max Length: 10
	PostalCode *string `json:"postalCode"`
}

// Validate validates this validate export compliance params body order information bill to
func (o *ValidateExportComplianceParamsBodyOrderInformationBillTo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateAddress1(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAddress2(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAddress3(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAddress4(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateAdministrativeArea(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCompany(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateEmail(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFirstName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLastName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLocality(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validatePostalCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ValidateExportComplianceParamsBodyOrderInformationBillTo) validateAddress1(formats strfmt.Registry) error {

	if err := validate.Required("validateExportComplianceRequest"+"."+"orderInformation"+"."+"billTo"+"."+"address1", "body", o.Address1); err != nil {
		return err
	}

	if err := validate.MaxLength("validateExportComplianceRequest"+"."+"orderInformation"+"."+"billTo"+"."+"address1", "body", *o.Address1, 60); err != nil {
		return err
	}

	return nil
}

func (o *ValidateExportComplianceParamsBodyOrderInformationBillTo) validateAddress2(formats strfmt.Registry) error {
	if swag.IsZero(o.Address2) { // not required
		return nil
	}

	if err := validate.MaxLength("validateExportComplianceRequest"+"."+"orderInformation"+"."+"billTo"+"."+"address2", "body", o.Address2, 60); err != nil {
		return err
	}

	return nil
}

func (o *ValidateExportComplianceParamsBodyOrderInformationBillTo) validateAddress3(formats strfmt.Registry) error {
	if swag.IsZero(o.Address3) { // not required
		return nil
	}

	if err := validate.MaxLength("validateExportComplianceRequest"+"."+"orderInformation"+"."+"billTo"+"."+"address3", "body", o.Address3, 60); err != nil {
		return err
	}

	return nil
}

func (o *ValidateExportComplianceParamsBodyOrderInformationBillTo) validateAddress4(formats strfmt.Registry) error {
	if swag.IsZero(o.Address4) { // not required
		return nil
	}

	if err := validate.MaxLength("validateExportComplianceRequest"+"."+"orderInformation"+"."+"billTo"+"."+"address4", "body", o.Address4, 60); err != nil {
		return err
	}

	return nil
}

func (o *ValidateExportComplianceParamsBodyOrderInformationBillTo) validateAdministrativeArea(formats strfmt.Registry) error {
	if swag.IsZero(o.AdministrativeArea) { // not required
		return nil
	}

	if err := validate.MaxLength("validateExportComplianceRequest"+"."+"orderInformation"+"."+"billTo"+"."+"administrativeArea", "body", o.AdministrativeArea, 20); err != nil {
		return err
	}

	return nil
}

func (o *ValidateExportComplianceParamsBodyOrderInformationBillTo) validateCompany(formats strfmt.Registry) error {
	if swag.IsZero(o.Company) { // not required
		return nil
	}

	if o.Company != nil {
		if err := o.Company.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("validateExportComplianceRequest" + "." + "orderInformation" + "." + "billTo" + "." + "company")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("validateExportComplianceRequest" + "." + "orderInformation" + "." + "billTo" + "." + "company")
			}
			return err
		}
	}

	return nil
}

func (o *ValidateExportComplianceParamsBodyOrderInformationBillTo) validateCountry(formats strfmt.Registry) error {

	if err := validate.Required("validateExportComplianceRequest"+"."+"orderInformation"+"."+"billTo"+"."+"country", "body", o.Country); err != nil {
		return err
	}

	if err := validate.MaxLength("validateExportComplianceRequest"+"."+"orderInformation"+"."+"billTo"+"."+"country", "body", *o.Country, 2); err != nil {
		return err
	}

	return nil
}

func (o *ValidateExportComplianceParamsBodyOrderInformationBillTo) validateEmail(formats strfmt.Registry) error {

	if err := validate.Required("validateExportComplianceRequest"+"."+"orderInformation"+"."+"billTo"+"."+"email", "body", o.Email); err != nil {
		return err
	}

	if err := validate.MaxLength("validateExportComplianceRequest"+"."+"orderInformation"+"."+"billTo"+"."+"email", "body", *o.Email, 255); err != nil {
		return err
	}

	return nil
}

func (o *ValidateExportComplianceParamsBodyOrderInformationBillTo) validateFirstName(formats strfmt.Registry) error {
	if swag.IsZero(o.FirstName) { // not required
		return nil
	}

	if err := validate.MaxLength("validateExportComplianceRequest"+"."+"orderInformation"+"."+"billTo"+"."+"firstName", "body", o.FirstName, 60); err != nil {
		return err
	}

	return nil
}

func (o *ValidateExportComplianceParamsBodyOrderInformationBillTo) validateLastName(formats strfmt.Registry) error {
	if swag.IsZero(o.LastName) { // not required
		return nil
	}

	if err := validate.MaxLength("validateExportComplianceRequest"+"."+"orderInformation"+"."+"billTo"+"."+"lastName", "body", o.LastName, 60); err != nil {
		return err
	}

	return nil
}

func (o *ValidateExportComplianceParamsBodyOrderInformationBillTo) validateLocality(formats strfmt.Registry) error {

	if err := validate.Required("validateExportComplianceRequest"+"."+"orderInformation"+"."+"billTo"+"."+"locality", "body", o.Locality); err != nil {
		return err
	}

	if err := validate.MaxLength("validateExportComplianceRequest"+"."+"orderInformation"+"."+"billTo"+"."+"locality", "body", *o.Locality, 50); err != nil {
		return err
	}

	return nil
}

func (o *ValidateExportComplianceParamsBodyOrderInformationBillTo) validatePostalCode(formats strfmt.Registry) error {

	if err := validate.Required("validateExportComplianceRequest"+"."+"orderInformation"+"."+"billTo"+"."+"postalCode", "body", o.PostalCode); err != nil {
		return err
	}

	if err := validate.MaxLength("validateExportComplianceRequest"+"."+"orderInformation"+"."+"billTo"+"."+"postalCode", "body", *o.PostalCode, 10); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this validate export compliance params body order information bill to based on the context it is used
func (o *ValidateExportComplianceParamsBodyOrderInformationBillTo) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := o.contextValidateCompany(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ValidateExportComplianceParamsBodyOrderInformationBillTo) contextValidateCompany(ctx context.Context, formats strfmt.Registry) error {

	if o.Company != nil {
		if err := o.Company.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("validateExportComplianceRequest" + "." + "orderInformation" + "." + "billTo" + "." + "company")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("validateExportComplianceRequest" + "." + "orderInformation" + "." + "billTo" + "." + "company")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (o *ValidateExportComplianceParamsBodyOrderInformationBillTo) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ValidateExportComplianceParamsBodyOrderInformationBillTo) UnmarshalBinary(b []byte) error {
	var res ValidateExportComplianceParamsBodyOrderInformationBillTo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*ValidateExportComplianceParamsBodyOrderInformationBillToCompany validate export compliance params body order information bill to company
swagger:model ValidateExportComplianceParamsBodyOrderInformationBillToCompany
*/
type ValidateExportComplianceParamsBodyOrderInformationBillToCompany struct {

	// Company name of person buying the product.
	// Important: This field or billTo.firstName and billTo.lastName must be present. Else, your request will fail.
	//
	// Max Length: 60
	Name string `json:"name,omitempty"`
}

// Validate validates this validate export compliance params body order information bill to company
func (o *ValidateExportComplianceParamsBodyOrderInformationBillToCompany) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ValidateExportComplianceParamsBodyOrderInformationBillToCompany) validateName(formats strfmt.Registry) error {
	if swag.IsZero(o.Name) { // not required
		return nil
	}

	if err := validate.MaxLength("validateExportComplianceRequest"+"."+"orderInformation"+"."+"billTo"+"."+"company"+"."+"name", "body", o.Name, 60); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this validate export compliance params body order information bill to company based on context it is used
func (o *ValidateExportComplianceParamsBodyOrderInformationBillToCompany) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *ValidateExportComplianceParamsBodyOrderInformationBillToCompany) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ValidateExportComplianceParamsBodyOrderInformationBillToCompany) UnmarshalBinary(b []byte) error {
	var res ValidateExportComplianceParamsBodyOrderInformationBillToCompany
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*ValidateExportComplianceParamsBodyOrderInformationLineItemsItems0 validate export compliance params body order information line items items0
swagger:model ValidateExportComplianceParamsBodyOrderInformationLineItemsItems0
*/
type ValidateExportComplianceParamsBodyOrderInformationLineItemsItems0 struct {

	// allowed export countries
	AllowedExportCountries []string `json:"allowedExportCountries"`

	// Type of product. The value for this field is used to identify the product category (electronic, handling, physical,
	// service, or shipping). The default value is `default`.
	//
	// If you are performing an authorization transaction (`processingOptions.capture` is set to `false`), and you set
	// this field to a value other than `default` or one of the values related to shipping and/or handling, then
	// `orderInformation.lineItems[].quantity`, `orderInformation.lineItems[].productName`, and
	// `orderInformation.lineItems[].productSku` fields are required.
	//
	// Optional field.
	//
	// For details, see the `product_code` field description in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/).
	//
	// #### Tax Calculation
	// Optional field for U.S., Canadian, international tax, and value added taxes.
	//
	// To use the tax calculation service, use values listed in the Tax Product Code Guide. For information about this
	// document, contact customer support. See "Product Codes," page 14, for more information.
	//
	// Max Length: 255
	ProductCode string `json:"productCode,omitempty"`

	// For an authorization or capture transaction (`processingOptions.capture` is `true` or `false`),
	// this field is required when `orderInformation.lineItems[].productCode` is not `default` or one of
	// the other values that are related to shipping and/or handling.
	//
	// #### Tax Calculation
	// Optional field for U.S., Canadian, international tax, and value added taxes.
	//
	// Max Length: 255
	ProductName string `json:"productName,omitempty"`

	// Indicates the level of risk for the product. This field can contain one of the following values:
	// - `low`: The product is associated with few chargebacks.
	// - `normal`: The product is associated with a normal number of chargebacks.
	// - `high`: The product is associated with many chargebacks.
	//
	// Max Length: 6
	ProductRisk string `json:"productRisk,omitempty"`

	// Product identifier code. Also known as the Stock Keeping Unit (SKU) code for the product.
	//
	// For an authorization or capture transaction (`processingOptions.capture` is set to `true` or `false`), this field is required when `orderInformation.lineItems[].productCode` is not set to **default** or one of the other values that are related to shipping and/or handling.
	//
	// #### Tax Calculation
	// Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes.
	// For an authorization or capture transaction (`processingOptions.capture` is set to `true` or `false`), this field is
	// required when `orderInformation.lineItems[].productCode` is not `default` or one of the values related to shipping and/or handling.
	//
	// Max Length: 255
	ProductSKU string `json:"productSKU,omitempty"`

	// Number of units for this order. Must be a non-negative integer.
	//
	// The default is `1`. For an authorization or capture transaction (`processingOptions.capture` is set to `true` or `false`),
	// this field is required when `orderInformation.lineItems[].productCode` is not `default` or one of the other values
	// related to shipping and/or handling.
	//
	// #### Tax Calculation
	// Optional field for U.S., Canadian, international tax, and value added taxes.
	//
	// Maximum: 9.99999999e+08
	// Minimum: 1
	Quantity int64 `json:"quantity,omitempty"`

	// restricted export countries
	RestrictedExportCountries []string `json:"restrictedExportCountries"`

	// Per-item price of the product. This value for this field cannot be negative.
	//
	// You must include either this field or the request-level field `orderInformation.amountDetails.totalAmount` in your request.
	//
	// You can include a decimal point (.), but you cannot include any other special characters.
	// The value is truncated to the correct number of decimal places.
	//
	// #### DCC with a Third-Party Provider
	// Set this field to the converted amount that was returned by the DCC provider. You must include either
	// the 1st line item in the order and this field, or the request-level field `orderInformation.amountDetails.totalAmount` in your request.
	//
	// #### FDMS South
	// If you accept IDR or CLP currencies, see the entry for FDMS South in the [Merchant Descriptors Using the SCMP API Guide.]
	// (https://apps.cybersource.com/library/documentation/dev_guides/Merchant_Descriptors_SCMP_API/html/)
	//
	// #### Tax Calculation
	// Required field for U.S., Canadian, international and value added taxes.
	//
	// #### Zero Amount Authorizations
	// If your processor supports zero amount authorizations, you can set this field to 0 for the
	// authorization to check if the card is lost or stolen.
	//
	// #### Maximum Field Lengths
	// For GPN and JCN Gateway: Decimal (10)
	// All other processors: Decimal (15)
	//
	// Required: true
	// Max Length: 15
	UnitPrice *string `json:"unitPrice"`
}

// Validate validates this validate export compliance params body order information line items items0
func (o *ValidateExportComplianceParamsBodyOrderInformationLineItemsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateProductCode(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProductName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProductRisk(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateProductSKU(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateQuantity(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateUnitPrice(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ValidateExportComplianceParamsBodyOrderInformationLineItemsItems0) validateProductCode(formats strfmt.Registry) error {
	if swag.IsZero(o.ProductCode) { // not required
		return nil
	}

	if err := validate.MaxLength("productCode", "body", o.ProductCode, 255); err != nil {
		return err
	}

	return nil
}

func (o *ValidateExportComplianceParamsBodyOrderInformationLineItemsItems0) validateProductName(formats strfmt.Registry) error {
	if swag.IsZero(o.ProductName) { // not required
		return nil
	}

	if err := validate.MaxLength("productName", "body", o.ProductName, 255); err != nil {
		return err
	}

	return nil
}

func (o *ValidateExportComplianceParamsBodyOrderInformationLineItemsItems0) validateProductRisk(formats strfmt.Registry) error {
	if swag.IsZero(o.ProductRisk) { // not required
		return nil
	}

	if err := validate.MaxLength("productRisk", "body", o.ProductRisk, 6); err != nil {
		return err
	}

	return nil
}

func (o *ValidateExportComplianceParamsBodyOrderInformationLineItemsItems0) validateProductSKU(formats strfmt.Registry) error {
	if swag.IsZero(o.ProductSKU) { // not required
		return nil
	}

	if err := validate.MaxLength("productSKU", "body", o.ProductSKU, 255); err != nil {
		return err
	}

	return nil
}

func (o *ValidateExportComplianceParamsBodyOrderInformationLineItemsItems0) validateQuantity(formats strfmt.Registry) error {
	if swag.IsZero(o.Quantity) { // not required
		return nil
	}

	if err := validate.MinimumInt("quantity", "body", o.Quantity, 1, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("quantity", "body", o.Quantity, 9.99999999e+08, false); err != nil {
		return err
	}

	return nil
}

func (o *ValidateExportComplianceParamsBodyOrderInformationLineItemsItems0) validateUnitPrice(formats strfmt.Registry) error {

	if err := validate.Required("unitPrice", "body", o.UnitPrice); err != nil {
		return err
	}

	if err := validate.MaxLength("unitPrice", "body", *o.UnitPrice, 15); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this validate export compliance params body order information line items items0 based on context it is used
func (o *ValidateExportComplianceParamsBodyOrderInformationLineItemsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *ValidateExportComplianceParamsBodyOrderInformationLineItemsItems0) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ValidateExportComplianceParamsBodyOrderInformationLineItemsItems0) UnmarshalBinary(b []byte) error {
	var res ValidateExportComplianceParamsBodyOrderInformationLineItemsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}

/*ValidateExportComplianceParamsBodyOrderInformationShipTo validate export compliance params body order information ship to
swagger:model ValidateExportComplianceParamsBodyOrderInformationShipTo
*/
type ValidateExportComplianceParamsBodyOrderInformationShipTo struct {

	// Country of the shipping address. Use the two-character [ISO Standard Country Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf)
	//
	// Required field for authorization if any shipping address information is included in the request; otherwise, optional.
	//
	// #### Tax Calculation
	// Optional field for U.S., Canadian, international tax, and value added taxes.
	// Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present.
	//
	// Max Length: 2
	Country string `json:"country,omitempty"`

	// First name of the recipient.
	//
	// #### Litle
	// Maximum length: 25
	//
	// #### All other processors
	// Maximum length: 60
	//
	// Optional field.
	//
	// Max Length: 60
	FirstName string `json:"firstName,omitempty"`

	// Last name of the recipient.
	//
	// #### Litle
	// Maximum length: 25
	//
	// #### All other processors
	// Maximum length: 60
	//
	// Optional field.
	//
	// Max Length: 60
	LastName string `json:"lastName,omitempty"`
}

// Validate validates this validate export compliance params body order information ship to
func (o *ValidateExportComplianceParamsBodyOrderInformationShipTo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := o.validateCountry(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateFirstName(formats); err != nil {
		res = append(res, err)
	}

	if err := o.validateLastName(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *ValidateExportComplianceParamsBodyOrderInformationShipTo) validateCountry(formats strfmt.Registry) error {
	if swag.IsZero(o.Country) { // not required
		return nil
	}

	if err := validate.MaxLength("validateExportComplianceRequest"+"."+"orderInformation"+"."+"shipTo"+"."+"country", "body", o.Country, 2); err != nil {
		return err
	}

	return nil
}

func (o *ValidateExportComplianceParamsBodyOrderInformationShipTo) validateFirstName(formats strfmt.Registry) error {
	if swag.IsZero(o.FirstName) { // not required
		return nil
	}

	if err := validate.MaxLength("validateExportComplianceRequest"+"."+"orderInformation"+"."+"shipTo"+"."+"firstName", "body", o.FirstName, 60); err != nil {
		return err
	}

	return nil
}

func (o *ValidateExportComplianceParamsBodyOrderInformationShipTo) validateLastName(formats strfmt.Registry) error {
	if swag.IsZero(o.LastName) { // not required
		return nil
	}

	if err := validate.MaxLength("validateExportComplianceRequest"+"."+"orderInformation"+"."+"shipTo"+"."+"lastName", "body", o.LastName, 60); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this validate export compliance params body order information ship to based on context it is used
func (o *ValidateExportComplianceParamsBodyOrderInformationShipTo) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (o *ValidateExportComplianceParamsBodyOrderInformationShipTo) MarshalBinary() ([]byte, error) {
	if o == nil {
		return nil, nil
	}
	return swag.WriteJSON(o)
}

// UnmarshalBinary interface implementation
func (o *ValidateExportComplianceParamsBodyOrderInformationShipTo) UnmarshalBinary(b []byte) error {
	var res ValidateExportComplianceParamsBodyOrderInformationShipTo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*o = res
	return nil
}
